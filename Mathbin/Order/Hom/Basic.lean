/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin

! This file was ported from Lean 3 source module order.hom.basic
! leanprover-community/mathlib commit 008205aa645b3f194c1da47025c5f110c8406eab
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Logic.Equiv.Option
import Mathbin.Order.RelIso.Basic
import Mathbin.Tactic.Monotonicity.Basic
import Mathbin.Tactic.AssertExists
import Mathbin.Order.Disjoint

/-!
# Order homomorphisms

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines order homomorphisms, which are bundled monotone functions. A preorder
homomorphism `f : α →o β` is a function `α → β` along with a proof that `∀ x y, x ≤ y → f x ≤ f y`.

## Main definitions

In this file we define the following bundled monotone maps:
 * `order_hom α β` a.k.a. `α →o β`: Preorder homomorphism.
    An `order_hom α β` is a function `f : α → β` such that `a₁ ≤ a₂ → f a₁ ≤ f a₂`
 * `order_embedding α β` a.k.a. `α ↪o β`: Relation embedding.
    An `order_embedding α β` is an embedding `f : α ↪ β` such that `a ≤ b ↔ f a ≤ f b`.
    Defined as an abbreviation of `@rel_embedding α β (≤) (≤)`.
* `order_iso`: Relation isomorphism.
    An `order_iso α β` is an equivalence `f : α ≃ β` such that `a ≤ b ↔ f a ≤ f b`.
    Defined as an abbreviation of `@rel_iso α β (≤) (≤)`.

We also define many `order_hom`s. In some cases we define two versions, one with `ₘ` suffix and
one without it (e.g., `order_hom.compₘ` and `order_hom.comp`). This means that the former
function is a "more bundled" version of the latter. We can't just drop the "less bundled" version
because the more bundled version usually does not work with dot notation.

* `order_hom.id`: identity map as `α →o α`;
* `order_hom.curry`: an order isomorphism between `α × β →o γ` and `α →o β →o γ`;
* `order_hom.comp`: composition of two bundled monotone maps;
* `order_hom.compₘ`: composition of bundled monotone maps as a bundled monotone map;
* `order_hom.const`: constant function as a bundled monotone map;
* `order_hom.prod`: combine `α →o β` and `α →o γ` into `α →o β × γ`;
* `order_hom.prodₘ`: a more bundled version of `order_hom.prod`;
* `order_hom.prod_iso`: order isomorphism between `α →o β × γ` and `(α →o β) × (α →o γ)`;
* `order_hom.diag`: diagonal embedding of `α` into `α × α` as a bundled monotone map;
* `order_hom.on_diag`: restrict a monotone map `α →o α →o β` to the diagonal;
* `order_hom.fst`: projection `prod.fst : α × β → α` as a bundled monotone map;
* `order_hom.snd`: projection `prod.snd : α × β → β` as a bundled monotone map;
* `order_hom.prod_map`: `prod.map f g` as a bundled monotone map;
* `pi.eval_order_hom`: evaluation of a function at a point `function.eval i` as a bundled
  monotone map;
* `order_hom.coe_fn_hom`: coercion to function as a bundled monotone map;
* `order_hom.apply`: application of a `order_hom` at a point as a bundled monotone map;
* `order_hom.pi`: combine a family of monotone maps `f i : α →o π i` into a monotone map
  `α →o Π i, π i`;
* `order_hom.pi_iso`: order isomorphism between `α →o Π i, π i` and `Π i, α →o π i`;
* `order_hom.subtyle.val`: embedding `subtype.val : subtype p → α` as a bundled monotone map;
* `order_hom.dual`: reinterpret a monotone map `α →o β` as a monotone map `αᵒᵈ →o βᵒᵈ`;
* `order_hom.dual_iso`: order isomorphism between `α →o β` and `(αᵒᵈ →o βᵒᵈ)ᵒᵈ`;
* `order_iso.compl`: order isomorphism `α ≃o αᵒᵈ` given by taking complements in a
  boolean algebra;

We also define two functions to convert other bundled maps to `α →o β`:

* `order_embedding.to_order_hom`: convert `α ↪o β` to `α →o β`;
* `rel_hom.to_order_hom`: convert a `rel_hom` between strict orders to a `order_hom`.

## Tags

monotone map, bundled morphism
-/


open OrderDual

variable {F α β γ δ : Type _}

#print OrderHom /-
/-- Bundled monotone (aka, increasing) function -/
structure OrderHom (α β : Type _) [Preorder α] [Preorder β] where
  toFun : α → β
  monotone' : Monotone to_fun
#align order_hom OrderHom
-/

-- mathport name: «expr →o »
infixr:25 " →o " => OrderHom

#print OrderEmbedding /-
/-- An order embedding is an embedding `f : α ↪ β` such that `a ≤ b ↔ (f a) ≤ (f b)`.
This definition is an abbreviation of `rel_embedding (≤) (≤)`. -/
abbrev OrderEmbedding (α β : Type _) [LE α] [LE β] :=
  @RelEmbedding α β (· ≤ ·) (· ≤ ·)
#align order_embedding OrderEmbedding
-/

-- mathport name: «expr ↪o »
infixl:25 " ↪o " => OrderEmbedding

#print OrderIso /-
/-- An order isomorphism is an equivalence such that `a ≤ b ↔ (f a) ≤ (f b)`.
This definition is an abbreviation of `rel_iso (≤) (≤)`. -/
abbrev OrderIso (α β : Type _) [LE α] [LE β] :=
  @RelIso α β (· ≤ ·) (· ≤ ·)
#align order_iso OrderIso
-/

-- mathport name: «expr ≃o »
infixl:25 " ≃o " => OrderIso

section

#print OrderHomClass /-
/-- `order_hom_class F α b` asserts that `F` is a type of `≤`-preserving morphisms. -/
abbrev OrderHomClass (F : Type _) (α β : outParam (Type _)) [LE α] [LE β] :=
  RelHomClass F ((· ≤ ·) : α → α → Prop) ((· ≤ ·) : β → β → Prop)
#align order_hom_class OrderHomClass
-/

#print OrderIsoClass /-
/-- `order_iso_class F α β` states that `F` is a type of order isomorphisms.

You should extend this class when you extend `order_iso`. -/
class OrderIsoClass (F : Type _) (α β : outParam (Type _)) [LE α] [LE β] extends
  EquivLike F α β where
  map_le_map_iff (f : F) {a b : α} : f a ≤ f b ↔ a ≤ b
#align order_iso_class OrderIsoClass
-/

end

export OrderIsoClass (map_le_map_iff)

attribute [simp] map_le_map_iff

instance [LE α] [LE β] [OrderIsoClass F α β] : CoeTC F (α ≃o β) :=
  ⟨fun f => ⟨f, fun _ _ => map_le_map_iff f⟩⟩

#print OrderIsoClass.toOrderHomClass /-
-- See note [lower instance priority]
instance (priority := 100) OrderIsoClass.toOrderHomClass [LE α] [LE β] [OrderIsoClass F α β] :
    OrderHomClass F α β :=
  { EquivLike.toEmbeddingLike with map_rel := fun f a b => (map_le_map_iff f).2 }
#align order_iso_class.to_order_hom_class OrderIsoClass.toOrderHomClass
-/

namespace OrderHomClass

variable [Preorder α] [Preorder β] [OrderHomClass F α β]

/- warning: order_hom_class.monotone -> OrderHomClass.monotone is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : OrderHomClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2)] (f : F), Monotone.{u2, u3} α β _inst_1 _inst_2 (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (RelHomClass.toFunLike.{u1, u2, u3} F α β (LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1)) (LE.le.{u3} β (Preorder.toLE.{u3} β _inst_2)) _inst_3)) f)
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u3}} {β : Type.{u2}} [_inst_1 : Preorder.{u3} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : OrderHomClass.{u1, u3, u2} F α β (Preorder.toLE.{u3} α _inst_1) (Preorder.toLE.{u2} β _inst_2)] (f : F), Monotone.{u3, u2} α β _inst_1 _inst_2 (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) _x) (RelHomClass.toFunLike.{u1, u3, u2} F α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.2092 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.2094 : α) => LE.le.{u3} α (Preorder.toLE.{u3} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.2092 x._@.Mathlib.Order.Hom.Basic._hyg.2094) (fun (_x : β) (x._@.Mathlib.Order.Hom.Basic._hyg.2116 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) _x x._@.Mathlib.Order.Hom.Basic._hyg.2116) _inst_3) f)
Case conversion may be inaccurate. Consider using '#align order_hom_class.monotone OrderHomClass.monotoneₓ'. -/
protected theorem monotone (f : F) : Monotone (f : α → β) := fun _ _ => map_rel f
#align order_hom_class.monotone OrderHomClass.monotone

/- warning: order_hom_class.mono -> OrderHomClass.mono is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : OrderHomClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2)] (f : F), Monotone.{u2, u3} α β _inst_1 _inst_2 (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (RelHomClass.toFunLike.{u1, u2, u3} F α β (LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1)) (LE.le.{u3} β (Preorder.toLE.{u3} β _inst_2)) _inst_3)) f)
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u3}} {β : Type.{u2}} [_inst_1 : Preorder.{u3} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : OrderHomClass.{u1, u3, u2} F α β (Preorder.toLE.{u3} α _inst_1) (Preorder.toLE.{u2} β _inst_2)] (f : F), Monotone.{u3, u2} α β _inst_1 _inst_2 (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) _x) (RelHomClass.toFunLike.{u1, u3, u2} F α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.2092 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.2094 : α) => LE.le.{u3} α (Preorder.toLE.{u3} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.2092 x._@.Mathlib.Order.Hom.Basic._hyg.2094) (fun (_x : β) (x._@.Mathlib.Order.Hom.Basic._hyg.2116 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) _x x._@.Mathlib.Order.Hom.Basic._hyg.2116) _inst_3) f)
Case conversion may be inaccurate. Consider using '#align order_hom_class.mono OrderHomClass.monoₓ'. -/
protected theorem mono (f : F) : Monotone (f : α → β) := fun _ _ => map_rel f
#align order_hom_class.mono OrderHomClass.mono

instance : CoeTC F (α →o β) :=
  ⟨fun f =>
    { toFun := f
      monotone' := OrderHomClass.mono _ }⟩

end OrderHomClass

section OrderIsoClass

section LE

variable [LE α] [LE β] [OrderIsoClass F α β]

/- warning: map_inv_le_iff -> map_inv_le_iff is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u3} β] [_inst_3 : OrderIsoClass.{u1, u2, u3} F α β _inst_1 _inst_2] (f : F) {a : α} {b : β}, Iff (LE.le.{u2} α _inst_1 (EquivLike.inv.{succ u1, succ u2, succ u3} F α β (OrderIsoClass.toEquivLike.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3) f b) a) (LE.le.{u3} β _inst_2 b (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (RelHomClass.toFunLike.{u1, u2, u3} F α β (LE.le.{u2} α _inst_1) (LE.le.{u3} β _inst_2) (OrderIsoClass.toOrderHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3))) f a))
but is expected to have type
  forall {F : Type.{u2}} {α : Type.{u3}} {β : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u1} β] [_inst_3 : OrderIsoClass.{u2, u3, u1} F α β _inst_1 _inst_2] (f : F) {a : α} {b : β}, Iff (LE.le.{u3} α _inst_1 (EquivLike.inv.{succ u2, succ u3, succ u1} F α β (OrderIsoClass.toEquivLike.{u2, u3, u1} F α β _inst_1 _inst_2 _inst_3) f b) a) (LE.le.{u1} β _inst_2 b (FunLike.coe.{succ u2, succ u3, succ u1} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) _x) (RelHomClass.toFunLike.{u2, u3, u1} F α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.2092 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.2094 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.2092 x._@.Mathlib.Order.Hom.Basic._hyg.2094) (fun (_x : β) (x._@.Mathlib.Order.Hom.Basic._hyg.2116 : β) => LE.le.{u1} β _inst_2 _x x._@.Mathlib.Order.Hom.Basic._hyg.2116) (OrderIsoClass.toOrderHomClass.{u2, u3, u1} F α β _inst_1 _inst_2 _inst_3)) f a))
Case conversion may be inaccurate. Consider using '#align map_inv_le_iff map_inv_le_iffₓ'. -/
@[simp]
theorem map_inv_le_iff (f : F) {a : α} {b : β} : EquivLike.inv f b ≤ a ↔ b ≤ f a :=
  by
  convert (map_le_map_iff _).symm
  exact (EquivLike.right_inv _ _).symm
#align map_inv_le_iff map_inv_le_iff

/- warning: le_map_inv_iff -> le_map_inv_iff is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u3} β] [_inst_3 : OrderIsoClass.{u1, u2, u3} F α β _inst_1 _inst_2] (f : F) {a : α} {b : β}, Iff (LE.le.{u2} α _inst_1 a (EquivLike.inv.{succ u1, succ u2, succ u3} F α β (OrderIsoClass.toEquivLike.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3) f b)) (LE.le.{u3} β _inst_2 (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (RelHomClass.toFunLike.{u1, u2, u3} F α β (LE.le.{u2} α _inst_1) (LE.le.{u3} β _inst_2) (OrderIsoClass.toOrderHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3))) f a) b)
but is expected to have type
  forall {F : Type.{u2}} {α : Type.{u3}} {β : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u1} β] [_inst_3 : OrderIsoClass.{u2, u3, u1} F α β _inst_1 _inst_2] (f : F) {a : α} {b : β}, Iff (LE.le.{u3} α _inst_1 a (EquivLike.inv.{succ u2, succ u3, succ u1} F α β (OrderIsoClass.toEquivLike.{u2, u3, u1} F α β _inst_1 _inst_2 _inst_3) f b)) (LE.le.{u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) _inst_2 (FunLike.coe.{succ u2, succ u3, succ u1} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) _x) (RelHomClass.toFunLike.{u2, u3, u1} F α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.2092 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.2094 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.2092 x._@.Mathlib.Order.Hom.Basic._hyg.2094) (fun (_x : β) (x._@.Mathlib.Order.Hom.Basic._hyg.2116 : β) => LE.le.{u1} β _inst_2 _x x._@.Mathlib.Order.Hom.Basic._hyg.2116) (OrderIsoClass.toOrderHomClass.{u2, u3, u1} F α β _inst_1 _inst_2 _inst_3)) f a) b)
Case conversion may be inaccurate. Consider using '#align le_map_inv_iff le_map_inv_iffₓ'. -/
@[simp]
theorem le_map_inv_iff (f : F) {a : α} {b : β} : a ≤ EquivLike.inv f b ↔ f a ≤ b :=
  by
  convert (map_le_map_iff _).symm
  exact (EquivLike.right_inv _ _).symm
#align le_map_inv_iff le_map_inv_iff

end LE

variable [Preorder α] [Preorder β] [OrderIsoClass F α β]

include β

/- warning: map_lt_map_iff -> map_lt_map_iff is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : OrderIsoClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2)] (f : F) {a : α} {b : α}, Iff (LT.lt.{u3} β (Preorder.toLT.{u3} β _inst_2) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (RelHomClass.toFunLike.{u1, u2, u3} F α β (LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1)) (LE.le.{u3} β (Preorder.toLE.{u3} β _inst_2)) (OrderIsoClass.toOrderHomClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_3))) f a) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (RelHomClass.toFunLike.{u1, u2, u3} F α β (LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1)) (LE.le.{u3} β (Preorder.toLE.{u3} β _inst_2)) (OrderIsoClass.toOrderHomClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_3))) f b)) (LT.lt.{u2} α (Preorder.toLT.{u2} α _inst_1) a b)
but is expected to have type
  forall {F : Type.{u2}} {α : Type.{u1}} {β : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : OrderIsoClass.{u2, u1, u3} F α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} β _inst_2)] (f : F) {a : α} {b : α}, Iff (LT.lt.{u3} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) (Preorder.toLT.{u3} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) _inst_2) (FunLike.coe.{succ u2, succ u1, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) _x) (RelHomClass.toFunLike.{u2, u1, u3} F α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.2092 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.2094 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.2092 x._@.Mathlib.Order.Hom.Basic._hyg.2094) (fun (_x : β) (x._@.Mathlib.Order.Hom.Basic._hyg.2116 : β) => LE.le.{u3} β (Preorder.toLE.{u3} β _inst_2) _x x._@.Mathlib.Order.Hom.Basic._hyg.2116) (OrderIsoClass.toOrderHomClass.{u2, u1, u3} F α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_3)) f a) (FunLike.coe.{succ u2, succ u1, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) _x) (RelHomClass.toFunLike.{u2, u1, u3} F α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.2092 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.2094 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.2092 x._@.Mathlib.Order.Hom.Basic._hyg.2094) (fun (_x : β) (x._@.Mathlib.Order.Hom.Basic._hyg.2116 : β) => LE.le.{u3} β (Preorder.toLE.{u3} β _inst_2) _x x._@.Mathlib.Order.Hom.Basic._hyg.2116) (OrderIsoClass.toOrderHomClass.{u2, u1, u3} F α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_3)) f b)) (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1) a b)
Case conversion may be inaccurate. Consider using '#align map_lt_map_iff map_lt_map_iffₓ'. -/
theorem map_lt_map_iff (f : F) {a b : α} : f a < f b ↔ a < b :=
  lt_iff_lt_of_le_iff_le' (map_le_map_iff f) (map_le_map_iff f)
#align map_lt_map_iff map_lt_map_iff

/- warning: map_inv_lt_iff -> map_inv_lt_iff is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : OrderIsoClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2)] (f : F) {a : α} {b : β}, Iff (LT.lt.{u2} α (Preorder.toLT.{u2} α _inst_1) (EquivLike.inv.{succ u1, succ u2, succ u3} F α β (OrderIsoClass.toEquivLike.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_3) f b) a) (LT.lt.{u3} β (Preorder.toLT.{u3} β _inst_2) b (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (RelHomClass.toFunLike.{u1, u2, u3} F α β (LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1)) (LE.le.{u3} β (Preorder.toLE.{u3} β _inst_2)) (OrderIsoClass.toOrderHomClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_3))) f a))
but is expected to have type
  forall {F : Type.{u2}} {α : Type.{u3}} {β : Type.{u1}} [_inst_1 : Preorder.{u3} α] [_inst_2 : Preorder.{u1} β] [_inst_3 : OrderIsoClass.{u2, u3, u1} F α β (Preorder.toLE.{u3} α _inst_1) (Preorder.toLE.{u1} β _inst_2)] (f : F) {a : α} {b : β}, Iff (LT.lt.{u3} α (Preorder.toLT.{u3} α _inst_1) (EquivLike.inv.{succ u2, succ u3, succ u1} F α β (OrderIsoClass.toEquivLike.{u2, u3, u1} F α β (Preorder.toLE.{u3} α _inst_1) (Preorder.toLE.{u1} β _inst_2) _inst_3) f b) a) (LT.lt.{u1} β (Preorder.toLT.{u1} β _inst_2) b (FunLike.coe.{succ u2, succ u3, succ u1} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) _x) (RelHomClass.toFunLike.{u2, u3, u1} F α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.2092 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.2094 : α) => LE.le.{u3} α (Preorder.toLE.{u3} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.2092 x._@.Mathlib.Order.Hom.Basic._hyg.2094) (fun (_x : β) (x._@.Mathlib.Order.Hom.Basic._hyg.2116 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) _x x._@.Mathlib.Order.Hom.Basic._hyg.2116) (OrderIsoClass.toOrderHomClass.{u2, u3, u1} F α β (Preorder.toLE.{u3} α _inst_1) (Preorder.toLE.{u1} β _inst_2) _inst_3)) f a))
Case conversion may be inaccurate. Consider using '#align map_inv_lt_iff map_inv_lt_iffₓ'. -/
@[simp]
theorem map_inv_lt_iff (f : F) {a : α} {b : β} : EquivLike.inv f b < a ↔ b < f a :=
  by
  convert (map_lt_map_iff _).symm
  exact (EquivLike.right_inv _ _).symm
#align map_inv_lt_iff map_inv_lt_iff

/- warning: lt_map_inv_iff -> lt_map_inv_iff is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : OrderIsoClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2)] (f : F) {a : α} {b : β}, Iff (LT.lt.{u2} α (Preorder.toLT.{u2} α _inst_1) a (EquivLike.inv.{succ u1, succ u2, succ u3} F α β (OrderIsoClass.toEquivLike.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_3) f b)) (LT.lt.{u3} β (Preorder.toLT.{u3} β _inst_2) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (RelHomClass.toFunLike.{u1, u2, u3} F α β (LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1)) (LE.le.{u3} β (Preorder.toLE.{u3} β _inst_2)) (OrderIsoClass.toOrderHomClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_3))) f a) b)
but is expected to have type
  forall {F : Type.{u2}} {α : Type.{u3}} {β : Type.{u1}} [_inst_1 : Preorder.{u3} α] [_inst_2 : Preorder.{u1} β] [_inst_3 : OrderIsoClass.{u2, u3, u1} F α β (Preorder.toLE.{u3} α _inst_1) (Preorder.toLE.{u1} β _inst_2)] (f : F) {a : α} {b : β}, Iff (LT.lt.{u3} α (Preorder.toLT.{u3} α _inst_1) a (EquivLike.inv.{succ u2, succ u3, succ u1} F α β (OrderIsoClass.toEquivLike.{u2, u3, u1} F α β (Preorder.toLE.{u3} α _inst_1) (Preorder.toLE.{u1} β _inst_2) _inst_3) f b)) (LT.lt.{u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) (Preorder.toLT.{u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) _inst_2) (FunLike.coe.{succ u2, succ u3, succ u1} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) _x) (RelHomClass.toFunLike.{u2, u3, u1} F α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.2092 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.2094 : α) => LE.le.{u3} α (Preorder.toLE.{u3} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.2092 x._@.Mathlib.Order.Hom.Basic._hyg.2094) (fun (_x : β) (x._@.Mathlib.Order.Hom.Basic._hyg.2116 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) _x x._@.Mathlib.Order.Hom.Basic._hyg.2116) (OrderIsoClass.toOrderHomClass.{u2, u3, u1} F α β (Preorder.toLE.{u3} α _inst_1) (Preorder.toLE.{u1} β _inst_2) _inst_3)) f a) b)
Case conversion may be inaccurate. Consider using '#align lt_map_inv_iff lt_map_inv_iffₓ'. -/
@[simp]
theorem lt_map_inv_iff (f : F) {a : α} {b : β} : a < EquivLike.inv f b ↔ f a < b :=
  by
  convert (map_lt_map_iff _).symm
  exact (EquivLike.right_inv _ _).symm
#align lt_map_inv_iff lt_map_inv_iff

end OrderIsoClass

namespace OrderHom

variable [Preorder α] [Preorder β] [Preorder γ] [Preorder δ]

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (α →o β) fun _ => α → β :=
  ⟨OrderHom.toFun⟩

initialize_simps_projections OrderHom (toFun → coe)

/- warning: order_hom.monotone -> OrderHom.monotone is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2), Monotone.{u1, u2} α β _inst_1 _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (f : OrderHom.{u2, u1} α β _inst_1 _inst_2), Monotone.{u2, u1} α β _inst_1 _inst_2 (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align order_hom.monotone OrderHom.monotoneₓ'. -/
protected theorem monotone (f : α →o β) : Monotone f :=
  f.monotone'
#align order_hom.monotone OrderHom.monotone

/- warning: order_hom.mono -> OrderHom.mono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2), Monotone.{u1, u2} α β _inst_1 _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (f : OrderHom.{u2, u1} α β _inst_1 _inst_2), Monotone.{u2, u1} α β _inst_1 _inst_2 (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 f)
Case conversion may be inaccurate. Consider using '#align order_hom.mono OrderHom.monoₓ'. -/
protected theorem mono (f : α →o β) : Monotone f :=
  f.Monotone
#align order_hom.mono OrderHom.mono

instance : OrderHomClass (α →o β) α β where
  coe := toFun
  coe_injective' f g h := by
    cases f
    cases g
    congr
  map_rel f := f.Monotone

/- warning: order_hom.to_fun_eq_coe clashes with [anonymous] -> [anonymous]
warning: order_hom.to_fun_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {f : OrderHom.{u1, u2} α β _inst_1 _inst_2}, Eq.{max (succ u1) (succ u2)} (α -> β) (OrderHom.toFun.{u1, u2} α β _inst_1 _inst_2 f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}}, (Nat -> α -> β) -> Nat -> (List.{u1} α) -> (List.{u2} β)
Case conversion may be inaccurate. Consider using '#align order_hom.to_fun_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] {f : α →o β} : f.toFun = f :=
  rfl
#align order_hom.to_fun_eq_coe[anonymous]

/- warning: order_hom.coe_fun_mk -> OrderHom.coe_fun_mk is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {f : α -> β} (hf : Monotone.{u1, u2} α β _inst_1 _inst_2 f), Eq.{max (succ u1) (succ u2)} ((fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.mk.{u1, u2} α β _inst_1 _inst_2 f hf)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (OrderHom.mk.{u1, u2} α β _inst_1 _inst_2 f hf)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {f : α -> β} (hf : Monotone.{u2, u1} α β _inst_1 _inst_2 f), Eq.{max (succ u2) (succ u1)} (α -> β) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 (OrderHom.mk.{u2, u1} α β _inst_1 _inst_2 f hf)) f
Case conversion may be inaccurate. Consider using '#align order_hom.coe_fun_mk OrderHom.coe_fun_mkₓ'. -/
@[simp]
theorem coe_fun_mk {f : α → β} (hf : Monotone f) : (mk f hf : α → β) = f :=
  rfl
#align order_hom.coe_fun_mk OrderHom.coe_fun_mk

/- warning: order_hom.ext -> OrderHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2) (g : OrderHom.{u1, u2} α β _inst_1 _inst_2), (Eq.{max (succ u1) (succ u2)} ((fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g)) -> (Eq.{max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (f : OrderHom.{u2, u1} α β _inst_1 _inst_2) (g : OrderHom.{u2, u1} α β _inst_1 _inst_2), (Eq.{max (succ u2) (succ u1)} (α -> β) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 f) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 g)) -> (Eq.{max (succ u2) (succ u1)} (OrderHom.{u2, u1} α β _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align order_hom.ext OrderHom.extₓ'. -/
-- See library note [partially-applied ext lemmas]
@[ext]
theorem ext (f g : α →o β) (h : (f : α → β) = g) : f = g :=
  FunLike.coe_injective h
#align order_hom.ext OrderHom.ext

theorem coe_eq (f : α →o β) : coe f = f := by ext <;> rfl
#align order_hom.coe_eq OrderHom.coe_eq

/-- One can lift an unbundled monotone function to a bundled one. -/
instance : CanLift (α → β) (α →o β) coeFn Monotone where prf f h := ⟨⟨f, h⟩, rfl⟩

#print OrderHom.copy /-
/-- Copy of an `order_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : α →o β) (f' : α → β) (h : f' = f) : α →o β :=
  ⟨f', h.symm.subst f.monotone'⟩
#align order_hom.copy OrderHom.copy
-/

/- warning: order_hom.coe_copy -> OrderHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (OrderHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (f : OrderHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 f)), Eq.{max (succ u2) (succ u1)} (α -> β) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 (OrderHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align order_hom.coe_copy OrderHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : α →o β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align order_hom.coe_copy OrderHom.coe_copy

/- warning: order_hom.copy_eq -> OrderHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (f : OrderHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 f)), Eq.{max (succ u2) (succ u1)} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (OrderHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h) f
Case conversion may be inaccurate. Consider using '#align order_hom.copy_eq OrderHom.copy_eqₓ'. -/
theorem copy_eq (f : α →o β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align order_hom.copy_eq OrderHom.copy_eq

#print OrderHom.id /-
/-- The identity function as bundled monotone function. -/
@[simps (config := { fullyApplied := false })]
def id : α →o α :=
  ⟨id, monotone_id⟩
#align order_hom.id OrderHom.id
-/

instance : Inhabited (α →o α) :=
  ⟨id⟩

/-- The preorder structure of `α →o β` is pointwise inequality: `f ≤ g ↔ ∀ a, f a ≤ g a`. -/
instance : Preorder (α →o β) :=
  @Preorder.lift (α →o β) (α → β) _ coeFn

instance {β : Type _} [PartialOrder β] : PartialOrder (α →o β) :=
  @PartialOrder.lift (α →o β) (α → β) _ coeFn ext

/- warning: order_hom.le_def -> OrderHom.le_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {f : OrderHom.{u1, u2} α β _inst_1 _inst_2} {g : OrderHom.{u1, u2} α β _inst_1 _inst_2}, Iff (LE.le.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (Preorder.toLE.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.preorder.{u1, u2} α β _inst_1 _inst_2)) f g) (forall (x : α), LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {f : OrderHom.{u2, u1} α β _inst_1 _inst_2} {g : OrderHom.{u2, u1} α β _inst_1 _inst_2}, Iff (LE.le.{max u2 u1} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (Preorder.toLE.{max u2 u1} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (OrderHom.instPreorderOrderHom.{u2, u1} α β _inst_1 _inst_2)) f g) (forall (x : α), LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 f x) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 g x))
Case conversion may be inaccurate. Consider using '#align order_hom.le_def OrderHom.le_defₓ'. -/
theorem le_def {f g : α →o β} : f ≤ g ↔ ∀ x, f x ≤ g x :=
  Iff.rfl
#align order_hom.le_def OrderHom.le_def

/- warning: order_hom.coe_le_coe -> OrderHom.coe_le_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {f : OrderHom.{u1, u2} α β _inst_1 _inst_2} {g : OrderHom.{u1, u2} α β _inst_1 _inst_2}, Iff (LE.le.{max u1 u2} ((fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) f) (Pi.hasLe.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => Preorder.toLE.{u2} β _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g)) (LE.le.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (Preorder.toLE.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.preorder.{u1, u2} α β _inst_1 _inst_2)) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {f : OrderHom.{u2, u1} α β _inst_1 _inst_2} {g : OrderHom.{u2, u1} α β _inst_1 _inst_2}, Iff (LE.le.{max u2 u1} (α -> β) (Pi.hasLe.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => Preorder.toLE.{u1} β _inst_2)) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 f) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 g)) (LE.le.{max u2 u1} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (Preorder.toLE.{max u2 u1} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (OrderHom.instPreorderOrderHom.{u2, u1} α β _inst_1 _inst_2)) f g)
Case conversion may be inaccurate. Consider using '#align order_hom.coe_le_coe OrderHom.coe_le_coeₓ'. -/
@[simp, norm_cast]
theorem coe_le_coe {f g : α →o β} : (f : α → β) ≤ g ↔ f ≤ g :=
  Iff.rfl
#align order_hom.coe_le_coe OrderHom.coe_le_coe

/- warning: order_hom.mk_le_mk -> OrderHom.mk_le_mk is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {f : α -> β} {g : α -> β} {hf : Monotone.{u1, u2} α β _inst_1 _inst_2 f} {hg : Monotone.{u1, u2} α β _inst_1 _inst_2 g}, Iff (LE.le.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (Preorder.toLE.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.preorder.{u1, u2} α β _inst_1 _inst_2)) (OrderHom.mk.{u1, u2} α β _inst_1 _inst_2 f hf) (OrderHom.mk.{u1, u2} α β _inst_1 _inst_2 g hg)) (LE.le.{max u1 u2} (α -> β) (Pi.hasLe.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => Preorder.toLE.{u2} β _inst_2)) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {f : α -> β} {g : α -> β} {hf : Monotone.{u2, u1} α β _inst_1 _inst_2 f} {hg : Monotone.{u2, u1} α β _inst_1 _inst_2 g}, Iff (LE.le.{max u2 u1} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (Preorder.toLE.{max u2 u1} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (OrderHom.instPreorderOrderHom.{u2, u1} α β _inst_1 _inst_2)) (OrderHom.mk.{u2, u1} α β _inst_1 _inst_2 f hf) (OrderHom.mk.{u2, u1} α β _inst_1 _inst_2 g hg)) (LE.le.{max u2 u1} (α -> β) (Pi.hasLe.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => Preorder.toLE.{u1} β _inst_2)) f g)
Case conversion may be inaccurate. Consider using '#align order_hom.mk_le_mk OrderHom.mk_le_mkₓ'. -/
@[simp]
theorem mk_le_mk {f g : α → β} {hf hg} : mk f hf ≤ mk g hg ↔ f ≤ g :=
  Iff.rfl
#align order_hom.mk_le_mk OrderHom.mk_le_mk

/- warning: order_hom.apply_mono -> OrderHom.apply_mono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {f : OrderHom.{u1, u2} α β _inst_1 _inst_2} {g : OrderHom.{u1, u2} α β _inst_1 _inst_2} {x : α} {y : α}, (LE.le.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (Preorder.toLE.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.preorder.{u1, u2} α β _inst_1 _inst_2)) f g) -> (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x y) -> (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {f : OrderHom.{u2, u1} α β _inst_1 _inst_2} {g : OrderHom.{u2, u1} α β _inst_1 _inst_2} {x : α} {y : α}, (LE.le.{max u2 u1} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (Preorder.toLE.{max u2 u1} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (OrderHom.instPreorderOrderHom.{u2, u1} α β _inst_1 _inst_2)) f g) -> (LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x y) -> (LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 f x) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 g y))
Case conversion may be inaccurate. Consider using '#align order_hom.apply_mono OrderHom.apply_monoₓ'. -/
@[mono]
theorem apply_mono {f g : α →o β} {x y : α} (h₁ : f ≤ g) (h₂ : x ≤ y) : f x ≤ g y :=
  (h₁ x).trans <| g.mono h₂
#align order_hom.apply_mono OrderHom.apply_mono

/- warning: order_hom.curry -> OrderHom.curry is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ], OrderIso.{max (max u1 u2) u3, max u1 u2 u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.preorder.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (Preorder.toLE.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ], OrderIso.{max u3 u2 u1, max (max u3 u2) u1} (OrderHom.{max u2 u1, u3} (Prod.{u1, u2} α β) γ (Prod.instPreorderProd.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u1, max u3 u2} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u2, u3} β γ _inst_2 _inst_3)) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{max u2 u1, u3} (Prod.{u1, u2} α β) γ (Prod.instPreorderProd.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.instPreorderOrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.instPreorderProd.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{u1, max u3 u2} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.instPreorderOrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u2, u3} β γ _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align order_hom.curry OrderHom.curryₓ'. -/
/-- Curry/uncurry as an order isomorphism between `α × β →o γ` and `α →o β →o γ`. -/
def curry : (α × β →o γ) ≃o (α →o β →o γ)
    where
  toFun f :=
    ⟨fun x => ⟨Function.curry f x, fun y₁ y₂ h => f.mono ⟨le_rfl, h⟩⟩, fun x₁ x₂ h y =>
      f.mono ⟨h, le_rfl⟩⟩
  invFun f :=
    ⟨Function.uncurry fun x => f x, fun x y h => (f.mono h.1 x.2).trans <| (f y.1).mono h.2⟩
  left_inv f := by
    ext ⟨x, y⟩
    rfl
  right_inv f := by
    ext (x y)
    rfl
  map_rel_iff' f g := by simp [le_def]
#align order_hom.curry OrderHom.curry

/- warning: order_hom.curry_apply -> OrderHom.curry_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] (f : OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (x : α) (y : β), Eq.{succ u3} γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : OrderHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (OrderHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) (coeFn.{max (succ u1) (succ (max u2 u3)), max (succ u1) (succ (max u2 u3))} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (fun (_x : OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) => α -> (OrderHom.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.hasCoeToFun.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (coeFn.{max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3)), max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3))} (OrderIso.{max (max u1 u2) u3, max u1 u2 u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.preorder.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (Preorder.toLE.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)))) (fun (_x : RelIso.{max (max u1 u2) u3, max u1 u2 u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (LE.le.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.preorder.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3))) (LE.le.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (Preorder.toLE.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3))))) => (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) -> (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3))) (RelIso.hasCoeToFun.{max (max u1 u2) u3, max u1 u2 u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (LE.le.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.preorder.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3))) (LE.le.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (Preorder.toLE.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3))))) (OrderHom.curry.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3) f) x) y) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (fun (_x : OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} α β) -> γ) (OrderHom.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) f (Prod.mk.{u1, u2} α β x y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u3}} {γ : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u1} γ] (f : OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (x : α) (y : β), Eq.{succ u1} γ (OrderHom.toFun.{u3, u1} β γ _inst_2 _inst_3 (OrderHom.toFun.{u2, max u3 u1} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3) (FunLike.coe.{succ (max (max u1 u3) u2), succ (max (max u1 u3) u2), succ (max (max u1 u3) u2)} (Function.Embedding.{succ (max (max u1 u3) u2), succ (max (max u1 u3) u2)} (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3))) (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (fun (_x : OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) => OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) _x) (EmbeddingLike.toFunLike.{succ (max (max u1 u3) u2), succ (max (max u1 u3) u2), succ (max (max u1 u3) u2)} (Function.Embedding.{succ (max (max u1 u3) u2), succ (max (max u1 u3) u2)} (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3))) (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) (Function.instEmbeddingLikeEmbedding.{succ (max (max u1 u3) u2), succ (max (max u1 u3) u2)} (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)))) (RelEmbedding.toEmbedding.{max (max u1 u3) u2, max (max u1 u3) u2} (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) => LE.le.{max u1 u3 u2} (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u2 u3) u1} (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (OrderHom.instPreorderOrderHom.{max u2 u3, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) => LE.le.{max (max u1 u3) u2} (OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) (Preorder.toLE.{max (max u2 u3) u1} (OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) (OrderHom.instPreorderOrderHom.{u2, max u3 u1} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max (max u1 u3) u2, max (max u1 u3) u2} (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) => LE.le.{max u1 u3 u2} (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u2 u3) u1} (OrderHom.{max u3 u2, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3) (OrderHom.instPreorderOrderHom.{max u2 u3, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) => LE.le.{max (max u1 u3) u2} (OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) (Preorder.toLE.{max (max u2 u3) u1} (OrderHom.{u2, max u1 u3} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3)) (OrderHom.instPreorderOrderHom.{u2, max u3 u1} α (OrderHom.{u3, u1} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u1} β γ _inst_2 _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderHom.curry.{u2, u3, u1} α β γ _inst_1 _inst_2 _inst_3))) f) x) y) (OrderHom.toFun.{max u2 u3, u1} (Prod.{u2, u3} α β) γ (Prod.instPreorderProd.{u2, u3} α β _inst_1 _inst_2) _inst_3 f (Prod.mk.{u2, u3} α β x y))
Case conversion may be inaccurate. Consider using '#align order_hom.curry_apply OrderHom.curry_applyₓ'. -/
@[simp]
theorem curry_apply (f : α × β →o γ) (x : α) (y : β) : curry f x y = f (x, y) :=
  rfl
#align order_hom.curry_apply OrderHom.curry_apply

/- warning: order_hom.curry_symm_apply -> OrderHom.curry_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] (f : OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (x : Prod.{u1, u2} α β), Eq.{succ u3} γ (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (fun (_x : OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) => (Prod.{u1, u2} α β) -> γ) (OrderHom.hasCoeToFun.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (RelIso.{max u1 u2 u3, max (max u1 u2) u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (LE.le.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (Preorder.toLE.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)))) (LE.le.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.preorder.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3)))) (fun (_x : RelIso.{max u1 u2 u3, max (max u1 u2) u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (LE.le.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (Preorder.toLE.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)))) (LE.le.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.preorder.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3)))) => (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) -> (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3)) (RelIso.hasCoeToFun.{max u1 u2 u3, max (max u1 u2) u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (LE.le.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (Preorder.toLE.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)))) (LE.le.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.preorder.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3)))) (RelIso.symm.{max (max u1 u2) u3, max u1 u2 u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (LE.le.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3) (OrderHom.preorder.{max u1 u2, u3} (Prod.{u1, u2} α β) γ (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_3))) (LE.le.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (Preorder.toLE.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)))) (OrderHom.curry.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3)) f) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : OrderHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (OrderHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) (coeFn.{max (succ u1) (succ (max u2 u3)), max (succ u1) (succ (max u2 u3))} (OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (fun (_x : OrderHom.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) => α -> (OrderHom.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.hasCoeToFun.{u1, max u2 u3} α (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_1 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) f (Prod.fst.{u1, u2} α β x)) (Prod.snd.{u1, u2} α β x))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {γ : Type.{u2}} [_inst_1 : Preorder.{u3} α] [_inst_2 : Preorder.{u1} β] [_inst_3 : Preorder.{u2} γ] (f : OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (x : Prod.{u3, u1} α β), Eq.{succ u2} γ (OrderHom.toFun.{max u3 u1, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3 (FunLike.coe.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Function.Embedding.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3)) (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (fun (_x : OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) => OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) _x) (EmbeddingLike.toFunLike.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (Function.Embedding.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3)) (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (Function.instEmbeddingLikeEmbedding.{succ (max (max u2 u1) u3), succ (max (max u2 u1) u3)} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3))) (RelEmbedding.toEmbedding.{max (max u2 u1) u3, max (max u2 u1) u3} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) => LE.le.{max (max u2 u1) u3} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (Preorder.toLE.{max (max u3 u1) u2} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (OrderHom.instPreorderOrderHom.{u3, max u1 u2} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) => LE.le.{max u2 u1 u3} (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u3 u1) u2} (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (OrderHom.instPreorderOrderHom.{max u3 u1, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (RelIso.toRelEmbedding.{max (max u2 u1) u3, max (max u2 u1) u3} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) => LE.le.{max (max u2 u1) u3} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (Preorder.toLE.{max (max u3 u1) u2} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (OrderHom.instPreorderOrderHom.{u3, max u1 u2} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) => LE.le.{max u2 u1 u3} (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u3 u1) u2} (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (OrderHom.instPreorderOrderHom.{max u3 u1, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (RelIso.symm.{max (max u2 u1) u3, max (max u2 u1) u3} (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) => LE.le.{max u2 u1 u3} (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (Preorder.toLE.{max (max u3 u1) u2} (OrderHom.{max u1 u3, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3) (OrderHom.instPreorderOrderHom.{max u3 u1, u2} (Prod.{u3, u1} α β) γ (Prod.instPreorderProd.{u3, u1} α β _inst_1 _inst_2) _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) => LE.le.{max (max u2 u1) u3} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (Preorder.toLE.{max (max u3 u1) u2} (OrderHom.{u3, max u2 u1} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3)) (OrderHom.instPreorderOrderHom.{u3, max u1 u2} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderHom.curry.{u3, u1, u2} α β γ _inst_1 _inst_2 _inst_3)))) f) x) (OrderHom.toFun.{u1, u2} β γ _inst_2 _inst_3 (OrderHom.toFun.{u3, max u1 u2} α (OrderHom.{u1, u2} β γ _inst_2 _inst_3) _inst_1 (OrderHom.instPreorderOrderHom.{u1, u2} β γ _inst_2 _inst_3) f (Prod.fst.{u3, u1} α β x)) (Prod.snd.{u3, u1} α β x))
Case conversion may be inaccurate. Consider using '#align order_hom.curry_symm_apply OrderHom.curry_symm_applyₓ'. -/
@[simp]
theorem curry_symm_apply (f : α →o β →o γ) (x : α × β) : curry.symm f x = f x.1 x.2 :=
  rfl
#align order_hom.curry_symm_apply OrderHom.curry_symm_apply

#print OrderHom.comp /-
/-- The composition of two bundled monotone functions. -/
@[simps (config := { fullyApplied := false })]
def comp (g : β →o γ) (f : α →o β) : α →o γ :=
  ⟨g ∘ f, g.mono.comp f.mono⟩
#align order_hom.comp OrderHom.comp
-/

/- warning: order_hom.comp_mono -> OrderHom.comp_mono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] {{g₁ : OrderHom.{u2, u3} β γ _inst_2 _inst_3}} {{g₂ : OrderHom.{u2, u3} β γ _inst_2 _inst_3}}, (LE.le.{max u2 u3} (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (Preorder.toLE.{max u2 u3} (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) g₁ g₂) -> (forall {{f₁ : OrderHom.{u1, u2} α β _inst_1 _inst_2}} {{f₂ : OrderHom.{u1, u2} α β _inst_1 _inst_2}}, (LE.le.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (Preorder.toLE.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.preorder.{u1, u2} α β _inst_1 _inst_2)) f₁ f₂) -> (LE.le.{max u1 u3} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (Preorder.toLE.{max u1 u3} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.preorder.{u1, u3} α γ _inst_1 _inst_3)) (OrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₁ f₁) (OrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₂ f₂)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] {{g₁ : OrderHom.{u3, u2} β γ _inst_2 _inst_3}} {{g₂ : OrderHom.{u3, u2} β γ _inst_2 _inst_3}}, (LE.le.{max u3 u2} (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (Preorder.toLE.{max u3 u2} (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (OrderHom.instPreorderOrderHom.{u3, u2} β γ _inst_2 _inst_3)) g₁ g₂) -> (forall {{f₁ : OrderHom.{u1, u3} α β _inst_1 _inst_2}} {{f₂ : OrderHom.{u1, u3} α β _inst_1 _inst_2}}, (LE.le.{max u1 u3} (OrderHom.{u1, u3} α β _inst_1 _inst_2) (Preorder.toLE.{max u1 u3} (OrderHom.{u1, u3} α β _inst_1 _inst_2) (OrderHom.instPreorderOrderHom.{u1, u3} α β _inst_1 _inst_2)) f₁ f₂) -> (LE.le.{max u1 u2} (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (Preorder.toLE.{max u1 u2} (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (OrderHom.instPreorderOrderHom.{u1, u2} α γ _inst_1 _inst_3)) (OrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₁ f₁) (OrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₂ f₂)))
Case conversion may be inaccurate. Consider using '#align order_hom.comp_mono OrderHom.comp_monoₓ'. -/
@[mono]
theorem comp_mono ⦃g₁ g₂ : β →o γ⦄ (hg : g₁ ≤ g₂) ⦃f₁ f₂ : α →o β⦄ (hf : f₁ ≤ f₂) :
    g₁.comp f₁ ≤ g₂.comp f₂ := fun x => (hg _).trans (g₂.mono <| hf _)
#align order_hom.comp_mono OrderHom.comp_mono

#print OrderHom.compₘ /-
/-- The composition of two bundled monotone functions, a fully bundled version. -/
@[simps (config := { fullyApplied := false })]
def compₘ : (β →o γ) →o (α →o β) →o α →o γ :=
  curry ⟨fun f : (β →o γ) × (α →o β) => f.1.comp f.2, fun f₁ f₂ h => comp_mono h.1 h.2⟩
#align order_hom.compₘ OrderHom.compₘ
-/

/- warning: order_hom.comp_id -> OrderHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.comp.{u1, u1, u2} α α β _inst_1 _inst_1 _inst_2 f (OrderHom.id.{u1} α _inst_1)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (f : OrderHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (OrderHom.comp.{u2, u2, u1} α α β _inst_1 _inst_1 _inst_2 f (OrderHom.id.{u2} α _inst_1)) f
Case conversion may be inaccurate. Consider using '#align order_hom.comp_id OrderHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : α →o β) : comp f id = f := by
  ext
  rfl
#align order_hom.comp_id OrderHom.comp_id

/- warning: order_hom.id_comp -> OrderHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_2 (OrderHom.id.{u2} β _inst_2) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (f : OrderHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (OrderHom.{u2, u1} α β _inst_1 _inst_2) (OrderHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_2 (OrderHom.id.{u1} β _inst_2) f) f
Case conversion may be inaccurate. Consider using '#align order_hom.id_comp OrderHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : α →o β) : comp id f = f := by
  ext
  rfl
#align order_hom.id_comp OrderHom.id_comp

#print OrderHom.const /-
/-- Constant function bundled as a `order_hom`. -/
@[simps (config := { fullyApplied := false })]
def const (α : Type _) [Preorder α] {β : Type _} [Preorder β] : β →o α →o β
    where
  toFun b := ⟨Function.const α b, fun _ _ _ => le_rfl⟩
  monotone' b₁ b₂ h x := h
#align order_hom.const OrderHom.const
-/

/- warning: order_hom.const_comp -> OrderHom.const_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2) (c : γ), Eq.{max (succ u1) (succ u3)} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (OrderHom.{u3, max u2 u3} γ (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_3 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (fun (_x : OrderHom.{u3, max u2 u3} γ (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_3 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) => γ -> (OrderHom.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.hasCoeToFun.{u3, max u2 u3} γ (OrderHom.{u2, u3} β γ _inst_2 _inst_3) _inst_3 (OrderHom.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.const.{u2, u3} β _inst_2 γ _inst_3) c) f) (coeFn.{max (succ u3) (succ (max u1 u3)), max (succ u3) (succ (max u1 u3))} (OrderHom.{u3, max u1 u3} γ (OrderHom.{u1, u3} α γ _inst_1 _inst_3) _inst_3 (OrderHom.preorder.{u1, u3} α γ _inst_1 _inst_3)) (fun (_x : OrderHom.{u3, max u1 u3} γ (OrderHom.{u1, u3} α γ _inst_1 _inst_3) _inst_3 (OrderHom.preorder.{u1, u3} α γ _inst_1 _inst_3)) => γ -> (OrderHom.{u1, u3} α γ _inst_1 _inst_3)) (OrderHom.hasCoeToFun.{u3, max u1 u3} γ (OrderHom.{u1, u3} α γ _inst_1 _inst_3) _inst_3 (OrderHom.preorder.{u1, u3} α γ _inst_1 _inst_3)) (OrderHom.const.{u1, u3} α _inst_1 γ _inst_3) c)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Preorder.{u3} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u1} γ] (f : OrderHom.{u3, u2} α β _inst_1 _inst_2) (c : γ), Eq.{max (succ u3) (succ u1)} (OrderHom.{u3, u1} α γ _inst_1 _inst_3) (OrderHom.comp.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3 (OrderHom.toFun.{u1, max u2 u1} γ (OrderHom.{u2, u1} β γ _inst_2 _inst_3) _inst_3 (OrderHom.instPreorderOrderHom.{u2, u1} β γ _inst_2 _inst_3) (OrderHom.const.{u2, u1} β _inst_2 γ _inst_3) c) f) (OrderHom.toFun.{u1, max u3 u1} γ (OrderHom.{u3, u1} α γ _inst_1 _inst_3) _inst_3 (OrderHom.instPreorderOrderHom.{u3, u1} α γ _inst_1 _inst_3) (OrderHom.const.{u3, u1} α _inst_1 γ _inst_3) c)
Case conversion may be inaccurate. Consider using '#align order_hom.const_comp OrderHom.const_compₓ'. -/
@[simp]
theorem const_comp (f : α →o β) (c : γ) : (const β c).comp f = const α c :=
  rfl
#align order_hom.const_comp OrderHom.const_comp

/- warning: order_hom.comp_const -> OrderHom.comp_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (γ : Type.{u3}) [_inst_5 : Preorder.{u3} γ] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2) (c : α), Eq.{max (succ u3) (succ u2)} (OrderHom.{u3, u2} γ β _inst_5 _inst_2) (OrderHom.comp.{u3, u1, u2} γ α β _inst_5 _inst_1 _inst_2 f (coeFn.{max (succ u1) (succ (max u3 u1)), max (succ u1) (succ (max u3 u1))} (OrderHom.{u1, max u3 u1} α (OrderHom.{u3, u1} γ α _inst_5 _inst_1) _inst_1 (OrderHom.preorder.{u3, u1} γ α _inst_5 _inst_1)) (fun (_x : OrderHom.{u1, max u3 u1} α (OrderHom.{u3, u1} γ α _inst_5 _inst_1) _inst_1 (OrderHom.preorder.{u3, u1} γ α _inst_5 _inst_1)) => α -> (OrderHom.{u3, u1} γ α _inst_5 _inst_1)) (OrderHom.hasCoeToFun.{u1, max u3 u1} α (OrderHom.{u3, u1} γ α _inst_5 _inst_1) _inst_1 (OrderHom.preorder.{u3, u1} γ α _inst_5 _inst_1)) (OrderHom.const.{u3, u1} γ _inst_5 α _inst_1) c)) (coeFn.{max (succ u2) (succ (max u3 u2)), max (succ u2) (succ (max u3 u2))} (OrderHom.{u2, max u3 u2} β (OrderHom.{u3, u2} γ β _inst_5 _inst_2) _inst_2 (OrderHom.preorder.{u3, u2} γ β _inst_5 _inst_2)) (fun (_x : OrderHom.{u2, max u3 u2} β (OrderHom.{u3, u2} γ β _inst_5 _inst_2) _inst_2 (OrderHom.preorder.{u3, u2} γ β _inst_5 _inst_2)) => β -> (OrderHom.{u3, u2} γ β _inst_5 _inst_2)) (OrderHom.hasCoeToFun.{u2, max u3 u2} β (OrderHom.{u3, u2} γ β _inst_5 _inst_2) _inst_2 (OrderHom.preorder.{u3, u2} γ β _inst_5 _inst_2)) (OrderHom.const.{u3, u2} γ _inst_5 β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (γ : Type.{u3}) [_inst_5 : Preorder.{u3} γ] (f : OrderHom.{u2, u1} α β _inst_1 _inst_2) (c : α), Eq.{max (succ u1) (succ u3)} (OrderHom.{u3, u1} γ β _inst_5 _inst_2) (OrderHom.comp.{u3, u2, u1} γ α β _inst_5 _inst_1 _inst_2 f (OrderHom.toFun.{u2, max u3 u2} α (OrderHom.{u3, u2} γ α _inst_5 _inst_1) _inst_1 (OrderHom.instPreorderOrderHom.{u3, u2} γ α _inst_5 _inst_1) (OrderHom.const.{u3, u2} γ _inst_5 α _inst_1) c)) (OrderHom.toFun.{u1, max u3 u1} β (OrderHom.{u3, u1} γ β _inst_5 _inst_2) _inst_2 (OrderHom.instPreorderOrderHom.{u3, u1} γ β _inst_5 _inst_2) (OrderHom.const.{u3, u1} γ _inst_5 β _inst_2) (OrderHom.toFun.{u2, u1} α β _inst_1 _inst_2 f c))
Case conversion may be inaccurate. Consider using '#align order_hom.comp_const OrderHom.comp_constₓ'. -/
@[simp]
theorem comp_const (γ : Type _) [Preorder γ] (f : α →o β) (c : α) :
    f.comp (const γ c) = const γ (f c) :=
  rfl
#align order_hom.comp_const OrderHom.comp_const

/- warning: order_hom.prod -> OrderHom.prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ], (OrderHom.{u1, u2} α β _inst_1 _inst_2) -> (OrderHom.{u1, u3} α γ _inst_1 _inst_3) -> (OrderHom.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ], (OrderHom.{u1, u2} α β _inst_1 _inst_2) -> (OrderHom.{u1, u3} α γ _inst_1 _inst_3) -> (OrderHom.{u1, max u3 u2} α (Prod.{u2, u3} β γ) _inst_1 (Prod.instPreorderProd.{u2, u3} β γ _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align order_hom.prod OrderHom.prodₓ'. -/
/-- Given two bundled monotone maps `f`, `g`, `f.prod g` is the map `x ↦ (f x, g x)` bundled as a
`order_hom`. -/
@[simps]
protected def prod (f : α →o β) (g : α →o γ) : α →o β × γ :=
  ⟨fun x => (f x, g x), fun x y h => ⟨f.mono h, g.mono h⟩⟩
#align order_hom.prod OrderHom.prod

/- warning: order_hom.prod_mono -> OrderHom.prod_mono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] {f₁ : OrderHom.{u1, u2} α β _inst_1 _inst_2} {f₂ : OrderHom.{u1, u2} α β _inst_1 _inst_2}, (LE.le.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (Preorder.toLE.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.preorder.{u1, u2} α β _inst_1 _inst_2)) f₁ f₂) -> (forall {g₁ : OrderHom.{u1, u3} α γ _inst_1 _inst_3} {g₂ : OrderHom.{u1, u3} α γ _inst_1 _inst_3}, (LE.le.{max u1 u3} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (Preorder.toLE.{max u1 u3} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.preorder.{u1, u3} α γ _inst_1 _inst_3)) g₁ g₂) -> (LE.le.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3)) (Preorder.toLE.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3))) (OrderHom.prod.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f₁ g₁) (OrderHom.prod.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f₂ g₂)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Preorder.{u3} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u1} γ] {f₁ : OrderHom.{u3, u2} α β _inst_1 _inst_2} {f₂ : OrderHom.{u3, u2} α β _inst_1 _inst_2}, (LE.le.{max u3 u2} (OrderHom.{u3, u2} α β _inst_1 _inst_2) (Preorder.toLE.{max u3 u2} (OrderHom.{u3, u2} α β _inst_1 _inst_2) (OrderHom.instPreorderOrderHom.{u3, u2} α β _inst_1 _inst_2)) f₁ f₂) -> (forall {g₁ : OrderHom.{u3, u1} α γ _inst_1 _inst_3} {g₂ : OrderHom.{u3, u1} α γ _inst_1 _inst_3}, (LE.le.{max u3 u1} (OrderHom.{u3, u1} α γ _inst_1 _inst_3) (Preorder.toLE.{max u3 u1} (OrderHom.{u3, u1} α γ _inst_1 _inst_3) (OrderHom.instPreorderOrderHom.{u3, u1} α γ _inst_1 _inst_3)) g₁ g₂) -> (LE.le.{max (max u3 u2) u1} (OrderHom.{u3, max u1 u2} α (Prod.{u2, u1} β γ) _inst_1 (Prod.instPreorderProd.{u2, u1} β γ _inst_2 _inst_3)) (Preorder.toLE.{max (max u3 u2) u1} (OrderHom.{u3, max u1 u2} α (Prod.{u2, u1} β γ) _inst_1 (Prod.instPreorderProd.{u2, u1} β γ _inst_2 _inst_3)) (OrderHom.instPreorderOrderHom.{u3, max u2 u1} α (Prod.{u2, u1} β γ) _inst_1 (Prod.instPreorderProd.{u2, u1} β γ _inst_2 _inst_3))) (OrderHom.prod.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3 f₁ g₁) (OrderHom.prod.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3 f₂ g₂)))
Case conversion may be inaccurate. Consider using '#align order_hom.prod_mono OrderHom.prod_monoₓ'. -/
@[mono]
theorem prod_mono {f₁ f₂ : α →o β} (hf : f₁ ≤ f₂) {g₁ g₂ : α →o γ} (hg : g₁ ≤ g₂) :
    f₁.Prod g₁ ≤ f₂.Prod g₂ := fun x => Prod.le_def.2 ⟨hf _, hg _⟩
#align order_hom.prod_mono OrderHom.prod_mono

/- warning: order_hom.comp_prod_comp_same -> OrderHom.comp_prod_comp_same is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] (f₁ : OrderHom.{u2, u3} β γ _inst_2 _inst_3) (f₂ : OrderHom.{u2, u3} β γ _inst_2 _inst_3) (g : OrderHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (OrderHom.{u1, u3} α (Prod.{u3, u3} γ γ) _inst_1 (Prod.preorder.{u3, u3} γ γ _inst_3 _inst_3)) (OrderHom.prod.{u1, u3, u3} α γ γ _inst_1 _inst_3 _inst_3 (OrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f₁ g) (OrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f₂ g)) (OrderHom.comp.{u1, u2, u3} α β (Prod.{u3, u3} γ γ) _inst_1 _inst_2 (Prod.preorder.{u3, u3} γ γ _inst_3 _inst_3) (OrderHom.prod.{u2, u3, u3} β γ γ _inst_2 _inst_3 _inst_3 f₁ f₂) g)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] (f₁ : OrderHom.{u3, u2} β γ _inst_2 _inst_3) (f₂ : OrderHom.{u3, u2} β γ _inst_2 _inst_3) (g : OrderHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (OrderHom.{u1, u2} α (Prod.{u2, u2} γ γ) _inst_1 (Prod.instPreorderProd.{u2, u2} γ γ _inst_3 _inst_3)) (OrderHom.prod.{u1, u2, u2} α γ γ _inst_1 _inst_3 _inst_3 (OrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f₁ g) (OrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f₂ g)) (OrderHom.comp.{u1, u3, u2} α β (Prod.{u2, u2} γ γ) _inst_1 _inst_2 (Prod.instPreorderProd.{u2, u2} γ γ _inst_3 _inst_3) (OrderHom.prod.{u3, u2, u2} β γ γ _inst_2 _inst_3 _inst_3 f₁ f₂) g)
Case conversion may be inaccurate. Consider using '#align order_hom.comp_prod_comp_same OrderHom.comp_prod_comp_sameₓ'. -/
theorem comp_prod_comp_same (f₁ f₂ : β →o γ) (g : α →o β) :
    (f₁.comp g).Prod (f₂.comp g) = (f₁.Prod f₂).comp g :=
  rfl
#align order_hom.comp_prod_comp_same OrderHom.comp_prod_comp_same

/- warning: order_hom.prodₘ -> OrderHom.prodₘ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ], OrderHom.{max u1 u2, max (max u1 u3) u1 u2 u3} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.{max u1 u3, max u1 u2 u3} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.preorder.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3))) (OrderHom.preorder.{u1, u2} α β _inst_1 _inst_2) (OrderHom.preorder.{max u1 u3, max u1 u2 u3} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.preorder.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ], OrderHom.{max u2 u1, max (max (max u3 u2) u1) u3 u1} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.{max u3 u1, max (max u3 u2) u1} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.{u1, max u3 u2} α (Prod.{u2, u3} β γ) _inst_1 (Prod.instPreorderProd.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.instPreorderOrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.instPreorderOrderHom.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.instPreorderProd.{u2, u3} β γ _inst_2 _inst_3))) (OrderHom.instPreorderOrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.instPreorderOrderHom.{max u1 u3, max (max u1 u2) u3} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.{u1, max u3 u2} α (Prod.{u2, u3} β γ) _inst_1 (Prod.instPreorderProd.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.instPreorderOrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.instPreorderOrderHom.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.instPreorderProd.{u2, u3} β γ _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align order_hom.prodₘ OrderHom.prodₘₓ'. -/
/-- Given two bundled monotone maps `f`, `g`, `f.prod g` is the map `x ↦ (f x, g x)` bundled as a
`order_hom`. This is a fully bundled version. -/
@[simps]
def prodₘ : (α →o β) →o (α →o γ) →o α →o β × γ :=
  curry ⟨fun f : (α →o β) × (α →o γ) => f.1.Prod f.2, fun f₁ f₂ h => prod_mono h.1 h.2⟩
#align order_hom.prodₘ OrderHom.prodₘ

/- warning: order_hom.diag -> OrderHom.diag is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Preorder.{u1} α], OrderHom.{u1, u1} α (Prod.{u1, u1} α α) _inst_1 (Prod.preorder.{u1, u1} α α _inst_1 _inst_1)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Preorder.{u1} α], OrderHom.{u1, u1} α (Prod.{u1, u1} α α) _inst_1 (Prod.instPreorderProd.{u1, u1} α α _inst_1 _inst_1)
Case conversion may be inaccurate. Consider using '#align order_hom.diag OrderHom.diagₓ'. -/
/-- Diagonal embedding of `α` into `α × α` as a `order_hom`. -/
@[simps]
def diag : α →o α × α :=
  id.Prod id
#align order_hom.diag OrderHom.diag

#print OrderHom.onDiag /-
/-- Restriction of `f : α →o α →o β` to the diagonal. -/
@[simps (config := { simpRhs := true })]
def onDiag (f : α →o α →o β) : α →o β :=
  (curry.symm f).comp diag
#align order_hom.on_diag OrderHom.onDiag
-/

/- warning: order_hom.fst -> OrderHom.fst is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], OrderHom.{max u1 u2, u1} (Prod.{u1, u2} α β) α (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_1
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], OrderHom.{max u2 u1, u1} (Prod.{u1, u2} α β) α (Prod.instPreorderProd.{u1, u2} α β _inst_1 _inst_2) _inst_1
Case conversion may be inaccurate. Consider using '#align order_hom.fst OrderHom.fstₓ'. -/
/-- `prod.fst` as a `order_hom`. -/
@[simps]
def fst : α × β →o α :=
  ⟨Prod.fst, fun x y h => h.1⟩
#align order_hom.fst OrderHom.fst

/- warning: order_hom.snd -> OrderHom.snd is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], OrderHom.{max u1 u2, u2} (Prod.{u1, u2} α β) β (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_2
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], OrderHom.{max u2 u1, u2} (Prod.{u1, u2} α β) β (Prod.instPreorderProd.{u1, u2} α β _inst_1 _inst_2) _inst_2
Case conversion may be inaccurate. Consider using '#align order_hom.snd OrderHom.sndₓ'. -/
/-- `prod.snd` as a `order_hom`. -/
@[simps]
def snd : α × β →o β :=
  ⟨Prod.snd, fun x y h => h.2⟩
#align order_hom.snd OrderHom.snd

/- warning: order_hom.fst_prod_snd -> OrderHom.fst_prod_snd is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β], Eq.{succ (max u1 u2)} (OrderHom.{max u1 u2, max u1 u2} (Prod.{u1, u2} α β) (Prod.{u1, u2} α β) (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) (Prod.preorder.{u1, u2} α β _inst_1 _inst_2)) (OrderHom.prod.{max u1 u2, u1, u2} (Prod.{u1, u2} α β) α β (Prod.preorder.{u1, u2} α β _inst_1 _inst_2) _inst_1 _inst_2 (OrderHom.fst.{u1, u2} α β _inst_1 _inst_2) (OrderHom.snd.{u1, u2} α β _inst_1 _inst_2)) (OrderHom.id.{max u1 u2} (Prod.{u1, u2} α β) (Prod.preorder.{u1, u2} α β _inst_1 _inst_2))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β], Eq.{max (succ u2) (succ u1)} (OrderHom.{max u2 u1, max u1 u2} (Prod.{u2, u1} α β) (Prod.{u2, u1} α β) (Prod.instPreorderProd.{u2, u1} α β _inst_1 _inst_2) (Prod.instPreorderProd.{u2, u1} α β _inst_1 _inst_2)) (OrderHom.prod.{max u2 u1, u2, u1} (Prod.{u2, u1} α β) α β (Prod.instPreorderProd.{u2, u1} α β _inst_1 _inst_2) _inst_1 _inst_2 (OrderHom.fst.{u2, u1} α β _inst_1 _inst_2) (OrderHom.snd.{u2, u1} α β _inst_1 _inst_2)) (OrderHom.id.{max u2 u1} (Prod.{u2, u1} α β) (Prod.instPreorderProd.{u2, u1} α β _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align order_hom.fst_prod_snd OrderHom.fst_prod_sndₓ'. -/
@[simp]
theorem fst_prod_snd : (fst : α × β →o α).Prod snd = id :=
  by
  ext ⟨x, y⟩ : 2
  rfl
#align order_hom.fst_prod_snd OrderHom.fst_prod_snd

/- warning: order_hom.fst_comp_prod -> OrderHom.fst_comp_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2) (g : OrderHom.{u1, u3} α γ _inst_1 _inst_3), Eq.{max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.comp.{u1, max u2 u3, u2} α (Prod.{u2, u3} β γ) β _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3) _inst_2 (OrderHom.fst.{u2, u3} β γ _inst_2 _inst_3) (OrderHom.prod.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) f
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Preorder.{u3} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u1} γ] (f : OrderHom.{u3, u2} α β _inst_1 _inst_2) (g : OrderHom.{u3, u1} α γ _inst_1 _inst_3), Eq.{max (succ u3) (succ u2)} (OrderHom.{u3, u2} α β _inst_1 _inst_2) (OrderHom.comp.{u3, max u1 u2, u2} α (Prod.{u2, u1} β γ) β _inst_1 (Prod.instPreorderProd.{u2, u1} β γ _inst_2 _inst_3) _inst_2 (OrderHom.fst.{u2, u1} β γ _inst_2 _inst_3) (OrderHom.prod.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3 f g)) f
Case conversion may be inaccurate. Consider using '#align order_hom.fst_comp_prod OrderHom.fst_comp_prodₓ'. -/
@[simp]
theorem fst_comp_prod (f : α →o β) (g : α →o γ) : fst.comp (f.Prod g) = f :=
  ext _ _ rfl
#align order_hom.fst_comp_prod OrderHom.fst_comp_prod

/- warning: order_hom.snd_comp_prod -> OrderHom.snd_comp_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] (f : OrderHom.{u1, u2} α β _inst_1 _inst_2) (g : OrderHom.{u1, u3} α γ _inst_1 _inst_3), Eq.{max (succ u1) (succ u3)} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.comp.{u1, max u2 u3, u3} α (Prod.{u2, u3} β γ) γ _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3) _inst_3 (OrderHom.snd.{u2, u3} β γ _inst_2 _inst_3) (OrderHom.prod.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) g
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Preorder.{u3} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u1} γ] (f : OrderHom.{u3, u2} α β _inst_1 _inst_2) (g : OrderHom.{u3, u1} α γ _inst_1 _inst_3), Eq.{max (succ u3) (succ u1)} (OrderHom.{u3, u1} α γ _inst_1 _inst_3) (OrderHom.comp.{u3, max u1 u2, u1} α (Prod.{u2, u1} β γ) γ _inst_1 (Prod.instPreorderProd.{u2, u1} β γ _inst_2 _inst_3) _inst_3 (OrderHom.snd.{u2, u1} β γ _inst_2 _inst_3) (OrderHom.prod.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3 f g)) g
Case conversion may be inaccurate. Consider using '#align order_hom.snd_comp_prod OrderHom.snd_comp_prodₓ'. -/
@[simp]
theorem snd_comp_prod (f : α →o β) (g : α →o γ) : snd.comp (f.Prod g) = g :=
  ext _ _ rfl
#align order_hom.snd_comp_prod OrderHom.snd_comp_prod

/- warning: order_hom.prod_iso -> OrderHom.prodIso is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ], OrderIso.{max u1 u2 u3, max (max u1 u2) u1 u3} (OrderHom.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3)) (Prod.{max u1 u2, max u1 u3} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.{u1, u3} α γ _inst_1 _inst_3)) (Preorder.toLE.{max u1 u2 u3} (OrderHom.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.preorder.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.preorder.{u2, u3} β γ _inst_2 _inst_3))) (Prod.hasLe.{max u1 u2, max u1 u3} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (Preorder.toLE.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.preorder.{u1, u2} α β _inst_1 _inst_2)) (Preorder.toLE.{max u1 u3} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.preorder.{u1, u3} α γ _inst_1 _inst_3)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ], OrderIso.{max (max u3 u2) u1, max (max u3 u1) u2 u1} (OrderHom.{u1, max u3 u2} α (Prod.{u2, u3} β γ) _inst_1 (Prod.instPreorderProd.{u2, u3} β γ _inst_2 _inst_3)) (Prod.{max u2 u1, max u3 u1} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.{u1, u3} α γ _inst_1 _inst_3)) (Preorder.toLE.{max (max u1 u2) u3} (OrderHom.{u1, max u3 u2} α (Prod.{u2, u3} β γ) _inst_1 (Prod.instPreorderProd.{u2, u3} β γ _inst_2 _inst_3)) (OrderHom.instPreorderOrderHom.{u1, max u2 u3} α (Prod.{u2, u3} β γ) _inst_1 (Prod.instPreorderProd.{u2, u3} β γ _inst_2 _inst_3))) (Prod.instLEProd.{max u1 u2, max u1 u3} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (Preorder.toLE.{max u1 u2} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.instPreorderOrderHom.{u1, u2} α β _inst_1 _inst_2)) (Preorder.toLE.{max u1 u3} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.instPreorderOrderHom.{u1, u3} α γ _inst_1 _inst_3)))
Case conversion may be inaccurate. Consider using '#align order_hom.prod_iso OrderHom.prodIsoₓ'. -/
/-- Order isomorphism between the space of monotone maps to `β × γ` and the product of the spaces
of monotone maps to `β` and `γ`. -/
@[simps]
def prodIso : (α →o β × γ) ≃o (α →o β) × (α →o γ)
    where
  toFun f := (fst.comp f, snd.comp f)
  invFun f := f.1.Prod f.2
  left_inv f := by ext <;> rfl
  right_inv f := by ext <;> rfl
  map_rel_iff' f g := forall_and.symm
#align order_hom.prod_iso OrderHom.prodIso

/- warning: order_hom.prod_map -> OrderHom.prodMap is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] [_inst_4 : Preorder.{u4} δ], (OrderHom.{u1, u2} α β _inst_1 _inst_2) -> (OrderHom.{u3, u4} γ δ _inst_3 _inst_4) -> (OrderHom.{max u1 u3, max u2 u4} (Prod.{u1, u3} α γ) (Prod.{u2, u4} β δ) (Prod.preorder.{u1, u3} α γ _inst_1 _inst_3) (Prod.preorder.{u2, u4} β δ _inst_2 _inst_4))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] [_inst_4 : Preorder.{u4} δ], (OrderHom.{u1, u2} α β _inst_1 _inst_2) -> (OrderHom.{u3, u4} γ δ _inst_3 _inst_4) -> (OrderHom.{max u3 u1, max u4 u2} (Prod.{u1, u3} α γ) (Prod.{u2, u4} β δ) (Prod.instPreorderProd.{u1, u3} α γ _inst_1 _inst_3) (Prod.instPreorderProd.{u2, u4} β δ _inst_2 _inst_4))
Case conversion may be inaccurate. Consider using '#align order_hom.prod_map OrderHom.prodMapₓ'. -/
/-- `prod.map` of two `order_hom`s as a `order_hom`. -/
@[simps]
def prodMap (f : α →o β) (g : γ →o δ) : α × γ →o β × δ :=
  ⟨Prod.map f g, fun x y h => ⟨f.mono h.1, g.mono h.2⟩⟩
#align order_hom.prod_map OrderHom.prodMap

variable {ι : Type _} {π : ι → Type _} [∀ i, Preorder (π i)]

#print Pi.evalOrderHom /-
/-- Evaluation of an unbundled function at a point (`function.eval`) as a `order_hom`. -/
@[simps (config := { fullyApplied := false })]
def Pi.evalOrderHom (i : ι) : (∀ j, π j) →o π i :=
  ⟨Function.eval i, Function.monotone_eval i⟩
#align pi.eval_order_hom Pi.evalOrderHom
-/

#print OrderHom.coeFnHom /-
/-- The "forgetful functor" from `α →o β` to `α → β` that takes the underlying function,
is monotone. -/
@[simps (config := { fullyApplied := false })]
def coeFnHom : (α →o β) →o α → β where
  toFun f := f
  monotone' x y h := h
#align order_hom.coe_fn_hom OrderHom.coeFnHom
-/

#print OrderHom.apply /-
/-- Function application `λ f, f a` (for fixed `a`) is a monotone function from the
monotone function space `α →o β` to `β`. See also `pi.eval_order_hom`.  -/
@[simps (config := { fullyApplied := false })]
def apply (x : α) : (α →o β) →o β :=
  (Pi.evalOrderHom x).comp coeFnHom
#align order_hom.apply OrderHom.apply
-/

#print OrderHom.pi /-
/-- Construct a bundled monotone map `α →o Π i, π i` from a family of monotone maps
`f i : α →o π i`. -/
@[simps]
def pi (f : ∀ i, α →o π i) : α →o ∀ i, π i :=
  ⟨fun x i => f i x, fun x y h i => (f i).mono h⟩
#align order_hom.pi OrderHom.pi
-/

#print OrderHom.piIso /-
/-- Order isomorphism between bundled monotone maps `α →o Π i, π i` and families of bundled monotone
maps `Π i, α →o π i`. -/
@[simps]
def piIso : (α →o ∀ i, π i) ≃o ∀ i, α →o π i
    where
  toFun f i := (Pi.evalOrderHom i).comp f
  invFun := pi
  left_inv f := by
    ext (x i)
    rfl
  right_inv f := by
    ext (x i)
    rfl
  map_rel_iff' f g := forall_swap
#align order_hom.pi_iso OrderHom.piIso
-/

#print OrderHom.Subtype.val /-
/-- `subtype.val` as a bundled monotone function.  -/
@[simps (config := { fullyApplied := false })]
def Subtype.val (p : α → Prop) : Subtype p →o α :=
  ⟨Subtype.val, fun x y h => h⟩
#align order_hom.subtype.val OrderHom.Subtype.val
-/

#print OrderHom.unique /-
/-- There is a unique monotone map from a subsingleton to itself. -/
instance unique [Subsingleton α] : Unique (α →o α)
    where
  default := OrderHom.id
  uniq a := ext _ _ (Subsingleton.elim _ _)
#align order_hom.unique OrderHom.unique
-/

#print OrderHom.orderHom_eq_id /-
theorem orderHom_eq_id [Subsingleton α] (g : α →o α) : g = OrderHom.id :=
  Subsingleton.elim _ _
#align order_hom.order_hom_eq_id OrderHom.orderHom_eq_id
-/

#print OrderHom.dual /-
/-- Reinterpret a bundled monotone function as a monotone function between dual orders. -/
@[simps]
protected def dual : (α →o β) ≃ (αᵒᵈ →o βᵒᵈ)
    where
  toFun f := ⟨OrderDual.toDual ∘ f ∘ OrderDual.ofDual, f.mono.dual⟩
  invFun f := ⟨OrderDual.ofDual ∘ f ∘ OrderDual.toDual, f.mono.dual⟩
  left_inv f := ext _ _ rfl
  right_inv f := ext _ _ rfl
#align order_hom.dual OrderHom.dual
-/

#print OrderHom.dual_id /-
@[simp]
theorem dual_id : (OrderHom.id : α →o α).dual = OrderHom.id :=
  rfl
#align order_hom.dual_id OrderHom.dual_id
-/

/- warning: order_hom.dual_comp -> OrderHom.dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] (g : OrderHom.{u2, u3} β γ _inst_2 _inst_3) (f : OrderHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_3)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_3))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_3))) => (OrderHom.{u1, u3} α γ _inst_1 _inst_3) -> (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_3))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_3))) (OrderHom.dual.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f)) (OrderHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (OrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (OrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3))) => (OrderHom.{u2, u3} β γ _inst_2 _inst_3) -> (OrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (OrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3))) (OrderHom.dual.{u2, u3} β γ _inst_2 _inst_3) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2))) => (OrderHom.{u1, u2} α β _inst_1 _inst_2) -> (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2))) (OrderHom.dual.{u1, u2} α β _inst_1 _inst_2) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] (g : OrderHom.{u3, u2} β γ _inst_2 _inst_3) (f : OrderHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderHom.{u1, u2} α γ _inst_1 _inst_3) => OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3))) (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (fun (_x : OrderHom.{u1, u2} α γ _inst_1 _inst_3) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderHom.{u1, u2} α γ _inst_1 _inst_3) => OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3))) (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3))) (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3))))) (OrderHom.dual.{u1, u2} α γ _inst_1 _inst_3) (OrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f)) (OrderHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3))) (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (fun (_x : OrderHom.{u3, u2} β γ _inst_2 _inst_3) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderHom.{u3, u2} β γ _inst_2 _inst_3) => OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3))) (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3))) (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3))))) (OrderHom.dual.{u3, u2} β γ _inst_2 _inst_3) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (OrderHom.{u1, u3} α β _inst_1 _inst_2) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2))) (OrderHom.{u1, u3} α β _inst_1 _inst_2) (fun (_x : OrderHom.{u1, u3} α β _inst_1 _inst_2) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderHom.{u1, u3} α β _inst_1 _inst_2) => OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (OrderHom.{u1, u3} α β _inst_1 _inst_2) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2))) (OrderHom.{u1, u3} α β _inst_1 _inst_2) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (OrderHom.{u1, u3} α β _inst_1 _inst_2) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2))) (OrderHom.{u1, u3} α β _inst_1 _inst_2) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) (Equiv.instEquivLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (OrderHom.{u1, u3} α β _inst_1 _inst_2) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2))))) (OrderHom.dual.{u1, u3} α β _inst_1 _inst_2) f))
Case conversion may be inaccurate. Consider using '#align order_hom.dual_comp OrderHom.dual_compₓ'. -/
@[simp]
theorem dual_comp (g : β →o γ) (f : α →o β) : (g.comp f).dual = g.dual.comp f.dual :=
  rfl
#align order_hom.dual_comp OrderHom.dual_comp

#print OrderHom.symm_dual_id /-
@[simp]
theorem symm_dual_id : OrderHom.dual.symm OrderHom.id = (OrderHom.id : α →o α) :=
  rfl
#align order_hom.symm_dual_id OrderHom.symm_dual_id
-/

/- warning: order_hom.symm_dual_comp -> OrderHom.symm_dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] (g : OrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3)) (f : OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2)), Eq.{max (succ u1) (succ u3)} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_3)) (OrderHom.{u1, u3} α γ _inst_1 _inst_3)) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_3)) (OrderHom.{u1, u3} α γ _inst_1 _inst_3)) => (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_3)) -> (OrderHom.{u1, u3} α γ _inst_1 _inst_3)) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_3)) (OrderHom.{u1, u3} α γ _inst_1 _inst_3)) (Equiv.symm.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_3)) (OrderHom.dual.{u1, u3} α γ _inst_1 _inst_3)) (OrderHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3) g f)) (OrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3)) (OrderHom.{u2, u3} β γ _inst_2 _inst_3)) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3)) (OrderHom.{u2, u3} β γ _inst_2 _inst_3)) => (OrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3)) -> (OrderHom.{u2, u3} β γ _inst_2 _inst_3)) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3)) (OrderHom.{u2, u3} β γ _inst_2 _inst_3)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (OrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_2) (OrderDual.preorder.{u3} γ _inst_3)) (OrderHom.dual.{u2, u3} β γ _inst_2 _inst_3)) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2)) (OrderHom.{u1, u2} α β _inst_1 _inst_2)) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2)) (OrderHom.{u1, u2} α β _inst_1 _inst_2)) => (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2)) -> (OrderHom.{u1, u2} α β _inst_1 _inst_2)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2)) (OrderHom.{u1, u2} α β _inst_1 _inst_2)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_2)) (OrderHom.dual.{u1, u2} α β _inst_1 _inst_2)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] (g : OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (f : OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) => OrderHom.{u1, u2} α γ _inst_1 _inst_3) (OrderHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u1, u2} α γ _inst_1 _inst_3)) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (fun (_x : OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) => OrderHom.{u1, u2} α γ _inst_1 _inst_3) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u1, u2} α γ _inst_1 _inst_3)) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u1, u2} α γ _inst_1 _inst_3)) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u1, u2} α γ _inst_1 _inst_3)))) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (OrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.dual.{u1, u2} α γ _inst_1 _inst_3)) (OrderHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3) g f)) (OrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u3, u2} β γ _inst_2 _inst_3)) (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (fun (_x : OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) => OrderHom.{u3, u2} β γ _inst_2 _inst_3) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u3, u2} β γ _inst_2 _inst_3)) (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u3, u2} β γ _inst_2 _inst_3)) (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.{u3, u2} β γ _inst_2 _inst_3)))) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderHom.{u3, u2} β γ _inst_2 _inst_3) (OrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_2) (OrderDual.preorder.{u2} γ _inst_3)) (OrderHom.dual.{u3, u2} β γ _inst_2 _inst_3)) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) (OrderHom.{u1, u3} α β _inst_1 _inst_2)) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) (fun (_x : OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) => OrderHom.{u1, u3} α β _inst_1 _inst_2) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) (OrderHom.{u1, u3} α β _inst_1 _inst_2)) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) (OrderHom.{u1, u3} α β _inst_1 _inst_2) (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) (OrderHom.{u1, u3} α β _inst_1 _inst_2)) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) (OrderHom.{u1, u3} α β _inst_1 _inst_2) (Equiv.instEquivLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) (OrderHom.{u1, u3} α β _inst_1 _inst_2)))) (Equiv.symm.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (OrderHom.{u1, u3} α β _inst_1 _inst_2) (OrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_2)) (OrderHom.dual.{u1, u3} α β _inst_1 _inst_2)) f))
Case conversion may be inaccurate. Consider using '#align order_hom.symm_dual_comp OrderHom.symm_dual_compₓ'. -/
@[simp]
theorem symm_dual_comp (g : βᵒᵈ →o γᵒᵈ) (f : αᵒᵈ →o βᵒᵈ) :
    OrderHom.dual.symm (g.comp f) = (OrderHom.dual.symm g).comp (OrderHom.dual.symm f) :=
  rfl
#align order_hom.symm_dual_comp OrderHom.symm_dual_comp

#print OrderHom.dualIso /-
/-- `order_hom.dual` as an order isomorphism. -/
def dualIso (α β : Type _) [Preorder α] [Preorder β] : (α →o β) ≃o (αᵒᵈ →o βᵒᵈ)ᵒᵈ
    where
  toEquiv := OrderHom.dual.trans OrderDual.toDual
  map_rel_iff' f g := Iff.rfl
#align order_hom.dual_iso OrderHom.dualIso
-/

#print OrderHom.withBotMap /-
/-- Lift an order homomorphism `f : α →o β` to an order homomorphism `with_bot α →o with_bot β`. -/
@[simps (config := { fullyApplied := false })]
protected def withBotMap (f : α →o β) : WithBot α →o WithBot β :=
  ⟨WithBot.map f, f.mono.with_bot_map⟩
#align order_hom.with_bot_map OrderHom.withBotMap
-/

#print OrderHom.withTopMap /-
/-- Lift an order homomorphism `f : α →o β` to an order homomorphism `with_top α →o with_top β`. -/
@[simps (config := { fullyApplied := false })]
protected def withTopMap (f : α →o β) : WithTop α →o WithTop β :=
  ⟨WithTop.map f, f.mono.with_top_map⟩
#align order_hom.with_top_map OrderHom.withTopMap
-/

end OrderHom

#print RelEmbedding.orderEmbeddingOfLTEmbedding /-
/-- Embeddings of partial orders that preserve `<` also preserve `≤`. -/
def RelEmbedding.orderEmbeddingOfLTEmbedding [PartialOrder α] [PartialOrder β]
    (f : ((· < ·) : α → α → Prop) ↪r ((· < ·) : β → β → Prop)) : α ↪o β :=
  { f with
    map_rel_iff' := by
      intros
      simp [le_iff_lt_or_eq, f.map_rel_iff, f.injective.eq_iff] }
#align rel_embedding.order_embedding_of_lt_embedding RelEmbedding.orderEmbeddingOfLTEmbedding
-/

/- warning: rel_embedding.order_embedding_of_lt_embedding_apply -> RelEmbedding.orderEmbeddingOfLTEmbedding_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : PartialOrder.{u2} β] {f : RelEmbedding.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))} {x : α}, Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) (RelEmbedding.orderEmbeddingOfLTEmbedding.{u1, u2} α β _inst_1 _inst_2 f) x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RelEmbedding.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) (fun (_x : RelEmbedding.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) f x)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : PartialOrder.{u1} β] {f : RelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.6340 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.6342 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.6340 x._@.Mathlib.Order.Hom.Basic._hyg.6342) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.6362 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.6364 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.6362 x._@.Mathlib.Order.Hom.Basic._hyg.6364)} {x : α}, Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (RelEmbedding.orderEmbeddingOfLTEmbedding.{u2, u1} α β _inst_1 _inst_2 f)) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.6340 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.6342 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.6340 x._@.Mathlib.Order.Hom.Basic._hyg.6342) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.6362 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.6364 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.6362 x._@.Mathlib.Order.Hom.Basic._hyg.6364) f) x)
Case conversion may be inaccurate. Consider using '#align rel_embedding.order_embedding_of_lt_embedding_apply RelEmbedding.orderEmbeddingOfLTEmbedding_applyₓ'. -/
@[simp]
theorem RelEmbedding.orderEmbeddingOfLTEmbedding_apply [PartialOrder α] [PartialOrder β]
    {f : ((· < ·) : α → α → Prop) ↪r ((· < ·) : β → β → Prop)} {x : α} :
    RelEmbedding.orderEmbeddingOfLTEmbedding f x = f x :=
  rfl
#align
  rel_embedding.order_embedding_of_lt_embedding_apply RelEmbedding.orderEmbeddingOfLTEmbedding_apply

namespace OrderEmbedding

variable [Preorder α] [Preorder β] (f : α ↪o β)

#print OrderEmbedding.ltEmbedding /-
/-- `<` is preserved by order embeddings of preorders. -/
def ltEmbedding : ((· < ·) : α → α → Prop) ↪r ((· < ·) : β → β → Prop) :=
  { f with map_rel_iff' := by intros <;> simp [lt_iff_le_not_le, f.map_rel_iff] }
#align order_embedding.lt_embedding OrderEmbedding.ltEmbedding
-/

/- warning: order_embedding.lt_embedding_apply -> OrderEmbedding.ltEmbedding_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RelEmbedding.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1)) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (fun (_x : RelEmbedding.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1)) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1)) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (OrderEmbedding.ltEmbedding.{u1, u2} α β _inst_1 _inst_2 f) x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) f x)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} α β)) (RelEmbedding.toEmbedding.{u1, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.6437 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.6439 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.6437 x._@.Mathlib.Order.Hom.Basic._hyg.6439) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.6459 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.6461 : β) => LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.6459 x._@.Mathlib.Order.Hom.Basic._hyg.6461) (OrderEmbedding.ltEmbedding.{u1, u2} α β _inst_1 _inst_2 f)) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} α β)) (RelEmbedding.toEmbedding.{u1, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) x)
Case conversion may be inaccurate. Consider using '#align order_embedding.lt_embedding_apply OrderEmbedding.ltEmbedding_applyₓ'. -/
@[simp]
theorem ltEmbedding_apply (x : α) : f.ltEmbedding x = f x :=
  rfl
#align order_embedding.lt_embedding_apply OrderEmbedding.ltEmbedding_apply

/- warning: order_embedding.le_iff_le -> OrderEmbedding.le_iff_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) {a : α} {b : α}, Iff (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) f b)) (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) a b)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) {a : α} {b : α}, Iff (LE.le.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} α β)) (RelEmbedding.toEmbedding.{u1, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} α β)) (RelEmbedding.toEmbedding.{u1, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) b)) (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) a b)
Case conversion may be inaccurate. Consider using '#align order_embedding.le_iff_le OrderEmbedding.le_iff_leₓ'. -/
@[simp]
theorem le_iff_le {a b} : f a ≤ f b ↔ a ≤ b :=
  f.map_rel_iff
#align order_embedding.le_iff_le OrderEmbedding.le_iff_le

/- warning: order_embedding.lt_iff_lt -> OrderEmbedding.lt_iff_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) {a : α} {b : α}, Iff (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) f b)) (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1) a b)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) {a : α} {b : α}, Iff (LT.lt.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} α β)) (RelEmbedding.toEmbedding.{u1, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} α β)) (RelEmbedding.toEmbedding.{u1, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) b)) (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1) a b)
Case conversion may be inaccurate. Consider using '#align order_embedding.lt_iff_lt OrderEmbedding.lt_iff_ltₓ'. -/
@[simp]
theorem lt_iff_lt {a b} : f a < f b ↔ a < b :=
  f.ltEmbedding.map_rel_iff
#align order_embedding.lt_iff_lt OrderEmbedding.lt_iff_lt

/- warning: order_embedding.eq_iff_eq -> OrderEmbedding.eq_iff_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) {a : α} {b : α}, Iff (Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) f b)) (Eq.{succ u1} α a b)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) {a : α} {b : α}, Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} α β)) (RelEmbedding.toEmbedding.{u1, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} α β)) (RelEmbedding.toEmbedding.{u1, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) b)) (Eq.{succ u1} α a b)
Case conversion may be inaccurate. Consider using '#align order_embedding.eq_iff_eq OrderEmbedding.eq_iff_eqₓ'. -/
@[simp]
theorem eq_iff_eq {a b} : f a = f b ↔ a = b :=
  f.Injective.eq_iff
#align order_embedding.eq_iff_eq OrderEmbedding.eq_iff_eq

/- warning: order_embedding.monotone -> OrderEmbedding.monotone is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)), Monotone.{u1, u2} α β _inst_1 _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (f : OrderEmbedding.{u2, u1} α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2)), Monotone.{u2, u1} α β _inst_1 _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f))
Case conversion may be inaccurate. Consider using '#align order_embedding.monotone OrderEmbedding.monotoneₓ'. -/
protected theorem monotone : Monotone f :=
  OrderHomClass.monotone f
#align order_embedding.monotone OrderEmbedding.monotone

/- warning: order_embedding.strict_mono -> OrderEmbedding.strictMono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)), StrictMono.{u1, u2} α β _inst_1 _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (f : OrderEmbedding.{u2, u1} α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2)), StrictMono.{u2, u1} α β _inst_1 _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f))
Case conversion may be inaccurate. Consider using '#align order_embedding.strict_mono OrderEmbedding.strictMonoₓ'. -/
protected theorem strictMono : StrictMono f := fun x y => f.lt_iff_lt.2
#align order_embedding.strict_mono OrderEmbedding.strictMono

/- warning: order_embedding.acc -> OrderEmbedding.acc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (a : α), (Acc.{succ u2} β (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) f a)) -> (Acc.{succ u1} α (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1)) a)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (a : α), (Acc.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.6692 : (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (x._@.Mathlib.Order.Hom.Basic._hyg.6694 : (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) => LT.lt.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.6692 x._@.Mathlib.Order.Hom.Basic._hyg.6694) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} α β)) (RelEmbedding.toEmbedding.{u1, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) a)) -> (Acc.{succ u1} α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.6712 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.6714 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.6712 x._@.Mathlib.Order.Hom.Basic._hyg.6714) a)
Case conversion may be inaccurate. Consider using '#align order_embedding.acc OrderEmbedding.accₓ'. -/
protected theorem acc (a : α) : Acc (· < ·) (f a) → Acc (· < ·) a :=
  f.ltEmbedding.Acc a
#align order_embedding.acc OrderEmbedding.acc

#print OrderEmbedding.wellFounded /-
protected theorem wellFounded :
    WellFounded ((· < ·) : β → β → Prop) → WellFounded ((· < ·) : α → α → Prop) :=
  f.ltEmbedding.WellFounded
#align order_embedding.well_founded OrderEmbedding.wellFounded
-/

#print OrderEmbedding.isWellOrder /-
protected theorem isWellOrder [IsWellOrder β (· < ·)] : IsWellOrder α (· < ·) :=
  f.ltEmbedding.IsWellOrder
#align order_embedding.is_well_order OrderEmbedding.isWellOrder
-/

#print OrderEmbedding.dual /-
/-- An order embedding is also an order embedding between dual orders. -/
protected def dual : αᵒᵈ ↪o βᵒᵈ :=
  ⟨f.toEmbedding, fun a b => f.map_rel_iff⟩
#align order_embedding.dual OrderEmbedding.dual
-/

#print OrderEmbedding.withBotMap /-
/-- A version of `with_bot.map` for order embeddings. -/
@[simps (config := { fullyApplied := false })]
protected def withBotMap (f : α ↪o β) : WithBot α ↪o WithBot β :=
  { f.toEmbedding.option_map with
    toFun := WithBot.map f
    map_rel_iff' := WithBot.map_le_iff f fun a b => f.map_rel_iff }
#align order_embedding.with_bot_map OrderEmbedding.withBotMap
-/

#print OrderEmbedding.withTopMap /-
/-- A version of `with_top.map` for order embeddings. -/
@[simps (config := { fullyApplied := false })]
protected def withTopMap (f : α ↪o β) : WithTop α ↪o WithTop β :=
  { f.dual.with_bot_map.dual with toFun := WithTop.map f }
#align order_embedding.with_top_map OrderEmbedding.withTopMap
-/

#print OrderEmbedding.ofMapLeIff /-
/-- To define an order embedding from a partial order to a preorder it suffices to give a function
together with a proof that it satisfies `f a ≤ f b ↔ a ≤ b`.
-/
def ofMapLeIff {α β} [PartialOrder α] [Preorder β] (f : α → β) (hf : ∀ a b, f a ≤ f b ↔ a ≤ b) :
    α ↪o β :=
  RelEmbedding.ofMapRelIff f hf
#align order_embedding.of_map_le_iff OrderEmbedding.ofMapLeIff
-/

/- warning: order_embedding.coe_of_map_le_iff -> OrderEmbedding.coe_ofMapLeIff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : PartialOrder.{u1} α] [_inst_4 : Preorder.{u2} β] {f : α -> β} (h : forall (a : α) (b : α), Iff (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_4) (f a) (f b)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3)) a b)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3)) (Preorder.toLE.{u2} β _inst_4)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3))) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_4))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3))) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_4))) (OrderEmbedding.ofMapLeIff.{u1, u2} α β _inst_3 _inst_4 f h)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_3 : PartialOrder.{u2} α] [_inst_4 : Preorder.{u1} β] {f : α -> β} (h : forall (a : α) (b : α), Iff (LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) (f a) (f b)) (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_3)) a b)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_3)) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (OrderEmbedding.ofMapLeIff.{u2, u1} α β _inst_3 _inst_4 f h))) f
Case conversion may be inaccurate. Consider using '#align order_embedding.coe_of_map_le_iff OrderEmbedding.coe_ofMapLeIffₓ'. -/
@[simp]
theorem coe_ofMapLeIff {α β} [PartialOrder α] [Preorder β] {f : α → β} (h) :
    ⇑(ofMapLeIff f h) = f :=
  rfl
#align order_embedding.coe_of_map_le_iff OrderEmbedding.coe_ofMapLeIff

#print OrderEmbedding.ofStrictMono /-
/-- A strictly monotone map from a linear order is an order embedding. -/
def ofStrictMono {α β} [LinearOrder α] [Preorder β] (f : α → β) (h : StrictMono f) : α ↪o β :=
  ofMapLeIff f fun _ _ => h.le_iff_le
#align order_embedding.of_strict_mono OrderEmbedding.ofStrictMono
-/

/- warning: order_embedding.coe_of_strict_mono -> OrderEmbedding.coe_ofStrictMono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_3 : LinearOrder.{u1} α] [_inst_4 : Preorder.{u2} β] {f : α -> β} (h : StrictMono.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_3)))) _inst_4 f), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_3))))) (Preorder.toLE.{u2} β _inst_4)) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_3)))))) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_4))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (LinearOrder.toLattice.{u1} α _inst_3)))))) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_4))) (OrderEmbedding.ofStrictMono.{u1, u2} α β _inst_3 _inst_4 f h)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_3 : LinearOrder.{u2} α] [_inst_4 : Preorder.{u1} β] {f : α -> β} (h : StrictMono.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_3))))) _inst_4 f), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (OrderEmbedding.ofStrictMono.{u2, u1} α β _inst_3 _inst_4 f h))) f
Case conversion may be inaccurate. Consider using '#align order_embedding.coe_of_strict_mono OrderEmbedding.coe_ofStrictMonoₓ'. -/
@[simp]
theorem coe_ofStrictMono {α β} [LinearOrder α] [Preorder β] {f : α → β} (h : StrictMono f) :
    ⇑(ofStrictMono f h) = f :=
  rfl
#align order_embedding.coe_of_strict_mono OrderEmbedding.coe_ofStrictMono

#print OrderEmbedding.subtype /-
/-- Embedding of a subtype into the ambient type as an `order_embedding`. -/
@[simps (config := { fullyApplied := false })]
def subtype (p : α → Prop) : Subtype p ↪o α :=
  ⟨Function.Embedding.subtype p, fun x y => Iff.rfl⟩
#align order_embedding.subtype OrderEmbedding.subtype
-/

#print OrderEmbedding.toOrderHom /-
/-- Convert an `order_embedding` to a `order_hom`. -/
@[simps (config := { fullyApplied := false })]
def toOrderHom {X Y : Type _} [Preorder X] [Preorder Y] (f : X ↪o Y) : X →o Y
    where
  toFun := f
  monotone' := f.Monotone
#align order_embedding.to_order_hom OrderEmbedding.toOrderHom
-/

end OrderEmbedding

section RelHom

variable [PartialOrder α] [Preorder β]

namespace RelHom

variable (f : ((· < ·) : α → α → Prop) →r ((· < ·) : β → β → Prop))

#print RelHom.toOrderHom /-
/-- A bundled expression of the fact that a map between partial orders that is strictly monotone
is weakly monotone. -/
@[simps (config := { fullyApplied := false })]
def toOrderHom : α →o β where
  toFun := f
  monotone' := StrictMono.monotone fun x y => f.map_rel
#align rel_hom.to_order_hom RelHom.toOrderHom
-/

end RelHom

/- warning: rel_embedding.to_order_hom_injective -> RelEmbedding.toOrderHom_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : Preorder.{u2} β] (f : RelEmbedding.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))), Function.Injective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderHom.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2) (fun (_x : OrderHom.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2) => α -> β) (OrderHom.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2) (RelHom.toOrderHom.{u1, u2} α β _inst_1 _inst_2 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (RelEmbedding.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (RelHom.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RelEmbedding.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (RelHom.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RelEmbedding.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (RelHom.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (coeBase.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RelEmbedding.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (RelHom.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (RelEmbedding.RelHom.hasCoe.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2)))))) f)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : Preorder.{u1} β] (f : RelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.7514 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.7516 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.7514 x._@.Mathlib.Order.Hom.Basic._hyg.7516) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.7536 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.7538 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.7536 x._@.Mathlib.Order.Hom.Basic._hyg.7538)), Function.Injective.{succ u2, succ u1} α β (OrderHom.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_2 (RelHom.toOrderHom.{u2, u1} α β _inst_1 _inst_2 (RelEmbedding.toRelHom.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.7514 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.7516 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.7514 x._@.Mathlib.Order.Hom.Basic._hyg.7516) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.7536 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.7538 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.7536 x._@.Mathlib.Order.Hom.Basic._hyg.7538) f)))
Case conversion may be inaccurate. Consider using '#align rel_embedding.to_order_hom_injective RelEmbedding.toOrderHom_injectiveₓ'. -/
theorem RelEmbedding.toOrderHom_injective
    (f : ((· < ·) : α → α → Prop) ↪r ((· < ·) : β → β → Prop)) :
    Function.Injective (f : ((· < ·) : α → α → Prop) →r ((· < ·) : β → β → Prop)).toOrderHom :=
  fun _ _ h => f.Injective h
#align rel_embedding.to_order_hom_injective RelEmbedding.toOrderHom_injective

end RelHom

namespace OrderIso

section LE

variable [LE α] [LE β] [LE γ]

instance : OrderIsoClass (α ≃o β) α β where
  coe f := f.toFun
  inv f := f.invFun
  left_inv f := f.left_inv
  right_inv f := f.right_inv
  coe_injective' f g h₁ h₂ := by
    obtain ⟨⟨_, _⟩, _⟩ := f
    obtain ⟨⟨_, _⟩, _⟩ := g
    congr
  map_le_map_iff f _ _ := f.map_rel_iff'

/- warning: order_iso.to_fun_eq_coe -> OrderIso.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {f : OrderIso.{u1, u2} α β _inst_1 _inst_2}, Eq.{max (succ u1) (succ u2)} (α -> β) (Equiv.toFun.{succ u1, succ u2} α β (RelIso.toEquiv.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {f : OrderIso.{u2, u1} α β _inst_1 _inst_2}, Eq.{max (succ u2) (succ u1)} (α -> β) (Equiv.toFun.{succ u2, succ u1} α β (RelIso.toEquiv.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)))
Case conversion may be inaccurate. Consider using '#align order_iso.to_fun_eq_coe OrderIso.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe {f : α ≃o β} : f.toFun = f :=
  rfl
#align order_iso.to_fun_eq_coe OrderIso.toFun_eq_coe

/- warning: order_iso.ext -> OrderIso.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] {f : OrderIso.{u1, u2} α β _inst_1 _inst_2} {g : OrderIso.{u1, u2} α β _inst_1 _inst_2}, (Eq.{max (succ u1) (succ u2)} ((fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) g)) -> (Eq.{max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] {f : OrderIso.{u2, u1} α β _inst_1 _inst_2} {g : OrderIso.{u2, u1} α β _inst_1 _inst_2}, (Eq.{max (succ u2) (succ u1)} (forall (a : α), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) g)))) -> (Eq.{max (succ u2) (succ u1)} (OrderIso.{u2, u1} α β _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align order_iso.ext OrderIso.extₓ'. -/
-- See note [partially-applied ext lemmas]
@[ext]
theorem ext {f g : α ≃o β} (h : (f : α → β) = g) : f = g :=
  FunLike.coe_injective h
#align order_iso.ext OrderIso.ext

#print OrderIso.toOrderEmbedding /-
/-- Reinterpret an order isomorphism as an order embedding. -/
def toOrderEmbedding (e : α ≃o β) : α ↪o β :=
  e.toRelEmbedding
#align order_iso.to_order_embedding OrderIso.toOrderEmbedding
-/

/- warning: order_iso.coe_to_order_embedding -> OrderIso.coe_toOrderEmbedding is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) (OrderIso.toOrderEmbedding.{u1, u2} α β _inst_1 _inst_2 e)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) (OrderIso.toOrderEmbedding.{u2, u1} α β _inst_1 _inst_2 e))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)))
Case conversion may be inaccurate. Consider using '#align order_iso.coe_to_order_embedding OrderIso.coe_toOrderEmbeddingₓ'. -/
@[simp]
theorem coe_toOrderEmbedding (e : α ≃o β) : ⇑e.toOrderEmbedding = e :=
  rfl
#align order_iso.coe_to_order_embedding OrderIso.coe_toOrderEmbedding

/- warning: order_iso.bijective -> OrderIso.bijective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2), Function.Bijective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2), Function.Bijective.{succ u2, succ u1} α β (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)))
Case conversion may be inaccurate. Consider using '#align order_iso.bijective OrderIso.bijectiveₓ'. -/
protected theorem bijective (e : α ≃o β) : Function.Bijective e :=
  e.toEquiv.Bijective
#align order_iso.bijective OrderIso.bijective

/- warning: order_iso.injective -> OrderIso.injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2), Function.Injective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2), Function.Injective.{succ u2, succ u1} α β (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)))
Case conversion may be inaccurate. Consider using '#align order_iso.injective OrderIso.injectiveₓ'. -/
protected theorem injective (e : α ≃o β) : Function.Injective e :=
  e.toEquiv.Injective
#align order_iso.injective OrderIso.injective

/- warning: order_iso.surjective -> OrderIso.surjective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2), Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2), Function.Surjective.{succ u2, succ u1} α β (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)))
Case conversion may be inaccurate. Consider using '#align order_iso.surjective OrderIso.surjectiveₓ'. -/
protected theorem surjective (e : α ≃o β) : Function.Surjective e :=
  e.toEquiv.Surjective
#align order_iso.surjective OrderIso.surjective

/- warning: order_iso.apply_eq_iff_eq -> OrderIso.apply_eq_iff_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2) {x : α} {y : α}, Iff (Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e y)) (Eq.{succ u1} α x y)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2) {x : α} {y : α}, Iff (Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) y)) (Eq.{succ u2} α x y)
Case conversion may be inaccurate. Consider using '#align order_iso.apply_eq_iff_eq OrderIso.apply_eq_iff_eqₓ'. -/
@[simp]
theorem apply_eq_iff_eq (e : α ≃o β) {x y : α} : e x = e y ↔ x = y :=
  e.toEquiv.apply_eq_iff_eq
#align order_iso.apply_eq_iff_eq OrderIso.apply_eq_iff_eq

#print OrderIso.refl /-
/-- Identity order isomorphism. -/
def refl (α : Type _) [LE α] : α ≃o α :=
  RelIso.refl (· ≤ ·)
#align order_iso.refl OrderIso.refl
-/

/- warning: order_iso.coe_refl -> OrderIso.coe_refl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} α α _inst_1 _inst_1) (fun (_x : RelIso.{u1, u1} α α (LE.le.{u1} α _inst_1) (LE.le.{u1} α _inst_1)) => α -> α) (RelIso.hasCoeToFun.{u1, u1} α α (LE.le.{u1} α _inst_1) (LE.le.{u1} α _inst_1)) (OrderIso.refl.{u1} α _inst_1)) (id.{succ u1} α)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} α α) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} α α) α α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} α α)) (RelEmbedding.toEmbedding.{u1, u1} α α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} α α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.refl.{u1} α _inst_1)))) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align order_iso.coe_refl OrderIso.coe_reflₓ'. -/
@[simp]
theorem coe_refl : ⇑(refl α) = id :=
  rfl
#align order_iso.coe_refl OrderIso.coe_refl

/- warning: order_iso.refl_apply -> OrderIso.refl_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (x : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} α α _inst_1 _inst_1) (fun (_x : RelIso.{u1, u1} α α (LE.le.{u1} α _inst_1) (LE.le.{u1} α _inst_1)) => α -> α) (RelIso.hasCoeToFun.{u1, u1} α α (LE.le.{u1} α _inst_1) (LE.le.{u1} α _inst_1)) (OrderIso.refl.{u1} α _inst_1) x) x
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => α) x) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} α α) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} α α) α α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} α α)) (RelEmbedding.toEmbedding.{u1, u1} α α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} α α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.refl.{u1} α _inst_1))) x) x
Case conversion may be inaccurate. Consider using '#align order_iso.refl_apply OrderIso.refl_applyₓ'. -/
@[simp]
theorem refl_apply (x : α) : refl α x = x :=
  rfl
#align order_iso.refl_apply OrderIso.refl_apply

#print OrderIso.refl_toEquiv /-
@[simp]
theorem refl_toEquiv : (refl α).toEquiv = Equiv.refl α :=
  rfl
#align order_iso.refl_to_equiv OrderIso.refl_toEquiv
-/

#print OrderIso.symm /-
/-- Inverse of an order isomorphism. -/
def symm (e : α ≃o β) : β ≃o α :=
  e.symm
#align order_iso.symm OrderIso.symm
-/

/- warning: order_iso.apply_symm_apply -> OrderIso.apply_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2) (x : β), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderIso.{u2, u1} β α _inst_2 _inst_1) (fun (_x : RelIso.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) => β -> α) (RelIso.hasCoeToFun.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2 e) x)) x
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2) (x : β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β (fun (a : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) a) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} β α)) (RelEmbedding.toEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, u1} α β _inst_1 _inst_2 e))) x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} β α)) (RelEmbedding.toEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, u1} α β _inst_1 _inst_2 e))) x)) x
Case conversion may be inaccurate. Consider using '#align order_iso.apply_symm_apply OrderIso.apply_symm_applyₓ'. -/
@[simp]
theorem apply_symm_apply (e : α ≃o β) (x : β) : e (e.symm x) = x :=
  e.toEquiv.apply_symm_apply x
#align order_iso.apply_symm_apply OrderIso.apply_symm_apply

/- warning: order_iso.symm_apply_apply -> OrderIso.symm_apply_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2) (x : α), Eq.{succ u1} α (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderIso.{u2, u1} β α _inst_2 _inst_1) (fun (_x : RelIso.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) => β -> α) (RelIso.hasCoeToFun.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2 e) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e x)) x
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (a : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} β α)) (RelEmbedding.toEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, u1} α β _inst_1 _inst_2 e))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x)) x
Case conversion may be inaccurate. Consider using '#align order_iso.symm_apply_apply OrderIso.symm_apply_applyₓ'. -/
@[simp]
theorem symm_apply_apply (e : α ≃o β) (x : α) : e.symm (e x) = x :=
  e.toEquiv.symm_apply_apply x
#align order_iso.symm_apply_apply OrderIso.symm_apply_apply

#print OrderIso.symm_refl /-
@[simp]
theorem symm_refl (α : Type _) [LE α] : (refl α).symm = refl α :=
  rfl
#align order_iso.symm_refl OrderIso.symm_refl
-/

/- warning: order_iso.apply_eq_iff_eq_symm_apply -> OrderIso.apply_eq_iff_eq_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2) (x : α) (y : β), Iff (Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e x) y) (Eq.{succ u1} α x (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderIso.{u2, u1} β α _inst_2 _inst_1) (fun (_x : RelIso.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) => β -> α) (RelIso.hasCoeToFun.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2 e) y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2) (x : α) (y : β), Iff (Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x) y) (Eq.{succ u2} α x (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} β α)) (RelEmbedding.toEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, u1} α β _inst_1 _inst_2 e))) y))
Case conversion may be inaccurate. Consider using '#align order_iso.apply_eq_iff_eq_symm_apply OrderIso.apply_eq_iff_eq_symm_applyₓ'. -/
theorem apply_eq_iff_eq_symm_apply (e : α ≃o β) (x : α) (y : β) : e x = y ↔ x = e.symm y :=
  e.toEquiv.apply_eq_iff_eq_symm_apply
#align order_iso.apply_eq_iff_eq_symm_apply OrderIso.apply_eq_iff_eq_symm_apply

/- warning: order_iso.symm_apply_eq -> OrderIso.symm_apply_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2) {x : α} {y : β}, Iff (Eq.{succ u1} α (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderIso.{u2, u1} β α _inst_2 _inst_1) (fun (_x : RelIso.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) => β -> α) (RelIso.hasCoeToFun.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2 e) y) x) (Eq.{succ u2} β y (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2) {x : α} {y : β}, Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) y) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} β α)) (RelEmbedding.toEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, u1} α β _inst_1 _inst_2 e))) y) x) (Eq.{succ u1} β y (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x))
Case conversion may be inaccurate. Consider using '#align order_iso.symm_apply_eq OrderIso.symm_apply_eqₓ'. -/
theorem symm_apply_eq (e : α ≃o β) {x : α} {y : β} : e.symm y = x ↔ y = e x :=
  e.toEquiv.symm_apply_eq
#align order_iso.symm_apply_eq OrderIso.symm_apply_eq

/- warning: order_iso.symm_symm -> OrderIso.symm_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (OrderIso.symm.{u2, u1} β α _inst_2 _inst_1 (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2 e)) e
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (OrderIso.{u2, u1} α β _inst_1 _inst_2) (OrderIso.symm.{u1, u2} β α _inst_2 _inst_1 (OrderIso.symm.{u2, u1} α β _inst_1 _inst_2 e)) e
Case conversion may be inaccurate. Consider using '#align order_iso.symm_symm OrderIso.symm_symmₓ'. -/
@[simp]
theorem symm_symm (e : α ≃o β) : e.symm.symm = e :=
  by
  ext
  rfl
#align order_iso.symm_symm OrderIso.symm_symm

/- warning: order_iso.symm_injective -> OrderIso.symm_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β], Function.Injective.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (OrderIso.{u2, u1} β α _inst_2 _inst_1) (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β], Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderIso.{u2, u1} α β _inst_1 _inst_2) (OrderIso.{u1, u2} β α _inst_2 _inst_1) (OrderIso.symm.{u2, u1} α β _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align order_iso.symm_injective OrderIso.symm_injectiveₓ'. -/
theorem symm_injective : Function.Injective (symm : α ≃o β → β ≃o α) := fun e e' h => by
  rw [← e.symm_symm, h, e'.symm_symm]
#align order_iso.symm_injective OrderIso.symm_injective

/- warning: order_iso.to_equiv_symm -> OrderIso.toEquiv_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2), Eq.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2)} (Equiv.{succ u2, succ u1} β α) (Equiv.symm.{succ u1, succ u2} α β (RelIso.toEquiv.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2) e)) (RelIso.toEquiv.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1) (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2 e))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (Equiv.{succ u1, succ u2} β α) (Equiv.symm.{succ u2, succ u1} α β (RelIso.toEquiv.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) (RelIso.toEquiv.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, u1} α β _inst_1 _inst_2 e))
Case conversion may be inaccurate. Consider using '#align order_iso.to_equiv_symm OrderIso.toEquiv_symmₓ'. -/
@[simp]
theorem toEquiv_symm (e : α ≃o β) : e.toEquiv.symm = e.symm.toEquiv :=
  rfl
#align order_iso.to_equiv_symm OrderIso.toEquiv_symm

#print OrderIso.trans /-
/-- Composition of two order isomorphisms is an order isomorphism. -/
@[trans]
def trans (e : α ≃o β) (e' : β ≃o γ) : α ≃o γ :=
  e.trans e'
#align order_iso.trans OrderIso.trans
-/

/- warning: order_iso.coe_trans -> OrderIso.coe_trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2) (e' : OrderIso.{u2, u3} β γ _inst_2 _inst_3), Eq.{max (succ u1) (succ u3)} (α -> γ) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderIso.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : RelIso.{u1, u3} α γ (LE.le.{u1} α _inst_1) (LE.le.{u3} γ _inst_3)) => α -> γ) (RelIso.hasCoeToFun.{u1, u3} α γ (LE.le.{u1} α _inst_1) (LE.le.{u3} γ _inst_3)) (OrderIso.trans.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 e e')) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderIso.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : RelIso.{u2, u3} β γ (LE.le.{u2} β _inst_2) (LE.le.{u3} γ _inst_3)) => β -> γ) (RelIso.hasCoeToFun.{u2, u3} β γ (LE.le.{u2} β _inst_2) (LE.le.{u3} γ _inst_3)) e') (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (e : OrderIso.{u3, u2} α β _inst_1 _inst_2) (e' : OrderIso.{u2, u1} β γ _inst_2 _inst_3), Eq.{max (succ u3) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => γ) ᾰ) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Function.Embedding.{succ u3, succ u1} α γ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => γ) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), succ u3, succ u1} (Function.Embedding.{succ u3, succ u1} α γ) α γ (Function.instEmbeddingLikeEmbedding.{succ u3, succ u1} α γ)) (RelEmbedding.toEmbedding.{u3, u1} α γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u3, u1} α γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.trans.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3 e e')))) (Function.comp.{succ u3, succ u2, succ u1} α β γ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} β γ) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => γ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} β γ) β γ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} β γ)) (RelEmbedding.toEmbedding.{u2, u1} β γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} β γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e'))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Function.Embedding.{succ u3, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u2} (Function.Embedding.{succ u3, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u3, succ u2} α β)) (RelEmbedding.toEmbedding.{u3, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u3, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e))))
Case conversion may be inaccurate. Consider using '#align order_iso.coe_trans OrderIso.coe_transₓ'. -/
@[simp]
theorem coe_trans (e : α ≃o β) (e' : β ≃o γ) : ⇑(e.trans e') = e' ∘ e :=
  rfl
#align order_iso.coe_trans OrderIso.coe_trans

/- warning: order_iso.trans_apply -> OrderIso.trans_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2) (e' : OrderIso.{u2, u3} β γ _inst_2 _inst_3) (x : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderIso.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : RelIso.{u1, u3} α γ (LE.le.{u1} α _inst_1) (LE.le.{u3} γ _inst_3)) => α -> γ) (RelIso.hasCoeToFun.{u1, u3} α γ (LE.le.{u1} α _inst_1) (LE.le.{u3} γ _inst_3)) (OrderIso.trans.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 e e') x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderIso.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : RelIso.{u2, u3} β γ (LE.le.{u2} β _inst_2) (LE.le.{u3} γ _inst_3)) => β -> γ) (RelIso.hasCoeToFun.{u2, u3} β γ (LE.le.{u2} β _inst_2) (LE.le.{u3} γ _inst_3)) e' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e x))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (e : OrderIso.{u3, u2} α β _inst_1 _inst_2) (e' : OrderIso.{u2, u1} β γ _inst_2 _inst_3) (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => γ) x) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Function.Embedding.{succ u3, succ u1} α γ) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => γ) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), succ u3, succ u1} (Function.Embedding.{succ u3, succ u1} α γ) α γ (Function.instEmbeddingLikeEmbedding.{succ u3, succ u1} α γ)) (RelEmbedding.toEmbedding.{u3, u1} α γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u3, u1} α γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.trans.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3 e e'))) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} β γ) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => γ) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} β γ) β γ (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} β γ)) (RelEmbedding.toEmbedding.{u2, u1} β γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} β γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e')) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Function.Embedding.{succ u3, succ u2} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u2} (Function.Embedding.{succ u3, succ u2} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u3, succ u2} α β)) (RelEmbedding.toEmbedding.{u3, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u3, u2} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x))
Case conversion may be inaccurate. Consider using '#align order_iso.trans_apply OrderIso.trans_applyₓ'. -/
@[simp]
theorem trans_apply (e : α ≃o β) (e' : β ≃o γ) (x : α) : e.trans e' x = e' (e x) :=
  rfl
#align order_iso.trans_apply OrderIso.trans_apply

/- warning: order_iso.refl_trans -> OrderIso.refl_trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (OrderIso.trans.{u1, u1, u2} α α β _inst_1 _inst_1 _inst_2 (OrderIso.refl.{u1} α _inst_1) e) e
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (OrderIso.{u2, u1} α β _inst_1 _inst_2) (OrderIso.trans.{u2, u2, u1} α α β _inst_1 _inst_1 _inst_2 (OrderIso.refl.{u2} α _inst_1) e) e
Case conversion may be inaccurate. Consider using '#align order_iso.refl_trans OrderIso.refl_transₓ'. -/
@[simp]
theorem refl_trans (e : α ≃o β) : (refl α).trans e = e :=
  by
  ext x
  rfl
#align order_iso.refl_trans OrderIso.refl_trans

/- warning: order_iso.trans_refl -> OrderIso.trans_refl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (OrderIso.trans.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_2 e (OrderIso.refl.{u2} β _inst_2)) e
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (OrderIso.{u2, u1} α β _inst_1 _inst_2) (OrderIso.trans.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_2 e (OrderIso.refl.{u1} β _inst_2)) e
Case conversion may be inaccurate. Consider using '#align order_iso.trans_refl OrderIso.trans_reflₓ'. -/
@[simp]
theorem trans_refl (e : α ≃o β) : e.trans (refl β) = e :=
  by
  ext x
  rfl
#align order_iso.trans_refl OrderIso.trans_refl

/- warning: order_iso.symm_trans_apply -> OrderIso.symm_trans_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (e₁ : OrderIso.{u1, u2} α β _inst_1 _inst_2) (e₂ : OrderIso.{u2, u3} β γ _inst_2 _inst_3) (c : γ), Eq.{succ u1} α (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (OrderIso.{u3, u1} γ α _inst_3 _inst_1) (fun (_x : RelIso.{u3, u1} γ α (LE.le.{u3} γ _inst_3) (LE.le.{u1} α _inst_1)) => γ -> α) (RelIso.hasCoeToFun.{u3, u1} γ α (LE.le.{u3} γ _inst_3) (LE.le.{u1} α _inst_1)) (OrderIso.symm.{u1, u3} α γ _inst_1 _inst_3 (OrderIso.trans.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 e₁ e₂)) c) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderIso.{u2, u1} β α _inst_2 _inst_1) (fun (_x : RelIso.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) => β -> α) (RelIso.hasCoeToFun.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2 e₁) (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (OrderIso.{u3, u2} γ β _inst_3 _inst_2) (fun (_x : RelIso.{u3, u2} γ β (LE.le.{u3} γ _inst_3) (LE.le.{u2} β _inst_2)) => γ -> β) (RelIso.hasCoeToFun.{u3, u2} γ β (LE.le.{u3} γ _inst_3) (LE.le.{u2} β _inst_2)) (OrderIso.symm.{u2, u3} β γ _inst_2 _inst_3 e₂) c))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (e₁ : OrderIso.{u3, u2} α β _inst_1 _inst_2) (e₂ : OrderIso.{u2, u1} β γ _inst_2 _inst_3) (c : γ), Eq.{succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : γ) => α) c) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Function.Embedding.{succ u1, succ u3} γ α) γ (fun (_x : γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : γ) => α) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u3), succ u1, succ u3} (Function.Embedding.{succ u1, succ u3} γ α) γ α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u3} γ α)) (RelEmbedding.toEmbedding.{u1, u3} γ α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u3} γ α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u3, u1} α γ _inst_1 _inst_3 (OrderIso.trans.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3 e₁ e₂)))) c) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Function.Embedding.{succ u2, succ u3} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), succ u2, succ u3} (Function.Embedding.{succ u2, succ u3} β α) β α (Function.instEmbeddingLikeEmbedding.{succ u2, succ u3} β α)) (RelEmbedding.toEmbedding.{u2, u3} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u3} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u3, u2} α β _inst_1 _inst_2 e₁))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} γ β) γ (fun (_x : γ) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : γ) => β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} γ β) γ β (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} γ β)) (RelEmbedding.toEmbedding.{u1, u2} γ β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u2} γ β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : γ) => LE.le.{u1} γ _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u2} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, u1} β γ _inst_2 _inst_3 e₂))) c))
Case conversion may be inaccurate. Consider using '#align order_iso.symm_trans_apply OrderIso.symm_trans_applyₓ'. -/
@[simp]
theorem symm_trans_apply (e₁ : α ≃o β) (e₂ : β ≃o γ) (c : γ) :
    (e₁.trans e₂).symm c = e₁.symm (e₂.symm c) :=
  rfl
#align order_iso.symm_trans_apply OrderIso.symm_trans_apply

/- warning: order_iso.symm_trans -> OrderIso.symm_trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u3} γ] (e₁ : OrderIso.{u1, u2} α β _inst_1 _inst_2) (e₂ : OrderIso.{u2, u3} β γ _inst_2 _inst_3), Eq.{max (succ u3) (succ u1)} (OrderIso.{u3, u1} γ α _inst_3 _inst_1) (OrderIso.symm.{u1, u3} α γ _inst_1 _inst_3 (OrderIso.trans.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 e₁ e₂)) (OrderIso.trans.{u3, u2, u1} γ β α _inst_3 _inst_2 _inst_1 (OrderIso.symm.{u2, u3} β γ _inst_2 _inst_3 e₂) (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2 e₁))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : LE.{u3} α] [_inst_2 : LE.{u2} β] [_inst_3 : LE.{u1} γ] (e₁ : OrderIso.{u3, u2} α β _inst_1 _inst_2) (e₂ : OrderIso.{u2, u1} β γ _inst_2 _inst_3), Eq.{max (succ u3) (succ u1)} (OrderIso.{u1, u3} γ α _inst_3 _inst_1) (OrderIso.symm.{u3, u1} α γ _inst_1 _inst_3 (OrderIso.trans.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3 e₁ e₂)) (OrderIso.trans.{u1, u2, u3} γ β α _inst_3 _inst_2 _inst_1 (OrderIso.symm.{u2, u1} β γ _inst_2 _inst_3 e₂) (OrderIso.symm.{u3, u2} α β _inst_1 _inst_2 e₁))
Case conversion may be inaccurate. Consider using '#align order_iso.symm_trans OrderIso.symm_transₓ'. -/
theorem symm_trans (e₁ : α ≃o β) (e₂ : β ≃o γ) : (e₁.trans e₂).symm = e₂.symm.trans e₁.symm :=
  rfl
#align order_iso.symm_trans OrderIso.symm_trans

#print OrderIso.prodComm /-
/-- `prod.swap` as an `order_iso`. -/
def prodComm : α × β ≃o β × α where
  toEquiv := Equiv.prodComm α β
  map_rel_iff' a b := Prod.swap_le_swap
#align order_iso.prod_comm OrderIso.prodComm
-/

/- warning: order_iso.coe_prod_comm -> OrderIso.coe_prodComm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β], Eq.{max (succ (max u1 u2)) (succ (max u2 u1))} ((Prod.{u1, u2} α β) -> (Prod.{u2, u1} β α)) (coeFn.{max (succ (max u1 u2)) (succ (max u2 u1)), max (succ (max u1 u2)) (succ (max u2 u1))} (OrderIso.{max u1 u2, max u2 u1} (Prod.{u1, u2} α β) (Prod.{u2, u1} β α) (Prod.hasLe.{u1, u2} α β _inst_1 _inst_2) (Prod.hasLe.{u2, u1} β α _inst_2 _inst_1)) (fun (_x : RelIso.{max u1 u2, max u2 u1} (Prod.{u1, u2} α β) (Prod.{u2, u1} β α) (LE.le.{max u1 u2} (Prod.{u1, u2} α β) (Prod.hasLe.{u1, u2} α β _inst_1 _inst_2)) (LE.le.{max u2 u1} (Prod.{u2, u1} β α) (Prod.hasLe.{u2, u1} β α _inst_2 _inst_1))) => (Prod.{u1, u2} α β) -> (Prod.{u2, u1} β α)) (RelIso.hasCoeToFun.{max u1 u2, max u2 u1} (Prod.{u1, u2} α β) (Prod.{u2, u1} β α) (LE.le.{max u1 u2} (Prod.{u1, u2} α β) (Prod.hasLe.{u1, u2} α β _inst_1 _inst_2)) (LE.le.{max u2 u1} (Prod.{u2, u1} β α) (Prod.hasLe.{u2, u1} β α _inst_2 _inst_1))) (OrderIso.prodComm.{u1, u2} α β _inst_1 _inst_2)) (Prod.swap.{u1, u2} α β)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : Prod.{u2, u1} α β), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u2, u1} α β) => Prod.{u1, u2} β α) ᾰ) (FunLike.coe.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (Prod.{u2, u1} α β) (Prod.{u1, u2} β α)) (Prod.{u2, u1} α β) (fun (_x : Prod.{u2, u1} α β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Prod.{u2, u1} α β) => Prod.{u1, u2} β α) _x) (EmbeddingLike.toFunLike.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} (Function.Embedding.{succ (max u2 u1), succ (max u2 u1)} (Prod.{u2, u1} α β) (Prod.{u1, u2} β α)) (Prod.{u2, u1} α β) (Prod.{u1, u2} β α) (Function.instEmbeddingLikeEmbedding.{succ (max u2 u1), succ (max u2 u1)} (Prod.{u2, u1} α β) (Prod.{u1, u2} β α))) (RelEmbedding.toEmbedding.{max u2 u1, max u2 u1} (Prod.{u2, u1} α β) (Prod.{u1, u2} β α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Prod.{u2, u1} α β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Prod.{u2, u1} α β) => LE.le.{max u1 u2} (Prod.{u2, u1} α β) (Prod.instLEProd.{u2, u1} α β _inst_1 _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Prod.{u1, u2} β α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Prod.{u1, u2} β α) => LE.le.{max u2 u1} (Prod.{u1, u2} β α) (Prod.instLEProd.{u1, u2} β α _inst_2 _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{max u2 u1, max u2 u1} (Prod.{u2, u1} α β) (Prod.{u1, u2} β α) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : Prod.{u2, u1} α β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : Prod.{u2, u1} α β) => LE.le.{max u1 u2} (Prod.{u2, u1} α β) (Prod.instLEProd.{u2, u1} α β _inst_1 _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : Prod.{u1, u2} β α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : Prod.{u1, u2} β α) => LE.le.{max u2 u1} (Prod.{u1, u2} β α) (Prod.instLEProd.{u1, u2} β α _inst_2 _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.prodComm.{u2, u1} α β _inst_1 _inst_2)))) (Prod.swap.{u2, u1} α β)
Case conversion may be inaccurate. Consider using '#align order_iso.coe_prod_comm OrderIso.coe_prodCommₓ'. -/
@[simp]
theorem coe_prodComm : ⇑(prodComm : α × β ≃o β × α) = Prod.swap :=
  rfl
#align order_iso.coe_prod_comm OrderIso.coe_prodComm

/- warning: order_iso.prod_comm_symm -> OrderIso.prodComm_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β], Eq.{max (succ (max u2 u1)) (succ (max u1 u2))} (OrderIso.{max u2 u1, max u1 u2} (Prod.{u2, u1} β α) (Prod.{u1, u2} α β) (Prod.hasLe.{u2, u1} β α _inst_2 _inst_1) (Prod.hasLe.{u1, u2} α β _inst_1 _inst_2)) (OrderIso.symm.{max u1 u2, max u2 u1} (Prod.{u1, u2} α β) (Prod.{u2, u1} β α) (Prod.hasLe.{u1, u2} α β _inst_1 _inst_2) (Prod.hasLe.{u2, u1} β α _inst_2 _inst_1) (OrderIso.prodComm.{u1, u2} α β _inst_1 _inst_2)) (OrderIso.prodComm.{u2, u1} β α _inst_2 _inst_1)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β], Eq.{max (succ u2) (succ u1)} (OrderIso.{max u2 u1, max u2 u1} (Prod.{u1, u2} β α) (Prod.{u2, u1} α β) (Prod.instLEProd.{u1, u2} β α _inst_2 _inst_1) (Prod.instLEProd.{u2, u1} α β _inst_1 _inst_2)) (OrderIso.symm.{max u2 u1, max u2 u1} (Prod.{u2, u1} α β) (Prod.{u1, u2} β α) (Prod.instLEProd.{u2, u1} α β _inst_1 _inst_2) (Prod.instLEProd.{u1, u2} β α _inst_2 _inst_1) (OrderIso.prodComm.{u2, u1} α β _inst_1 _inst_2)) (OrderIso.prodComm.{u1, u2} β α _inst_2 _inst_1)
Case conversion may be inaccurate. Consider using '#align order_iso.prod_comm_symm OrderIso.prodComm_symmₓ'. -/
@[simp]
theorem prodComm_symm : (prodComm : α × β ≃o β × α).symm = prod_comm :=
  rfl
#align order_iso.prod_comm_symm OrderIso.prodComm_symm

variable (α)

#print OrderIso.dualDual /-
/-- The order isomorphism between a type and its double dual. -/
def dualDual : α ≃o αᵒᵈᵒᵈ :=
  refl α
#align order_iso.dual_dual OrderIso.dualDual
-/

/- warning: order_iso.coe_dual_dual -> OrderIso.coe_dualDual is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : LE.{u1} α], Eq.{succ u1} (α -> (OrderDual.{u1} (OrderDual.{u1} α))) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) _inst_1 (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) (LE.le.{u1} α _inst_1) (LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) => α -> (OrderDual.{u1} (OrderDual.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) (LE.le.{u1} α _inst_1) (LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) (OrderIso.dualDual.{u1} α _inst_1)) (Function.comp.{succ u1, succ u1, succ u1} α (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α))) (fun (_x : Equiv.{succ u1, succ u1} (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α))) => (OrderDual.{u1} α) -> (OrderDual.{u1} (OrderDual.{u1} α))) (Equiv.hasCoeToFun.{succ u1, succ u1} (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α))) (OrderDual.toDual.{u1} (OrderDual.{u1} α))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) => α -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} α (OrderDual.{u1} α)) (OrderDual.toDual.{u1} α)))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : LE.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} (OrderDual.{u1} α)) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} α (OrderDual.{u1} (OrderDual.{u1} α))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} (OrderDual.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} α (OrderDual.{u1} (OrderDual.{u1} α))) α (OrderDual.{u1} (OrderDual.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} α (OrderDual.{u1} (OrderDual.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.instLEOrderDual.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.instLEOrderDual.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.dualDual.{u1} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u1} α (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α)) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} α) (fun (_x : OrderDual.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} α) => OrderDual.{u1} (OrderDual.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α))))) (OrderDual.toDual.{u1} (OrderDual.{u1} α))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} α (OrderDual.{u1} α)))) (OrderDual.toDual.{u1} α)))
Case conversion may be inaccurate. Consider using '#align order_iso.coe_dual_dual OrderIso.coe_dualDualₓ'. -/
@[simp]
theorem coe_dualDual : ⇑(dualDual α) = to_dual ∘ to_dual :=
  rfl
#align order_iso.coe_dual_dual OrderIso.coe_dualDual

/- warning: order_iso.coe_dual_dual_symm -> OrderIso.coe_dualDual_symm is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : LE.{u1} α], Eq.{succ u1} ((OrderDual.{u1} (OrderDual.{u1} α)) -> α) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (OrderDual.{u1} (OrderDual.{u1} α)) α (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) _inst_1) (fun (_x : RelIso.{u1, u1} (OrderDual.{u1} (OrderDual.{u1} α)) α (LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} α _inst_1)) => (OrderDual.{u1} (OrderDual.{u1} α)) -> α) (RelIso.hasCoeToFun.{u1, u1} (OrderDual.{u1} (OrderDual.{u1} α)) α (LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} α _inst_1)) (OrderIso.symm.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) _inst_1 (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderIso.dualDual.{u1} α _inst_1))) (Function.comp.{succ u1, succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α) α (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) α) (fun (_x : Equiv.{succ u1, succ u1} (OrderDual.{u1} α) α) => (OrderDual.{u1} α) -> α) (Equiv.hasCoeToFun.{succ u1, succ u1} (OrderDual.{u1} α) α) (OrderDual.ofDual.{u1} α)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) => (OrderDual.{u1} (OrderDual.{u1} α)) -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) (OrderDual.ofDual.{u1} (OrderDual.{u1} α))))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : LE.{u1} α], Eq.{succ u1} (forall (ᾰ : OrderDual.{u1} (OrderDual.{u1} α)), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (OrderDual.{u1} α)) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) α) (OrderDual.{u1} (OrderDual.{u1} α)) (fun (_x : OrderDual.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (OrderDual.{u1} α)) => α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) α) (OrderDual.{u1} (OrderDual.{u1} α)) α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) α)) (RelEmbedding.toEmbedding.{u1, u1} (OrderDual.{u1} (OrderDual.{u1} α)) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.instLEOrderDual.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (OrderDual.{u1} (OrderDual.{u1} α)) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.instLEOrderDual.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) _inst_1 (OrderDual.instLEOrderDual.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) (OrderIso.dualDual.{u1} α _inst_1))))) (Function.comp.{succ u1, succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α) α (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) α) (OrderDual.{u1} α) (fun (_x : OrderDual.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} α) => α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) α) (OrderDual.{u1} α) α (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) α) (OrderDual.{u1} α) α (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (OrderDual.{u1} α) α))) (OrderDual.ofDual.{u1} α)) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) (OrderDual.{u1} (OrderDual.{u1} α)) (fun (_x : OrderDual.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)))) (OrderDual.ofDual.{u1} (OrderDual.{u1} α))))
Case conversion may be inaccurate. Consider using '#align order_iso.coe_dual_dual_symm OrderIso.coe_dualDual_symmₓ'. -/
@[simp]
theorem coe_dualDual_symm : ⇑(dualDual α).symm = of_dual ∘ of_dual :=
  rfl
#align order_iso.coe_dual_dual_symm OrderIso.coe_dualDual_symm

variable {α}

/- warning: order_iso.dual_dual_apply -> OrderIso.dualDual_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) _inst_1 (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) (LE.le.{u1} α _inst_1) (LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) => α -> (OrderDual.{u1} (OrderDual.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) (LE.le.{u1} α _inst_1) (LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) (OrderIso.dualDual.{u1} α _inst_1) a) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α))) (fun (_x : Equiv.{succ u1, succ u1} (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α))) => (OrderDual.{u1} α) -> (OrderDual.{u1} (OrderDual.{u1} α))) (Equiv.hasCoeToFun.{succ u1, succ u1} (OrderDual.{u1} α) (OrderDual.{u1} (OrderDual.{u1} α))) (OrderDual.toDual.{u1} (OrderDual.{u1} α)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) => α -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} α (OrderDual.{u1} α)) (OrderDual.toDual.{u1} α) a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} (OrderDual.{u1} α)) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} α (OrderDual.{u1} (OrderDual.{u1} α))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} (OrderDual.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} α (OrderDual.{u1} (OrderDual.{u1} α))) α (OrderDual.{u1} (OrderDual.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} α (OrderDual.{u1} (OrderDual.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.instLEOrderDual.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.instLEOrderDual.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.dualDual.{u1} α _inst_1))) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (OrderDual.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a))) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (fun (_x : (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) => OrderDual.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (OrderDual.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a))) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (OrderDual.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (OrderDual.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a))) ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (OrderDual.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (OrderDual.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a))))) (OrderDual.toDual.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a)) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} α (OrderDual.{u1} α)))) (OrderDual.toDual.{u1} α) a))
Case conversion may be inaccurate. Consider using '#align order_iso.dual_dual_apply OrderIso.dualDual_applyₓ'. -/
@[simp]
theorem dualDual_apply (a : α) : dualDual α a = toDual (toDual a) :=
  rfl
#align order_iso.dual_dual_apply OrderIso.dualDual_apply

/- warning: order_iso.dual_dual_symm_apply -> OrderIso.dualDual_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : OrderDual.{u1} (OrderDual.{u1} α)), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (OrderDual.{u1} (OrderDual.{u1} α)) α (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) _inst_1) (fun (_x : RelIso.{u1, u1} (OrderDual.{u1} (OrderDual.{u1} α)) α (LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} α _inst_1)) => (OrderDual.{u1} (OrderDual.{u1} α)) -> α) (RelIso.hasCoeToFun.{u1, u1} (OrderDual.{u1} (OrderDual.{u1} α)) α (LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} α _inst_1)) (OrderIso.symm.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) _inst_1 (OrderDual.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderIso.dualDual.{u1} α _inst_1)) a) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) α) (fun (_x : Equiv.{succ u1, succ u1} (OrderDual.{u1} α) α) => (OrderDual.{u1} α) -> α) (Equiv.hasCoeToFun.{succ u1, succ u1} (OrderDual.{u1} α) α) (OrderDual.ofDual.{u1} α) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) => (OrderDual.{u1} (OrderDual.{u1} α)) -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) (OrderDual.ofDual.{u1} (OrderDual.{u1} α)) a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : OrderDual.{u1} (OrderDual.{u1} α)), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (OrderDual.{u1} α)) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) α) (OrderDual.{u1} (OrderDual.{u1} α)) (fun (_x : OrderDual.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (OrderDual.{u1} α)) => α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) α) (OrderDual.{u1} (OrderDual.{u1} α)) α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) α)) (RelEmbedding.toEmbedding.{u1, u1} (OrderDual.{u1} (OrderDual.{u1} α)) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.instLEOrderDual.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (OrderDual.{u1} (OrderDual.{u1} α)) α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.instLEOrderDual.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u1} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u1, u1} α (OrderDual.{u1} (OrderDual.{u1} α)) _inst_1 (OrderDual.instLEOrderDual.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) (OrderIso.dualDual.{u1} α _inst_1)))) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) α) (OrderDual.{u1} α) (fun (_x : OrderDual.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} α) => α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) α) (OrderDual.{u1} α) α (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} α) α) (OrderDual.{u1} α) α (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (OrderDual.{u1} α) α))) (OrderDual.ofDual.{u1} α) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) (OrderDual.{u1} (OrderDual.{u1} α)) (fun (_x : OrderDual.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)) (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (OrderDual.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} α)))) (OrderDual.ofDual.{u1} (OrderDual.{u1} α)) a))
Case conversion may be inaccurate. Consider using '#align order_iso.dual_dual_symm_apply OrderIso.dualDual_symm_applyₓ'. -/
@[simp]
theorem dualDual_symm_apply (a : αᵒᵈᵒᵈ) : (dualDual α).symm a = ofDual (ofDual a) :=
  rfl
#align order_iso.dual_dual_symm_apply OrderIso.dualDual_symm_apply

end LE

open Set

section Le

variable [LE α] [LE β] [LE γ]

/- warning: order_iso.le_iff_le -> OrderIso.le_iff_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2) {x : α} {y : α}, Iff (LE.le.{u2} β _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e y)) (LE.le.{u1} α _inst_1 x y)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2) {x : α} {y : α}, Iff (LE.le.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) y)) (LE.le.{u2} α _inst_1 x y)
Case conversion may be inaccurate. Consider using '#align order_iso.le_iff_le OrderIso.le_iff_leₓ'. -/
@[simp]
theorem le_iff_le (e : α ≃o β) {x y : α} : e x ≤ e y ↔ x ≤ y :=
  e.map_rel_iff
#align order_iso.le_iff_le OrderIso.le_iff_le

/- warning: order_iso.le_symm_apply -> OrderIso.le_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2) {x : α} {y : β}, Iff (LE.le.{u1} α _inst_1 x (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderIso.{u2, u1} β α _inst_2 _inst_1) (fun (_x : RelIso.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) => β -> α) (RelIso.hasCoeToFun.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2 e) y)) (LE.le.{u2} β _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e x) y)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2) {x : α} {y : β}, Iff (LE.le.{u2} α _inst_1 x (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} β α)) (RelEmbedding.toEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, u1} α β _inst_1 _inst_2 e))) y)) (LE.le.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x) y)
Case conversion may be inaccurate. Consider using '#align order_iso.le_symm_apply OrderIso.le_symm_applyₓ'. -/
theorem le_symm_apply (e : α ≃o β) {x : α} {y : β} : x ≤ e.symm y ↔ e x ≤ y :=
  e.rel_symm_apply
#align order_iso.le_symm_apply OrderIso.le_symm_apply

/- warning: order_iso.symm_apply_le -> OrderIso.symm_apply_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : LE.{u2} β] (e : OrderIso.{u1, u2} α β _inst_1 _inst_2) {x : α} {y : β}, Iff (LE.le.{u1} α _inst_1 (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderIso.{u2, u1} β α _inst_2 _inst_1) (fun (_x : RelIso.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) => β -> α) (RelIso.hasCoeToFun.{u2, u1} β α (LE.le.{u2} β _inst_2) (LE.le.{u1} α _inst_1)) (OrderIso.symm.{u1, u2} α β _inst_1 _inst_2 e) y) x) (LE.le.{u2} β _inst_2 y (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 _inst_2) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β _inst_2)) e x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u1} β] (e : OrderIso.{u2, u1} α β _inst_1 _inst_2) {x : α} {y : β}, Iff (LE.le.{u2} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) y) _inst_1 (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ u2), succ u1, succ u2} (Function.Embedding.{succ u1, succ u2} β α) β α (Function.instEmbeddingLikeEmbedding.{succ u1, succ u2} β α)) (RelEmbedding.toEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u2, u1} α β _inst_1 _inst_2 e))) y) x) (LE.le.{u1} β _inst_2 y (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β _inst_2 x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x))
Case conversion may be inaccurate. Consider using '#align order_iso.symm_apply_le OrderIso.symm_apply_leₓ'. -/
theorem symm_apply_le (e : α ≃o β) {x : α} {y : β} : e.symm y ≤ x ↔ y ≤ e x :=
  e.symm_apply_rel
#align order_iso.symm_apply_le OrderIso.symm_apply_le

end Le

variable [Preorder α] [Preorder β] [Preorder γ]

/- warning: order_iso.monotone -> OrderIso.monotone is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (e : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)), Monotone.{u1, u2} α β _inst_1 _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) e)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (e : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2)), Monotone.{u2, u1} α β _inst_1 _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)))
Case conversion may be inaccurate. Consider using '#align order_iso.monotone OrderIso.monotoneₓ'. -/
protected theorem monotone (e : α ≃o β) : Monotone e :=
  e.toOrderEmbedding.Monotone
#align order_iso.monotone OrderIso.monotone

/- warning: order_iso.strict_mono -> OrderIso.strictMono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (e : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)), StrictMono.{u1, u2} α β _inst_1 _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) e)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (e : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2)), StrictMono.{u2, u1} α β _inst_1 _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)))
Case conversion may be inaccurate. Consider using '#align order_iso.strict_mono OrderIso.strictMonoₓ'. -/
protected theorem strictMono (e : α ≃o β) : StrictMono e :=
  e.toOrderEmbedding.StrictMono
#align order_iso.strict_mono OrderIso.strictMono

/- warning: order_iso.lt_iff_lt -> OrderIso.lt_iff_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (e : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) {x : α} {y : α}, Iff (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) e x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) e y)) (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1) x y)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (e : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2)) {x : α} {y : α}, Iff (LT.lt.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (Preorder.toLT.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) y)) (LT.lt.{u2} α (Preorder.toLT.{u2} α _inst_1) x y)
Case conversion may be inaccurate. Consider using '#align order_iso.lt_iff_lt OrderIso.lt_iff_ltₓ'. -/
@[simp]
theorem lt_iff_lt (e : α ≃o β) {x y : α} : e x < e y ↔ x < y :=
  e.toOrderEmbedding.lt_iff_lt
#align order_iso.lt_iff_lt OrderIso.lt_iff_lt

#print OrderIso.toRelIsoLT /-
/-- Converts an `order_iso` into a `rel_iso (<) (<)`. -/
def toRelIsoLT (e : α ≃o β) : ((· < ·) : α → α → Prop) ≃r ((· < ·) : β → β → Prop) :=
  ⟨e.toEquiv, fun x y => lt_iff_lt e⟩
#align order_iso.to_rel_iso_lt OrderIso.toRelIsoLT
-/

/- warning: order_iso.to_rel_iso_lt_apply -> OrderIso.toRelIsoLT_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (e : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RelIso.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1)) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (fun (_x : RelIso.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1)) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1)) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2))) (OrderIso.toRelIsoLT.{u1, u2} α β _inst_1 _inst_2 e) x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) e x)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (e : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2)) (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9264 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9266 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.9264 x._@.Mathlib.Order.Hom.Basic._hyg.9266) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9286 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9288 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.9286 x._@.Mathlib.Order.Hom.Basic._hyg.9288) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9264 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9266 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.9264 x._@.Mathlib.Order.Hom.Basic._hyg.9266) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9286 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9288 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.9286 x._@.Mathlib.Order.Hom.Basic._hyg.9288) (OrderIso.toRelIsoLT.{u2, u1} α β _inst_1 _inst_2 e))) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) e)) x)
Case conversion may be inaccurate. Consider using '#align order_iso.to_rel_iso_lt_apply OrderIso.toRelIsoLT_applyₓ'. -/
@[simp]
theorem toRelIsoLT_apply (e : α ≃o β) (x : α) : e.toRelIsoLt x = e x :=
  rfl
#align order_iso.to_rel_iso_lt_apply OrderIso.toRelIsoLT_apply

/- warning: order_iso.to_rel_iso_lt_symm -> OrderIso.toRelIsoLT_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (e : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)), Eq.{max (succ u2) (succ u1)} (RelIso.{u2, u1} β α (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2)) (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1))) (RelIso.symm.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α _inst_1)) (LT.lt.{u2} β (Preorder.toLT.{u2} β _inst_2)) (OrderIso.toRelIsoLT.{u1, u2} α β _inst_1 _inst_2 e)) (OrderIso.toRelIsoLT.{u2, u1} β α _inst_2 _inst_1 (OrderIso.symm.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2) e))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (e : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2)), Eq.{max (succ u2) (succ u1)} (RelIso.{u1, u2} β α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9286 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9288 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.9286 x._@.Mathlib.Order.Hom.Basic._hyg.9288) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9264 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9266 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.9264 x._@.Mathlib.Order.Hom.Basic._hyg.9266)) (RelIso.symm.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9264 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9266 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.9264 x._@.Mathlib.Order.Hom.Basic._hyg.9266) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9286 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9288 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.9286 x._@.Mathlib.Order.Hom.Basic._hyg.9288) (OrderIso.toRelIsoLT.{u2, u1} α β _inst_1 _inst_2 e)) (OrderIso.toRelIsoLT.{u1, u2} β α _inst_2 _inst_1 (OrderIso.symm.{u2, u1} α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2) e))
Case conversion may be inaccurate. Consider using '#align order_iso.to_rel_iso_lt_symm OrderIso.toRelIsoLT_symmₓ'. -/
@[simp]
theorem toRelIsoLT_symm (e : α ≃o β) : e.toRelIsoLt.symm = e.symm.toRelIsoLt :=
  rfl
#align order_iso.to_rel_iso_lt_symm OrderIso.toRelIsoLT_symm

#print OrderIso.ofRelIsoLT /-
/-- Converts a `rel_iso (<) (<)` into an `order_iso`. -/
def ofRelIsoLT {α β} [PartialOrder α] [PartialOrder β]
    (e : ((· < ·) : α → α → Prop) ≃r ((· < ·) : β → β → Prop)) : α ≃o β :=
  ⟨e.toEquiv, fun x y => by simp [le_iff_eq_or_lt, e.map_rel_iff]⟩
#align order_iso.of_rel_iso_lt OrderIso.ofRelIsoLT
-/

/- warning: order_iso.of_rel_iso_lt_apply -> OrderIso.ofRelIsoLT_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_4 : PartialOrder.{u1} α] [_inst_5 : PartialOrder.{u2} β] (e : RelIso.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)))) (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)))) (OrderIso.ofRelIsoLT.{u1, u2} α β _inst_4 _inst_5 e) x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RelIso.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)))) (fun (_x : RelIso.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)))) e x)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_4 : PartialOrder.{u2} α] [_inst_5 : PartialOrder.{u1} β] (e : RelIso.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9483 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9485 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) x._@.Mathlib.Order.Hom.Basic._hyg.9483 x._@.Mathlib.Order.Hom.Basic._hyg.9485) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9505 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9507 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.9505 x._@.Mathlib.Order.Hom.Basic._hyg.9507)) (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.ofRelIsoLT.{u2, u1} α β _inst_4 _inst_5 e))) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9483 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9485 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) x._@.Mathlib.Order.Hom.Basic._hyg.9483 x._@.Mathlib.Order.Hom.Basic._hyg.9485) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9505 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9507 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.9505 x._@.Mathlib.Order.Hom.Basic._hyg.9507) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9483 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9485 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) x._@.Mathlib.Order.Hom.Basic._hyg.9483 x._@.Mathlib.Order.Hom.Basic._hyg.9485) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9505 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9507 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.9505 x._@.Mathlib.Order.Hom.Basic._hyg.9507) e)) x)
Case conversion may be inaccurate. Consider using '#align order_iso.of_rel_iso_lt_apply OrderIso.ofRelIsoLT_applyₓ'. -/
@[simp]
theorem ofRelIsoLT_apply {α β} [PartialOrder α] [PartialOrder β]
    (e : ((· < ·) : α → α → Prop) ≃r ((· < ·) : β → β → Prop)) (x : α) : ofRelIsoLT e x = e x :=
  rfl
#align order_iso.of_rel_iso_lt_apply OrderIso.ofRelIsoLT_apply

/- warning: order_iso.of_rel_iso_lt_symm -> OrderIso.ofRelIsoLT_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_4 : PartialOrder.{u1} α] [_inst_5 : PartialOrder.{u2} β] (e : RelIso.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)))), Eq.{max (succ u2) (succ u1)} (OrderIso.{u2, u1} β α (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (OrderIso.symm.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)) (OrderIso.ofRelIsoLT.{u1, u2} α β _inst_4 _inst_5 e)) (OrderIso.ofRelIsoLT.{u2, u1} β α _inst_5 _inst_4 (RelIso.symm.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5))) e))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_4 : PartialOrder.{u2} α] [_inst_5 : PartialOrder.{u1} β] (e : RelIso.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9564 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9566 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) x._@.Mathlib.Order.Hom.Basic._hyg.9564 x._@.Mathlib.Order.Hom.Basic._hyg.9566) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9586 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9588 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.9586 x._@.Mathlib.Order.Hom.Basic._hyg.9588)), Eq.{max (succ u2) (succ u1)} (OrderIso.{u1, u2} β α (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4))) (OrderIso.symm.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) (OrderIso.ofRelIsoLT.{u2, u1} α β _inst_4 _inst_5 e)) (OrderIso.ofRelIsoLT.{u1, u2} β α _inst_5 _inst_4 (RelIso.symm.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9564 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9566 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) x._@.Mathlib.Order.Hom.Basic._hyg.9564 x._@.Mathlib.Order.Hom.Basic._hyg.9566) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9586 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9588 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.9586 x._@.Mathlib.Order.Hom.Basic._hyg.9588) e))
Case conversion may be inaccurate. Consider using '#align order_iso.of_rel_iso_lt_symm OrderIso.ofRelIsoLT_symmₓ'. -/
@[simp]
theorem ofRelIsoLT_symm {α β} [PartialOrder α] [PartialOrder β]
    (e : ((· < ·) : α → α → Prop) ≃r ((· < ·) : β → β → Prop)) :
    (ofRelIsoLT e).symm = ofRelIsoLT e.symm :=
  rfl
#align order_iso.of_rel_iso_lt_symm OrderIso.ofRelIsoLT_symm

/- warning: order_iso.of_rel_iso_lt_to_rel_iso_lt -> OrderIso.ofRelIsoLT_toRelIsoLT is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_4 : PartialOrder.{u1} α] [_inst_5 : PartialOrder.{u2} β] (e : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5))), Eq.{max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5))) (OrderIso.ofRelIsoLT.{u1, u2} α β _inst_4 _inst_5 (OrderIso.toRelIsoLT.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_4) (PartialOrder.toPreorder.{u2} β _inst_5) e)) e
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_4 : PartialOrder.{u2} α] [_inst_5 : PartialOrder.{u1} β] (e : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5))), Eq.{max (succ u2) (succ u1)} (OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5))) (OrderIso.ofRelIsoLT.{u2, u1} α β _inst_4 _inst_5 (OrderIso.toRelIsoLT.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_4) (PartialOrder.toPreorder.{u1} β _inst_5) e)) e
Case conversion may be inaccurate. Consider using '#align order_iso.of_rel_iso_lt_to_rel_iso_lt OrderIso.ofRelIsoLT_toRelIsoLTₓ'. -/
@[simp]
theorem ofRelIsoLT_toRelIsoLT {α β} [PartialOrder α] [PartialOrder β] (e : α ≃o β) :
    ofRelIsoLT (toRelIsoLT e) = e := by
  ext
  simp
#align order_iso.of_rel_iso_lt_to_rel_iso_lt OrderIso.ofRelIsoLT_toRelIsoLT

/- warning: order_iso.to_rel_iso_lt_of_rel_iso_lt -> OrderIso.toRelIsoLT_ofRelIsoLT is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_4 : PartialOrder.{u1} α] [_inst_5 : PartialOrder.{u2} β] (e : RelIso.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)))), Eq.{max (succ u1) (succ u2)} (RelIso.{u1, u2} α β (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_4))) (LT.lt.{u2} β (Preorder.toLT.{u2} β (PartialOrder.toPreorder.{u2} β _inst_5)))) (OrderIso.toRelIsoLT.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_4) (PartialOrder.toPreorder.{u2} β _inst_5) (OrderIso.ofRelIsoLT.{u1, u2} α β _inst_4 _inst_5 e)) e
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_4 : PartialOrder.{u2} α] [_inst_5 : PartialOrder.{u1} β] (e : RelIso.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9690 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9692 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) x._@.Mathlib.Order.Hom.Basic._hyg.9690 x._@.Mathlib.Order.Hom.Basic._hyg.9692) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9712 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9714 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.9712 x._@.Mathlib.Order.Hom.Basic._hyg.9714)), Eq.{max (succ u2) (succ u1)} (RelIso.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9264 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.9266 : α) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α _inst_4)) x._@.Mathlib.Order.Hom.Basic._hyg.9264 x._@.Mathlib.Order.Hom.Basic._hyg.9266) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.9286 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.9288 : β) => LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.9286 x._@.Mathlib.Order.Hom.Basic._hyg.9288)) (OrderIso.toRelIsoLT.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_4) (PartialOrder.toPreorder.{u1} β _inst_5) (OrderIso.ofRelIsoLT.{u2, u1} α β _inst_4 _inst_5 e)) e
Case conversion may be inaccurate. Consider using '#align order_iso.to_rel_iso_lt_of_rel_iso_lt OrderIso.toRelIsoLT_ofRelIsoLTₓ'. -/
@[simp]
theorem toRelIsoLT_ofRelIsoLT {α β} [PartialOrder α] [PartialOrder β]
    (e : ((· < ·) : α → α → Prop) ≃r ((· < ·) : β → β → Prop)) : toRelIsoLT (ofRelIsoLT e) = e :=
  by
  ext
  simp
#align order_iso.to_rel_iso_lt_of_rel_iso_lt OrderIso.toRelIsoLT_ofRelIsoLT

#print OrderIso.ofCmpEqCmp /-
/-- To show that `f : α → β`, `g : β → α` make up an order isomorphism of linear orders,
    it suffices to prove `cmp a (g b) = cmp (f a) b`. -/
def ofCmpEqCmp {α β} [LinearOrder α] [LinearOrder β] (f : α → β) (g : β → α)
    (h : ∀ (a : α) (b : β), cmp a (g b) = cmp (f a) b) : α ≃o β :=
  have gf : ∀ a : α, a = g (f a) := by
    intro
    rw [← cmp_eq_eq_iff, h, cmp_self_eq_eq]
  { toFun := f
    invFun := g
    left_inv := fun a => (gf a).symm
    right_inv := by
      intro
      rw [← cmp_eq_eq_iff, ← h, cmp_self_eq_eq]
    map_rel_iff' := by
      intros
      apply le_iff_le_of_cmp_eq_cmp
      convert (h _ _).symm
      apply gf }
#align order_iso.of_cmp_eq_cmp OrderIso.ofCmpEqCmp
-/

/- warning: order_iso.of_hom_inv -> OrderIso.ofHomInv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {F : Type.{u3}} {G : Type.{u4}} [_inst_4 : OrderHomClass.{u3, u1, u2} F α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)] [_inst_5 : OrderHomClass.{u4, u2, u1} G β α (Preorder.toLE.{u2} β _inst_2) (Preorder.toLE.{u1} α _inst_1)] (f : F) (g : G), (Eq.{succ u2} (OrderHom.{u2, u2} β β _inst_2 _inst_2) (OrderHom.comp.{u2, u1, u2} β α β _inst_2 _inst_1 _inst_2 ((fun (a : Type.{u3}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u3, max (succ u1) (succ u2)} a b] => self.0) F (OrderHom.{u1, u2} α β _inst_1 _inst_2) (HasLiftT.mk.{succ u3, max (succ u1) (succ u2)} F (OrderHom.{u1, u2} α β _inst_1 _inst_2) (CoeTCₓ.coe.{succ u3, max (succ u1) (succ u2)} F (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHomClass.OrderHom.hasCoeT.{u3, u1, u2} F α β _inst_1 _inst_2 _inst_4))) f) ((fun (a : Type.{u4}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{succ u4, max (succ u2) (succ u1)} a b] => self.0) G (OrderHom.{u2, u1} β α _inst_2 _inst_1) (HasLiftT.mk.{succ u4, max (succ u2) (succ u1)} G (OrderHom.{u2, u1} β α _inst_2 _inst_1) (CoeTCₓ.coe.{succ u4, max (succ u2) (succ u1)} G (OrderHom.{u2, u1} β α _inst_2 _inst_1) (OrderHomClass.OrderHom.hasCoeT.{u4, u2, u1} G β α _inst_2 _inst_1 _inst_5))) g)) (OrderHom.id.{u2} β _inst_2)) -> (Eq.{succ u1} (OrderHom.{u1, u1} α α _inst_1 _inst_1) (OrderHom.comp.{u1, u2, u1} α β α _inst_1 _inst_2 _inst_1 ((fun (a : Type.{u4}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{succ u4, max (succ u2) (succ u1)} a b] => self.0) G (OrderHom.{u2, u1} β α _inst_2 _inst_1) (HasLiftT.mk.{succ u4, max (succ u2) (succ u1)} G (OrderHom.{u2, u1} β α _inst_2 _inst_1) (CoeTCₓ.coe.{succ u4, max (succ u2) (succ u1)} G (OrderHom.{u2, u1} β α _inst_2 _inst_1) (OrderHomClass.OrderHom.hasCoeT.{u4, u2, u1} G β α _inst_2 _inst_1 _inst_5))) g) ((fun (a : Type.{u3}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u3, max (succ u1) (succ u2)} a b] => self.0) F (OrderHom.{u1, u2} α β _inst_1 _inst_2) (HasLiftT.mk.{succ u3, max (succ u1) (succ u2)} F (OrderHom.{u1, u2} α β _inst_1 _inst_2) (CoeTCₓ.coe.{succ u3, max (succ u1) (succ u2)} F (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHomClass.OrderHom.hasCoeT.{u3, u1, u2} F α β _inst_1 _inst_2 _inst_4))) f)) (OrderHom.id.{u1} α _inst_1)) -> (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {F : Type.{u3}} {G : Type.{u4}} [_inst_4 : OrderHomClass.{u3, u1, u2} F α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)] [_inst_5 : OrderHomClass.{u4, u2, u1} G β α (Preorder.toLE.{u2} β _inst_2) (Preorder.toLE.{u1} α _inst_1)] (f : F) (g : G), (Eq.{succ u2} (OrderHom.{u2, u2} β β _inst_2 _inst_2) (OrderHom.comp.{u2, u1, u2} β α β _inst_2 _inst_1 _inst_2 (OrderHomClass.toOrderHom.{u3, u1, u2} F α β _inst_1 _inst_2 _inst_4 f) (OrderHomClass.toOrderHom.{u4, u2, u1} G β α _inst_2 _inst_1 _inst_5 g)) (OrderHom.id.{u2} β _inst_2)) -> (Eq.{succ u1} (OrderHom.{u1, u1} α α _inst_1 _inst_1) (OrderHom.comp.{u1, u2, u1} α β α _inst_1 _inst_2 _inst_1 (OrderHomClass.toOrderHom.{u4, u2, u1} G β α _inst_2 _inst_1 _inst_5 g) (OrderHomClass.toOrderHom.{u3, u1, u2} F α β _inst_1 _inst_2 _inst_4 f)) (OrderHom.id.{u1} α _inst_1)) -> (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2))
Case conversion may be inaccurate. Consider using '#align order_iso.of_hom_inv OrderIso.ofHomInvₓ'. -/
/-- To show that `f : α →o β` and `g : β →o α` make up an order isomorphism it is enough to show
    that `g` is the inverse of `f`-/
def ofHomInv {F G : Type _} [OrderHomClass F α β] [OrderHomClass G β α] (f : F) (g : G)
    (h₁ : (f : α →o β).comp (g : β →o α) = OrderHom.id)
    (h₂ : (g : β →o α).comp (f : α →o β) = OrderHom.id) : α ≃o β
    where
  toFun := f
  invFun := g
  left_inv := FunLike.congr_fun h₂
  right_inv := FunLike.congr_fun h₁
  map_rel_iff' a b :=
    ⟨fun h => by
      replace h := map_rel g h
      rwa [Equiv.coe_fn_mk, show g (f a) = (g : β →o α).comp (f : α →o β) a from rfl,
        show g (f b) = (g : β →o α).comp (f : α →o β) b from rfl, h₂] at h,
      fun h => (f : α →o β).Monotone h⟩
#align order_iso.of_hom_inv OrderIso.ofHomInv

#print OrderIso.funUnique /-
/-- Order isomorphism between `α → β` and `β`, where `α` has a unique element. -/
@[simps toEquiv apply]
def funUnique (α β : Type _) [Unique α] [Preorder β] : (α → β) ≃o β
    where
  toEquiv := Equiv.funUnique α β
  map_rel_iff' f g := by simp [Pi.le_def, Unique.forall_iff]
#align order_iso.fun_unique OrderIso.funUnique
-/

/- warning: order_iso.fun_unique_symm_apply -> OrderIso.funUnique_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_4 : Unique.{succ u1} α] [_inst_5 : Preorder.{u2} β], Eq.{max (succ u1) (succ u2)} ((fun (_x : RelIso.{u2, max u1 u2} β (α -> β) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_5)) (LE.le.{max u1 u2} (α -> β) (Pi.hasLe.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => Preorder.toLE.{u2} β _inst_5)))) => β -> α -> β) (OrderIso.symm.{max u1 u2, u2} (α -> β) β (Pi.hasLe.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => Preorder.toLE.{u2} β _inst_5)) (Preorder.toLE.{u2} β _inst_5) (OrderIso.funUnique.{u1, u2} α β _inst_4 _inst_5))) (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (OrderIso.{u2, max u1 u2} β (α -> β) (Preorder.toLE.{u2} β _inst_5) (Pi.hasLe.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => Preorder.toLE.{u2} β _inst_5))) (fun (_x : RelIso.{u2, max u1 u2} β (α -> β) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_5)) (LE.le.{max u1 u2} (α -> β) (Pi.hasLe.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => Preorder.toLE.{u2} β _inst_5)))) => β -> α -> β) (RelIso.hasCoeToFun.{u2, max u1 u2} β (α -> β) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_5)) (LE.le.{max u1 u2} (α -> β) (Pi.hasLe.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => Preorder.toLE.{u2} β _inst_5)))) (OrderIso.symm.{max u1 u2, u2} (α -> β) β (Pi.hasLe.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => Preorder.toLE.{u2} β _inst_5)) (Preorder.toLE.{u2} β _inst_5) (OrderIso.funUnique.{u1, u2} α β _inst_4 _inst_5))) (Function.const.{succ u2, succ u1} β α)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_4 : Unique.{succ u2} α] [_inst_5 : Preorder.{u1} β], Eq.{max (succ u2) (succ u1)} (forall (a : β), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α -> β) a) (FunLike.coe.{max (succ u1) (succ (max u2 u1)), succ u1, succ (max u2 u1)} (Function.Embedding.{succ u1, succ (max u2 u1)} β (α -> β)) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α -> β) _x) (EmbeddingLike.toFunLike.{max (succ u1) (succ (max u2 u1)), succ u1, succ (max u2 u1)} (Function.Embedding.{succ u1, succ (max u2 u1)} β (α -> β)) β (α -> β) (Function.instEmbeddingLikeEmbedding.{succ u1, succ (max u2 u1)} β (α -> β))) (RelEmbedding.toEmbedding.{u1, max u2 u1} β (α -> β) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_5) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α -> β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α -> β) => LE.le.{max u2 u1} (α -> β) (Pi.hasLe.{u2, u1} α (fun (a._@.Mathlib.Order.Hom.Basic._hyg.10179 : α) => β) (fun (i : α) => Preorder.toLE.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, max u2 u1} β (α -> β) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_5) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : α -> β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : α -> β) => LE.le.{max u2 u1} (α -> β) (Pi.hasLe.{u2, u1} α (fun (a._@.Mathlib.Order.Hom.Basic._hyg.10179 : α) => β) (fun (i : α) => Preorder.toLE.{u1} β _inst_5)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{max u2 u1, u1} (α -> β) β (Pi.hasLe.{u2, u1} α (fun (a._@.Mathlib.Order.Hom.Basic._hyg.10179 : α) => β) (fun (i : α) => Preorder.toLE.{u1} β _inst_5)) (Preorder.toLE.{u1} β _inst_5) (OrderIso.funUnique.{u2, u1} α β _inst_4 _inst_5))))) (Function.const.{succ u1, succ u2} β α)
Case conversion may be inaccurate. Consider using '#align order_iso.fun_unique_symm_apply OrderIso.funUnique_symm_applyₓ'. -/
@[simp]
theorem funUnique_symm_apply {α β : Type _} [Unique α] [Preorder β] :
    ((funUnique α β).symm : β → α → β) = Function.const α :=
  rfl
#align order_iso.fun_unique_symm_apply OrderIso.funUnique_symm_apply

end OrderIso

namespace Equiv

variable [Preorder α] [Preorder β]

#print Equiv.toOrderIso /-
/-- If `e` is an equivalence with monotone forward and inverse maps, then `e` is an
order isomorphism. -/
def toOrderIso (e : α ≃ β) (h₁ : Monotone e) (h₂ : Monotone e.symm) : α ≃o β :=
  ⟨e, fun x y => ⟨fun h => by simpa only [e.symm_apply_apply] using h₂ h, fun h => h₁ h⟩⟩
#align equiv.to_order_iso Equiv.toOrderIso
-/

/- warning: equiv.coe_to_order_iso -> Equiv.coe_toOrderIso is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (e : Equiv.{succ u1, succ u2} α β) (h₁ : Monotone.{u1, u2} α β _inst_1 _inst_2 (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} α β) (fun (_x : Equiv.{succ u1, succ u2} α β) => α -> β) (Equiv.hasCoeToFun.{succ u1, succ u2} α β) e)) (h₂ : Monotone.{u2, u1} β α _inst_2 _inst_1 (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} β α) (fun (_x : Equiv.{succ u2, succ u1} β α) => β -> α) (Equiv.hasCoeToFun.{succ u2, succ u1} β α) (Equiv.symm.{succ u1, succ u2} α β e))), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2)) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2))) (Equiv.toOrderIso.{u1, u2} α β _inst_1 _inst_2 e h₁ h₂)) (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} α β) (fun (_x : Equiv.{succ u1, succ u2} α β) => α -> β) (Equiv.hasCoeToFun.{succ u1, succ u2} α β) e)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (e : Equiv.{succ u2, succ u1} α β) (h₁ : Monotone.{u2, u1} α β _inst_1 _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α β (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α β (Equiv.instEquivLikeEquiv.{succ u2, succ u1} α β))) e)) (h₂ : Monotone.{u1, u2} β α _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (Equiv.{succ u1, succ u2} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (Equiv.{succ u1, succ u2} β α) β α (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (Equiv.{succ u1, succ u2} β α) β α (Equiv.instEquivLikeEquiv.{succ u1, succ u2} β α))) (Equiv.symm.{succ u2, succ u1} α β e))), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (Equiv.toOrderIso.{u2, u1} α β _inst_1 _inst_2 e h₁ h₂)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α β (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α β (Equiv.instEquivLikeEquiv.{succ u2, succ u1} α β))) e)
Case conversion may be inaccurate. Consider using '#align equiv.coe_to_order_iso Equiv.coe_toOrderIsoₓ'. -/
@[simp]
theorem coe_toOrderIso (e : α ≃ β) (h₁ : Monotone e) (h₂ : Monotone e.symm) :
    ⇑(e.toOrderIso h₁ h₂) = e :=
  rfl
#align equiv.coe_to_order_iso Equiv.coe_toOrderIso

/- warning: equiv.to_order_iso_to_equiv -> Equiv.toOrderIso_toEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] (e : Equiv.{succ u1, succ u2} α β) (h₁ : Monotone.{u1, u2} α β _inst_1 _inst_2 (coeFn.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1), max (succ u1) (succ u2)} (Equiv.{succ u1, succ u2} α β) (fun (_x : Equiv.{succ u1, succ u2} α β) => α -> β) (Equiv.hasCoeToFun.{succ u1, succ u2} α β) e)) (h₂ : Monotone.{u2, u1} β α _inst_2 _inst_1 (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} β α) (fun (_x : Equiv.{succ u2, succ u1} β α) => β -> α) (Equiv.hasCoeToFun.{succ u2, succ u1} β α) (Equiv.symm.{succ u1, succ u2} α β e))), Eq.{max 1 (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{succ u1, succ u2} α β) (RelIso.toEquiv.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1)) (LE.le.{u2} β (Preorder.toLE.{u2} β _inst_2)) (Equiv.toOrderIso.{u1, u2} α β _inst_1 _inst_2 e h₁ h₂)) e
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] (e : Equiv.{succ u2, succ u1} α β) (h₁ : Monotone.{u2, u1} α β _inst_1 _inst_2 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α β (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (Equiv.{succ u2, succ u1} α β) α β (Equiv.instEquivLikeEquiv.{succ u2, succ u1} α β))) e)) (h₂ : Monotone.{u1, u2} β α _inst_2 _inst_1 (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (Equiv.{succ u1, succ u2} β α) β (fun (_x : β) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : β) => α) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u1, succ u2} (Equiv.{succ u1, succ u2} β α) β α (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u1, succ u2} (Equiv.{succ u1, succ u2} β α) β α (Equiv.instEquivLikeEquiv.{succ u1, succ u2} β α))) (Equiv.symm.{succ u2, succ u1} α β e))), Eq.{max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} α β) (RelIso.toEquiv.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (Equiv.toOrderIso.{u2, u1} α β _inst_1 _inst_2 e h₁ h₂)) e
Case conversion may be inaccurate. Consider using '#align equiv.to_order_iso_to_equiv Equiv.toOrderIso_toEquivₓ'. -/
@[simp]
theorem toOrderIso_toEquiv (e : α ≃ β) (h₁ : Monotone e) (h₂ : Monotone e.symm) :
    (e.toOrderIso h₁ h₂).toEquiv = e :=
  rfl
#align equiv.to_order_iso_to_equiv Equiv.toOrderIso_toEquiv

end Equiv

namespace StrictMono

variable {α β} [LinearOrder α] [Preorder β]

variable (f : α → β) (h_mono : StrictMono f) (h_surj : Function.Surjective f)

#print StrictMono.orderIsoOfRightInverse /-
/-- A strictly monotone function with a right inverse is an order isomorphism. -/
@[simps (config := { fullyApplied := False })]
def orderIsoOfRightInverse (g : β → α) (hg : Function.RightInverse g f) : α ≃o β :=
  { OrderEmbedding.ofStrictMono f h_mono with
    toFun := f
    invFun := g
    left_inv := fun x => h_mono.Injective <| hg _
    right_inv := hg }
#align strict_mono.order_iso_of_right_inverse StrictMono.orderIsoOfRightInverse
-/

end StrictMono

#print OrderIso.dual /-
/-- An order isomorphism is also an order isomorphism between dual orders. -/
protected def OrderIso.dual [LE α] [LE β] (f : α ≃o β) : αᵒᵈ ≃o βᵒᵈ :=
  ⟨f.toEquiv, fun _ _ => f.map_rel_iff⟩
#align order_iso.dual OrderIso.dual
-/

section LatticeIsos

/- warning: order_iso.map_bot' -> OrderIso.map_bot' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : PartialOrder.{u2} β] (f : OrderIso.{u1, u2} α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) {x : α} {y : β}, (forall (x' : α), LE.le.{u1} α _inst_1 x x') -> (forall (y' : β), LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) y y') -> (Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) f x) y)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : PartialOrder.{u1} β] (f : OrderIso.{u2, u1} α β _inst_1 (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))) {x : α} {y : β}, (forall (x' : α), LE.le.{u2} α _inst_1 x x') -> (forall (y' : β), LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) y y') -> (Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) x) y)
Case conversion may be inaccurate. Consider using '#align order_iso.map_bot' OrderIso.map_bot'ₓ'. -/
theorem OrderIso.map_bot' [LE α] [PartialOrder β] (f : α ≃o β) {x : α} {y : β} (hx : ∀ x', x ≤ x')
    (hy : ∀ y', y ≤ y') : f x = y :=
  by
  refine' le_antisymm _ (hy _)
  rw [← f.apply_symm_apply y, f.map_rel_iff]
  apply hx
#align order_iso.map_bot' OrderIso.map_bot'

/- warning: order_iso.map_bot -> OrderIso.map_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : PartialOrder.{u2} β] [_inst_3 : OrderBot.{u1} α _inst_1] [_inst_4 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))] (f : OrderIso.{u1, u2} α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) f (Bot.bot.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_3))) (Bot.bot.{u2} β (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) _inst_4))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : PartialOrder.{u1} β] [_inst_3 : OrderBot.{u2} α _inst_1] [_inst_4 : OrderBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))] (f : OrderIso.{u2, u1} α β _inst_1 (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (Bot.bot.{u2} α (OrderBot.toBot.{u2} α _inst_1 _inst_3))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) (Bot.bot.{u2} α (OrderBot.toBot.{u2} α _inst_1 _inst_3))) (Bot.bot.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (Bot.bot.{u2} α (OrderBot.toBot.{u2} α _inst_1 _inst_3))) (OrderBot.toBot.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (Bot.bot.{u2} α (OrderBot.toBot.{u2} α _inst_1 _inst_3))) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (Bot.bot.{u2} α (OrderBot.toBot.{u2} α _inst_1 _inst_3))) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (Bot.bot.{u2} α (OrderBot.toBot.{u2} α _inst_1 _inst_3))) _inst_2)) _inst_4))
Case conversion may be inaccurate. Consider using '#align order_iso.map_bot OrderIso.map_botₓ'. -/
theorem OrderIso.map_bot [LE α] [PartialOrder β] [OrderBot α] [OrderBot β] (f : α ≃o β) : f ⊥ = ⊥ :=
  f.map_bot' (fun _ => bot_le) fun _ => bot_le
#align order_iso.map_bot OrderIso.map_bot

/- warning: order_iso.map_top' -> OrderIso.map_top' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : PartialOrder.{u2} β] (f : OrderIso.{u1, u2} α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) {x : α} {y : β}, (forall (x' : α), LE.le.{u1} α _inst_1 x' x) -> (forall (y' : β), LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) y' y) -> (Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) f x) y)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : PartialOrder.{u1} β] (f : OrderIso.{u2, u1} α β _inst_1 (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))) {x : α} {y : β}, (forall (x' : α), LE.le.{u2} α _inst_1 x' x) -> (forall (y' : β), LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) y' y) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) x) y)
Case conversion may be inaccurate. Consider using '#align order_iso.map_top' OrderIso.map_top'ₓ'. -/
theorem OrderIso.map_top' [LE α] [PartialOrder β] (f : α ≃o β) {x : α} {y : β} (hx : ∀ x', x' ≤ x)
    (hy : ∀ y', y' ≤ y) : f x = y :=
  f.dual.map_bot' hx hy
#align order_iso.map_top' OrderIso.map_top'

/- warning: order_iso.map_top -> OrderIso.map_top is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : PartialOrder.{u2} β] [_inst_3 : OrderTop.{u1} α _inst_1] [_inst_4 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))] (f : OrderIso.{u1, u2} α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_1) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)))) f (Top.top.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_3))) (Top.top.{u2} β (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) _inst_4))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LE.{u2} α] [_inst_2 : PartialOrder.{u1} β] [_inst_3 : OrderTop.{u2} α _inst_1] [_inst_4 : OrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))] (f : OrderIso.{u2, u1} α β _inst_1 (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (Top.top.{u2} α (OrderTop.toTop.{u2} α _inst_1 _inst_3))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) (Top.top.{u2} α (OrderTop.toTop.{u2} α _inst_1 _inst_3))) (Top.top.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (Top.top.{u2} α (OrderTop.toTop.{u2} α _inst_1 _inst_3))) (OrderTop.toTop.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (Top.top.{u2} α (OrderTop.toTop.{u2} α _inst_1 _inst_3))) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (Top.top.{u2} α (OrderTop.toTop.{u2} α _inst_1 _inst_3))) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (Top.top.{u2} α (OrderTop.toTop.{u2} α _inst_1 _inst_3))) _inst_2)) _inst_4))
Case conversion may be inaccurate. Consider using '#align order_iso.map_top OrderIso.map_topₓ'. -/
theorem OrderIso.map_top [LE α] [PartialOrder β] [OrderTop α] [OrderTop β] (f : α ≃o β) : f ⊤ = ⊤ :=
  f.dual.map_bot
#align order_iso.map_top OrderIso.map_top

/- warning: order_embedding.map_inf_le -> OrderEmbedding.map_inf_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))) (x : α) (y : α), LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) f (HasInf.inf.{u1} α (SemilatticeInf.toHasInf.{u1} α _inst_1) x y)) (HasInf.inf.{u2} β (SemilatticeInf.toHasInf.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) f y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} α] [_inst_2 : SemilatticeInf.{u1} β] (f : OrderEmbedding.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2)))) (x : α) (y : α), LE.le.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (HasInf.inf.{u2} α (SemilatticeInf.toHasInf.{u2} α _inst_1) x y)) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (HasInf.inf.{u2} α (SemilatticeInf.toHasInf.{u2} α _inst_1) x y)) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (HasInf.inf.{u2} α (SemilatticeInf.toHasInf.{u2} α _inst_1) x y)) (SemilatticeInf.toPartialOrder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (HasInf.inf.{u2} α (SemilatticeInf.toHasInf.{u2} α _inst_1) x y)) _inst_2))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) (HasInf.inf.{u2} α (SemilatticeInf.toHasInf.{u2} α _inst_1) x y)) (HasInf.inf.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (SemilatticeInf.toHasInf.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) y))
Case conversion may be inaccurate. Consider using '#align order_embedding.map_inf_le OrderEmbedding.map_inf_leₓ'. -/
theorem OrderEmbedding.map_inf_le [SemilatticeInf α] [SemilatticeInf β] (f : α ↪o β) (x y : α) :
    f (x ⊓ y) ≤ f x ⊓ f y :=
  f.Monotone.map_inf_le x y
#align order_embedding.map_inf_le OrderEmbedding.map_inf_le

/- warning: order_embedding.le_map_sup -> OrderEmbedding.le_map_sup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] (f : OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))) (x : α) (y : α), LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) (HasSup.sup.{u2} β (SemilatticeSup.toHasSup.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) f y)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderEmbedding.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelEmbedding.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelEmbedding.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) f (HasSup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} α] [_inst_2 : SemilatticeSup.{u1} β] (f : OrderEmbedding.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2)))) (x : α) (y : α), LE.le.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (SemilatticeSup.toPartialOrder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) _inst_2))) (HasSup.sup.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (SemilatticeSup.toHasSup.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.744 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.746 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.744 x._@.Mathlib.Order.Hom.Basic._hyg.746) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.759 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.761 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.759 x._@.Mathlib.Order.Hom.Basic._hyg.761) f) (HasSup.sup.{u2} α (SemilatticeSup.toHasSup.{u2} α _inst_1) x y))
Case conversion may be inaccurate. Consider using '#align order_embedding.le_map_sup OrderEmbedding.le_map_supₓ'. -/
theorem OrderEmbedding.le_map_sup [SemilatticeSup α] [SemilatticeSup β] (f : α ↪o β) (x y : α) :
    f x ⊔ f y ≤ f (x ⊔ y) :=
  f.Monotone.le_map_sup x y
#align order_embedding.le_map_sup OrderEmbedding.le_map_sup

/- warning: order_iso.map_inf -> OrderIso.map_inf is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] (f : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))) (x : α) (y : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) f (HasInf.inf.{u1} α (SemilatticeInf.toHasInf.{u1} α _inst_1) x y)) (HasInf.inf.{u2} β (SemilatticeInf.toHasInf.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))))) f y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} α] [_inst_2 : SemilatticeInf.{u1} β] (f : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2)))) (x : α) (y : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (HasInf.inf.{u2} α (SemilatticeInf.toHasInf.{u2} α _inst_1) x y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) (HasInf.inf.{u2} α (SemilatticeInf.toHasInf.{u2} α _inst_1) x y)) (HasInf.inf.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (SemilatticeInf.toHasInf.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) y))
Case conversion may be inaccurate. Consider using '#align order_iso.map_inf OrderIso.map_infₓ'. -/
theorem OrderIso.map_inf [SemilatticeInf α] [SemilatticeInf β] (f : α ≃o β) (x y : α) :
    f (x ⊓ y) = f x ⊓ f y :=
  by
  refine' (f.to_order_embedding.map_inf_le x y).antisymm _
  apply f.symm.le_iff_le.1
  simpa using f.symm.to_order_embedding.map_inf_le (f x) (f y)
#align order_iso.map_inf OrderIso.map_inf

/- warning: order_iso.map_sup -> OrderIso.map_sup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] (f : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))) (x : α) (y : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) f (HasSup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x y)) (HasSup.sup.{u2} β (SemilatticeSup.toHasSup.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))))) f y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} α] [_inst_2 : SemilatticeSup.{u1} β] (f : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2)))) (x : α) (y : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) (HasSup.sup.{u2} α (SemilatticeSup.toHasSup.{u2} α _inst_1) x y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) (HasSup.sup.{u2} α (SemilatticeSup.toHasSup.{u2} α _inst_1) x y)) (HasSup.sup.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (SemilatticeSup.toHasSup.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) _inst_2) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) y))
Case conversion may be inaccurate. Consider using '#align order_iso.map_sup OrderIso.map_supₓ'. -/
theorem OrderIso.map_sup [SemilatticeSup α] [SemilatticeSup β] (f : α ≃o β) (x y : α) :
    f (x ⊔ y) = f x ⊔ f y :=
  f.dual.map_inf x y
#align order_iso.map_sup OrderIso.map_sup

/- warning: disjoint.map_order_iso -> Disjoint.map_orderIso is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} α] [_inst_2 : OrderBot.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))] [_inst_3 : SemilatticeInf.{u2} β] [_inst_4 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))] {a : α} {b : α} (f : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))), (Disjoint.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1) _inst_2 a b) -> (Disjoint.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3) _inst_4 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))))) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))))) f b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} α] [_inst_2 : OrderBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1)))] [_inst_3 : SemilatticeInf.{u1} β] [_inst_4 : OrderBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3)))] {a : α} {b : α} (f : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3)))), (Disjoint.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1) _inst_2 a b) -> (Disjoint.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (SemilatticeInf.toPartialOrder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) _inst_3) _inst_4 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) b))
Case conversion may be inaccurate. Consider using '#align disjoint.map_order_iso Disjoint.map_orderIsoₓ'. -/
/-- Note that this goal could also be stated `(disjoint on f) a b` -/
theorem Disjoint.map_orderIso [SemilatticeInf α] [OrderBot α] [SemilatticeInf β] [OrderBot β]
    {a b : α} (f : α ≃o β) (ha : Disjoint a b) : Disjoint (f a) (f b) :=
  by
  rw [disjoint_iff_inf_le, ← f.map_inf, ← f.map_bot]
  exact f.monotone ha.le_bot
#align disjoint.map_order_iso Disjoint.map_orderIso

/- warning: codisjoint.map_order_iso -> Codisjoint.map_orderIso is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} α] [_inst_2 : OrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))] [_inst_3 : SemilatticeSup.{u2} β] [_inst_4 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))] {a : α} {b : α} (f : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))), (Codisjoint.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1) _inst_2 a b) -> (Codisjoint.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3) _inst_4 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))))) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))))) f b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} α] [_inst_2 : OrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)))] [_inst_3 : SemilatticeSup.{u1} β] [_inst_4 : OrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3)))] {a : α} {b : α} (f : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3)))), (Codisjoint.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1) _inst_2 a b) -> (Codisjoint.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (SemilatticeSup.toPartialOrder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) _inst_3) _inst_4 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) b))
Case conversion may be inaccurate. Consider using '#align codisjoint.map_order_iso Codisjoint.map_orderIsoₓ'. -/
/-- Note that this goal could also be stated `(codisjoint on f) a b` -/
theorem Codisjoint.map_orderIso [SemilatticeSup α] [OrderTop α] [SemilatticeSup β] [OrderTop β]
    {a b : α} (f : α ≃o β) (ha : Codisjoint a b) : Codisjoint (f a) (f b) :=
  by
  rw [codisjoint_iff_le_sup, ← f.map_sup, ← f.map_top]
  exact f.monotone ha.top_le
#align codisjoint.map_order_iso Codisjoint.map_orderIso

/- warning: disjoint_map_order_iso_iff -> disjoint_map_orderIso_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} α] [_inst_2 : OrderBot.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))] [_inst_3 : SemilatticeInf.{u2} β] [_inst_4 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))] {a : α} {b : α} (f : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))), Iff (Disjoint.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3) _inst_4 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))))) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))))) f b)) (Disjoint.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1) _inst_2 a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} α] [_inst_2 : OrderBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1)))] [_inst_3 : SemilatticeInf.{u1} β] [_inst_4 : OrderBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3)))] {a : α} {b : α} (f : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3)))), Iff (Disjoint.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (SemilatticeInf.toPartialOrder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) _inst_3) _inst_4 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) b)) (Disjoint.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1) _inst_2 a b)
Case conversion may be inaccurate. Consider using '#align disjoint_map_order_iso_iff disjoint_map_orderIso_iffₓ'. -/
@[simp]
theorem disjoint_map_orderIso_iff [SemilatticeInf α] [OrderBot α] [SemilatticeInf β] [OrderBot β]
    {a b : α} (f : α ≃o β) : Disjoint (f a) (f b) ↔ Disjoint a b :=
  ⟨fun h => f.symm_apply_apply a ▸ f.symm_apply_apply b ▸ h.map_order_iso f.symm, fun h =>
    h.map_order_iso f⟩
#align disjoint_map_order_iso_iff disjoint_map_orderIso_iff

/- warning: codisjoint_map_order_iso_iff -> codisjoint_map_orderIso_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} α] [_inst_2 : OrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))] [_inst_3 : SemilatticeSup.{u2} β] [_inst_4 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))] {a : α} {b : α} (f : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))), Iff (Codisjoint.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3) _inst_4 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))))) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))))) f b)) (Codisjoint.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1) _inst_2 a b)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} α] [_inst_2 : OrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)))] [_inst_3 : SemilatticeSup.{u1} β] [_inst_4 : OrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3)))] {a : α} {b : α} (f : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3)))), Iff (Codisjoint.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) (SemilatticeSup.toPartialOrder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) a) _inst_3) _inst_4 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) b)) (Codisjoint.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1) _inst_2 a b)
Case conversion may be inaccurate. Consider using '#align codisjoint_map_order_iso_iff codisjoint_map_orderIso_iffₓ'. -/
@[simp]
theorem codisjoint_map_orderIso_iff [SemilatticeSup α] [OrderTop α] [SemilatticeSup β] [OrderTop β]
    {a b : α} (f : α ≃o β) : Codisjoint (f a) (f b) ↔ Codisjoint a b :=
  ⟨fun h => f.symm_apply_apply a ▸ f.symm_apply_apply b ▸ h.map_order_iso f.symm, fun h =>
    h.map_order_iso f⟩
#align codisjoint_map_order_iso_iff codisjoint_map_orderIso_iff

namespace WithBot

/- warning: with_bot.to_dual_top_equiv -> WithBot.toDualTopEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], OrderIso.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], OrderIso.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1))
Case conversion may be inaccurate. Consider using '#align with_bot.to_dual_top_equiv WithBot.toDualTopEquivₓ'. -/
/-- Taking the dual then adding `⊥` is the same as adding `⊤` then taking the dual.
This is the order iso form of `with_bot.of_dual`, as proven by `coe_to_dual_top_equiv_eq`.
-/
protected def toDualTopEquiv [LE α] : WithBot αᵒᵈ ≃o (WithTop α)ᵒᵈ :=
  OrderIso.refl _
#align with_bot.to_dual_top_equiv WithBot.toDualTopEquiv

/- warning: with_bot.to_dual_top_equiv_coe -> WithBot.toDualTopEquiv_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} (OrderDual.{u1} (WithTop.{u1} α)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)))) => (WithBot.{u1} (OrderDual.{u1} α)) -> (OrderDual.{u1} (WithTop.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)))) (WithBot.toDualTopEquiv.{u1} α _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (OrderDual.{u1} α) (WithBot.{u1} (OrderDual.{u1} α)) (HasLiftT.mk.{succ u1, succ u1} (OrderDual.{u1} α) (WithBot.{u1} (OrderDual.{u1} α)) (CoeTCₓ.coe.{succ u1, succ u1} (OrderDual.{u1} α) (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasCoeT.{u1} (OrderDual.{u1} α)))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) => α -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} α (OrderDual.{u1} α)) (OrderDual.toDual.{u1} α) a))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (fun (_x : Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) => (WithTop.{u1} α) -> (OrderDual.{u1} (WithTop.{u1} α))) (Equiv.hasCoeToFun.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (OrderDual.toDual.{u1} (WithTop.{u1} α)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (WithTop.{u1} α) (HasLiftT.mk.{succ u1, succ u1} α (WithTop.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} α (WithTop.{u1} α) (WithTop.hasCoeT.{u1} α))) a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithTop.{u1} α)) (WithBot.some.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (fun (a : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} α (OrderDual.{u1} α)))) (OrderDual.toDual.{u1} α) a))) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α))) (WithBot.{u1} (OrderDual.{u1} α)) (fun (_x : WithBot.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithTop.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α))) (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithBot.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithBot.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithTop.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithTop.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithBot.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithBot.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithTop.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithTop.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (WithBot.toDualTopEquiv.{u1} α _inst_1))) (WithBot.some.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} α (OrderDual.{u1} α)))) (OrderDual.toDual.{u1} α) a))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (fun (_x : WithTop.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} α) => OrderDual.{u1} (WithTop.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))))) (OrderDual.toDual.{u1} (WithTop.{u1} α)) (WithTop.some.{u1} α a))
Case conversion may be inaccurate. Consider using '#align with_bot.to_dual_top_equiv_coe WithBot.toDualTopEquiv_coeₓ'. -/
@[simp]
theorem toDualTopEquiv_coe [LE α] (a : α) :
    WithBot.toDualTopEquiv ↑(toDual a) = toDual (a : WithTop α) :=
  rfl
#align with_bot.to_dual_top_equiv_coe WithBot.toDualTopEquiv_coe

/- warning: with_bot.to_dual_top_equiv_symm_coe -> WithBot.toDualTopEquiv_symm_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) => (OrderDual.{u1} (WithTop.{u1} α)) -> (WithBot.{u1} (OrderDual.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) (OrderIso.symm.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)) (WithBot.toDualTopEquiv.{u1} α _inst_1)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (fun (_x : Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) => (WithTop.{u1} α) -> (OrderDual.{u1} (WithTop.{u1} α))) (Equiv.hasCoeToFun.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (OrderDual.toDual.{u1} (WithTop.{u1} α)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (WithTop.{u1} α) (HasLiftT.mk.{succ u1, succ u1} α (WithTop.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} α (WithTop.{u1} α) (WithTop.hasCoeT.{u1} α))) a))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (OrderDual.{u1} α) (WithBot.{u1} (OrderDual.{u1} α)) (HasLiftT.mk.{succ u1, succ u1} (OrderDual.{u1} α) (WithBot.{u1} (OrderDual.{u1} α)) (CoeTCₓ.coe.{succ u1, succ u1} (OrderDual.{u1} α) (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasCoeT.{u1} (OrderDual.{u1} α)))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) => α -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} α (OrderDual.{u1} α)) (OrderDual.toDual.{u1} α) a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (WithTop.{u1} α)) => WithBot.{u1} (OrderDual.{u1} α)) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (fun (a : WithTop.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} α) => OrderDual.{u1} (WithTop.{u1} α)) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))))) (OrderDual.toDual.{u1} (WithTop.{u1} α)) (WithTop.some.{u1} α a))) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} (WithTop.{u1} α)) (fun (_x : OrderDual.{u1} (WithTop.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (WithTop.{u1} α)) => WithBot.{u1} (OrderDual.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (WithTop.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (WithTop.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithBot.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithBot.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (WithTop.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (WithTop.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithBot.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithBot.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) (WithBot.toDualTopEquiv.{u1} α _inst_1)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (fun (_x : WithTop.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} α) => OrderDual.{u1} (WithTop.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))))) (OrderDual.toDual.{u1} (WithTop.{u1} α)) (WithTop.some.{u1} α a))) (WithBot.some.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} α (OrderDual.{u1} α)))) (OrderDual.toDual.{u1} α) a))
Case conversion may be inaccurate. Consider using '#align with_bot.to_dual_top_equiv_symm_coe WithBot.toDualTopEquiv_symm_coeₓ'. -/
@[simp]
theorem toDualTopEquiv_symm_coe [LE α] (a : α) :
    WithBot.toDualTopEquiv.symm (toDual (a : WithTop α)) = ↑(toDual a) :=
  rfl
#align with_bot.to_dual_top_equiv_symm_coe WithBot.toDualTopEquiv_symm_coe

/- warning: with_bot.to_dual_top_equiv_bot -> WithBot.toDualTopEquiv_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} (OrderDual.{u1} (WithTop.{u1} α)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)))) => (WithBot.{u1} (OrderDual.{u1} α)) -> (OrderDual.{u1} (WithTop.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)))) (WithBot.toDualTopEquiv.{u1} α _inst_1) (Bot.bot.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasBot.{u1} (OrderDual.{u1} α)))) (Bot.bot.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasBot.{u1} (WithTop.{u1} α) (WithTop.hasTop.{u1} α)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithTop.{u1} α)) (Bot.bot.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.bot.{u1} (OrderDual.{u1} α)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α))) (WithBot.{u1} (OrderDual.{u1} α)) (fun (_x : WithBot.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithTop.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α))) (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithBot.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithBot.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithTop.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithTop.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithBot.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithBot.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithTop.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithTop.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (WithBot.toDualTopEquiv.{u1} α _inst_1))) (Bot.bot.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.bot.{u1} (OrderDual.{u1} α)))) (Bot.bot.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithTop.{u1} α)) (Bot.bot.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.bot.{u1} (OrderDual.{u1} α)))) (OrderDual.bot.{u1} (WithTop.{u1} α) (WithTop.top.{u1} α)))
Case conversion may be inaccurate. Consider using '#align with_bot.to_dual_top_equiv_bot WithBot.toDualTopEquiv_botₓ'. -/
@[simp]
theorem toDualTopEquiv_bot [LE α] : WithBot.toDualTopEquiv (⊥ : WithBot αᵒᵈ) = ⊥ :=
  rfl
#align with_bot.to_dual_top_equiv_bot WithBot.toDualTopEquiv_bot

/- warning: with_bot.to_dual_top_equiv_symm_bot -> WithBot.toDualTopEquiv_symm_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) => (OrderDual.{u1} (WithTop.{u1} α)) -> (WithBot.{u1} (OrderDual.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) (OrderIso.symm.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)) (WithBot.toDualTopEquiv.{u1} α _inst_1)) (Bot.bot.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasBot.{u1} (WithTop.{u1} α) (WithTop.hasTop.{u1} α)))) (Bot.bot.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasBot.{u1} (OrderDual.{u1} α)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (WithTop.{u1} α)) => WithBot.{u1} (OrderDual.{u1} α)) (Bot.bot.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.bot.{u1} (WithTop.{u1} α) (WithTop.top.{u1} α)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} (WithTop.{u1} α)) (fun (_x : OrderDual.{u1} (WithTop.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (WithTop.{u1} α)) => WithBot.{u1} (OrderDual.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (WithTop.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (WithTop.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithBot.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithBot.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (WithTop.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (WithTop.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithBot.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithBot.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) (WithBot.toDualTopEquiv.{u1} α _inst_1)))) (Bot.bot.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.bot.{u1} (WithTop.{u1} α) (WithTop.top.{u1} α)))) (Bot.bot.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (WithTop.{u1} α)) => WithBot.{u1} (OrderDual.{u1} α)) (Bot.bot.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.bot.{u1} (WithTop.{u1} α) (WithTop.top.{u1} α)))) (WithBot.bot.{u1} (OrderDual.{u1} α)))
Case conversion may be inaccurate. Consider using '#align with_bot.to_dual_top_equiv_symm_bot WithBot.toDualTopEquiv_symm_botₓ'. -/
@[simp]
theorem toDualTopEquiv_symm_bot [LE α] : WithBot.toDualTopEquiv.symm (⊥ : (WithTop α)ᵒᵈ) = ⊥ :=
  rfl
#align with_bot.to_dual_top_equiv_symm_bot WithBot.toDualTopEquiv_symm_bot

/- warning: with_bot.coe_to_dual_top_equiv_eq -> WithBot.coe_toDualTopEquiv_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} ((fun (_x : RelIso.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)))) => (WithBot.{u1} (OrderDual.{u1} α)) -> (OrderDual.{u1} (WithTop.{u1} α))) (WithBot.toDualTopEquiv.{u1} α _inst_1)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)))) => (WithBot.{u1} (OrderDual.{u1} α)) -> (OrderDual.{u1} (WithTop.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.hasLe.{u1} (WithTop.{u1} α) (WithTop.hasLe.{u1} α _inst_1)))) (WithBot.toDualTopEquiv.{u1} α _inst_1)) (Function.comp.{succ u1, succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (fun (_x : Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) => (WithTop.{u1} α) -> (OrderDual.{u1} (WithTop.{u1} α))) (Equiv.hasCoeToFun.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (OrderDual.toDual.{u1} (WithTop.{u1} α))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α)) => (WithBot.{u1} (OrderDual.{u1} α)) -> (WithTop.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α)) (WithBot.ofDual.{u1} α)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} (forall (a : WithBot.{u1} (OrderDual.{u1} α)), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithTop.{u1} α)) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α))) (WithBot.{u1} (OrderDual.{u1} α)) (fun (_x : WithBot.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithTop.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α))) (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithBot.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithBot.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithTop.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithTop.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (WithBot.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithTop.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithBot.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithBot.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithBot.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithTop.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithTop.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithTop.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithTop.{u1} α) (WithTop.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (WithBot.toDualTopEquiv.{u1} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α)) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (fun (_x : WithTop.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} α) => OrderDual.{u1} (WithTop.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))) (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (WithTop.{u1} α) (OrderDual.{u1} (WithTop.{u1} α))))) (OrderDual.toDual.{u1} (WithTop.{u1} α))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (fun (_x : WithBot.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} (OrderDual.{u1} α)) => WithTop.{u1} α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α)) (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (WithBot.{u1} (OrderDual.{u1} α)) (WithTop.{u1} α)))) (WithBot.ofDual.{u1} α)))
Case conversion may be inaccurate. Consider using '#align with_bot.coe_to_dual_top_equiv_eq WithBot.coe_toDualTopEquiv_eqₓ'. -/
theorem coe_toDualTopEquiv_eq [LE α] :
    (WithBot.toDualTopEquiv : WithBot αᵒᵈ → (WithTop α)ᵒᵈ) = to_dual ∘ WithBot.ofDual :=
  funext fun _ => rfl
#align with_bot.coe_to_dual_top_equiv_eq WithBot.coe_toDualTopEquiv_eq

end WithBot

namespace WithTop

/- warning: with_top.to_dual_bot_equiv -> WithTop.toDualBotEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], OrderIso.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], OrderIso.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1))
Case conversion may be inaccurate. Consider using '#align with_top.to_dual_bot_equiv WithTop.toDualBotEquivₓ'. -/
/-- Taking the dual then adding `⊤` is the same as adding `⊥` then taking the dual.
This is the order iso form of `with_top.of_dual`, as proven by `coe_to_dual_bot_equiv_eq`. -/
protected def toDualBotEquiv [LE α] : WithTop αᵒᵈ ≃o (WithBot α)ᵒᵈ :=
  OrderIso.refl _
#align with_top.to_dual_bot_equiv WithTop.toDualBotEquiv

/- warning: with_top.to_dual_bot_equiv_coe -> WithTop.toDualBotEquiv_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} (OrderDual.{u1} (WithBot.{u1} α)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)))) => (WithTop.{u1} (OrderDual.{u1} α)) -> (OrderDual.{u1} (WithBot.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)))) (WithTop.toDualBotEquiv.{u1} α _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (OrderDual.{u1} α) (WithTop.{u1} (OrderDual.{u1} α)) (HasLiftT.mk.{succ u1, succ u1} (OrderDual.{u1} α) (WithTop.{u1} (OrderDual.{u1} α)) (CoeTCₓ.coe.{succ u1, succ u1} (OrderDual.{u1} α) (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasCoeT.{u1} (OrderDual.{u1} α)))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) => α -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} α (OrderDual.{u1} α)) (OrderDual.toDual.{u1} α) a))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (fun (_x : Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) => (WithBot.{u1} α) -> (OrderDual.{u1} (WithBot.{u1} α))) (Equiv.hasCoeToFun.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (OrderDual.toDual.{u1} (WithBot.{u1} α)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (WithBot.{u1} α) (HasLiftT.mk.{succ u1, succ u1} α (WithBot.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} α (WithBot.{u1} α) (WithBot.hasCoeT.{u1} α))) a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithBot.{u1} α)) (WithTop.some.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (fun (a : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} α (OrderDual.{u1} α)))) (OrderDual.toDual.{u1} α) a))) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α))) (WithTop.{u1} (OrderDual.{u1} α)) (fun (_x : WithTop.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithBot.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α))) (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithTop.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithTop.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithBot.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithBot.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithTop.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithTop.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithBot.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithBot.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (WithTop.toDualBotEquiv.{u1} α _inst_1))) (WithTop.some.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} α (OrderDual.{u1} α)))) (OrderDual.toDual.{u1} α) a))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (fun (_x : WithBot.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} α) => OrderDual.{u1} (WithBot.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))))) (OrderDual.toDual.{u1} (WithBot.{u1} α)) (WithBot.some.{u1} α a))
Case conversion may be inaccurate. Consider using '#align with_top.to_dual_bot_equiv_coe WithTop.toDualBotEquiv_coeₓ'. -/
@[simp]
theorem toDualBotEquiv_coe [LE α] (a : α) :
    WithTop.toDualBotEquiv ↑(toDual a) = toDual (a : WithBot α) :=
  rfl
#align with_top.to_dual_bot_equiv_coe WithTop.toDualBotEquiv_coe

/- warning: with_top.to_dual_bot_equiv_symm_coe -> WithTop.toDualBotEquiv_symm_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) => (OrderDual.{u1} (WithBot.{u1} α)) -> (WithTop.{u1} (OrderDual.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) (OrderIso.symm.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)) (WithTop.toDualBotEquiv.{u1} α _inst_1)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (fun (_x : Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) => (WithBot.{u1} α) -> (OrderDual.{u1} (WithBot.{u1} α))) (Equiv.hasCoeToFun.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (OrderDual.toDual.{u1} (WithBot.{u1} α)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (WithBot.{u1} α) (HasLiftT.mk.{succ u1, succ u1} α (WithBot.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} α (WithBot.{u1} α) (WithBot.hasCoeT.{u1} α))) a))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (OrderDual.{u1} α) (WithTop.{u1} (OrderDual.{u1} α)) (HasLiftT.mk.{succ u1, succ u1} (OrderDual.{u1} α) (WithTop.{u1} (OrderDual.{u1} α)) (CoeTCₓ.coe.{succ u1, succ u1} (OrderDual.{u1} α) (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasCoeT.{u1} (OrderDual.{u1} α)))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) => α -> (OrderDual.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} α (OrderDual.{u1} α)) (OrderDual.toDual.{u1} α) a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (WithBot.{u1} α)) => WithTop.{u1} (OrderDual.{u1} α)) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (fun (a : WithBot.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} α) => OrderDual.{u1} (WithBot.{u1} α)) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))))) (OrderDual.toDual.{u1} (WithBot.{u1} α)) (WithBot.some.{u1} α a))) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} (WithBot.{u1} α)) (fun (_x : OrderDual.{u1} (WithBot.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (WithBot.{u1} α)) => WithTop.{u1} (OrderDual.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (WithBot.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (WithBot.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithTop.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithTop.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (WithBot.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (WithBot.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithTop.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithTop.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) (WithTop.toDualBotEquiv.{u1} α _inst_1)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (fun (_x : WithBot.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} α) => OrderDual.{u1} (WithBot.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))))) (OrderDual.toDual.{u1} (WithBot.{u1} α)) (WithBot.some.{u1} α a))) (WithTop.some.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => OrderDual.{u1} α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} α (OrderDual.{u1} α)) α (OrderDual.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} α (OrderDual.{u1} α)))) (OrderDual.toDual.{u1} α) a))
Case conversion may be inaccurate. Consider using '#align with_top.to_dual_bot_equiv_symm_coe WithTop.toDualBotEquiv_symm_coeₓ'. -/
@[simp]
theorem toDualBotEquiv_symm_coe [LE α] (a : α) :
    WithTop.toDualBotEquiv.symm (toDual (a : WithBot α)) = ↑(toDual a) :=
  rfl
#align with_top.to_dual_bot_equiv_symm_coe WithTop.toDualBotEquiv_symm_coe

/- warning: with_top.to_dual_bot_equiv_top -> WithTop.toDualBotEquiv_top is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} (OrderDual.{u1} (WithBot.{u1} α)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)))) => (WithTop.{u1} (OrderDual.{u1} α)) -> (OrderDual.{u1} (WithBot.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)))) (WithTop.toDualBotEquiv.{u1} α _inst_1) (Top.top.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasTop.{u1} (OrderDual.{u1} α)))) (Top.top.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasTop.{u1} (WithBot.{u1} α) (WithBot.hasBot.{u1} α)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithBot.{u1} α)) (Top.top.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.top.{u1} (OrderDual.{u1} α)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α))) (WithTop.{u1} (OrderDual.{u1} α)) (fun (_x : WithTop.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithBot.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α))) (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithTop.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithTop.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithBot.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithBot.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithTop.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithTop.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithBot.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithBot.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (WithTop.toDualBotEquiv.{u1} α _inst_1))) (Top.top.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.top.{u1} (OrderDual.{u1} α)))) (Top.top.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithBot.{u1} α)) (Top.top.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.top.{u1} (OrderDual.{u1} α)))) (OrderDual.top.{u1} (WithBot.{u1} α) (WithBot.bot.{u1} α)))
Case conversion may be inaccurate. Consider using '#align with_top.to_dual_bot_equiv_top WithTop.toDualBotEquiv_topₓ'. -/
@[simp]
theorem toDualBotEquiv_top [LE α] : WithTop.toDualBotEquiv (⊤ : WithTop αᵒᵈ) = ⊤ :=
  rfl
#align with_top.to_dual_bot_equiv_top WithTop.toDualBotEquiv_top

/- warning: with_top.to_dual_bot_equiv_symm_top -> WithTop.toDualBotEquiv_symm_top is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) => (OrderDual.{u1} (WithBot.{u1} α)) -> (WithTop.{u1} (OrderDual.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)))) (OrderIso.symm.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)) (WithTop.toDualBotEquiv.{u1} α _inst_1)) (Top.top.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasTop.{u1} (WithBot.{u1} α) (WithBot.hasBot.{u1} α)))) (Top.top.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasTop.{u1} (OrderDual.{u1} α)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (WithBot.{u1} α)) => WithTop.{u1} (OrderDual.{u1} α)) (Top.top.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.top.{u1} (WithBot.{u1} α) (WithBot.bot.{u1} α)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} (WithBot.{u1} α)) (fun (_x : OrderDual.{u1} (WithBot.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (WithBot.{u1} α)) => WithTop.{u1} (OrderDual.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α))) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (WithBot.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (WithBot.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithTop.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithTop.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : OrderDual.{u1} (WithBot.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : OrderDual.{u1} (WithBot.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : WithTop.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : WithTop.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (OrderIso.symm.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) (WithTop.toDualBotEquiv.{u1} α _inst_1)))) (Top.top.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.top.{u1} (WithBot.{u1} α) (WithBot.bot.{u1} α)))) (Top.top.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : OrderDual.{u1} (WithBot.{u1} α)) => WithTop.{u1} (OrderDual.{u1} α)) (Top.top.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.top.{u1} (WithBot.{u1} α) (WithBot.bot.{u1} α)))) (WithTop.top.{u1} (OrderDual.{u1} α)))
Case conversion may be inaccurate. Consider using '#align with_top.to_dual_bot_equiv_symm_top WithTop.toDualBotEquiv_symm_topₓ'. -/
@[simp]
theorem toDualBotEquiv_symm_top [LE α] : WithTop.toDualBotEquiv.symm (⊤ : (WithBot α)ᵒᵈ) = ⊤ :=
  rfl
#align with_top.to_dual_bot_equiv_symm_top WithTop.toDualBotEquiv_symm_top

/- warning: with_top.coe_to_dual_bot_equiv_eq -> WithTop.coe_toDualBotEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} ((fun (_x : RelIso.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)))) => (WithTop.{u1} (OrderDual.{u1} α)) -> (OrderDual.{u1} (WithBot.{u1} α))) (WithTop.toDualBotEquiv.{u1} α _inst_1)) (coeFn.{succ u1, succ u1} (OrderIso.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1))) (fun (_x : RelIso.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)))) => (WithTop.{u1} (OrderDual.{u1} α)) -> (OrderDual.{u1} (WithBot.{u1} α))) (RelIso.hasCoeToFun.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.hasLe.{u1} (OrderDual.{u1} α) (OrderDual.hasLe.{u1} α _inst_1))) (LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.hasLe.{u1} (WithBot.{u1} α) (WithBot.hasLe.{u1} α _inst_1)))) (WithTop.toDualBotEquiv.{u1} α _inst_1)) (Function.comp.{succ u1, succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (fun (_x : Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) => (WithBot.{u1} α) -> (OrderDual.{u1} (WithBot.{u1} α))) (Equiv.hasCoeToFun.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (OrderDual.toDual.{u1} (WithBot.{u1} α))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α)) => (WithTop.{u1} (OrderDual.{u1} α)) -> (WithBot.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α)) (WithTop.ofDual.{u1} α)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α], Eq.{succ u1} (forall (a : WithTop.{u1} (OrderDual.{u1} α)), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithBot.{u1} α)) a) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α))) (WithTop.{u1} (OrderDual.{u1} α)) (fun (_x : WithTop.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} (OrderDual.{u1} α)) => OrderDual.{u1} (WithBot.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α))) (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)))) (RelEmbedding.toEmbedding.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithTop.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithTop.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithBot.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithBot.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u1, u1} (WithTop.{u1} (OrderDual.{u1} α)) (OrderDual.{u1} (WithBot.{u1} α)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : WithTop.{u1} (OrderDual.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : WithTop.{u1} (OrderDual.{u1} α)) => LE.le.{u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithTop.le.{u1} (OrderDual.{u1} α) (OrderDual.instLEOrderDual.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : OrderDual.{u1} (WithBot.{u1} α)) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : OrderDual.{u1} (WithBot.{u1} α)) => LE.le.{u1} (OrderDual.{u1} (WithBot.{u1} α)) (OrderDual.instLEOrderDual.{u1} (WithBot.{u1} α) (WithBot.le.{u1} α _inst_1)) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (WithTop.toDualBotEquiv.{u1} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α)) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (fun (_x : WithBot.{u1} α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithBot.{u1} α) => OrderDual.{u1} (WithBot.{u1} α)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))) (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (WithBot.{u1} α) (OrderDual.{u1} (WithBot.{u1} α))))) (OrderDual.toDual.{u1} (WithBot.{u1} α))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (fun (_x : WithTop.{u1} (OrderDual.{u1} α)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : WithTop.{u1} (OrderDual.{u1} α)) => WithBot.{u1} α) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α)) (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (WithTop.{u1} (OrderDual.{u1} α)) (WithBot.{u1} α)))) (WithTop.ofDual.{u1} α)))
Case conversion may be inaccurate. Consider using '#align with_top.coe_to_dual_bot_equiv_eq WithTop.coe_toDualBotEquivₓ'. -/
theorem coe_toDualBotEquiv [LE α] :
    (WithTop.toDualBotEquiv : WithTop αᵒᵈ → (WithBot α)ᵒᵈ) = to_dual ∘ WithTop.ofDual :=
  funext fun _ => rfl
#align with_top.coe_to_dual_bot_equiv_eq WithTop.coe_toDualBotEquiv

end WithTop

namespace OrderIso

variable [PartialOrder α] [PartialOrder β] [PartialOrder γ]

#print OrderIso.withTopCongr /-
/-- A version of `equiv.option_congr` for `with_top`. -/
@[simps apply]
def withTopCongr (e : α ≃o β) : WithTop α ≃o WithTop β :=
  { e.toOrderEmbedding.with_top_map with toEquiv := e.toEquiv.optionCongr }
#align order_iso.with_top_congr OrderIso.withTopCongr
-/

#print OrderIso.withTopCongr_refl /-
@[simp]
theorem withTopCongr_refl : (OrderIso.refl α).withTopCongr = OrderIso.refl _ :=
  RelIso.toEquiv_injective Equiv.optionCongr_refl
#align order_iso.with_top_congr_refl OrderIso.withTopCongr_refl
-/

/- warning: order_iso.with_top_congr_symm -> OrderIso.withTopCongr_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : PartialOrder.{u2} β] (e : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))), Eq.{max (succ u2) (succ u1)} (OrderIso.{u2, u1} (WithTop.{u2} β) (WithTop.{u1} α) (Preorder.toLE.{u2} (WithTop.{u2} β) (WithTop.preorder.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (Preorder.toLE.{u1} (WithTop.{u1} α) (WithTop.preorder.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)))) (OrderIso.symm.{u1, u2} (WithTop.{u1} α) (WithTop.{u2} β) (Preorder.toLE.{u1} (WithTop.{u1} α) (WithTop.preorder.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (Preorder.toLE.{u2} (WithTop.{u2} β) (WithTop.preorder.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (OrderIso.withTopCongr.{u1, u2} α β _inst_1 _inst_2 e)) (OrderIso.withTopCongr.{u2, u1} β α _inst_2 _inst_1 (OrderIso.symm.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) e))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : PartialOrder.{u1} β] (e : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))), Eq.{max (succ u2) (succ u1)} (OrderIso.{u1, u2} (WithTop.{u1} β) (WithTop.{u2} α) (Preorder.toLE.{u1} (WithTop.{u1} β) (WithTop.preorder.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))) (Preorder.toLE.{u2} (WithTop.{u2} α) (WithTop.preorder.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)))) (OrderIso.symm.{u2, u1} (WithTop.{u2} α) (WithTop.{u1} β) (Preorder.toLE.{u2} (WithTop.{u2} α) (WithTop.preorder.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1))) (Preorder.toLE.{u1} (WithTop.{u1} β) (WithTop.preorder.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))) (OrderIso.withTopCongr.{u2, u1} α β _inst_1 _inst_2 e)) (OrderIso.withTopCongr.{u1, u2} β α _inst_2 _inst_1 (OrderIso.symm.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) e))
Case conversion may be inaccurate. Consider using '#align order_iso.with_top_congr_symm OrderIso.withTopCongr_symmₓ'. -/
@[simp]
theorem withTopCongr_symm (e : α ≃o β) : e.withTopCongr.symm = e.symm.withTopCongr :=
  RelIso.toEquiv_injective e.toEquiv.option_congr_symm
#align order_iso.with_top_congr_symm OrderIso.withTopCongr_symm

/- warning: order_iso.with_top_congr_trans -> OrderIso.withTopCongr_trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : PartialOrder.{u2} β] [_inst_3 : PartialOrder.{u3} γ] (e₁ : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (e₂ : OrderIso.{u2, u3} β γ (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ _inst_3))), Eq.{max (succ u1) (succ u3)} (OrderIso.{u1, u3} (WithTop.{u1} α) (WithTop.{u3} γ) (Preorder.toLE.{u1} (WithTop.{u1} α) (WithTop.preorder.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (Preorder.toLE.{u3} (WithTop.{u3} γ) (WithTop.preorder.{u3} γ (PartialOrder.toPreorder.{u3} γ _inst_3)))) (OrderIso.trans.{u1, u2, u3} (WithTop.{u1} α) (WithTop.{u2} β) (WithTop.{u3} γ) (Preorder.toLE.{u1} (WithTop.{u1} α) (WithTop.preorder.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (Preorder.toLE.{u2} (WithTop.{u2} β) (WithTop.preorder.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (Preorder.toLE.{u3} (WithTop.{u3} γ) (WithTop.preorder.{u3} γ (PartialOrder.toPreorder.{u3} γ _inst_3))) (OrderIso.withTopCongr.{u1, u2} α β _inst_1 _inst_2 e₁) (OrderIso.withTopCongr.{u2, u3} β γ _inst_2 _inst_3 e₂)) (OrderIso.withTopCongr.{u1, u3} α γ _inst_1 _inst_3 (OrderIso.trans.{u1, u2, u3} α β γ (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ _inst_3)) e₁ e₂))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : PartialOrder.{u3} α] [_inst_2 : PartialOrder.{u2} β] [_inst_3 : PartialOrder.{u1} γ] (e₁ : OrderIso.{u3, u2} α β (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (e₂ : OrderIso.{u2, u1} β γ (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) (Preorder.toLE.{u1} γ (PartialOrder.toPreorder.{u1} γ _inst_3))), Eq.{max (succ u3) (succ u1)} (OrderIso.{u3, u1} (WithTop.{u3} α) (WithTop.{u1} γ) (Preorder.toLE.{u3} (WithTop.{u3} α) (WithTop.preorder.{u3} α (PartialOrder.toPreorder.{u3} α _inst_1))) (Preorder.toLE.{u1} (WithTop.{u1} γ) (WithTop.preorder.{u1} γ (PartialOrder.toPreorder.{u1} γ _inst_3)))) (OrderIso.trans.{u3, u2, u1} (WithTop.{u3} α) (WithTop.{u2} β) (WithTop.{u1} γ) (Preorder.toLE.{u3} (WithTop.{u3} α) (WithTop.preorder.{u3} α (PartialOrder.toPreorder.{u3} α _inst_1))) (Preorder.toLE.{u2} (WithTop.{u2} β) (WithTop.preorder.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (Preorder.toLE.{u1} (WithTop.{u1} γ) (WithTop.preorder.{u1} γ (PartialOrder.toPreorder.{u1} γ _inst_3))) (OrderIso.withTopCongr.{u3, u2} α β _inst_1 _inst_2 e₁) (OrderIso.withTopCongr.{u2, u1} β γ _inst_2 _inst_3 e₂)) (OrderIso.withTopCongr.{u3, u1} α γ _inst_1 _inst_3 (OrderIso.trans.{u3, u2, u1} α β γ (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) (Preorder.toLE.{u1} γ (PartialOrder.toPreorder.{u1} γ _inst_3)) e₁ e₂))
Case conversion may be inaccurate. Consider using '#align order_iso.with_top_congr_trans OrderIso.withTopCongr_transₓ'. -/
@[simp]
theorem withTopCongr_trans (e₁ : α ≃o β) (e₂ : β ≃o γ) :
    e₁.withTopCongr.trans e₂.withTopCongr = (e₁.trans e₂).withTopCongr :=
  RelIso.toEquiv_injective <| e₁.toEquiv.option_congr_trans e₂.toEquiv
#align order_iso.with_top_congr_trans OrderIso.withTopCongr_trans

#print OrderIso.withBotCongr /-
/-- A version of `equiv.option_congr` for `with_bot`. -/
@[simps apply]
def withBotCongr (e : α ≃o β) : WithBot α ≃o WithBot β :=
  { e.toOrderEmbedding.with_bot_map with toEquiv := e.toEquiv.optionCongr }
#align order_iso.with_bot_congr OrderIso.withBotCongr
-/

#print OrderIso.withBotCongr_refl /-
@[simp]
theorem withBotCongr_refl : (OrderIso.refl α).withBotCongr = OrderIso.refl _ :=
  RelIso.toEquiv_injective Equiv.optionCongr_refl
#align order_iso.with_bot_congr_refl OrderIso.withBotCongr_refl
-/

/- warning: order_iso.with_bot_congr_symm -> OrderIso.withBotCongr_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : PartialOrder.{u2} β] (e : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))), Eq.{max (succ u2) (succ u1)} (OrderIso.{u2, u1} (WithBot.{u2} β) (WithBot.{u1} α) (Preorder.toLE.{u2} (WithBot.{u2} β) (WithBot.preorder.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (Preorder.toLE.{u1} (WithBot.{u1} α) (WithBot.preorder.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)))) (OrderIso.symm.{u1, u2} (WithBot.{u1} α) (WithBot.{u2} β) (Preorder.toLE.{u1} (WithBot.{u1} α) (WithBot.preorder.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (Preorder.toLE.{u2} (WithBot.{u2} β) (WithBot.preorder.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (OrderIso.withBotCongr.{u1, u2} α β _inst_1 _inst_2 e)) (OrderIso.withBotCongr.{u2, u1} β α _inst_2 _inst_1 (OrderIso.symm.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) e))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : PartialOrder.{u1} β] (e : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))), Eq.{max (succ u2) (succ u1)} (OrderIso.{u1, u2} (WithBot.{u1} β) (WithBot.{u2} α) (Preorder.toLE.{u1} (WithBot.{u1} β) (WithBot.preorder.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))) (Preorder.toLE.{u2} (WithBot.{u2} α) (WithBot.preorder.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)))) (OrderIso.symm.{u2, u1} (WithBot.{u2} α) (WithBot.{u1} β) (Preorder.toLE.{u2} (WithBot.{u2} α) (WithBot.preorder.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1))) (Preorder.toLE.{u1} (WithBot.{u1} β) (WithBot.preorder.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2))) (OrderIso.withBotCongr.{u2, u1} α β _inst_1 _inst_2 e)) (OrderIso.withBotCongr.{u1, u2} β α _inst_2 _inst_1 (OrderIso.symm.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β _inst_2)) e))
Case conversion may be inaccurate. Consider using '#align order_iso.with_bot_congr_symm OrderIso.withBotCongr_symmₓ'. -/
@[simp]
theorem withBotCongr_symm (e : α ≃o β) : e.withBotCongr.symm = e.symm.withBotCongr :=
  RelIso.toEquiv_injective e.toEquiv.option_congr_symm
#align order_iso.with_bot_congr_symm OrderIso.withBotCongr_symm

/- warning: order_iso.with_bot_congr_trans -> OrderIso.withBotCongr_trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : PartialOrder.{u2} β] [_inst_3 : PartialOrder.{u3} γ] (e₁ : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (e₂ : OrderIso.{u2, u3} β γ (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ _inst_3))), Eq.{max (succ u1) (succ u3)} (OrderIso.{u1, u3} (WithBot.{u1} α) (WithBot.{u3} γ) (Preorder.toLE.{u1} (WithBot.{u1} α) (WithBot.preorder.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (Preorder.toLE.{u3} (WithBot.{u3} γ) (WithBot.preorder.{u3} γ (PartialOrder.toPreorder.{u3} γ _inst_3)))) (OrderIso.trans.{u1, u2, u3} (WithBot.{u1} α) (WithBot.{u2} β) (WithBot.{u3} γ) (Preorder.toLE.{u1} (WithBot.{u1} α) (WithBot.preorder.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))) (Preorder.toLE.{u2} (WithBot.{u2} β) (WithBot.preorder.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (Preorder.toLE.{u3} (WithBot.{u3} γ) (WithBot.preorder.{u3} γ (PartialOrder.toPreorder.{u3} γ _inst_3))) (OrderIso.withBotCongr.{u1, u2} α β _inst_1 _inst_2 e₁) (OrderIso.withBotCongr.{u2, u3} β γ _inst_2 _inst_3 e₂)) (OrderIso.withBotCongr.{u1, u3} α γ _inst_1 _inst_3 (OrderIso.trans.{u1, u2, u3} α β γ (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ _inst_3)) e₁ e₂))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : PartialOrder.{u3} α] [_inst_2 : PartialOrder.{u2} β] [_inst_3 : PartialOrder.{u1} γ] (e₁ : OrderIso.{u3, u2} α β (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (e₂ : OrderIso.{u2, u1} β γ (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) (Preorder.toLE.{u1} γ (PartialOrder.toPreorder.{u1} γ _inst_3))), Eq.{max (succ u3) (succ u1)} (OrderIso.{u3, u1} (WithBot.{u3} α) (WithBot.{u1} γ) (Preorder.toLE.{u3} (WithBot.{u3} α) (WithBot.preorder.{u3} α (PartialOrder.toPreorder.{u3} α _inst_1))) (Preorder.toLE.{u1} (WithBot.{u1} γ) (WithBot.preorder.{u1} γ (PartialOrder.toPreorder.{u1} γ _inst_3)))) (OrderIso.trans.{u3, u2, u1} (WithBot.{u3} α) (WithBot.{u2} β) (WithBot.{u1} γ) (Preorder.toLE.{u3} (WithBot.{u3} α) (WithBot.preorder.{u3} α (PartialOrder.toPreorder.{u3} α _inst_1))) (Preorder.toLE.{u2} (WithBot.{u2} β) (WithBot.preorder.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2))) (Preorder.toLE.{u1} (WithBot.{u1} γ) (WithBot.preorder.{u1} γ (PartialOrder.toPreorder.{u1} γ _inst_3))) (OrderIso.withBotCongr.{u3, u2} α β _inst_1 _inst_2 e₁) (OrderIso.withBotCongr.{u2, u1} β γ _inst_2 _inst_3 e₂)) (OrderIso.withBotCongr.{u3, u1} α γ _inst_1 _inst_3 (OrderIso.trans.{u3, u2, u1} α β γ (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α _inst_1)) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_2)) (Preorder.toLE.{u1} γ (PartialOrder.toPreorder.{u1} γ _inst_3)) e₁ e₂))
Case conversion may be inaccurate. Consider using '#align order_iso.with_bot_congr_trans OrderIso.withBotCongr_transₓ'. -/
@[simp]
theorem withBotCongr_trans (e₁ : α ≃o β) (e₂ : β ≃o γ) :
    e₁.withBotCongr.trans e₂.withBotCongr = (e₁.trans e₂).withBotCongr :=
  RelIso.toEquiv_injective <| e₁.toEquiv.option_congr_trans e₂.toEquiv
#align order_iso.with_bot_congr_trans OrderIso.withBotCongr_trans

end OrderIso

section BoundedOrder

variable [Lattice α] [Lattice β] [BoundedOrder α] [BoundedOrder β] (f : α ≃o β)

include f

/- warning: order_iso.is_compl -> OrderIso.isCompl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] (f : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))) {x : α} {y : α}, (IsCompl.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) _inst_3 x y) -> (IsCompl.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) _inst_4 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))))) f y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] [_inst_3 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_4 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))] (f : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))) {x : α} {y : α}, (IsCompl.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) _inst_3 x y) -> (IsCompl.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (SemilatticeInf.toPartialOrder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (Lattice.toSemilatticeInf.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) _inst_2)) _inst_4 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) y))
Case conversion may be inaccurate. Consider using '#align order_iso.is_compl OrderIso.isComplₓ'. -/
theorem OrderIso.isCompl {x y : α} (h : IsCompl x y) : IsCompl (f x) (f y) :=
  ⟨h.1.map_order_iso _, h.2.map_order_iso _⟩
#align order_iso.is_compl OrderIso.isCompl

/- warning: order_iso.is_compl_iff -> OrderIso.isCompl_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] (f : OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))) {x : α} {y : α}, Iff (IsCompl.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) _inst_3 x y) (IsCompl.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) _inst_4 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))))) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))) (LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))))) f y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] [_inst_3 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_4 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))] (f : OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))) {x : α} {y : α}, Iff (IsCompl.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) _inst_3 x y) (IsCompl.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (SemilatticeInf.toPartialOrder.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) (Lattice.toSemilatticeInf.{u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) x) _inst_2)) _inst_4 (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) (RelEmbedding.toEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) (RelIso.toRelEmbedding.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1411 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1413 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) x._@.Mathlib.Order.Hom.Basic._hyg.1411 x._@.Mathlib.Order.Hom.Basic._hyg.1413) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1426 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1428 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) x._@.Mathlib.Order.Hom.Basic._hyg.1426 x._@.Mathlib.Order.Hom.Basic._hyg.1428) f)) y))
Case conversion may be inaccurate. Consider using '#align order_iso.is_compl_iff OrderIso.isCompl_iffₓ'. -/
theorem OrderIso.isCompl_iff {x y : α} : IsCompl x y ↔ IsCompl (f x) (f y) :=
  ⟨f.IsCompl, fun h => f.symm_apply_apply x ▸ f.symm_apply_apply y ▸ f.symm.IsCompl h⟩
#align order_iso.is_compl_iff OrderIso.isCompl_iff

/- warning: order_iso.complemented_lattice -> OrderIso.complementedLattice is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))], (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))) -> (forall [_inst_5 : ComplementedLattice.{u1} α _inst_1 _inst_3], ComplementedLattice.{u2} β _inst_2 _inst_4)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] [_inst_3 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_4 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))], (OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))) -> (forall [_inst_5 : ComplementedLattice.{u2} α _inst_1 _inst_3], ComplementedLattice.{u1} β _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align order_iso.complemented_lattice OrderIso.complementedLatticeₓ'. -/
theorem OrderIso.complementedLattice [ComplementedLattice α] : ComplementedLattice β :=
  ⟨fun x => by
    obtain ⟨y, hy⟩ := exists_is_compl (f.symm x)
    rw [← f.symm_apply_apply y] at hy
    refine' ⟨f y, f.symm.is_compl_iff.2 hy⟩⟩
#align order_iso.complemented_lattice OrderIso.complementedLattice

/- warning: order_iso.complemented_lattice_iff -> OrderIso.complementedLattice_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))], (OrderIso.{u1, u2} α β (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))) -> (Iff (ComplementedLattice.{u1} α _inst_1 _inst_3) (ComplementedLattice.{u2} β _inst_2 _inst_4))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] [_inst_3 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_4 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))], (OrderIso.{u2, u1} α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))) -> (Iff (ComplementedLattice.{u2} α _inst_1 _inst_3) (ComplementedLattice.{u1} β _inst_2 _inst_4))
Case conversion may be inaccurate. Consider using '#align order_iso.complemented_lattice_iff OrderIso.complementedLattice_iffₓ'. -/
theorem OrderIso.complementedLattice_iff : ComplementedLattice α ↔ ComplementedLattice β :=
  ⟨by
    intro
    exact f.complemented_lattice, by
    intro
    exact f.symm.complemented_lattice⟩
#align order_iso.complemented_lattice_iff OrderIso.complementedLattice_iff

end BoundedOrder

end LatticeIsos

-- Developments relating order homs and sets belong in `order.hom.set` or later.
assert_not_exists Set.range

