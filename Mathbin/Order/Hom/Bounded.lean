/-
Copyright (c) 2022 Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies

! This file was ported from Lean 3 source module order.hom.bounded
! leanprover-community/mathlib commit 1f0096e6caa61e9c849ec2adbd227e960e9dff58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Order.Hom.Basic
import Mathbin.Order.BoundedOrder

/-!
# Bounded order homomorphisms

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines (bounded) order homomorphisms.

We use the `fun_like` design, so each type of morphisms has a companion typeclass which is meant to
be satisfied by itself and all stricter types.

## Types of morphisms

* `top_hom`: Maps which preserve `⊤`.
* `bot_hom`: Maps which preserve `⊥`.
* `bounded_order_hom`: Bounded order homomorphisms. Monotone maps which preserve `⊤` and `⊥`.

## Typeclasses

* `top_hom_class`
* `bot_hom_class`
* `bounded_order_hom_class`
-/


open Function OrderDual

variable {F α β γ δ : Type _}

#print TopHom /-
/-- The type of `⊤`-preserving functions from `α` to `β`. -/
structure TopHom (α β : Type _) [Top α] [Top β] where
  toFun : α → β
  map_top' : to_fun ⊤ = ⊤
#align top_hom TopHom
-/

#print BotHom /-
/-- The type of `⊥`-preserving functions from `α` to `β`. -/
structure BotHom (α β : Type _) [Bot α] [Bot β] where
  toFun : α → β
  map_bot' : to_fun ⊥ = ⊥
#align bot_hom BotHom
-/

#print BoundedOrderHom /-
/-- The type of bounded order homomorphisms from `α` to `β`. -/
structure BoundedOrderHom (α β : Type _) [Preorder α] [Preorder β] [BoundedOrder α]
  [BoundedOrder β] extends OrderHom α β where
  map_top' : to_fun ⊤ = ⊤
  map_bot' : to_fun ⊥ = ⊥
#align bounded_order_hom BoundedOrderHom
-/

section

#print TopHomClass /-
/-- `top_hom_class F α β` states that `F` is a type of `⊤`-preserving morphisms.

You should extend this class when you extend `top_hom`. -/
class TopHomClass (F : Type _) (α β : outParam <| Type _) [Top α] [Top β] extends
  FunLike F α fun _ => β where
  map_top (f : F) : f ⊤ = ⊤
#align top_hom_class TopHomClass
-/

#print BotHomClass /-
/-- `bot_hom_class F α β` states that `F` is a type of `⊥`-preserving morphisms.

You should extend this class when you extend `bot_hom`. -/
class BotHomClass (F : Type _) (α β : outParam <| Type _) [Bot α] [Bot β] extends
  FunLike F α fun _ => β where
  map_bot (f : F) : f ⊥ = ⊥
#align bot_hom_class BotHomClass
-/

#print BoundedOrderHomClass /-
/-- `bounded_order_hom_class F α β` states that `F` is a type of bounded order morphisms.

You should extend this class when you extend `bounded_order_hom`. -/
class BoundedOrderHomClass (F : Type _) (α β : outParam <| Type _) [LE α] [LE β] [BoundedOrder α]
  [BoundedOrder β] extends RelHomClass F ((· ≤ ·) : α → α → Prop) ((· ≤ ·) : β → β → Prop) where
  map_top (f : F) : f ⊤ = ⊤
  map_bot (f : F) : f ⊥ = ⊥
#align bounded_order_hom_class BoundedOrderHomClass
-/

end

export TopHomClass (map_top)

export BotHomClass (map_bot)

attribute [simp] map_top map_bot

/- warning: bounded_order_hom_class.to_top_hom_class -> BoundedOrderHomClass.toTopHomClass is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u3} β] [_inst_3 : BoundedOrder.{u2} α _inst_1] [_inst_4 : BoundedOrder.{u3} β _inst_2] [_inst_5 : BoundedOrderHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4], TopHomClass.{u1, u2, u3} F α β (OrderTop.toHasTop.{u2} α _inst_1 (BoundedOrder.toOrderTop.{u2} α _inst_1 _inst_3)) (OrderTop.toHasTop.{u3} β _inst_2 (BoundedOrder.toOrderTop.{u3} β _inst_2 _inst_4))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} {_inst_1 : LE.{u2} α} {_inst_2 : LE.{u3} β} {_inst_3 : BoundedOrder.{u2} α _inst_1} {_inst_4 : BoundedOrder.{u3} β _inst_2} [_inst_5 : BoundedOrderHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4], TopHomClass.{u1, u2, u3} F α β (OrderTop.toTop.{u2} α _inst_1 (BoundedOrder.toOrderTop.{u2} α _inst_1 _inst_3)) (OrderTop.toTop.{u3} β _inst_2 (BoundedOrder.toOrderTop.{u3} β _inst_2 _inst_4))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom_class.to_top_hom_class BoundedOrderHomClass.toTopHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) BoundedOrderHomClass.toTopHomClass [LE α] [LE β] [BoundedOrder α]
    [BoundedOrder β] [BoundedOrderHomClass F α β] : TopHomClass F α β :=
  { ‹BoundedOrderHomClass F α β› with }
#align bounded_order_hom_class.to_top_hom_class BoundedOrderHomClass.toTopHomClass

/- warning: bounded_order_hom_class.to_bot_hom_class -> BoundedOrderHomClass.toBotHomClass is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LE.{u2} α] [_inst_2 : LE.{u3} β] [_inst_3 : BoundedOrder.{u2} α _inst_1] [_inst_4 : BoundedOrder.{u3} β _inst_2] [_inst_5 : BoundedOrderHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4], BotHomClass.{u1, u2, u3} F α β (OrderBot.toHasBot.{u2} α _inst_1 (BoundedOrder.toOrderBot.{u2} α _inst_1 _inst_3)) (OrderBot.toHasBot.{u3} β _inst_2 (BoundedOrder.toOrderBot.{u3} β _inst_2 _inst_4))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} {_inst_1 : LE.{u2} α} {_inst_2 : LE.{u3} β} {_inst_3 : BoundedOrder.{u2} α _inst_1} {_inst_4 : BoundedOrder.{u3} β _inst_2} [_inst_5 : BoundedOrderHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4], BotHomClass.{u1, u2, u3} F α β (OrderBot.toBot.{u2} α _inst_1 (BoundedOrder.toOrderBot.{u2} α _inst_1 _inst_3)) (OrderBot.toBot.{u3} β _inst_2 (BoundedOrder.toOrderBot.{u3} β _inst_2 _inst_4))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom_class.to_bot_hom_class BoundedOrderHomClass.toBotHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) BoundedOrderHomClass.toBotHomClass [LE α] [LE β] [BoundedOrder α]
    [BoundedOrder β] [BoundedOrderHomClass F α β] : BotHomClass F α β :=
  { ‹BoundedOrderHomClass F α β› with }
#align bounded_order_hom_class.to_bot_hom_class BoundedOrderHomClass.toBotHomClass

/- warning: order_iso_class.to_top_hom_class -> OrderIsoClass.toTopHomClass is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LE.{u2} α] [_inst_2 : OrderTop.{u2} α _inst_1] [_inst_3 : PartialOrder.{u3} β] [_inst_4 : OrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))] [_inst_5 : OrderIsoClass.{u1, u2, u3} F α β _inst_1 (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))], TopHomClass.{u1, u2, u3} F α β (OrderTop.toHasTop.{u2} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3)) _inst_4)
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} {_inst_1 : LE.{u2} α} {_inst_2 : OrderTop.{u2} α _inst_1} {_inst_3 : PartialOrder.{u3} β} {_inst_4 : OrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))} [_inst_5 : OrderIsoClass.{u1, u2, u3} F α β _inst_1 (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))], TopHomClass.{u1, u2, u3} F α β (OrderTop.toTop.{u2} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3)) _inst_4)
Case conversion may be inaccurate. Consider using '#align order_iso_class.to_top_hom_class OrderIsoClass.toTopHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) OrderIsoClass.toTopHomClass [LE α] [OrderTop α] [PartialOrder β]
    [OrderTop β] [OrderIsoClass F α β] : TopHomClass F α β :=
  { show OrderHomClass F α β from inferInstance with
    map_top := fun f => top_le_iff.1 <| (map_inv_le_iff f).1 le_top }
#align order_iso_class.to_top_hom_class OrderIsoClass.toTopHomClass

/- warning: order_iso_class.to_bot_hom_class -> OrderIsoClass.toBotHomClass is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LE.{u2} α] [_inst_2 : OrderBot.{u2} α _inst_1] [_inst_3 : PartialOrder.{u3} β] [_inst_4 : OrderBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))] [_inst_5 : OrderIsoClass.{u1, u2, u3} F α β _inst_1 (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))], BotHomClass.{u1, u2, u3} F α β (OrderBot.toHasBot.{u2} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3)) _inst_4)
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} {_inst_1 : LE.{u2} α} {_inst_2 : OrderBot.{u2} α _inst_1} {_inst_3 : PartialOrder.{u3} β} {_inst_4 : OrderBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))} [_inst_5 : OrderIsoClass.{u1, u2, u3} F α β _inst_1 (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))], BotHomClass.{u1, u2, u3} F α β (OrderBot.toBot.{u2} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3)) _inst_4)
Case conversion may be inaccurate. Consider using '#align order_iso_class.to_bot_hom_class OrderIsoClass.toBotHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) OrderIsoClass.toBotHomClass [LE α] [OrderBot α] [PartialOrder β]
    [OrderBot β] [OrderIsoClass F α β] : BotHomClass F α β :=
  {--⟨λ f, le_bot_iff.1 $ (le_map_inv_iff f).1 bot_le⟩
    show OrderHomClass F α β from inferInstance with
    map_bot := fun f => le_bot_iff.1 <| (le_map_inv_iff f).1 bot_le }
#align order_iso_class.to_bot_hom_class OrderIsoClass.toBotHomClass

#print OrderIsoClass.toBoundedOrderHomClass /-
-- See note [lower instance priority]
instance (priority := 100) OrderIsoClass.toBoundedOrderHomClass [LE α] [BoundedOrder α]
    [PartialOrder β] [BoundedOrder β] [OrderIsoClass F α β] : BoundedOrderHomClass F α β :=
  { show OrderHomClass F α β from inferInstance, OrderIsoClass.toTopHomClass,
    OrderIsoClass.toBotHomClass with }
#align order_iso_class.to_bounded_order_hom_class OrderIsoClass.toBoundedOrderHomClass
-/

/- warning: map_eq_top_iff -> map_eq_top_iff is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LE.{u2} α] [_inst_2 : OrderTop.{u2} α _inst_1] [_inst_3 : PartialOrder.{u3} β] [_inst_4 : OrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))] [_inst_5 : OrderIsoClass.{u1, u2, u3} F α β _inst_1 (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))] (f : F) {a : α}, Iff (Eq.{succ u3} β (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (TopHomClass.toFunLike.{u1, u2, u3} F α β (OrderTop.toHasTop.{u2} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3)) _inst_4) (OrderIsoClass.toTopHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))) f a) (Top.top.{u3} β (OrderTop.toHasTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3)) _inst_4))) (Eq.{succ u2} α a (Top.top.{u2} α (OrderTop.toHasTop.{u2} α _inst_1 _inst_2)))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u3}} {β : Type.{u2}} [_inst_1 : LE.{u3} α] [_inst_2 : OrderTop.{u3} α _inst_1] [_inst_3 : PartialOrder.{u2} β] [_inst_4 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_3))] [_inst_5 : OrderIsoClass.{u1, u3, u2} F α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_3))] (f : F) {a : α}, Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) _x) (RelHomClass.toFunLike.{u1, u3, u2} F α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.2092 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.2094 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.2092 x._@.Mathlib.Order.Hom.Basic._hyg.2094) (fun (_x : β) (x._@.Mathlib.Order.Hom.Basic._hyg.2116 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_3)) _x x._@.Mathlib.Order.Hom.Basic._hyg.2116) (OrderIsoClass.toOrderHomClass.{u1, u3, u2} F α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_3)) _inst_5)) f a) (Top.top.{u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) (OrderTop.toTop.{u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) _inst_3)) _inst_4))) (Eq.{succ u3} α a (Top.top.{u3} α (OrderTop.toTop.{u3} α _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align map_eq_top_iff map_eq_top_iffₓ'. -/
@[simp]
theorem map_eq_top_iff [LE α] [OrderTop α] [PartialOrder β] [OrderTop β] [OrderIsoClass F α β]
    (f : F) {a : α} : f a = ⊤ ↔ a = ⊤ := by rw [← map_top f, (EquivLike.injective f).eq_iff]
#align map_eq_top_iff map_eq_top_iff

/- warning: map_eq_bot_iff -> map_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LE.{u2} α] [_inst_2 : OrderBot.{u2} α _inst_1] [_inst_3 : PartialOrder.{u3} β] [_inst_4 : OrderBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))] [_inst_5 : OrderIsoClass.{u1, u2, u3} F α β _inst_1 (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3))] (f : F) {a : α}, Iff (Eq.{succ u3} β (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (BotHomClass.toFunLike.{u1, u2, u3} F α β (OrderBot.toHasBot.{u2} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3)) _inst_4) (OrderIsoClass.toBotHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))) f a) (Bot.bot.{u3} β (OrderBot.toHasBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β _inst_3)) _inst_4))) (Eq.{succ u2} α a (Bot.bot.{u2} α (OrderBot.toHasBot.{u2} α _inst_1 _inst_2)))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u3}} {β : Type.{u2}} [_inst_1 : LE.{u3} α] [_inst_2 : OrderBot.{u3} α _inst_1] [_inst_3 : PartialOrder.{u2} β] [_inst_4 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_3))] [_inst_5 : OrderIsoClass.{u1, u3, u2} F α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_3))] (f : F) {a : α}, Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) _x) (RelHomClass.toFunLike.{u1, u3, u2} F α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.2092 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.2094 : α) => LE.le.{u3} α _inst_1 x._@.Mathlib.Order.Hom.Basic._hyg.2092 x._@.Mathlib.Order.Hom.Basic._hyg.2094) (fun (_x : β) (x._@.Mathlib.Order.Hom.Basic._hyg.2116 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_3)) _x x._@.Mathlib.Order.Hom.Basic._hyg.2116) (OrderIsoClass.toOrderHomClass.{u1, u3, u2} F α β _inst_1 (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β _inst_3)) _inst_5)) f a) (Bot.bot.{u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) (OrderBot.toBot.{u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.931 : α) => β) a) _inst_3)) _inst_4))) (Eq.{succ u3} α a (Bot.bot.{u3} α (OrderBot.toBot.{u3} α _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align map_eq_bot_iff map_eq_bot_iffₓ'. -/
@[simp]
theorem map_eq_bot_iff [LE α] [OrderBot α] [PartialOrder β] [OrderBot β] [OrderIsoClass F α β]
    (f : F) {a : α} : f a = ⊥ ↔ a = ⊥ := by rw [← map_bot f, (EquivLike.injective f).eq_iff]
#align map_eq_bot_iff map_eq_bot_iff

instance [Top α] [Top β] [TopHomClass F α β] : CoeTC F (TopHom α β) :=
  ⟨fun f => ⟨f, map_top f⟩⟩

instance [Bot α] [Bot β] [BotHomClass F α β] : CoeTC F (BotHom α β) :=
  ⟨fun f => ⟨f, map_bot f⟩⟩

instance [Preorder α] [Preorder β] [BoundedOrder α] [BoundedOrder β] [BoundedOrderHomClass F α β] :
    CoeTC F (BoundedOrderHom α β) :=
  ⟨fun f =>
    { (f : α →o β) with
      toFun := f
      map_top' := map_top f
      map_bot' := map_bot f }⟩

/-! ### Top homomorphisms -/


namespace TopHom

variable [Top α]

section Top

variable [Top β] [Top γ] [Top δ]

instance : TopHomClass (TopHom α β) α β
    where
  coe := TopHom.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
  map_top := TopHom.map_top'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (TopHom α β) fun _ => α → β :=
  FunLike.hasCoeToFun

/- warning: top_hom.to_fun_eq_coe clashes with [anonymous] -> [anonymous]
warning: top_hom.to_fun_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] {f : TopHom.{u1, u2} α β _inst_1 _inst_2}, Eq.{max (succ u1) (succ u2)} (α -> β) (TopHom.toFun.{u1, u2} α β _inst_1 _inst_2 f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : TopHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}}, (Nat -> α -> β) -> Nat -> (List.{u1} α) -> (List.{u2} β)
Case conversion may be inaccurate. Consider using '#align top_hom.to_fun_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] {f : TopHom α β} : f.toFun = (f : α → β) :=
  rfl
#align top_hom.to_fun_eq_coe [anonymous]

-- this must come after the coe_to_fun definition
initialize_simps_projections TopHom (toFun → apply)

/- warning: top_hom.ext -> TopHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] {f : TopHom.{u1, u2} α β _inst_1 _inst_2} {g : TopHom.{u1, u2} α β _inst_1 _inst_2}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : TopHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : TopHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a)) -> (Eq.{max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Top.{u2} α] [_inst_2 : Top.{u1} β] {f : TopHom.{u2, u1} α β _inst_1 _inst_2} {g : TopHom.{u2, u1} α β _inst_1 _inst_2}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 _inst_2)) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 _inst_2)) g a)) -> (Eq.{max (succ u2) (succ u1)} (TopHom.{u2, u1} α β _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align top_hom.ext TopHom.extₓ'. -/
@[ext]
theorem ext {f g : TopHom α β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align top_hom.ext TopHom.ext

/- warning: top_hom.copy -> TopHom.copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] (f : TopHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : TopHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)) -> (TopHom.{u1, u2} α β _inst_1 _inst_2)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] (f : TopHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (TopHom.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u2, u1, u2} (TopHom.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (TopHom.instTopHomClassTopHom.{u1, u2} α β _inst_1 _inst_2)) f)) -> (TopHom.{u1, u2} α β _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align top_hom.copy TopHom.copyₓ'. -/
/-- Copy of a `top_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : TopHom α β) (f' : α → β) (h : f' = f) : TopHom α β
    where
  toFun := f'
  map_top' := h.symm ▸ f.map_top'
#align top_hom.copy TopHom.copy

/- warning: top_hom.coe_copy -> TopHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] (f : TopHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : TopHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : TopHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (TopHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Top.{u2} α] [_inst_2 : Top.{u1} β] (f : TopHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 _inst_2)) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 _inst_2)) (TopHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align top_hom.coe_copy TopHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : TopHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align top_hom.coe_copy TopHom.coe_copy

/- warning: top_hom.copy_eq -> TopHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] (f : TopHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : TopHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (TopHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Top.{u2} α] [_inst_2 : Top.{u1} β] (f : TopHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 _inst_2)) f)), Eq.{max (succ u2) (succ u1)} (TopHom.{u2, u1} α β _inst_1 _inst_2) (TopHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h) f
Case conversion may be inaccurate. Consider using '#align top_hom.copy_eq TopHom.copy_eqₓ'. -/
theorem copy_eq (f : TopHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align top_hom.copy_eq TopHom.copy_eq

instance : Inhabited (TopHom α β) :=
  ⟨⟨fun _ => ⊤, rfl⟩⟩

variable (α)

#print TopHom.id /-
/-- `id` as a `top_hom`. -/
protected def id : TopHom α α :=
  ⟨id, rfl⟩
#align top_hom.id TopHom.id
-/

/- warning: top_hom.coe_id -> TopHom.coe_id is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : Top.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (TopHom.{u1, u1} α α _inst_1 _inst_1) (fun (_x : TopHom.{u1, u1} α α _inst_1 _inst_1) => α -> α) (TopHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_1) (TopHom.id.{u1} α _inst_1)) (id.{succ u1} α)
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : Top.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (TopHom.{u1, u1} α α _inst_1 _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => α) _x) (TopHomClass.toFunLike.{u1, u1, u1} (TopHom.{u1, u1} α α _inst_1 _inst_1) α α _inst_1 _inst_1 (TopHom.instTopHomClassTopHom.{u1, u1} α α _inst_1 _inst_1)) (TopHom.id.{u1} α _inst_1)) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align top_hom.coe_id TopHom.coe_idₓ'. -/
@[simp]
theorem coe_id : ⇑(TopHom.id α) = id :=
  rfl
#align top_hom.coe_id TopHom.coe_id

variable {α}

/- warning: top_hom.id_apply -> TopHom.id_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Top.{u1} α] (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (TopHom.{u1, u1} α α _inst_1 _inst_1) (fun (_x : TopHom.{u1, u1} α α _inst_1 _inst_1) => α -> α) (TopHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_1) (TopHom.id.{u1} α _inst_1) a) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Top.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (TopHom.{u1, u1} α α _inst_1 _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => α) _x) (TopHomClass.toFunLike.{u1, u1, u1} (TopHom.{u1, u1} α α _inst_1 _inst_1) α α _inst_1 _inst_1 (TopHom.instTopHomClassTopHom.{u1, u1} α α _inst_1 _inst_1)) (TopHom.id.{u1} α _inst_1) a) a
Case conversion may be inaccurate. Consider using '#align top_hom.id_apply TopHom.id_applyₓ'. -/
@[simp]
theorem id_apply (a : α) : TopHom.id α a = a :=
  rfl
#align top_hom.id_apply TopHom.id_apply

#print TopHom.comp /-
/-- Composition of `top_hom`s as a `top_hom`. -/
def comp (f : TopHom β γ) (g : TopHom α β) : TopHom α γ
    where
  toFun := f ∘ g
  map_top' := by rw [comp_apply, map_top, map_top]
#align top_hom.comp TopHom.comp
-/

/- warning: top_hom.coe_comp -> TopHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] [_inst_3 : Top.{u3} γ] (f : TopHom.{u2, u3} β γ _inst_2 _inst_3) (g : TopHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} ((fun (_x : TopHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (TopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (TopHom.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : TopHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (TopHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3) (TopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : TopHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (TopHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : TopHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u3} β] [_inst_3 : Top.{u2} γ] (f : TopHom.{u3, u2} β γ _inst_2 _inst_3) (g : TopHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (TopHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => γ) _x) (TopHomClass.toFunLike.{max u1 u2, u1, u2} (TopHom.{u1, u2} α γ _inst_1 _inst_3) α γ _inst_1 _inst_3 (TopHom.instTopHomClassTopHom.{u1, u2} α γ _inst_1 _inst_3)) (TopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (TopHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : β) => γ) _x) (TopHomClass.toFunLike.{max u3 u2, u3, u2} (TopHom.{u3, u2} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (TopHom.instTopHomClassTopHom.{u3, u2} β γ _inst_2 _inst_3)) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (TopHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u3, u1, u3} (TopHom.{u1, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (TopHom.instTopHomClassTopHom.{u1, u3} α β _inst_1 _inst_2)) g))
Case conversion may be inaccurate. Consider using '#align top_hom.coe_comp TopHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (f : TopHom β γ) (g : TopHom α β) : (f.comp g : α → γ) = f ∘ g :=
  rfl
#align top_hom.coe_comp TopHom.coe_comp

/- warning: top_hom.comp_apply -> TopHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] [_inst_3 : Top.{u3} γ] (f : TopHom.{u2, u3} β γ _inst_2 _inst_3) (g : TopHom.{u1, u2} α β _inst_1 _inst_2) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (TopHom.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : TopHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (TopHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3) (TopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : TopHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (TopHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : TopHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u3} β] [_inst_3 : Top.{u2} γ] (f : TopHom.{u3, u2} β γ _inst_2 _inst_3) (g : TopHom.{u1, u3} α β _inst_1 _inst_2) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (TopHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => γ) _x) (TopHomClass.toFunLike.{max u1 u2, u1, u2} (TopHom.{u1, u2} α γ _inst_1 _inst_3) α γ _inst_1 _inst_3 (TopHom.instTopHomClassTopHom.{u1, u2} α γ _inst_1 _inst_3)) (TopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (TopHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : β) => γ) _x) (TopHomClass.toFunLike.{max u3 u2, u3, u2} (TopHom.{u3, u2} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (TopHom.instTopHomClassTopHom.{u3, u2} β γ _inst_2 _inst_3)) f (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (TopHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u3, u1, u3} (TopHom.{u1, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (TopHom.instTopHomClassTopHom.{u1, u3} α β _inst_1 _inst_2)) g a))
Case conversion may be inaccurate. Consider using '#align top_hom.comp_apply TopHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (f : TopHom β γ) (g : TopHom α β) (a : α) : (f.comp g) a = f (g a) :=
  rfl
#align top_hom.comp_apply TopHom.comp_apply

/- warning: top_hom.comp_assoc -> TopHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] [_inst_3 : Top.{u3} γ] [_inst_4 : Top.{u4} δ] (f : TopHom.{u3, u4} γ δ _inst_3 _inst_4) (g : TopHom.{u2, u3} β γ _inst_2 _inst_3) (h : TopHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u4)} (TopHom.{u1, u4} α δ _inst_1 _inst_4) (TopHom.comp.{u1, u2, u4} α β δ _inst_1 _inst_2 _inst_4 (TopHom.comp.{u2, u3, u4} β γ δ _inst_2 _inst_3 _inst_4 f g) h) (TopHom.comp.{u1, u3, u4} α γ δ _inst_1 _inst_3 _inst_4 f (TopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u4}} {δ : Type.{u3}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] [_inst_3 : Top.{u4} γ] [_inst_4 : Top.{u3} δ] (f : TopHom.{u4, u3} γ δ _inst_3 _inst_4) (g : TopHom.{u2, u4} β γ _inst_2 _inst_3) (h : TopHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (TopHom.{u1, u3} α δ _inst_1 _inst_4) (TopHom.comp.{u1, u2, u3} α β δ _inst_1 _inst_2 _inst_4 (TopHom.comp.{u2, u4, u3} β γ δ _inst_2 _inst_3 _inst_4 f g) h) (TopHom.comp.{u1, u4, u3} α γ δ _inst_1 _inst_3 _inst_4 f (TopHom.comp.{u1, u2, u4} α β γ _inst_1 _inst_2 _inst_3 g h))
Case conversion may be inaccurate. Consider using '#align top_hom.comp_assoc TopHom.comp_assocₓ'. -/
@[simp]
theorem comp_assoc (f : TopHom γ δ) (g : TopHom β γ) (h : TopHom α β) :
    (f.comp g).comp h = f.comp (g.comp h) :=
  rfl
#align top_hom.comp_assoc TopHom.comp_assoc

/- warning: top_hom.comp_id -> TopHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] (f : TopHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (TopHom.comp.{u1, u1, u2} α α β _inst_1 _inst_1 _inst_2 f (TopHom.id.{u1} α _inst_1)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Top.{u2} α] [_inst_2 : Top.{u1} β] (f : TopHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (TopHom.{u2, u1} α β _inst_1 _inst_2) (TopHom.comp.{u2, u2, u1} α α β _inst_1 _inst_1 _inst_2 f (TopHom.id.{u2} α _inst_1)) f
Case conversion may be inaccurate. Consider using '#align top_hom.comp_id TopHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : TopHom α β) : f.comp (TopHom.id α) = f :=
  TopHom.ext fun a => rfl
#align top_hom.comp_id TopHom.comp_id

/- warning: top_hom.id_comp -> TopHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] (f : TopHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (TopHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_2 (TopHom.id.{u2} β _inst_2) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Top.{u2} α] [_inst_2 : Top.{u1} β] (f : TopHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (TopHom.{u2, u1} α β _inst_1 _inst_2) (TopHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_2 (TopHom.id.{u1} β _inst_2) f) f
Case conversion may be inaccurate. Consider using '#align top_hom.id_comp TopHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : TopHom α β) : (TopHom.id β).comp f = f :=
  TopHom.ext fun a => rfl
#align top_hom.id_comp TopHom.id_comp

/- warning: top_hom.cancel_right -> TopHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] [_inst_3 : Top.{u3} γ] {g₁ : TopHom.{u2, u3} β γ _inst_2 _inst_3} {g₂ : TopHom.{u2, u3} β γ _inst_2 _inst_3} {f : TopHom.{u1, u2} α β _inst_1 _inst_2}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : TopHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (TopHom.{u1, u3} α γ _inst_1 _inst_3) (TopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₁ f) (TopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₂ f)) (Eq.{max (succ u2) (succ u3)} (TopHom.{u2, u3} β γ _inst_2 _inst_3) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u3} β] [_inst_3 : Top.{u2} γ] {g₁ : TopHom.{u3, u2} β γ _inst_2 _inst_3} {g₂ : TopHom.{u3, u2} β γ _inst_2 _inst_3} {f : TopHom.{u1, u3} α β _inst_1 _inst_2}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (TopHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u3, u1, u3} (TopHom.{u1, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (TopHom.instTopHomClassTopHom.{u1, u3} α β _inst_1 _inst_2)) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (TopHom.{u1, u2} α γ _inst_1 _inst_3) (TopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₁ f) (TopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₂ f)) (Eq.{max (succ u3) (succ u2)} (TopHom.{u3, u2} β γ _inst_2 _inst_3) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align top_hom.cancel_right TopHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : TopHom β γ} {f : TopHom α β} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => TopHom.ext <| hf.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align top_hom.cancel_right TopHom.cancel_right

/- warning: top_hom.cancel_left -> TopHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u2} β] [_inst_3 : Top.{u3} γ] {g : TopHom.{u2, u3} β γ _inst_2 _inst_3} {f₁ : TopHom.{u1, u2} α β _inst_1 _inst_2} {f₂ : TopHom.{u1, u2} α β _inst_1 _inst_2}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : TopHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (TopHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (TopHom.{u1, u3} α γ _inst_1 _inst_3) (TopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f₁) (TopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f₂)) (Eq.{max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 _inst_2) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Top.{u3} β] [_inst_3 : Top.{u2} γ] {g : TopHom.{u3, u2} β γ _inst_2 _inst_3} {f₁ : TopHom.{u1, u3} α β _inst_1 _inst_2} {f₂ : TopHom.{u1, u3} α β _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (TopHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : β) => γ) _x) (TopHomClass.toFunLike.{max u3 u2, u3, u2} (TopHom.{u3, u2} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (TopHom.instTopHomClassTopHom.{u3, u2} β γ _inst_2 _inst_3)) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (TopHom.{u1, u2} α γ _inst_1 _inst_3) (TopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f₁) (TopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f₂)) (Eq.{max (succ u1) (succ u3)} (TopHom.{u1, u3} α β _inst_1 _inst_2) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align top_hom.cancel_left TopHom.cancel_leftₓ'. -/
theorem cancel_left {g : TopHom β γ} {f₁ f₂ : TopHom α β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => TopHom.ext fun a => hg <| by rw [← TopHom.comp_apply, h, TopHom.comp_apply],
    congr_arg _⟩
#align top_hom.cancel_left TopHom.cancel_left

end Top

instance [Preorder β] [Top β] : Preorder (TopHom α β) :=
  Preorder.lift (coeFn : TopHom α β → α → β)

instance [PartialOrder β] [Top β] : PartialOrder (TopHom α β) :=
  PartialOrder.lift _ FunLike.coe_injective

section OrderTop

variable [Preorder β] [OrderTop β]

instance : OrderTop (TopHom α β) :=
  ⟨⟨⊤, rfl⟩, fun _ => le_top⟩

/- warning: top_hom.coe_top -> TopHom.coe_top is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : OrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2)], Eq.{succ (max u1 u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), succ (max u1 u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (Top.top.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (OrderTop.toHasTop.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (Preorder.toLE.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (TopHom.preorder.{u1, u2} α β _inst_1 _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3))) (TopHom.orderTop.{u1, u2} α β _inst_1 _inst_2 _inst_3)))) (Top.top.{max u1 u2} (α -> β) (Pi.hasTop.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Top.{u2} α] [_inst_2 : Preorder.{u1} β] [_inst_3 : OrderTop.{u1} β (Preorder.toLE.{u1} β _inst_2)], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3)) α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3) (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3))) (Top.top.{max u2 u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3)) (OrderTop.toTop.{max u2 u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3)) (Preorder.toLE.{max u2 u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3)) (TopHom.instPreorderTopHom.{u2, u1} α β _inst_1 _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3))) (TopHom.instOrderTopTopHomToTopToLEToLEInstPreorderTopHom.{u2, u1} α β _inst_1 _inst_2 _inst_3)))) (Top.top.{max u2 u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) ᾰ) (Pi.instTopForAll.{u2, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) ᾰ) (fun (i : α) => OrderTop.toTop.{u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) i) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) i) _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align top_hom.coe_top TopHom.coe_topₓ'. -/
@[simp]
theorem coe_top : ⇑(⊤ : TopHom α β) = ⊤ :=
  rfl
#align top_hom.coe_top TopHom.coe_top

/- warning: top_hom.top_apply -> TopHom.top_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : OrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2)] (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (Top.top.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (OrderTop.toHasTop.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (Preorder.toLE.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (TopHom.preorder.{u1, u2} α β _inst_1 _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3))) (TopHom.orderTop.{u1, u2} α β _inst_1 _inst_2 _inst_3))) a) (Top.top.{u2} β (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : OrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2)] (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u2, u1, u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3) (TopHom.instTopHomClassTopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3))) (Top.top.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (OrderTop.toTop.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (Preorder.toLE.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (TopHom.instPreorderTopHom.{u1, u2} α β _inst_1 _inst_2 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3))) (TopHom.instOrderTopTopHomToTopToLEToLEInstPreorderTopHom.{u1, u2} α β _inst_1 _inst_2 _inst_3))) a) (Top.top.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) (OrderTop.toTop.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align top_hom.top_apply TopHom.top_applyₓ'. -/
@[simp]
theorem top_apply (a : α) : (⊤ : TopHom α β) a = ⊤ :=
  rfl
#align top_hom.top_apply TopHom.top_apply

end OrderTop

section SemilatticeInf

variable [SemilatticeInf β] [OrderTop β] (f g : TopHom α β)

instance : HasInf (TopHom α β) :=
  ⟨fun f g => ⟨f ⊓ g, by rw [Pi.inf_apply, map_top, map_top, inf_top_eq]⟩⟩

instance : SemilatticeInf (TopHom α β) :=
  FunLike.coe_injective.SemilatticeInf _ fun _ _ => rfl

/- warning: top_hom.coe_inf -> TopHom.coe_inf is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] [_inst_3 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))] (f : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (HasInf.inf.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (TopHom.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g)) (HasInf.inf.{max u1 u2} (α -> β) (Pi.hasInf.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeInf.toHasInf.{u2} β _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) g))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Top.{u2} α] [_inst_2 : SemilatticeInf.{u1} β] [_inst_3 : OrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2)))] (f : TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) (g : TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3))) (HasInf.inf.{max u2 u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) (TopHom.instHasInfTopHomToTopToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3) f g)) (HasInf.inf.{max u2 u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) ᾰ) (Pi.instHasInfForAll.{u2, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) ᾰ) (fun (i : α) => SemilatticeInf.toHasInf.{u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) i) _inst_2)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3))) g))
Case conversion may be inaccurate. Consider using '#align top_hom.coe_inf TopHom.coe_infₓ'. -/
@[simp]
theorem coe_inf : ⇑(f ⊓ g) = f ⊓ g :=
  rfl
#align top_hom.coe_inf TopHom.coe_inf

/- warning: top_hom.inf_apply -> TopHom.inf_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] [_inst_3 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))] (f : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (HasInf.inf.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (TopHom.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g) a) (HasInf.inf.{u2} β (SemilatticeInf.toHasInf.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] [_inst_3 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))] (f : TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u2, u1, u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3))) (HasInf.inf.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (TopHom.instHasInfTopHomToTopToLEToPreorderToPartialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g) a) (HasInf.inf.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) (SemilatticeInf.toHasInf.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u2, u1, u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3))) f a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u2, u1, u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3))) g a))
Case conversion may be inaccurate. Consider using '#align top_hom.inf_apply TopHom.inf_applyₓ'. -/
@[simp]
theorem inf_apply (a : α) : (f ⊓ g) a = f a ⊓ g a :=
  rfl
#align top_hom.inf_apply TopHom.inf_apply

end SemilatticeInf

section SemilatticeSup

variable [SemilatticeSup β] [OrderTop β] (f g : TopHom α β)

instance : HasSup (TopHom α β) :=
  ⟨fun f g => ⟨f ⊔ g, by rw [Pi.sup_apply, map_top, map_top, sup_top_eq]⟩⟩

instance : SemilatticeSup (TopHom α β) :=
  FunLike.coe_injective.SemilatticeSup _ fun _ _ => rfl

/- warning: top_hom.coe_sup -> TopHom.coe_sup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] [_inst_3 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))] (f : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (HasSup.sup.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (TopHom.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g)) (HasSup.sup.{max u1 u2} (α -> β) (Pi.hasSup.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeSup.toHasSup.{u2} β _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) g))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Top.{u2} α] [_inst_2 : SemilatticeSup.{u1} β] [_inst_3 : OrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2)))] (f : TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) (g : TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3))) (HasSup.sup.{max u2 u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) (TopHom.instHasSupTopHomToTopToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3) f g)) (HasSup.sup.{max u2 u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) ᾰ) (Pi.instHasSupForAll.{u2, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) ᾰ) (fun (i : α) => SemilatticeSup.toHasSup.{u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) i) _inst_2)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u2 u1, u2, u1} (TopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u2, u1} α β _inst_1 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3))) g))
Case conversion may be inaccurate. Consider using '#align top_hom.coe_sup TopHom.coe_supₓ'. -/
@[simp]
theorem coe_sup : ⇑(f ⊔ g) = f ⊔ g :=
  rfl
#align top_hom.coe_sup TopHom.coe_sup

/- warning: top_hom.sup_apply -> TopHom.sup_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] [_inst_3 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))] (f : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (HasSup.sup.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (TopHom.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g) a) (HasSup.sup.{u2} β (SemilatticeSup.toHasSup.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : TopHom.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (TopHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Top.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] [_inst_3 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))] (f : TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u2, u1, u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3))) (HasSup.sup.{max u1 u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (TopHom.instHasSupTopHomToTopToLEToPreorderToPartialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g) a) (HasSup.sup.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) (SemilatticeSup.toHasSup.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) a) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u2, u1, u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3))) f a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.239 : α) => β) _x) (TopHomClass.toFunLike.{max u1 u2, u1, u2} (TopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3) (TopHom.instTopHomClassTopHom.{u1, u2} α β _inst_1 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3))) g a))
Case conversion may be inaccurate. Consider using '#align top_hom.sup_apply TopHom.sup_applyₓ'. -/
@[simp]
theorem sup_apply (a : α) : (f ⊔ g) a = f a ⊔ g a :=
  rfl
#align top_hom.sup_apply TopHom.sup_apply

end SemilatticeSup

instance [Lattice β] [OrderTop β] : Lattice (TopHom α β) :=
  FunLike.coe_injective.Lattice _ (fun _ _ => rfl) fun _ _ => rfl

instance [DistribLattice β] [OrderTop β] : DistribLattice (TopHom α β) :=
  FunLike.coe_injective.DistribLattice _ (fun _ _ => rfl) fun _ _ => rfl

end TopHom

/-! ### Bot homomorphisms -/


namespace BotHom

variable [Bot α]

section Bot

variable [Bot β] [Bot γ] [Bot δ]

instance : BotHomClass (BotHom α β) α β
    where
  coe := BotHom.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
  map_bot := BotHom.map_bot'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (BotHom α β) fun _ => α → β :=
  FunLike.hasCoeToFun

/- warning: bot_hom.to_fun_eq_coe clashes with [anonymous] -> [anonymous]
warning: bot_hom.to_fun_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] {f : BotHom.{u1, u2} α β _inst_1 _inst_2}, Eq.{max (succ u1) (succ u2)} (α -> β) (BotHom.toFun.{u1, u2} α β _inst_1 _inst_2 f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BotHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}}, (Nat -> α -> β) -> Nat -> (List.{u1} α) -> (List.{u2} β)
Case conversion may be inaccurate. Consider using '#align bot_hom.to_fun_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] {f : BotHom α β} : f.toFun = (f : α → β) :=
  rfl
#align bot_hom.to_fun_eq_coe [anonymous]

-- this must come after the coe_to_fun definition
initialize_simps_projections BotHom (toFun → apply)

/- warning: bot_hom.ext -> BotHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] {f : BotHom.{u1, u2} α β _inst_1 _inst_2} {g : BotHom.{u1, u2} α β _inst_1 _inst_2}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BotHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BotHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a)) -> (Eq.{max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Bot.{u2} α] [_inst_2 : Bot.{u1} β] {f : BotHom.{u2, u1} α β _inst_1 _inst_2} {g : BotHom.{u2, u1} α β _inst_1 _inst_2}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 _inst_2)) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 _inst_2)) g a)) -> (Eq.{max (succ u2) (succ u1)} (BotHom.{u2, u1} α β _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align bot_hom.ext BotHom.extₓ'. -/
@[ext]
theorem ext {f g : BotHom α β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align bot_hom.ext BotHom.ext

/- warning: bot_hom.copy -> BotHom.copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] (f : BotHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BotHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)) -> (BotHom.{u1, u2} α β _inst_1 _inst_2)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] (f : BotHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BotHom.{u1, u2} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BotHom.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BotHom.instBotHomClassBotHom.{u1, u2} α β _inst_1 _inst_2)) f)) -> (BotHom.{u1, u2} α β _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align bot_hom.copy BotHom.copyₓ'. -/
/-- Copy of a `bot_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : BotHom α β) (f' : α → β) (h : f' = f) : BotHom α β
    where
  toFun := f'
  map_bot' := h.symm ▸ f.map_bot'
#align bot_hom.copy BotHom.copy

/- warning: bot_hom.coe_copy -> BotHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] (f : BotHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BotHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BotHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (BotHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Bot.{u2} α] [_inst_2 : Bot.{u1} β] (f : BotHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 _inst_2)) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 _inst_2)) (BotHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align bot_hom.coe_copy BotHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : BotHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align bot_hom.coe_copy BotHom.coe_copy

/- warning: bot_hom.copy_eq -> BotHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] (f : BotHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BotHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (BotHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Bot.{u2} α] [_inst_2 : Bot.{u1} β] (f : BotHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 _inst_2)) f)), Eq.{max (succ u2) (succ u1)} (BotHom.{u2, u1} α β _inst_1 _inst_2) (BotHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h) f
Case conversion may be inaccurate. Consider using '#align bot_hom.copy_eq BotHom.copy_eqₓ'. -/
theorem copy_eq (f : BotHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align bot_hom.copy_eq BotHom.copy_eq

instance : Inhabited (BotHom α β) :=
  ⟨⟨fun _ => ⊥, rfl⟩⟩

variable (α)

#print BotHom.id /-
/-- `id` as a `bot_hom`. -/
protected def id : BotHom α α :=
  ⟨id, rfl⟩
#align bot_hom.id BotHom.id
-/

/- warning: bot_hom.coe_id -> BotHom.coe_id is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : Bot.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (BotHom.{u1, u1} α α _inst_1 _inst_1) (fun (_x : BotHom.{u1, u1} α α _inst_1 _inst_1) => α -> α) (BotHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_1) (BotHom.id.{u1} α _inst_1)) (id.{succ u1} α)
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : Bot.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (BotHom.{u1, u1} α α _inst_1 _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => α) _x) (BotHomClass.toFunLike.{u1, u1, u1} (BotHom.{u1, u1} α α _inst_1 _inst_1) α α _inst_1 _inst_1 (BotHom.instBotHomClassBotHom.{u1, u1} α α _inst_1 _inst_1)) (BotHom.id.{u1} α _inst_1)) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align bot_hom.coe_id BotHom.coe_idₓ'. -/
@[simp]
theorem coe_id : ⇑(BotHom.id α) = id :=
  rfl
#align bot_hom.coe_id BotHom.coe_id

variable {α}

/- warning: bot_hom.id_apply -> BotHom.id_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Bot.{u1} α] (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (BotHom.{u1, u1} α α _inst_1 _inst_1) (fun (_x : BotHom.{u1, u1} α α _inst_1 _inst_1) => α -> α) (BotHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_1) (BotHom.id.{u1} α _inst_1) a) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Bot.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (BotHom.{u1, u1} α α _inst_1 _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => α) _x) (BotHomClass.toFunLike.{u1, u1, u1} (BotHom.{u1, u1} α α _inst_1 _inst_1) α α _inst_1 _inst_1 (BotHom.instBotHomClassBotHom.{u1, u1} α α _inst_1 _inst_1)) (BotHom.id.{u1} α _inst_1) a) a
Case conversion may be inaccurate. Consider using '#align bot_hom.id_apply BotHom.id_applyₓ'. -/
@[simp]
theorem id_apply (a : α) : BotHom.id α a = a :=
  rfl
#align bot_hom.id_apply BotHom.id_apply

#print BotHom.comp /-
/-- Composition of `bot_hom`s as a `bot_hom`. -/
def comp (f : BotHom β γ) (g : BotHom α β) : BotHom α γ
    where
  toFun := f ∘ g
  map_bot' := by rw [comp_apply, map_bot, map_bot]
#align bot_hom.comp BotHom.comp
-/

/- warning: bot_hom.coe_comp -> BotHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] [_inst_3 : Bot.{u3} γ] (f : BotHom.{u2, u3} β γ _inst_2 _inst_3) (g : BotHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} ((fun (_x : BotHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (BotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BotHom.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : BotHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (BotHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3) (BotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : BotHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (BotHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BotHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u3} β] [_inst_3 : Bot.{u2} γ] (f : BotHom.{u3, u2} β γ _inst_2 _inst_3) (g : BotHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BotHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => γ) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BotHom.{u1, u2} α γ _inst_1 _inst_3) α γ _inst_1 _inst_3 (BotHom.instBotHomClassBotHom.{u1, u2} α γ _inst_1 _inst_3)) (BotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (BotHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : β) => γ) _x) (BotHomClass.toFunLike.{max u3 u2, u3, u2} (BotHom.{u3, u2} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (BotHom.instBotHomClassBotHom.{u3, u2} β γ _inst_2 _inst_3)) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BotHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u3, u1, u3} (BotHom.{u1, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BotHom.instBotHomClassBotHom.{u1, u3} α β _inst_1 _inst_2)) g))
Case conversion may be inaccurate. Consider using '#align bot_hom.coe_comp BotHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (f : BotHom β γ) (g : BotHom α β) : (f.comp g : α → γ) = f ∘ g :=
  rfl
#align bot_hom.coe_comp BotHom.coe_comp

/- warning: bot_hom.comp_apply -> BotHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] [_inst_3 : Bot.{u3} γ] (f : BotHom.{u2, u3} β γ _inst_2 _inst_3) (g : BotHom.{u1, u2} α β _inst_1 _inst_2) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BotHom.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : BotHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (BotHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3) (BotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : BotHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (BotHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BotHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u3} β] [_inst_3 : Bot.{u2} γ] (f : BotHom.{u3, u2} β γ _inst_2 _inst_3) (g : BotHom.{u1, u3} α β _inst_1 _inst_2) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BotHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => γ) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BotHom.{u1, u2} α γ _inst_1 _inst_3) α γ _inst_1 _inst_3 (BotHom.instBotHomClassBotHom.{u1, u2} α γ _inst_1 _inst_3)) (BotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (BotHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : β) => γ) _x) (BotHomClass.toFunLike.{max u3 u2, u3, u2} (BotHom.{u3, u2} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (BotHom.instBotHomClassBotHom.{u3, u2} β γ _inst_2 _inst_3)) f (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BotHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u3, u1, u3} (BotHom.{u1, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BotHom.instBotHomClassBotHom.{u1, u3} α β _inst_1 _inst_2)) g a))
Case conversion may be inaccurate. Consider using '#align bot_hom.comp_apply BotHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (f : BotHom β γ) (g : BotHom α β) (a : α) : (f.comp g) a = f (g a) :=
  rfl
#align bot_hom.comp_apply BotHom.comp_apply

/- warning: bot_hom.comp_assoc -> BotHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] [_inst_3 : Bot.{u3} γ] [_inst_4 : Bot.{u4} δ] (f : BotHom.{u3, u4} γ δ _inst_3 _inst_4) (g : BotHom.{u2, u3} β γ _inst_2 _inst_3) (h : BotHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u4)} (BotHom.{u1, u4} α δ _inst_1 _inst_4) (BotHom.comp.{u1, u2, u4} α β δ _inst_1 _inst_2 _inst_4 (BotHom.comp.{u2, u3, u4} β γ δ _inst_2 _inst_3 _inst_4 f g) h) (BotHom.comp.{u1, u3, u4} α γ δ _inst_1 _inst_3 _inst_4 f (BotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u4}} {δ : Type.{u3}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] [_inst_3 : Bot.{u4} γ] [_inst_4 : Bot.{u3} δ] (f : BotHom.{u4, u3} γ δ _inst_3 _inst_4) (g : BotHom.{u2, u4} β γ _inst_2 _inst_3) (h : BotHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (BotHom.{u1, u3} α δ _inst_1 _inst_4) (BotHom.comp.{u1, u2, u3} α β δ _inst_1 _inst_2 _inst_4 (BotHom.comp.{u2, u4, u3} β γ δ _inst_2 _inst_3 _inst_4 f g) h) (BotHom.comp.{u1, u4, u3} α γ δ _inst_1 _inst_3 _inst_4 f (BotHom.comp.{u1, u2, u4} α β γ _inst_1 _inst_2 _inst_3 g h))
Case conversion may be inaccurate. Consider using '#align bot_hom.comp_assoc BotHom.comp_assocₓ'. -/
@[simp]
theorem comp_assoc (f : BotHom γ δ) (g : BotHom β γ) (h : BotHom α β) :
    (f.comp g).comp h = f.comp (g.comp h) :=
  rfl
#align bot_hom.comp_assoc BotHom.comp_assoc

/- warning: bot_hom.comp_id -> BotHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] (f : BotHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (BotHom.comp.{u1, u1, u2} α α β _inst_1 _inst_1 _inst_2 f (BotHom.id.{u1} α _inst_1)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Bot.{u2} α] [_inst_2 : Bot.{u1} β] (f : BotHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (BotHom.{u2, u1} α β _inst_1 _inst_2) (BotHom.comp.{u2, u2, u1} α α β _inst_1 _inst_1 _inst_2 f (BotHom.id.{u2} α _inst_1)) f
Case conversion may be inaccurate. Consider using '#align bot_hom.comp_id BotHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : BotHom α β) : f.comp (BotHom.id α) = f :=
  BotHom.ext fun a => rfl
#align bot_hom.comp_id BotHom.comp_id

/- warning: bot_hom.id_comp -> BotHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] (f : BotHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (BotHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_2 (BotHom.id.{u2} β _inst_2) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Bot.{u2} α] [_inst_2 : Bot.{u1} β] (f : BotHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (BotHom.{u2, u1} α β _inst_1 _inst_2) (BotHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_2 (BotHom.id.{u1} β _inst_2) f) f
Case conversion may be inaccurate. Consider using '#align bot_hom.id_comp BotHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : BotHom α β) : (BotHom.id β).comp f = f :=
  BotHom.ext fun a => rfl
#align bot_hom.id_comp BotHom.id_comp

/- warning: bot_hom.cancel_right -> BotHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] [_inst_3 : Bot.{u3} γ] {g₁ : BotHom.{u2, u3} β γ _inst_2 _inst_3} {g₂ : BotHom.{u2, u3} β γ _inst_2 _inst_3} {f : BotHom.{u1, u2} α β _inst_1 _inst_2}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : BotHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (BotHom.{u1, u3} α γ _inst_1 _inst_3) (BotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₁ f) (BotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₂ f)) (Eq.{max (succ u2) (succ u3)} (BotHom.{u2, u3} β γ _inst_2 _inst_3) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u3} β] [_inst_3 : Bot.{u2} γ] {g₁ : BotHom.{u3, u2} β γ _inst_2 _inst_3} {g₂ : BotHom.{u3, u2} β γ _inst_2 _inst_3} {f : BotHom.{u1, u3} α β _inst_1 _inst_2}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BotHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u3, u1, u3} (BotHom.{u1, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (BotHom.instBotHomClassBotHom.{u1, u3} α β _inst_1 _inst_2)) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (BotHom.{u1, u2} α γ _inst_1 _inst_3) (BotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₁ f) (BotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₂ f)) (Eq.{max (succ u3) (succ u2)} (BotHom.{u3, u2} β γ _inst_2 _inst_3) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align bot_hom.cancel_right BotHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : BotHom β γ} {f : BotHom α β} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => BotHom.ext <| hf.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align bot_hom.cancel_right BotHom.cancel_right

/- warning: bot_hom.cancel_left -> BotHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u2} β] [_inst_3 : Bot.{u3} γ] {g : BotHom.{u2, u3} β γ _inst_2 _inst_3} {f₁ : BotHom.{u1, u2} α β _inst_1 _inst_2} {f₂ : BotHom.{u1, u2} α β _inst_1 _inst_2}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : BotHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (BotHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (BotHom.{u1, u3} α γ _inst_1 _inst_3) (BotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f₁) (BotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f₂)) (Eq.{max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 _inst_2) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Bot.{u3} β] [_inst_3 : Bot.{u2} γ] {g : BotHom.{u3, u2} β γ _inst_2 _inst_3} {f₁ : BotHom.{u1, u3} α β _inst_1 _inst_2} {f₂ : BotHom.{u1, u3} α β _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (BotHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : β) => γ) _x) (BotHomClass.toFunLike.{max u3 u2, u3, u2} (BotHom.{u3, u2} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (BotHom.instBotHomClassBotHom.{u3, u2} β γ _inst_2 _inst_3)) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (BotHom.{u1, u2} α γ _inst_1 _inst_3) (BotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f₁) (BotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f₂)) (Eq.{max (succ u1) (succ u3)} (BotHom.{u1, u3} α β _inst_1 _inst_2) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align bot_hom.cancel_left BotHom.cancel_leftₓ'. -/
theorem cancel_left {g : BotHom β γ} {f₁ f₂ : BotHom α β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => BotHom.ext fun a => hg <| by rw [← BotHom.comp_apply, h, BotHom.comp_apply],
    congr_arg _⟩
#align bot_hom.cancel_left BotHom.cancel_left

end Bot

instance [Preorder β] [Bot β] : Preorder (BotHom α β) :=
  Preorder.lift (coeFn : BotHom α β → α → β)

instance [PartialOrder β] [Bot β] : PartialOrder (BotHom α β) :=
  PartialOrder.lift _ FunLike.coe_injective

section OrderBot

variable [Preorder β] [OrderBot β]

instance : OrderBot (BotHom α β) :=
  ⟨⟨⊥, rfl⟩, fun _ => bot_le⟩

/- warning: bot_hom.coe_bot -> BotHom.coe_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : OrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2)], Eq.{succ (max u1 u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), succ (max u1 u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (Bot.bot.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (OrderBot.toHasBot.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (Preorder.toLE.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (BotHom.preorder.{u1, u2} α β _inst_1 _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3))) (BotHom.orderBot.{u1, u2} α β _inst_1 _inst_2 _inst_3)))) (Bot.bot.{max u1 u2} (α -> β) (Pi.hasBot.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Bot.{u2} α] [_inst_2 : Preorder.{u1} β] [_inst_3 : OrderBot.{u1} β (Preorder.toLE.{u1} β _inst_2)], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3)) α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3) (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3))) (Bot.bot.{max u2 u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3)) (OrderBot.toBot.{max u2 u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3)) (Preorder.toLE.{max u2 u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3)) (BotHom.instPreorderBotHom.{u2, u1} α β _inst_1 _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_3))) (BotHom.instOrderBotBotHomToBotToLEToLEInstPreorderBotHom.{u2, u1} α β _inst_1 _inst_2 _inst_3)))) (Bot.bot.{max u2 u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (Pi.instBotForAll.{u2, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (fun (i : α) => OrderBot.toBot.{u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) i) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) i) _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align bot_hom.coe_bot BotHom.coe_botₓ'. -/
@[simp]
theorem coe_bot : ⇑(⊥ : BotHom α β) = ⊥ :=
  rfl
#align bot_hom.coe_bot BotHom.coe_bot

/- warning: bot_hom.bot_apply -> BotHom.bot_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : OrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2)] (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (Bot.bot.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (OrderBot.toHasBot.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (Preorder.toLE.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (BotHom.preorder.{u1, u2} α β _inst_1 _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3))) (BotHom.orderBot.{u1, u2} α β _inst_1 _inst_2 _inst_3))) a) (Bot.bot.{u2} β (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : OrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2)] (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3) (BotHom.instBotHomClassBotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3))) (Bot.bot.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (OrderBot.toBot.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (Preorder.toLE.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3)) (BotHom.instPreorderBotHom.{u1, u2} α β _inst_1 _inst_2 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_3))) (BotHom.instOrderBotBotHomToBotToLEToLEInstPreorderBotHom.{u1, u2} α β _inst_1 _inst_2 _inst_3))) a) (Bot.bot.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) (OrderBot.toBot.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align bot_hom.bot_apply BotHom.bot_applyₓ'. -/
@[simp]
theorem bot_apply (a : α) : (⊥ : BotHom α β) a = ⊥ :=
  rfl
#align bot_hom.bot_apply BotHom.bot_apply

end OrderBot

section SemilatticeInf

variable [SemilatticeInf β] [OrderBot β] (f g : BotHom α β)

instance : HasInf (BotHom α β) :=
  ⟨fun f g => ⟨f ⊓ g, by rw [Pi.inf_apply, map_bot, map_bot, inf_bot_eq]⟩⟩

instance : SemilatticeInf (BotHom α β) :=
  FunLike.coe_injective.SemilatticeInf _ fun _ _ => rfl

/- warning: bot_hom.coe_inf -> BotHom.coe_inf is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] [_inst_3 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))] (f : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (HasInf.inf.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (BotHom.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g)) (HasInf.inf.{max u1 u2} (α -> β) (Pi.hasInf.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeInf.toHasInf.{u2} β _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) g))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Bot.{u2} α] [_inst_2 : SemilatticeInf.{u1} β] [_inst_3 : OrderBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2)))] (f : BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) (g : BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3))) (HasInf.inf.{max u2 u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) (BotHom.instHasInfBotHomToBotToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3) f g)) (HasInf.inf.{max u2 u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (Pi.instHasInfForAll.{u2, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (fun (i : α) => SemilatticeInf.toHasInf.{u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) i) _inst_2)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_2))) _inst_3))) g))
Case conversion may be inaccurate. Consider using '#align bot_hom.coe_inf BotHom.coe_infₓ'. -/
@[simp]
theorem coe_inf : ⇑(f ⊓ g) = f ⊓ g :=
  rfl
#align bot_hom.coe_inf BotHom.coe_inf

/- warning: bot_hom.inf_apply -> BotHom.inf_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] [_inst_3 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))] (f : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (HasInf.inf.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (BotHom.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g) a) (HasInf.inf.{u2} β (SemilatticeInf.toHasInf.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] [_inst_3 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2)))] (f : BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3))) (HasInf.inf.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) (BotHom.instHasInfBotHomToBotToLEToPreorderToPartialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g) a) (HasInf.inf.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) (SemilatticeInf.toHasInf.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3))) f a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_2))) _inst_3))) g a))
Case conversion may be inaccurate. Consider using '#align bot_hom.inf_apply BotHom.inf_applyₓ'. -/
@[simp]
theorem inf_apply (a : α) : (f ⊓ g) a = f a ⊓ g a :=
  rfl
#align bot_hom.inf_apply BotHom.inf_apply

end SemilatticeInf

section SemilatticeSup

variable [SemilatticeSup β] [OrderBot β] (f g : BotHom α β)

instance : HasSup (BotHom α β) :=
  ⟨fun f g => ⟨f ⊔ g, by rw [Pi.sup_apply, map_bot, map_bot, sup_bot_eq]⟩⟩

instance : SemilatticeSup (BotHom α β) :=
  FunLike.coe_injective.SemilatticeSup _ fun _ _ => rfl

/- warning: bot_hom.coe_sup -> BotHom.coe_sup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] [_inst_3 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))] (f : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (HasSup.sup.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (BotHom.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g)) (HasSup.sup.{max u1 u2} (α -> β) (Pi.hasSup.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeSup.toHasSup.{u2} β _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) g))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Bot.{u2} α] [_inst_2 : SemilatticeSup.{u1} β] [_inst_3 : OrderBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2)))] (f : BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) (g : BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3))) (HasSup.sup.{max u2 u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) (BotHom.instHasSupBotHomToBotToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3) f g)) (HasSup.sup.{max u2 u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (Pi.instHasSupForAll.{u2, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (fun (i : α) => SemilatticeSup.toHasSup.{u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) i) _inst_2)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u2, u1} α β _inst_1 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_2))) _inst_3))) g))
Case conversion may be inaccurate. Consider using '#align bot_hom.coe_sup BotHom.coe_supₓ'. -/
@[simp]
theorem coe_sup : ⇑(f ⊔ g) = f ⊔ g :=
  rfl
#align bot_hom.coe_sup BotHom.coe_sup

/- warning: bot_hom.sup_apply -> BotHom.sup_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] [_inst_3 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))] (f : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (HasSup.sup.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (BotHom.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g) a) (HasSup.sup.{u2} β (SemilatticeSup.toHasSup.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (fun (_x : BotHom.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) => α -> β) (BotHom.hasCoeToFun.{u1, u2} α β _inst_1 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Bot.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] [_inst_3 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2)))] (f : BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (g : BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3))) (HasSup.sup.{max u1 u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) (BotHom.instHasSupBotHomToBotToLEToPreorderToPartialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_3) f g) a) (HasSup.sup.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) (SemilatticeSup.toHasSup.{u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) _inst_2) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3))) f a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3)) α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3) (BotHom.instBotHomClassBotHom.{u1, u2} α β _inst_1 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_2))) _inst_3))) g a))
Case conversion may be inaccurate. Consider using '#align bot_hom.sup_apply BotHom.sup_applyₓ'. -/
@[simp]
theorem sup_apply (a : α) : (f ⊔ g) a = f a ⊔ g a :=
  rfl
#align bot_hom.sup_apply BotHom.sup_apply

end SemilatticeSup

instance [Lattice β] [OrderBot β] : Lattice (BotHom α β) :=
  FunLike.coe_injective.Lattice _ (fun _ _ => rfl) fun _ _ => rfl

instance [DistribLattice β] [OrderBot β] : DistribLattice (BotHom α β) :=
  FunLike.coe_injective.DistribLattice _ (fun _ _ => rfl) fun _ _ => rfl

end BotHom

/-! ### Bounded order homomorphisms -/


namespace BoundedOrderHom

variable [Preorder α] [Preorder β] [Preorder γ] [Preorder δ] [BoundedOrder α] [BoundedOrder β]
  [BoundedOrder γ] [BoundedOrder δ]

/- warning: bounded_order_hom.to_top_hom -> BoundedOrderHom.toTopHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)], (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) -> (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)], (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) -> (TopHom.{u1, u2} α β (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.to_top_hom BoundedOrderHom.toTopHomₓ'. -/
/-- Reinterpret a `bounded_order_hom` as a `top_hom`. -/
def toTopHom (f : BoundedOrderHom α β) : TopHom α β :=
  { f with }
#align bounded_order_hom.to_top_hom BoundedOrderHom.toTopHom

/- warning: bounded_order_hom.to_bot_hom -> BoundedOrderHom.toBotHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)], (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) -> (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)], (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) -> (BotHom.{u1, u2} α β (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.to_bot_hom BoundedOrderHom.toBotHomₓ'. -/
/-- Reinterpret a `bounded_order_hom` as a `bot_hom`. -/
def toBotHom (f : BoundedOrderHom α β) : BotHom α β :=
  { f with }
#align bounded_order_hom.to_bot_hom BoundedOrderHom.toBotHom

instance : BoundedOrderHomClass (BoundedOrderHom α β) α β
    where
  coe f := f.toFun
  coe_injective' f g h := by obtain ⟨⟨_, _⟩, _⟩ := f <;> obtain ⟨⟨_, _⟩, _⟩ := g <;> congr
  map_rel f := f.monotone'
  map_top f := f.map_top'
  map_bot f := f.map_bot'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (BoundedOrderHom α β) fun _ => α → β :=
  FunLike.hasCoeToFun

/- warning: bounded_order_hom.to_fun_eq_coe clashes with [anonymous] -> [anonymous]
warning: bounded_order_hom.to_fun_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] {f : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6}, Eq.{max (succ u1) (succ u2)} (α -> β) (OrderHom.toFun.{u1, u2} α β _inst_1 _inst_2 (BoundedOrderHom.toOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6 f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedOrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}}, (Nat -> α -> β) -> Nat -> (List.{u1} α) -> (List.{u2} β)
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.to_fun_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] {f : BoundedOrderHom α β} : f.toFun = (f : α → β) :=
  rfl
#align bounded_order_hom.to_fun_eq_coe [anonymous]

/- warning: bounded_order_hom.ext -> BoundedOrderHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] {f : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6} {g : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedOrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedOrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) g a)) -> (Eq.{max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α _inst_1)] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β _inst_2)] {f : BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6} {g : BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toBot.{u2} α (Preorder.toLE.{u2} α _inst_1) (BoundedOrder.toOrderBot.{u2} α (Preorder.toLE.{u2} α _inst_1) _inst_5)) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) (BoundedOrder.toOrderBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u2 u1, u2, u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toBot.{u2} α (Preorder.toLE.{u2} α _inst_1) (BoundedOrder.toOrderBot.{u2} α (Preorder.toLE.{u2} α _inst_1) _inst_5)) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) (BoundedOrder.toOrderBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u2 u1, u2, u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6))) g a)) -> (Eq.{max (succ u2) (succ u1)} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) f g)
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.ext BoundedOrderHom.extₓ'. -/
@[ext]
theorem ext {f g : BoundedOrderHom α β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align bounded_order_hom.ext BoundedOrderHom.ext

/- warning: bounded_order_hom.copy -> BoundedOrderHom.copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] (f : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedOrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f)) -> (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] (f : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6))) f)) -> (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.copy BoundedOrderHom.copyₓ'. -/
/-- Copy of a `bounded_order_hom` with a new `to_fun` equal to the old one. Useful to fix
definitional equalities. -/
protected def copy (f : BoundedOrderHom α β) (f' : α → β) (h : f' = f) : BoundedOrderHom α β :=
  { f.toOrderHom.copy f' h, f.toTopHom.copy f' h, f.toBotHom.copy f' h with }
#align bounded_order_hom.copy BoundedOrderHom.copy

/- warning: bounded_order_hom.coe_copy -> BoundedOrderHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] (f : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedOrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedOrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedOrderHom.copy.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α _inst_1)] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β _inst_2)] (f : BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toBot.{u2} α (Preorder.toLE.{u2} α _inst_1) (BoundedOrder.toOrderBot.{u2} α (Preorder.toLE.{u2} α _inst_1) _inst_5)) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) (BoundedOrder.toOrderBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u2 u1, u2, u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6))) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toBot.{u2} α (Preorder.toLE.{u2} α _inst_1) (BoundedOrder.toOrderBot.{u2} α (Preorder.toLE.{u2} α _inst_1) _inst_5)) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) (BoundedOrder.toOrderBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u2 u1, u2, u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6))) (BoundedOrderHom.copy.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.coe_copy BoundedOrderHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : BoundedOrderHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align bounded_order_hom.coe_copy BoundedOrderHom.coe_copy

/- warning: bounded_order_hom.copy_eq -> BoundedOrderHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] (f : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedOrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f)), Eq.{max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedOrderHom.copy.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α _inst_1)] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β _inst_2)] (f : BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toBot.{u2} α (Preorder.toLE.{u2} α _inst_1) (BoundedOrder.toOrderBot.{u2} α (Preorder.toLE.{u2} α _inst_1) _inst_5)) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β _inst_2) (BoundedOrder.toOrderBot.{u1} β (Preorder.toLE.{u1} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u2 u1, u2, u1} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u2} α _inst_1) (Preorder.toLE.{u1} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6))) f)), Eq.{max (succ u2) (succ u1)} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedOrderHom.copy.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6 f f' h) f
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.copy_eq BoundedOrderHom.copy_eqₓ'. -/
theorem copy_eq (f : BoundedOrderHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align bounded_order_hom.copy_eq BoundedOrderHom.copy_eq

variable (α)

#print BoundedOrderHom.id /-
/-- `id` as a `bounded_order_hom`. -/
protected def id : BoundedOrderHom α α :=
  { OrderHom.id, TopHom.id α, BotHom.id α with }
#align bounded_order_hom.id BoundedOrderHom.id
-/

instance : Inhabited (BoundedOrderHom α α) :=
  ⟨BoundedOrderHom.id α⟩

/- warning: bounded_order_hom.coe_id -> BoundedOrderHom.coe_id is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : Preorder.{u1} α] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (BoundedOrderHom.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) (fun (_x : BoundedOrderHom.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) => α -> α) (BoundedOrderHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) (BoundedOrderHom.id.{u1} α _inst_1 _inst_5)) (id.{succ u1} α)
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : Preorder.{u1} α] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (BoundedOrderHom.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => α) _x) (BotHomClass.toFunLike.{u1, u1, u1} (BoundedOrderHom.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) α α (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (BoundedOrderHomClass.toBotHomClass.{u1, u1, u1} (BoundedOrderHom.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) α α (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u1} α _inst_1) _inst_5 _inst_5 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5))) (BoundedOrderHom.id.{u1} α _inst_1 _inst_5)) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.coe_id BoundedOrderHom.coe_idₓ'. -/
@[simp]
theorem coe_id : ⇑(BoundedOrderHom.id α) = id :=
  rfl
#align bounded_order_hom.coe_id BoundedOrderHom.coe_id

variable {α}

/- warning: bounded_order_hom.id_apply -> BoundedOrderHom.id_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Preorder.{u1} α] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (BoundedOrderHom.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) (fun (_x : BoundedOrderHom.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) => α -> α) (BoundedOrderHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) (BoundedOrderHom.id.{u1} α _inst_1 _inst_5) a) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Preorder.{u1} α] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (BoundedOrderHom.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => α) _x) (BotHomClass.toFunLike.{u1, u1, u1} (BoundedOrderHom.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) α α (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (BoundedOrderHomClass.toBotHomClass.{u1, u1, u1} (BoundedOrderHom.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5) α α (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u1} α _inst_1) _inst_5 _inst_5 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u1} α α _inst_1 _inst_1 _inst_5 _inst_5))) (BoundedOrderHom.id.{u1} α _inst_1 _inst_5) a) a
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.id_apply BoundedOrderHom.id_applyₓ'. -/
@[simp]
theorem id_apply (a : α) : BoundedOrderHom.id α a = a :=
  rfl
#align bounded_order_hom.id_apply BoundedOrderHom.id_apply

#print BoundedOrderHom.comp /-
/-- Composition of `bounded_order_hom`s as a `bounded_order_hom`. -/
def comp (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) : BoundedOrderHom α γ :=
  { f.toOrderHom.comp g.toOrderHom, f.toTopHom.comp g.toTopHom, f.toBotHom.comp g.toBotHom with }
#align bounded_order_hom.comp BoundedOrderHom.comp
-/

/- warning: bounded_order_hom.coe_comp -> BoundedOrderHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_3)] (f : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} ((fun (_x : BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) => α -> γ) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (fun (_x : BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) => α -> γ) (BoundedOrderHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (fun (_x : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) => β -> γ) (BoundedOrderHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedOrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_2)] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_3)] (f : BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => γ) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toBotHomClass.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} γ _inst_3) _inst_5 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7))) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : β) => γ) _x) (BotHomClass.toFunLike.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (OrderBot.toBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toBotHomClass.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Preorder.toLE.{u3} β _inst_2) (Preorder.toLE.{u2} γ _inst_3) _inst_6 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7))) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6))) g))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.coe_comp BoundedOrderHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) : (f.comp g : α → γ) = f ∘ g :=
  rfl
#align bounded_order_hom.coe_comp BoundedOrderHom.coe_comp

/- warning: bounded_order_hom.comp_apply -> BoundedOrderHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_3)] (f : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (fun (_x : BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) => α -> γ) (BoundedOrderHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (fun (_x : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) => β -> γ) (BoundedOrderHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedOrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_2)] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_3)] (f : BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => γ) _x) (BotHomClass.toFunLike.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toBotHomClass.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} γ _inst_3) _inst_5 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7))) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : β) => γ) _x) (BotHomClass.toFunLike.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (OrderBot.toBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toBotHomClass.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Preorder.toLE.{u3} β _inst_2) (Preorder.toLE.{u2} γ _inst_3) _inst_6 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7))) f (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6))) g a))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.comp_apply BoundedOrderHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) (a : α) :
    (f.comp g) a = f (g a) :=
  rfl
#align bounded_order_hom.comp_apply BoundedOrderHom.comp_apply

/- warning: bounded_order_hom.coe_comp_order_hom -> BoundedOrderHom.coe_comp_order_hom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_3)] (f : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} (OrderHom.{u1, u3} α γ _inst_1 _inst_3) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (OrderHom.{u1, u3} α γ _inst_1 _inst_3) (OrderHomClass.OrderHom.hasCoeT.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 (BoundedOrderHomClass.toRelHomClass.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} γ _inst_3) _inst_5 _inst_7 (BoundedOrderHom.boundedOrderHomClass.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7))))) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (OrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (OrderHom.{u2, u3} β γ _inst_2 _inst_3) (OrderHomClass.OrderHom.hasCoeT.{max u2 u3, u2, u3} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 (BoundedOrderHomClass.toRelHomClass.{max u2 u3, u2, u3} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Preorder.toLE.{u2} β _inst_2) (Preorder.toLE.{u3} γ _inst_3) _inst_6 _inst_7 (BoundedOrderHom.boundedOrderHomClass.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7))))) f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (OrderHom.{u1, u2} α β _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (OrderHom.{u1, u2} α β _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (OrderHom.{u1, u2} α β _inst_1 _inst_2) (OrderHomClass.OrderHom.hasCoeT.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 (BoundedOrderHomClass.toRelHomClass.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.boundedOrderHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6))))) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_2)] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_3)] (f : BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (OrderHom.{u1, u2} α γ _inst_1 _inst_3) (OrderHomClass.toOrderHom.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 (BoundedOrderHomClass.toRelHomClass.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} γ _inst_3) _inst_5 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7)) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (OrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 (OrderHomClass.toOrderHom.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 (BoundedOrderHomClass.toRelHomClass.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Preorder.toLE.{u3} β _inst_2) (Preorder.toLE.{u2} γ _inst_3) _inst_6 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)) f) (OrderHomClass.toOrderHom.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 (BoundedOrderHomClass.toRelHomClass.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)) g))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.coe_comp_order_hom BoundedOrderHom.coe_comp_order_homₓ'. -/
@[simp]
theorem coe_comp_order_hom (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) :
    (f.comp g : OrderHom α γ) = (f : OrderHom β γ).comp g :=
  rfl
#align bounded_order_hom.coe_comp_order_hom BoundedOrderHom.coe_comp_order_hom

/- warning: bounded_order_hom.coe_comp_top_hom -> BoundedOrderHom.coe_comp_top_hom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_3)] (f : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (TopHom.hasCoeT.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toTopHomClass.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} γ _inst_3) _inst_5 _inst_7 (BoundedOrderHom.boundedOrderHomClass.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7))))) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (TopHom.comp.{u1, u2, u3} α β γ (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (OrderTop.toHasTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (OrderTop.toHasTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (OrderTop.toHasTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (OrderTop.toHasTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (TopHom.hasCoeT.{max u2 u3, u2, u3} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (OrderTop.toHasTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderTop.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toTopHomClass.{max u2 u3, u2, u3} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Preorder.toLE.{u2} β _inst_2) (Preorder.toLE.{u3} γ _inst_3) _inst_6 _inst_7 (BoundedOrderHom.boundedOrderHomClass.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7))))) f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6))) (TopHom.hasCoeT.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (BoundedOrderHomClass.toTopHomClass.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.boundedOrderHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6))))) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_2)] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_3)] (f : BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7))) (TopHomClass.toTopHom.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toTopHomClass.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} γ _inst_3) _inst_5 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7)) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (TopHom.comp.{u1, u3, u2} α β γ (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (TopHomClass.toTopHom.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toTopHomClass.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Preorder.toLE.{u3} β _inst_2) (Preorder.toLE.{u2} γ _inst_3) _inst_6 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)) f) (TopHomClass.toTopHom.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (BoundedOrderHomClass.toTopHomClass.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)) g))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.coe_comp_top_hom BoundedOrderHom.coe_comp_top_homₓ'. -/
@[simp]
theorem coe_comp_top_hom (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) :
    (f.comp g : TopHom α γ) = (f : TopHom β γ).comp g :=
  rfl
#align bounded_order_hom.coe_comp_top_hom BoundedOrderHom.coe_comp_top_hom

/- warning: bounded_order_hom.coe_comp_bot_hom -> BoundedOrderHom.coe_comp_bot_hom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_3)] (f : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (BotHom.hasCoeT.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toBotHomClass.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} γ _inst_3) _inst_5 _inst_7 (BoundedOrderHom.boundedOrderHomClass.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7))))) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (BotHom.comp.{u1, u2, u3} α β γ (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (OrderBot.toHasBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (OrderBot.toHasBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (OrderBot.toHasBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (OrderBot.toHasBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7))) (BotHom.hasCoeT.{max u2 u3, u2, u3} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (OrderBot.toHasBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) (BoundedOrder.toOrderBot.{u3} γ (Preorder.toLE.{u3} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toBotHomClass.{max u2 u3, u2, u3} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Preorder.toLE.{u2} β _inst_2) (Preorder.toLE.{u3} γ _inst_3) _inst_6 _inst_7 (BoundedOrderHom.boundedOrderHomClass.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7))))) f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6))) (BotHom.hasCoeT.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β _inst_2) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.boundedOrderHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6))))) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_2)] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_3)] (f : BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7))) (BotHomClass.toBotHom.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toBotHomClass.{max u1 u2, u1, u2} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u2} γ _inst_3) _inst_5 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7)) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (BotHom.comp.{u1, u3, u2} α β γ (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (OrderBot.toBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (BotHomClass.toBotHom.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (OrderBot.toBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toBotHomClass.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Preorder.toLE.{u3} β _inst_2) (Preorder.toLE.{u2} γ _inst_3) _inst_6 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)) f) (BotHomClass.toBotHom.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)) g))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.coe_comp_bot_hom BoundedOrderHom.coe_comp_bot_homₓ'. -/
@[simp]
theorem coe_comp_bot_hom (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) :
    (f.comp g : BotHom α γ) = (f : BotHom β γ).comp g :=
  rfl
#align bounded_order_hom.coe_comp_bot_hom BoundedOrderHom.coe_comp_bot_hom

/- warning: bounded_order_hom.comp_assoc -> BoundedOrderHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] [_inst_4 : Preorder.{u4} δ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_3)] [_inst_8 : BoundedOrder.{u4} δ (Preorder.toLE.{u4} δ _inst_4)] (f : BoundedOrderHom.{u3, u4} γ δ _inst_3 _inst_4 _inst_7 _inst_8) (g : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (h : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u4)} (BoundedOrderHom.{u1, u4} α δ _inst_1 _inst_4 _inst_5 _inst_8) (BoundedOrderHom.comp.{u1, u2, u4} α β δ _inst_1 _inst_2 _inst_4 _inst_5 _inst_6 _inst_8 (BoundedOrderHom.comp.{u2, u3, u4} β γ δ _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g) h) (BoundedOrderHom.comp.{u1, u3, u4} α γ δ _inst_1 _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 f (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u4}} {δ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u4} γ] [_inst_4 : Preorder.{u3} δ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] [_inst_7 : BoundedOrder.{u4} γ (Preorder.toLE.{u4} γ _inst_3)] [_inst_8 : BoundedOrder.{u3} δ (Preorder.toLE.{u3} δ _inst_4)] (f : BoundedOrderHom.{u4, u3} γ δ _inst_3 _inst_4 _inst_7 _inst_8) (g : BoundedOrderHom.{u2, u4} β γ _inst_2 _inst_3 _inst_6 _inst_7) (h : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α δ _inst_1 _inst_4 _inst_5 _inst_8) (BoundedOrderHom.comp.{u1, u2, u3} α β δ _inst_1 _inst_2 _inst_4 _inst_5 _inst_6 _inst_8 (BoundedOrderHom.comp.{u2, u4, u3} β γ δ _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g) h) (BoundedOrderHom.comp.{u1, u4, u3} α γ δ _inst_1 _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 f (BoundedOrderHom.comp.{u1, u2, u4} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g h))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.comp_assoc BoundedOrderHom.comp_assocₓ'. -/
@[simp]
theorem comp_assoc (f : BoundedOrderHom γ δ) (g : BoundedOrderHom β γ) (h : BoundedOrderHom α β) :
    (f.comp g).comp h = f.comp (g.comp h) :=
  rfl
#align bounded_order_hom.comp_assoc BoundedOrderHom.comp_assoc

/- warning: bounded_order_hom.comp_id -> BoundedOrderHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] (f : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedOrderHom.comp.{u1, u1, u2} α α β _inst_1 _inst_1 _inst_2 _inst_5 _inst_5 _inst_6 f (BoundedOrderHom.id.{u1} α _inst_1 _inst_5)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α _inst_1)] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β _inst_2)] (f : BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u2) (succ u1)} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedOrderHom.comp.{u2, u2, u1} α α β _inst_1 _inst_1 _inst_2 _inst_5 _inst_5 _inst_6 f (BoundedOrderHom.id.{u2} α _inst_1 _inst_5)) f
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.comp_id BoundedOrderHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : BoundedOrderHom α β) : f.comp (BoundedOrderHom.id α) = f :=
  BoundedOrderHom.ext fun a => rfl
#align bounded_order_hom.comp_id BoundedOrderHom.comp_id

/- warning: bounded_order_hom.id_comp -> BoundedOrderHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] (f : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedOrderHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_2 _inst_5 _inst_6 _inst_6 (BoundedOrderHom.id.{u2} β _inst_2 _inst_6) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α _inst_1)] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β _inst_2)] (f : BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u2) (succ u1)} (BoundedOrderHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedOrderHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_2 _inst_5 _inst_6 _inst_6 (BoundedOrderHom.id.{u1} β _inst_2 _inst_6) f) f
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.id_comp BoundedOrderHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : BoundedOrderHom α β) : (BoundedOrderHom.id β).comp f = f :=
  BoundedOrderHom.ext fun a => rfl
#align bounded_order_hom.id_comp BoundedOrderHom.id_comp

/- warning: bounded_order_hom.cancel_right -> BoundedOrderHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_3)] {g₁ : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7} {g₂ : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7} {f : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedOrderHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g₁ f) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g₂ f)) (Eq.{max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_2)] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_3)] {g₁ : BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7} {g₂ : BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7} {f : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : α) => β) _x) (BotHomClass.toFunLike.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α _inst_1) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_5)) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (BoundedOrderHomClass.toBotHomClass.{max u1 u3, u1, u3} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Preorder.toLE.{u1} α _inst_1) (Preorder.toLE.{u3} β _inst_2) _inst_5 _inst_6 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6))) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g₁ f) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g₂ f)) (Eq.{max (succ u3) (succ u2)} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.cancel_right BoundedOrderHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : BoundedOrderHom β γ} {f : BoundedOrderHom α β} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => BoundedOrderHom.ext <| hf.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align bounded_order_hom.cancel_right BoundedOrderHom.cancel_right

/- warning: bounded_order_hom.cancel_left -> BoundedOrderHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] [_inst_3 : Preorder.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_2)] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_3)] {g : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7} {f₁ : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6} {f₂ : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (fun (_x : BoundedOrderHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) => β -> γ) (BoundedOrderHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g f₁) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g f₂)) (Eq.{max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u3} β] [_inst_3 : Preorder.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_2)] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_3)] {g : BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7} {f₁ : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6} {f₂ : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Bounded._hyg.287 : β) => γ) _x) (BotHomClass.toFunLike.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β _inst_2) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β _inst_2) _inst_6)) (OrderBot.toBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) (BoundedOrder.toOrderBot.{u2} γ (Preorder.toLE.{u2} γ _inst_3) _inst_7)) (BoundedOrderHomClass.toBotHomClass.{max u3 u2, u3, u2} (BoundedOrderHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Preorder.toLE.{u3} β _inst_2) (Preorder.toLE.{u2} γ _inst_3) _inst_6 _inst_7 (BoundedOrderHom.instBoundedOrderHomClassBoundedOrderHomToLEToLE.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7))) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g f₁) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g f₂)) (Eq.{max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.cancel_left BoundedOrderHom.cancel_leftₓ'. -/
theorem cancel_left {g : BoundedOrderHom β γ} {f₁ f₂ : BoundedOrderHom α β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h =>
    BoundedOrderHom.ext fun a =>
      hg <| by rw [← BoundedOrderHom.comp_apply, h, BoundedOrderHom.comp_apply],
    congr_arg _⟩
#align bounded_order_hom.cancel_left BoundedOrderHom.cancel_left

end BoundedOrderHom

/-! ### Dual homs -/


namespace TopHom

variable [LE α] [OrderTop α] [LE β] [OrderTop β] [LE γ] [OrderTop γ]

/- warning: top_hom.dual -> TopHom.dual is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderTop.{u1} α _inst_1] [_inst_3 : LE.{u2} β] [_inst_4 : OrderTop.{u2} β _inst_3], Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderTop.{u1} α _inst_1] [_inst_3 : LE.{u2} β] [_inst_4 : OrderTop.{u2} β _inst_3], Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (TopHom.{u1, u2} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} β _inst_3 _inst_4)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} β (OrderTop.toTop.{u2} β _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align top_hom.dual TopHom.dualₓ'. -/
/-- Reinterpret a top homomorphism as a bot homomorphism between the dual lattices. -/
@[simps]
protected def dual : TopHom α β ≃ BotHom αᵒᵈ βᵒᵈ
    where
  toFun f := ⟨f, f.map_top'⟩
  invFun f := ⟨f, f.map_bot'⟩
  left_inv f := TopHom.ext fun _ => rfl
  right_inv f := BotHom.ext fun _ => rfl
#align top_hom.dual TopHom.dual

/- warning: top_hom.dual_id -> TopHom.dual_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderTop.{u1} α _inst_1], Eq.{succ u1} (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (TopHom.{u1, u1} α α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)))) (fun (_x : Equiv.{succ u1, succ u1} (TopHom.{u1, u1} α α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)))) => (TopHom.{u1, u1} α α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) -> (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)))) (Equiv.hasCoeToFun.{succ u1, succ u1} (TopHom.{u1, u1} α α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)))) (TopHom.dual.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (TopHom.id.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) (BotHom.id.{u1} (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderTop.{u1} α _inst_1], Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) => BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (TopHom.id.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)))) (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (fun (_x : TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) => BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)))) (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)))) (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)))))) (TopHom.dual.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (TopHom.id.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (BotHom.id.{u1} (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align top_hom.dual_id TopHom.dual_idₓ'. -/
@[simp]
theorem dual_id : (TopHom.id α).dual = BotHom.id _ :=
  rfl
#align top_hom.dual_id TopHom.dual_id

/- warning: top_hom.dual_comp -> TopHom.dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderTop.{u1} α _inst_1] [_inst_3 : LE.{u2} β] [_inst_4 : OrderTop.{u2} β _inst_3] [_inst_5 : LE.{u3} γ] [_inst_6 : OrderTop.{u3} γ _inst_5] (g : TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (f : TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)), Eq.{max (succ u1) (succ u3)} (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)))) => (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) -> (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)))) (TopHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (TopHom.comp.{u1, u2, u3} α β γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6) g f)) (BotHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (BotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (BotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)))) => (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) -> (BotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (BotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)))) (TopHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)))) => (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) -> (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)))) (TopHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderTop.{u1} α _inst_1] [_inst_3 : LE.{u3} β] [_inst_4 : OrderTop.{u3} β _inst_3] [_inst_5 : LE.{u2} γ] [_inst_6 : OrderTop.{u2} γ _inst_5] (g : TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (f : TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) => BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.comp.{u1, u3, u2} α β γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)))) (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (fun (_x : TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) => BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)))) (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)))) (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)))))) (TopHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (TopHom.comp.{u1, u3, u2} α β γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6) g f)) (BotHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)))) (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (fun (_x : TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) => BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)))) (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)))) (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)))))) (TopHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)))) (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (fun (_x : TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) => BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)))) (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)))) (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (Equiv.instEquivLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)))))) (TopHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
Case conversion may be inaccurate. Consider using '#align top_hom.dual_comp TopHom.dual_compₓ'. -/
@[simp]
theorem dual_comp (g : TopHom β γ) (f : TopHom α β) : (g.comp f).dual = g.dual.comp f.dual :=
  rfl
#align top_hom.dual_comp TopHom.dual_comp

/- warning: top_hom.symm_dual_id -> TopHom.symm_dual_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderTop.{u1} α _inst_1], Eq.{succ u1} (TopHom.{u1, u1} α α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} α α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) (fun (_x : Equiv.{succ u1, succ u1} (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} α α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) => (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) -> (TopHom.{u1, u1} α α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) (Equiv.hasCoeToFun.{succ u1, succ u1} (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} α α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) (Equiv.symm.{succ u1, succ u1} (TopHom.{u1, u1} α α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))) (TopHom.dual.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2)) (BotHom.id.{u1} (OrderDual.{u1} α) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)))) (TopHom.id.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderTop.{u1} α _inst_1], Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) => TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (BotHom.id.{u1} (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (fun (_x : BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) => TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2))))) (Equiv.symm.{succ u1, succ u1} (TopHom.{u1, u1} α α (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (BotHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))) (TopHom.dual.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2)) (BotHom.id.{u1} (OrderDual.{u1} α) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)))) (TopHom.id.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align top_hom.symm_dual_id TopHom.symm_dual_idₓ'. -/
@[simp]
theorem symm_dual_id : TopHom.dual.symm (BotHom.id _) = TopHom.id α :=
  rfl
#align top_hom.symm_dual_id TopHom.symm_dual_id

/- warning: top_hom.symm_dual_comp -> TopHom.symm_dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderTop.{u1} α _inst_1] [_inst_3 : LE.{u2} β] [_inst_4 : OrderTop.{u2} β _inst_3] [_inst_5 : LE.{u3} γ] [_inst_6 : OrderTop.{u3} γ _inst_5] (g : BotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (f : BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4))), Eq.{max (succ u1) (succ u3)} (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) => (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) -> (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (Equiv.symm.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (TopHom.{u1, u3} α γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (TopHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (BotHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) g f)) (TopHom.comp.{u1, u2, u3} α β γ (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) => (BotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) -> (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u2, u3} β γ (OrderTop.toHasTop.{u2} β _inst_3 _inst_4) (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6)) (BotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (OrderDual.hasBot.{u3} γ (OrderTop.toHasTop.{u3} γ _inst_5 _inst_6))) (TopHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4))) (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4))) (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4))) => (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4))) -> (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4))) (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} α β (OrderTop.toHasTop.{u1} α _inst_1 _inst_2) (OrderTop.toHasTop.{u2} β _inst_3 _inst_4)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasBot.{u1} α (OrderTop.toHasTop.{u1} α _inst_1 _inst_2)) (OrderDual.hasBot.{u2} β (OrderTop.toHasTop.{u2} β _inst_3 _inst_4))) (TopHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderTop.{u1} α _inst_1] [_inst_3 : LE.{u3} β] [_inst_4 : OrderTop.{u3} β _inst_3] [_inst_5 : LE.{u2} γ] [_inst_6 : OrderTop.{u2} γ _inst_5] (g : BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (f : BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) => TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (fun (_x : BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) => TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6))))) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (TopHom.{u1, u2} α γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (BotHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) g f)) (TopHom.comp.{u1, u3, u2} α β γ (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (fun (_x : BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) => TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6))))) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u3, u2} β γ (OrderTop.toTop.{u3} β _inst_3 _inst_4) (OrderTop.toTop.{u2} γ _inst_5 _inst_6)) (BotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (OrderDual.bot.{u2} γ (OrderTop.toTop.{u2} γ _inst_5 _inst_6))) (TopHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (fun (_x : BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) => TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (Equiv.instEquivLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4))))) (Equiv.symm.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (TopHom.{u1, u3} α β (OrderTop.toTop.{u1} α _inst_1 _inst_2) (OrderTop.toTop.{u3} β _inst_3 _inst_4)) (BotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.bot.{u1} α (OrderTop.toTop.{u1} α _inst_1 _inst_2)) (OrderDual.bot.{u3} β (OrderTop.toTop.{u3} β _inst_3 _inst_4))) (TopHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
Case conversion may be inaccurate. Consider using '#align top_hom.symm_dual_comp TopHom.symm_dual_compₓ'. -/
@[simp]
theorem symm_dual_comp (g : BotHom βᵒᵈ γᵒᵈ) (f : BotHom αᵒᵈ βᵒᵈ) :
    TopHom.dual.symm (g.comp f) = (TopHom.dual.symm g).comp (TopHom.dual.symm f) :=
  rfl
#align top_hom.symm_dual_comp TopHom.symm_dual_comp

end TopHom

namespace BotHom

variable [LE α] [OrderBot α] [LE β] [OrderBot β] [LE γ] [OrderBot γ]

/- warning: bot_hom.dual -> BotHom.dual is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1] [_inst_3 : LE.{u2} β] [_inst_4 : OrderBot.{u2} β _inst_3], Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1] [_inst_3 : LE.{u2} β] [_inst_4 : OrderBot.{u2} β _inst_3], Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BotHom.{u1, u2} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} β _inst_3 _inst_4)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} β (OrderBot.toBot.{u2} β _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align bot_hom.dual BotHom.dualₓ'. -/
/-- Reinterpret a bot homomorphism as a top homomorphism between the dual lattices. -/
@[simps]
protected def dual : BotHom α β ≃ TopHom αᵒᵈ βᵒᵈ
    where
  toFun f := ⟨f, f.map_bot'⟩
  invFun f := ⟨f, f.map_top'⟩
  left_inv f := BotHom.ext fun _ => rfl
  right_inv f := TopHom.ext fun _ => rfl
#align bot_hom.dual BotHom.dual

/- warning: bot_hom.dual_id -> BotHom.dual_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1], Eq.{succ u1} (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (BotHom.{u1, u1} α α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)))) (fun (_x : Equiv.{succ u1, succ u1} (BotHom.{u1, u1} α α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)))) => (BotHom.{u1, u1} α α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) -> (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)))) (Equiv.hasCoeToFun.{succ u1, succ u1} (BotHom.{u1, u1} α α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)))) (BotHom.dual.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (BotHom.id.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) (TopHom.id.{u1} (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1], Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) => TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (BotHom.id.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)))) (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (fun (_x : BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) => TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)))) (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)))) (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)))))) (BotHom.dual.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (BotHom.id.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (TopHom.id.{u1} (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)))
Case conversion may be inaccurate. Consider using '#align bot_hom.dual_id BotHom.dual_idₓ'. -/
@[simp]
theorem dual_id : (BotHom.id α).dual = TopHom.id _ :=
  rfl
#align bot_hom.dual_id BotHom.dual_id

/- warning: bot_hom.dual_comp -> BotHom.dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1] [_inst_3 : LE.{u2} β] [_inst_4 : OrderBot.{u2} β _inst_3] [_inst_5 : LE.{u3} γ] [_inst_6 : OrderBot.{u3} γ _inst_5] (g : BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (f : BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)), Eq.{max (succ u1) (succ u3)} (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)))) => (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) -> (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)))) (BotHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (BotHom.comp.{u1, u2, u3} α β γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6) g f)) (TopHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (TopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (TopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)))) => (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) -> (TopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (TopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)))) (BotHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)))) => (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) -> (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)))) (BotHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1] [_inst_3 : LE.{u3} β] [_inst_4 : OrderBot.{u3} β _inst_3] [_inst_5 : LE.{u2} γ] [_inst_6 : OrderBot.{u2} γ _inst_5] (g : BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (f : BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) => TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.comp.{u1, u3, u2} α β γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)))) (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (fun (_x : BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) => TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)))) (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)))) (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)))))) (BotHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (BotHom.comp.{u1, u3, u2} α β γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6) g f)) (TopHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)))) (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (fun (_x : BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) => TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)))) (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)))) (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)))))) (BotHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)))) (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (fun (_x : BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) => TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)))) (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)))) (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (Equiv.instEquivLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)))))) (BotHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
Case conversion may be inaccurate. Consider using '#align bot_hom.dual_comp BotHom.dual_compₓ'. -/
@[simp]
theorem dual_comp (g : BotHom β γ) (f : BotHom α β) : (g.comp f).dual = g.dual.comp f.dual :=
  rfl
#align bot_hom.dual_comp BotHom.dual_comp

/- warning: bot_hom.symm_dual_id -> BotHom.symm_dual_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1], Eq.{succ u1} (BotHom.{u1, u1} α α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} α α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) (fun (_x : Equiv.{succ u1, succ u1} (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} α α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) => (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) -> (BotHom.{u1, u1} α α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) (Equiv.hasCoeToFun.{succ u1, succ u1} (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} α α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) (Equiv.symm.{succ u1, succ u1} (BotHom.{u1, u1} α α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))) (BotHom.dual.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2)) (TopHom.id.{u1} (OrderDual.{u1} α) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)))) (BotHom.id.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1], Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) => BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (TopHom.id.{u1} (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (fun (_x : TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) => BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (Equiv.instEquivLikeEquiv.{succ u1, succ u1} (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2))))) (Equiv.symm.{succ u1, succ u1} (BotHom.{u1, u1} α α (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (TopHom.{u1, u1} (OrderDual.{u1} α) (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))) (BotHom.dual.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2)) (TopHom.id.{u1} (OrderDual.{u1} α) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)))) (BotHom.id.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2))
Case conversion may be inaccurate. Consider using '#align bot_hom.symm_dual_id BotHom.symm_dual_idₓ'. -/
@[simp]
theorem symm_dual_id : BotHom.dual.symm (TopHom.id _) = BotHom.id α :=
  rfl
#align bot_hom.symm_dual_id BotHom.symm_dual_id

/- warning: bot_hom.symm_dual_comp -> BotHom.symm_dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1] [_inst_3 : LE.{u2} β] [_inst_4 : OrderBot.{u2} β _inst_3] [_inst_5 : LE.{u3} γ] [_inst_6 : OrderBot.{u3} γ _inst_5] (g : TopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (f : TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4))), Eq.{max (succ u1) (succ u3)} (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) => (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) -> (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (Equiv.symm.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BotHom.{u1, u3} α γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (BotHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (TopHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) g f)) (BotHom.comp.{u1, u2, u3} α β γ (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) => (TopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) -> (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u2, u3} β γ (OrderBot.toHasBot.{u2} β _inst_3 _inst_4) (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6)) (TopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (OrderDual.hasTop.{u3} γ (OrderBot.toHasBot.{u3} γ _inst_5 _inst_6))) (BotHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4))) (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4))) (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4))) => (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4))) -> (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4))) (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4))) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BotHom.{u1, u2} α β (OrderBot.toHasBot.{u1} α _inst_1 _inst_2) (OrderBot.toHasBot.{u2} β _inst_3 _inst_4)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasTop.{u1} α (OrderBot.toHasBot.{u1} α _inst_1 _inst_2)) (OrderDual.hasTop.{u2} β (OrderBot.toHasBot.{u2} β _inst_3 _inst_4))) (BotHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : LE.{u1} α] [_inst_2 : OrderBot.{u1} α _inst_1] [_inst_3 : LE.{u3} β] [_inst_4 : OrderBot.{u3} β _inst_3] [_inst_5 : LE.{u2} γ] [_inst_6 : OrderBot.{u2} γ _inst_5] (g : TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (f : TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) => BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (fun (_x : TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) => BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6))))) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BotHom.{u1, u2} α γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (TopHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) g f)) (BotHom.comp.{u1, u3, u2} α β γ (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (fun (_x : TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) => BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6))))) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BotHom.{u3, u2} β γ (OrderBot.toBot.{u3} β _inst_3 _inst_4) (OrderBot.toBot.{u2} γ _inst_5 _inst_6)) (TopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (OrderDual.top.{u2} γ (OrderBot.toBot.{u2} γ _inst_5 _inst_6))) (BotHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (fun (_x : TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) => BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (Equiv.instEquivLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4))))) (Equiv.symm.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BotHom.{u1, u3} α β (OrderBot.toBot.{u1} α _inst_1 _inst_2) (OrderBot.toBot.{u3} β _inst_3 _inst_4)) (TopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.top.{u1} α (OrderBot.toBot.{u1} α _inst_1 _inst_2)) (OrderDual.top.{u3} β (OrderBot.toBot.{u3} β _inst_3 _inst_4))) (BotHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
Case conversion may be inaccurate. Consider using '#align bot_hom.symm_dual_comp BotHom.symm_dual_compₓ'. -/
@[simp]
theorem symm_dual_comp (g : TopHom βᵒᵈ γᵒᵈ) (f : TopHom αᵒᵈ βᵒᵈ) :
    BotHom.dual.symm (g.comp f) = (BotHom.dual.symm g).comp (BotHom.dual.symm f) :=
  rfl
#align bot_hom.symm_dual_comp BotHom.symm_dual_comp

end BotHom

namespace BoundedOrderHom

variable [Preorder α] [BoundedOrder α] [Preorder β] [BoundedOrder β] [Preorder γ] [BoundedOrder γ]

#print BoundedOrderHom.dual /-
/-- Reinterpret a bounded order homomorphism as a bounded order homomorphism between the dual
orders. -/
@[simps]
protected def dual : BoundedOrderHom α β ≃ BoundedOrderHom αᵒᵈ βᵒᵈ
    where
  toFun f := ⟨f.toOrderHom.dual, f.map_bot', f.map_top'⟩
  invFun f := ⟨OrderHom.dual.symm f.toOrderHom, f.map_bot', f.map_top'⟩
  left_inv f := ext fun a => rfl
  right_inv f := ext fun a => rfl
#align bounded_order_hom.dual BoundedOrderHom.dual
-/

#print BoundedOrderHom.dual_id /-
@[simp]
theorem dual_id : (BoundedOrderHom.id α).dual = BoundedOrderHom.id _ :=
  rfl
#align bounded_order_hom.dual_id BoundedOrderHom.dual_id
-/

/- warning: bounded_order_hom.dual_comp -> BoundedOrderHom.dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_3 : Preorder.{u2} β] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3)] [_inst_5 : Preorder.{u3} γ] [_inst_6 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5)] (g : BoundedOrderHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (f : BoundedOrderHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6))) => (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) -> (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6))) (BoundedOrderHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_3 _inst_5 _inst_2 _inst_4 _inst_6 g f)) (BoundedOrderHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6))) => (BoundedOrderHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) -> (BoundedOrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6))) (BoundedOrderHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4))) => (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) -> (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4))) (BoundedOrderHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_3 : Preorder.{u3} β] [_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3)] [_inst_5 : Preorder.{u2} γ] [_inst_6 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5)] (g : BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (f : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_3 _inst_5 _inst_2 _inst_4 _inst_6 g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6))) (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (fun (_x : BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6))) (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6))) (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6))))) (BoundedOrderHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_3 _inst_5 _inst_2 _inst_4 _inst_6 g f)) (BoundedOrderHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6))) (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) => BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6))) (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6))) (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6))))) (BoundedOrderHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4))) (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) => BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4))) (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4))) (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) (Equiv.instEquivLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4))))) (BoundedOrderHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.dual_comp BoundedOrderHom.dual_compₓ'. -/
@[simp]
theorem dual_comp (g : BoundedOrderHom β γ) (f : BoundedOrderHom α β) :
    (g.comp f).dual = g.dual.comp f.dual :=
  rfl
#align bounded_order_hom.dual_comp BoundedOrderHom.dual_comp

#print BoundedOrderHom.symm_dual_id /-
@[simp]
theorem symm_dual_id : BoundedOrderHom.dual.symm (BoundedOrderHom.id _) = BoundedOrderHom.id α :=
  rfl
#align bounded_order_hom.symm_dual_id BoundedOrderHom.symm_dual_id
-/

/- warning: bounded_order_hom.symm_dual_comp -> BoundedOrderHom.symm_dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Preorder.{u1} α] [_inst_2 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_3 : Preorder.{u2} β] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3)] [_inst_5 : Preorder.{u3} γ] [_inst_6 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5)] (g : BoundedOrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) (f : BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4)), Eq.{max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) => (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) -> (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.symm.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedOrderHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) (BoundedOrderHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (BoundedOrderHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6) g f)) (BoundedOrderHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_3 _inst_5 _inst_2 _inst_4 _inst_6 (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) (BoundedOrderHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) (BoundedOrderHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) => (BoundedOrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) -> (BoundedOrderHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) (BoundedOrderHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.preorder.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ _inst_5) _inst_6)) (BoundedOrderHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4)) (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4)) (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) => (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4)) -> (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4)) (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedOrderHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β _inst_3) _inst_4)) (BoundedOrderHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1)] [_inst_3 : Preorder.{u3} β] [_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3)] [_inst_5 : Preorder.{u2} γ] [_inst_6 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5)] (g : BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (f : BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) => BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (fun (_x : BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) => BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6)))) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedOrderHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedOrderHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (BoundedOrderHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6) g f)) (BoundedOrderHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_3 _inst_5 _inst_2 _inst_4 _inst_6 (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (fun (_x : BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) => BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (Equiv.instEquivLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6)))) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedOrderHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedOrderHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.preorder.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ _inst_5) _inst_6)) (BoundedOrderHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4)) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) (fun (_x : BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) => BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4)) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (EquivLike.toEmbeddingLike.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4)) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (Equiv.instEquivLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4)))) (Equiv.symm.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedOrderHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedOrderHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.preorder.{u1} α _inst_1) (OrderDual.preorder.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α _inst_1) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β _inst_3) _inst_4)) (BoundedOrderHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
Case conversion may be inaccurate. Consider using '#align bounded_order_hom.symm_dual_comp BoundedOrderHom.symm_dual_compₓ'. -/
@[simp]
theorem symm_dual_comp (g : BoundedOrderHom βᵒᵈ γᵒᵈ) (f : BoundedOrderHom αᵒᵈ βᵒᵈ) :
    BoundedOrderHom.dual.symm (g.comp f) =
      (BoundedOrderHom.dual.symm g).comp (BoundedOrderHom.dual.symm f) :=
  rfl
#align bounded_order_hom.symm_dual_comp BoundedOrderHom.symm_dual_comp

end BoundedOrderHom

