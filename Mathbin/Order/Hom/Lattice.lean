/-
Copyright (c) 2022 Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies

! This file was ported from Lean 3 source module order.hom.lattice
! leanprover-community/mathlib commit e97cf15cd1aec9bd5c193b2ffac5a6dc9118912b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Finset.Lattice
import Mathbin.Order.Hom.Bounded
import Mathbin.Order.SymmDiff

/-!
# Lattice homomorphisms

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines (bounded) lattice homomorphisms.

We use the `fun_like` design, so each type of morphisms has a companion typeclass which is meant to
be satisfied by itself and all stricter types.

## Types of morphisms

* `sup_hom`: Maps which preserve `⊔`.
* `inf_hom`: Maps which preserve `⊓`.
* `sup_bot_hom`: Finitary supremum homomorphisms. Maps which preserve `⊔` and `⊥`.
* `inf_top_hom`: Finitary infimum homomorphisms. Maps which preserve `⊓` and `⊤`.
* `lattice_hom`: Lattice homomorphisms. Maps which preserve `⊔` and `⊓`.
* `bounded_lattice_hom`: Bounded lattice homomorphisms. Maps which preserve `⊤`, `⊥`, `⊔` and `⊓`.

## Typeclasses

* `sup_hom_class`
* `inf_hom_class`
* `sup_bot_hom_class`
* `inf_top_hom_class`
* `lattice_hom_class`
* `bounded_lattice_hom_class`

## TODO

Do we need more intersections between `bot_hom`, `top_hom` and lattice homomorphisms?
-/


open Function OrderDual

variable {F ι α β γ δ : Type _}

#print SupHom /-
/-- The type of `⊔`-preserving functions from `α` to `β`. -/
structure SupHom (α β : Type _) [HasSup α] [HasSup β] where
  toFun : α → β
  map_sup' (a b : α) : to_fun (a ⊔ b) = to_fun a ⊔ to_fun b
#align sup_hom SupHom
-/

#print InfHom /-
/-- The type of `⊓`-preserving functions from `α` to `β`. -/
structure InfHom (α β : Type _) [HasInf α] [HasInf β] where
  toFun : α → β
  map_inf' (a b : α) : to_fun (a ⊓ b) = to_fun a ⊓ to_fun b
#align inf_hom InfHom
-/

#print SupBotHom /-
/-- The type of finitary supremum-preserving homomorphisms from `α` to `β`. -/
structure SupBotHom (α β : Type _) [HasSup α] [HasSup β] [Bot α] [Bot β] extends SupHom α β where
  map_bot' : to_fun ⊥ = ⊥
#align sup_bot_hom SupBotHom
-/

#print InfTopHom /-
/-- The type of finitary infimum-preserving homomorphisms from `α` to `β`. -/
structure InfTopHom (α β : Type _) [HasInf α] [HasInf β] [Top α] [Top β] extends InfHom α β where
  map_top' : to_fun ⊤ = ⊤
#align inf_top_hom InfTopHom
-/

#print LatticeHom /-
/-- The type of lattice homomorphisms from `α` to `β`. -/
structure LatticeHom (α β : Type _) [Lattice α] [Lattice β] extends SupHom α β where
  map_inf' (a b : α) : to_fun (a ⊓ b) = to_fun a ⊓ to_fun b
#align lattice_hom LatticeHom
-/

#print BoundedLatticeHom /-
/-- The type of bounded lattice homomorphisms from `α` to `β`. -/
structure BoundedLatticeHom (α β : Type _) [Lattice α] [Lattice β] [BoundedOrder α]
  [BoundedOrder β] extends LatticeHom α β where
  map_top' : to_fun ⊤ = ⊤
  map_bot' : to_fun ⊥ = ⊥
#align bounded_lattice_hom BoundedLatticeHom
-/

section

#print SupHomClass /-
/-- `sup_hom_class F α β` states that `F` is a type of `⊔`-preserving morphisms.

You should extend this class when you extend `sup_hom`. -/
class SupHomClass (F : Type _) (α β : outParam <| Type _) [HasSup α] [HasSup β] extends
  FunLike F α fun _ => β where
  map_sup (f : F) (a b : α) : f (a ⊔ b) = f a ⊔ f b
#align sup_hom_class SupHomClass
-/

#print InfHomClass /-
/-- `inf_hom_class F α β` states that `F` is a type of `⊓`-preserving morphisms.

You should extend this class when you extend `inf_hom`. -/
class InfHomClass (F : Type _) (α β : outParam <| Type _) [HasInf α] [HasInf β] extends
  FunLike F α fun _ => β where
  map_inf (f : F) (a b : α) : f (a ⊓ b) = f a ⊓ f b
#align inf_hom_class InfHomClass
-/

#print SupBotHomClass /-
/-- `sup_bot_hom_class F α β` states that `F` is a type of finitary supremum-preserving morphisms.

You should extend this class when you extend `sup_bot_hom`. -/
class SupBotHomClass (F : Type _) (α β : outParam <| Type _) [HasSup α] [HasSup β] [Bot α]
  [Bot β] extends SupHomClass F α β where
  map_bot (f : F) : f ⊥ = ⊥
#align sup_bot_hom_class SupBotHomClass
-/

#print InfTopHomClass /-
/-- `inf_top_hom_class F α β` states that `F` is a type of finitary infimum-preserving morphisms.

You should extend this class when you extend `sup_bot_hom`. -/
class InfTopHomClass (F : Type _) (α β : outParam <| Type _) [HasInf α] [HasInf β] [Top α]
  [Top β] extends InfHomClass F α β where
  map_top (f : F) : f ⊤ = ⊤
#align inf_top_hom_class InfTopHomClass
-/

#print LatticeHomClass /-
/-- `lattice_hom_class F α β` states that `F` is a type of lattice morphisms.

You should extend this class when you extend `lattice_hom`. -/
class LatticeHomClass (F : Type _) (α β : outParam <| Type _) [Lattice α] [Lattice β] extends
  SupHomClass F α β where
  map_inf (f : F) (a b : α) : f (a ⊓ b) = f a ⊓ f b
#align lattice_hom_class LatticeHomClass
-/

#print BoundedLatticeHomClass /-
/-- `bounded_lattice_hom_class F α β` states that `F` is a type of bounded lattice morphisms.

You should extend this class when you extend `bounded_lattice_hom`. -/
class BoundedLatticeHomClass (F : Type _) (α β : outParam <| Type _) [Lattice α] [Lattice β]
  [BoundedOrder α] [BoundedOrder β] extends LatticeHomClass F α β where
  map_top (f : F) : f ⊤ = ⊤
  map_bot (f : F) : f ⊥ = ⊥
#align bounded_lattice_hom_class BoundedLatticeHomClass
-/

end

export SupHomClass (map_sup)

export InfHomClass (map_inf)

attribute [simp] map_top map_bot map_sup map_inf

#print SupHomClass.toOrderHomClass /-
-- See note [lower instance priority]
instance (priority := 100) SupHomClass.toOrderHomClass [SemilatticeSup α] [SemilatticeSup β]
    [SupHomClass F α β] : OrderHomClass F α β :=
  { ‹SupHomClass F α β› with
    map_rel := fun f a b h => by rw [← sup_eq_right, ← map_sup, sup_eq_right.2 h] }
#align sup_hom_class.to_order_hom_class SupHomClass.toOrderHomClass
-/

#print InfHomClass.toOrderHomClass /-
-- See note [lower instance priority]
instance (priority := 100) InfHomClass.toOrderHomClass [SemilatticeInf α] [SemilatticeInf β]
    [InfHomClass F α β] : OrderHomClass F α β :=
  { ‹InfHomClass F α β› with
    map_rel := fun f a b h => by rw [← inf_eq_left, ← map_inf, inf_eq_left.2 h] }
#align inf_hom_class.to_order_hom_class InfHomClass.toOrderHomClass
-/

#print SupBotHomClass.toBotHomClass /-
-- See note [lower instance priority]
instance (priority := 100) SupBotHomClass.toBotHomClass [HasSup α] [HasSup β] [Bot α] [Bot β]
    [SupBotHomClass F α β] : BotHomClass F α β :=
  { ‹SupBotHomClass F α β› with }
#align sup_bot_hom_class.to_bot_hom_class SupBotHomClass.toBotHomClass
-/

#print InfTopHomClass.toTopHomClass /-
-- See note [lower instance priority]
instance (priority := 100) InfTopHomClass.toTopHomClass [HasInf α] [HasInf β] [Top α] [Top β]
    [InfTopHomClass F α β] : TopHomClass F α β :=
  { ‹InfTopHomClass F α β› with }
#align inf_top_hom_class.to_top_hom_class InfTopHomClass.toTopHomClass
-/

#print LatticeHomClass.toInfHomClass /-
-- See note [lower instance priority]
instance (priority := 100) LatticeHomClass.toInfHomClass [Lattice α] [Lattice β]
    [LatticeHomClass F α β] : InfHomClass F α β :=
  { ‹LatticeHomClass F α β› with }
#align lattice_hom_class.to_inf_hom_class LatticeHomClass.toInfHomClass
-/

/- warning: bounded_lattice_hom_class.to_sup_bot_hom_class -> BoundedLatticeHomClass.toSupBotHomClass is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))] [_inst_5 : BoundedLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4], SupBotHomClass.{u1, u2, u3} F α β (SemilatticeSup.toHasSup.{u2} α (Lattice.toSemilatticeSup.{u2} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (OrderBot.toHasBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (BoundedOrder.toOrderBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_3)) (OrderBot.toHasBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_4))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} {_inst_1 : Lattice.{u2} α} {_inst_2 : Lattice.{u3} β} {_inst_3 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))} {_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))} [_inst_5 : BoundedLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4], SupBotHomClass.{u1, u2, u3} F α β (SemilatticeSup.toHasSup.{u2} α (Lattice.toSemilatticeSup.{u2} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (OrderBot.toBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (BoundedOrder.toOrderBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_3)) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_4))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom_class.to_sup_bot_hom_class BoundedLatticeHomClass.toSupBotHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) BoundedLatticeHomClass.toSupBotHomClass [Lattice α] [Lattice β]
    [BoundedOrder α] [BoundedOrder β] [BoundedLatticeHomClass F α β] : SupBotHomClass F α β :=
  { ‹BoundedLatticeHomClass F α β› with }
#align bounded_lattice_hom_class.to_sup_bot_hom_class BoundedLatticeHomClass.toSupBotHomClass

/- warning: bounded_lattice_hom_class.to_inf_top_hom_class -> BoundedLatticeHomClass.toInfTopHomClass is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))] [_inst_5 : BoundedLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4], InfTopHomClass.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)) (OrderTop.toHasTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_3)) (OrderTop.toHasTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_4))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} {_inst_1 : Lattice.{u2} α} {_inst_2 : Lattice.{u3} β} {_inst_3 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))} {_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))} [_inst_5 : BoundedLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4], InfTopHomClass.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_3)) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_4))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom_class.to_inf_top_hom_class BoundedLatticeHomClass.toInfTopHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) BoundedLatticeHomClass.toInfTopHomClass [Lattice α] [Lattice β]
    [BoundedOrder α] [BoundedOrder β] [BoundedLatticeHomClass F α β] : InfTopHomClass F α β :=
  { ‹BoundedLatticeHomClass F α β› with }
#align bounded_lattice_hom_class.to_inf_top_hom_class BoundedLatticeHomClass.toInfTopHomClass

#print BoundedLatticeHomClass.toBoundedOrderHomClass /-
-- See note [lower instance priority]
instance (priority := 100) BoundedLatticeHomClass.toBoundedOrderHomClass [Lattice α] [Lattice β]
    [BoundedOrder α] [BoundedOrder β] [BoundedLatticeHomClass F α β] : BoundedOrderHomClass F α β :=
  { show OrderHomClass F α β from inferInstance, ‹BoundedLatticeHomClass F α β› with }
#align bounded_lattice_hom_class.to_bounded_order_hom_class BoundedLatticeHomClass.toBoundedOrderHomClass
-/

#print OrderIsoClass.toSupHomClass /-
-- See note [lower instance priority]
instance (priority := 100) OrderIsoClass.toSupHomClass [SemilatticeSup α] [SemilatticeSup β]
    [OrderIsoClass F α β] : SupHomClass F α β :=
  { show OrderHomClass F α β from inferInstance with
    map_sup := fun f a b =>
      eq_of_forall_ge_iff fun c => by simp only [← le_map_inv_iff, sup_le_iff] }
#align order_iso_class.to_sup_hom_class OrderIsoClass.toSupHomClass
-/

#print OrderIsoClass.toInfHomClass /-
-- See note [lower instance priority]
instance (priority := 100) OrderIsoClass.toInfHomClass [SemilatticeInf α] [SemilatticeInf β]
    [OrderIsoClass F α β] : InfHomClass F α β :=
  { show OrderHomClass F α β from inferInstance with
    map_inf := fun f a b =>
      eq_of_forall_le_iff fun c => by simp only [← map_inv_le_iff, le_inf_iff] }
#align order_iso_class.to_inf_hom_class OrderIsoClass.toInfHomClass
-/

/- warning: order_iso_class.to_sup_bot_hom_class -> OrderIsoClass.toSupBotHomClass is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : SemilatticeSup.{u2} α] [_inst_2 : OrderBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)))] [_inst_3 : SemilatticeSup.{u3} β] [_inst_4 : OrderBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeSup.toPartialOrder.{u3} β _inst_3)))] [_inst_5 : OrderIsoClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeSup.toPartialOrder.{u3} β _inst_3)))], SupBotHomClass.{u1, u2, u3} F α β (SemilatticeSup.toHasSup.{u2} α _inst_1) (SemilatticeSup.toHasSup.{u3} β _inst_3) (OrderBot.toHasBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) _inst_2) (OrderBot.toHasBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeSup.toPartialOrder.{u3} β _inst_3))) _inst_4)
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} {_inst_1 : SemilatticeSup.{u2} α} {_inst_2 : OrderBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)))} {_inst_3 : SemilatticeSup.{u3} β} {_inst_4 : OrderBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeSup.toPartialOrder.{u3} β _inst_3)))} [_inst_5 : OrderIsoClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeSup.toPartialOrder.{u3} β _inst_3)))], SupBotHomClass.{u1, u2, u3} F α β (SemilatticeSup.toHasSup.{u2} α _inst_1) (SemilatticeSup.toHasSup.{u3} β _inst_3) (OrderBot.toBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) _inst_2) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeSup.toPartialOrder.{u3} β _inst_3))) _inst_4)
Case conversion may be inaccurate. Consider using '#align order_iso_class.to_sup_bot_hom_class OrderIsoClass.toSupBotHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) OrderIsoClass.toSupBotHomClass [SemilatticeSup α] [OrderBot α]
    [SemilatticeSup β] [OrderBot β] [OrderIsoClass F α β] : SupBotHomClass F α β :=
  { OrderIsoClass.toSupHomClass, OrderIsoClass.toBotHomClass with }
#align order_iso_class.to_sup_bot_hom_class OrderIsoClass.toSupBotHomClass

/- warning: order_iso_class.to_inf_top_hom_class -> OrderIsoClass.toInfTopHomClass is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : SemilatticeInf.{u2} α] [_inst_2 : OrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1)))] [_inst_3 : SemilatticeInf.{u3} β] [_inst_4 : OrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β _inst_3)))] [_inst_5 : OrderIsoClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β _inst_3)))], InfTopHomClass.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α _inst_1) (SemilatticeInf.toHasInf.{u3} β _inst_3) (OrderTop.toHasTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) _inst_2) (OrderTop.toHasTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β _inst_3))) _inst_4)
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} {_inst_1 : SemilatticeInf.{u2} α} {_inst_2 : OrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1)))} {_inst_3 : SemilatticeInf.{u3} β} {_inst_4 : OrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β _inst_3)))} [_inst_5 : OrderIsoClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β _inst_3)))], InfTopHomClass.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α _inst_1) (SemilatticeInf.toHasInf.{u3} β _inst_3) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) _inst_2) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β _inst_3))) _inst_4)
Case conversion may be inaccurate. Consider using '#align order_iso_class.to_inf_top_hom_class OrderIsoClass.toInfTopHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) OrderIsoClass.toInfTopHomClass [SemilatticeInf α] [OrderTop α]
    [SemilatticeInf β] [OrderTop β] [OrderIsoClass F α β] : InfTopHomClass F α β :=
  { OrderIsoClass.toInfHomClass, OrderIsoClass.toTopHomClass with }
#align order_iso_class.to_inf_top_hom_class OrderIsoClass.toInfTopHomClass

#print OrderIsoClass.toLatticeHomClass /-
-- See note [lower instance priority]
instance (priority := 100) OrderIsoClass.toLatticeHomClass [Lattice α] [Lattice β]
    [OrderIsoClass F α β] : LatticeHomClass F α β :=
  { OrderIsoClass.toSupHomClass, OrderIsoClass.toInfHomClass with }
#align order_iso_class.to_lattice_hom_class OrderIsoClass.toLatticeHomClass
-/

#print OrderIsoClass.toBoundedLatticeHomClass /-
-- See note [lower instance priority]
instance (priority := 100) OrderIsoClass.toBoundedLatticeHomClass [Lattice α] [Lattice β]
    [BoundedOrder α] [BoundedOrder β] [OrderIsoClass F α β] : BoundedLatticeHomClass F α β :=
  { OrderIsoClass.toLatticeHomClass, OrderIsoClass.toBoundedOrderHomClass with }
#align order_iso_class.to_bounded_lattice_hom_class OrderIsoClass.toBoundedLatticeHomClass
-/

/- warning: map_finset_sup -> map_finset_sup is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {ι : Type.{u2}} {α : Type.{u3}} {β : Type.{u4}} [_inst_1 : SemilatticeSup.{u3} α] [_inst_2 : OrderBot.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeSup.toPartialOrder.{u3} α _inst_1)))] [_inst_3 : SemilatticeSup.{u4} β] [_inst_4 : OrderBot.{u4} β (Preorder.toLE.{u4} β (PartialOrder.toPreorder.{u4} β (SemilatticeSup.toPartialOrder.{u4} β _inst_3)))] [_inst_5 : SupBotHomClass.{u1, u3, u4} F α β (SemilatticeSup.toHasSup.{u3} α _inst_1) (SemilatticeSup.toHasSup.{u4} β _inst_3) (OrderBot.toHasBot.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeSup.toPartialOrder.{u3} α _inst_1))) _inst_2) (OrderBot.toHasBot.{u4} β (Preorder.toLE.{u4} β (PartialOrder.toPreorder.{u4} β (SemilatticeSup.toPartialOrder.{u4} β _inst_3))) _inst_4)] (f : F) (s : Finset.{u2} ι) (g : ι -> α), Eq.{succ u4} β (coeFn.{succ u1, max (succ u3) (succ u4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u3, succ u4} F α (fun (_x : α) => β) (SupHomClass.toFunLike.{u1, u3, u4} F α β (SemilatticeSup.toHasSup.{u3} α _inst_1) (SemilatticeSup.toHasSup.{u4} β _inst_3) (SupBotHomClass.toSupHomClass.{u1, u3, u4} F α β (SemilatticeSup.toHasSup.{u3} α _inst_1) (SemilatticeSup.toHasSup.{u4} β _inst_3) (OrderBot.toHasBot.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeSup.toPartialOrder.{u3} α _inst_1))) _inst_2) (OrderBot.toHasBot.{u4} β (Preorder.toLE.{u4} β (PartialOrder.toPreorder.{u4} β (SemilatticeSup.toPartialOrder.{u4} β _inst_3))) _inst_4) _inst_5))) f (Finset.sup.{u3, u2} α ι _inst_1 _inst_2 s g)) (Finset.sup.{u4, u2} β ι _inst_3 _inst_4 s (Function.comp.{succ u2, succ u3, succ u4} ι α β (coeFn.{succ u1, max (succ u3) (succ u4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u3, succ u4} F α (fun (_x : α) => β) (SupHomClass.toFunLike.{u1, u3, u4} F α β (SemilatticeSup.toHasSup.{u3} α _inst_1) (SemilatticeSup.toHasSup.{u4} β _inst_3) (SupBotHomClass.toSupHomClass.{u1, u3, u4} F α β (SemilatticeSup.toHasSup.{u3} α _inst_1) (SemilatticeSup.toHasSup.{u4} β _inst_3) (OrderBot.toHasBot.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeSup.toPartialOrder.{u3} α _inst_1))) _inst_2) (OrderBot.toHasBot.{u4} β (Preorder.toLE.{u4} β (PartialOrder.toPreorder.{u4} β (SemilatticeSup.toPartialOrder.{u4} β _inst_3))) _inst_4) _inst_5))) f) g))
but is expected to have type
  forall {F : Type.{u2}} {ι : Type.{u1}} {α : Type.{u4}} {β : Type.{u3}} [_inst_1 : SemilatticeSup.{u4} α] [_inst_2 : OrderBot.{u4} α (Preorder.toLE.{u4} α (PartialOrder.toPreorder.{u4} α (SemilatticeSup.toPartialOrder.{u4} α _inst_1)))] [_inst_3 : SemilatticeSup.{u3} β] [_inst_4 : OrderBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeSup.toPartialOrder.{u3} β _inst_3)))] [_inst_5 : SupBotHomClass.{u2, u4, u3} F α β (SemilatticeSup.toHasSup.{u4} α _inst_1) (SemilatticeSup.toHasSup.{u3} β _inst_3) (OrderBot.toBot.{u4} α (Preorder.toLE.{u4} α (PartialOrder.toPreorder.{u4} α (SemilatticeSup.toPartialOrder.{u4} α _inst_1))) _inst_2) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeSup.toPartialOrder.{u3} β _inst_3))) _inst_4)] (f : F) (s : Finset.{u1} ι) (g : ι -> α), Eq.{succ u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.429 : α) => β) (Finset.sup.{u4, u1} α ι _inst_1 _inst_2 s g)) (FunLike.coe.{succ u2, succ u4, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.429 : α) => β) _x) (SupHomClass.toFunLike.{u2, u4, u3} F α β (SemilatticeSup.toHasSup.{u4} α _inst_1) (SemilatticeSup.toHasSup.{u3} β _inst_3) (SupBotHomClass.toSupHomClass.{u2, u4, u3} F α β (SemilatticeSup.toHasSup.{u4} α _inst_1) (SemilatticeSup.toHasSup.{u3} β _inst_3) (OrderBot.toBot.{u4} α (Preorder.toLE.{u4} α (PartialOrder.toPreorder.{u4} α (SemilatticeSup.toPartialOrder.{u4} α _inst_1))) _inst_2) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeSup.toPartialOrder.{u3} β _inst_3))) _inst_4) _inst_5)) f (Finset.sup.{u4, u1} α ι _inst_1 _inst_2 s g)) (Finset.sup.{u3, u1} β ι _inst_3 _inst_4 s (Function.comp.{succ u1, succ u4, succ u3} ι α β (FunLike.coe.{succ u2, succ u4, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.429 : α) => β) _x) (SupHomClass.toFunLike.{u2, u4, u3} F α β (SemilatticeSup.toHasSup.{u4} α _inst_1) (SemilatticeSup.toHasSup.{u3} β _inst_3) (SupBotHomClass.toSupHomClass.{u2, u4, u3} F α β (SemilatticeSup.toHasSup.{u4} α _inst_1) (SemilatticeSup.toHasSup.{u3} β _inst_3) (OrderBot.toBot.{u4} α (Preorder.toLE.{u4} α (PartialOrder.toPreorder.{u4} α (SemilatticeSup.toPartialOrder.{u4} α _inst_1))) _inst_2) (OrderBot.toBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeSup.toPartialOrder.{u3} β _inst_3))) _inst_4) _inst_5)) f) g))
Case conversion may be inaccurate. Consider using '#align map_finset_sup map_finset_supₓ'. -/
@[simp]
theorem map_finset_sup [SemilatticeSup α] [OrderBot α] [SemilatticeSup β] [OrderBot β]
    [SupBotHomClass F α β] (f : F) (s : Finset ι) (g : ι → α) : f (s.sup g) = s.sup (f ∘ g) :=
  Finset.cons_induction_on s (map_bot f) fun i s _ h => by
    rw [Finset.sup_cons, Finset.sup_cons, map_sup, h]
#align map_finset_sup map_finset_sup

/- warning: map_finset_inf -> map_finset_inf is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {ι : Type.{u2}} {α : Type.{u3}} {β : Type.{u4}} [_inst_1 : SemilatticeInf.{u3} α] [_inst_2 : OrderTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α _inst_1)))] [_inst_3 : SemilatticeInf.{u4} β] [_inst_4 : OrderTop.{u4} β (Preorder.toLE.{u4} β (PartialOrder.toPreorder.{u4} β (SemilatticeInf.toPartialOrder.{u4} β _inst_3)))] [_inst_5 : InfTopHomClass.{u1, u3, u4} F α β (SemilatticeInf.toHasInf.{u3} α _inst_1) (SemilatticeInf.toHasInf.{u4} β _inst_3) (OrderTop.toHasTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α _inst_1))) _inst_2) (OrderTop.toHasTop.{u4} β (Preorder.toLE.{u4} β (PartialOrder.toPreorder.{u4} β (SemilatticeInf.toPartialOrder.{u4} β _inst_3))) _inst_4)] (f : F) (s : Finset.{u2} ι) (g : ι -> α), Eq.{succ u4} β (coeFn.{succ u1, max (succ u3) (succ u4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u3, succ u4} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u3, u4} F α β (SemilatticeInf.toHasInf.{u3} α _inst_1) (SemilatticeInf.toHasInf.{u4} β _inst_3) (InfTopHomClass.toInfHomClass.{u1, u3, u4} F α β (SemilatticeInf.toHasInf.{u3} α _inst_1) (SemilatticeInf.toHasInf.{u4} β _inst_3) (OrderTop.toHasTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α _inst_1))) _inst_2) (OrderTop.toHasTop.{u4} β (Preorder.toLE.{u4} β (PartialOrder.toPreorder.{u4} β (SemilatticeInf.toPartialOrder.{u4} β _inst_3))) _inst_4) _inst_5))) f (Finset.inf.{u3, u2} α ι _inst_1 _inst_2 s g)) (Finset.inf.{u4, u2} β ι _inst_3 _inst_4 s (Function.comp.{succ u2, succ u3, succ u4} ι α β (coeFn.{succ u1, max (succ u3) (succ u4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u3, succ u4} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u3, u4} F α β (SemilatticeInf.toHasInf.{u3} α _inst_1) (SemilatticeInf.toHasInf.{u4} β _inst_3) (InfTopHomClass.toInfHomClass.{u1, u3, u4} F α β (SemilatticeInf.toHasInf.{u3} α _inst_1) (SemilatticeInf.toHasInf.{u4} β _inst_3) (OrderTop.toHasTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α _inst_1))) _inst_2) (OrderTop.toHasTop.{u4} β (Preorder.toLE.{u4} β (PartialOrder.toPreorder.{u4} β (SemilatticeInf.toPartialOrder.{u4} β _inst_3))) _inst_4) _inst_5))) f) g))
but is expected to have type
  forall {F : Type.{u2}} {ι : Type.{u1}} {α : Type.{u4}} {β : Type.{u3}} [_inst_1 : SemilatticeInf.{u4} α] [_inst_2 : OrderTop.{u4} α (Preorder.toLE.{u4} α (PartialOrder.toPreorder.{u4} α (SemilatticeInf.toPartialOrder.{u4} α _inst_1)))] [_inst_3 : SemilatticeInf.{u3} β] [_inst_4 : OrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β _inst_3)))] [_inst_5 : InfTopHomClass.{u2, u4, u3} F α β (SemilatticeInf.toHasInf.{u4} α _inst_1) (SemilatticeInf.toHasInf.{u3} β _inst_3) (OrderTop.toTop.{u4} α (Preorder.toLE.{u4} α (PartialOrder.toPreorder.{u4} α (SemilatticeInf.toPartialOrder.{u4} α _inst_1))) _inst_2) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β _inst_3))) _inst_4)] (f : F) (s : Finset.{u1} ι) (g : ι -> α), Eq.{succ u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) (Finset.inf.{u4, u1} α ι _inst_1 _inst_2 s g)) (FunLike.coe.{succ u2, succ u4, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u2, u4, u3} F α β (SemilatticeInf.toHasInf.{u4} α _inst_1) (SemilatticeInf.toHasInf.{u3} β _inst_3) (InfTopHomClass.toInfHomClass.{u2, u4, u3} F α β (SemilatticeInf.toHasInf.{u4} α _inst_1) (SemilatticeInf.toHasInf.{u3} β _inst_3) (OrderTop.toTop.{u4} α (Preorder.toLE.{u4} α (PartialOrder.toPreorder.{u4} α (SemilatticeInf.toPartialOrder.{u4} α _inst_1))) _inst_2) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β _inst_3))) _inst_4) _inst_5)) f (Finset.inf.{u4, u1} α ι _inst_1 _inst_2 s g)) (Finset.inf.{u3, u1} β ι _inst_3 _inst_4 s (Function.comp.{succ u1, succ u4, succ u3} ι α β (FunLike.coe.{succ u2, succ u4, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u2, u4, u3} F α β (SemilatticeInf.toHasInf.{u4} α _inst_1) (SemilatticeInf.toHasInf.{u3} β _inst_3) (InfTopHomClass.toInfHomClass.{u2, u4, u3} F α β (SemilatticeInf.toHasInf.{u4} α _inst_1) (SemilatticeInf.toHasInf.{u3} β _inst_3) (OrderTop.toTop.{u4} α (Preorder.toLE.{u4} α (PartialOrder.toPreorder.{u4} α (SemilatticeInf.toPartialOrder.{u4} α _inst_1))) _inst_2) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β _inst_3))) _inst_4) _inst_5)) f) g))
Case conversion may be inaccurate. Consider using '#align map_finset_inf map_finset_infₓ'. -/
@[simp]
theorem map_finset_inf [SemilatticeInf α] [OrderTop α] [SemilatticeInf β] [OrderTop β]
    [InfTopHomClass F α β] (f : F) (s : Finset ι) (g : ι → α) : f (s.inf g) = s.inf (f ∘ g) :=
  Finset.cons_induction_on s (map_top f) fun i s _ h => by
    rw [Finset.inf_cons, Finset.inf_cons, map_inf, h]
#align map_finset_inf map_finset_inf

section BoundedLattice

variable [Lattice α] [BoundedOrder α] [Lattice β] [BoundedOrder β] [BoundedLatticeHomClass F α β]
  (f : F) {a b : α}

include β

/- warning: disjoint.map -> Disjoint.map is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : Lattice.{u2} α] [_inst_2 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_3 : Lattice.{u3} β] [_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3))))] [_inst_5 : BoundedLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 _inst_2 _inst_4] (f : F) {a : α} {b : α}, (Disjoint.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) (BoundedOrder.toOrderBot.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_2) a b) -> (Disjoint.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)) (BoundedOrder.toOrderBot.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5)))) f a) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5)))) f b))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u3}} {β : Type.{u2}} [_inst_1 : Lattice.{u3} α] [_inst_2 : BoundedOrder.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1))))] [_inst_3 : Lattice.{u2} β] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3))))] [_inst_5 : BoundedLatticeHomClass.{u1, u3, u2} F α β _inst_1 _inst_3 _inst_2 _inst_4] (f : F) {a : α} {b : α}, (Disjoint.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)) (BoundedOrder.toOrderBot.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) _inst_2) a b) -> (Disjoint.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (SemilatticeInf.toPartialOrder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (Lattice.toSemilatticeInf.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) _inst_3)) (BoundedOrder.toOrderBot.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (SemilatticeInf.toPartialOrder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (Lattice.toSemilatticeInf.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) _inst_3)))) _inst_4) (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (InfTopHomClass.toInfHomClass.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (OrderTop.toTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) (BoundedOrder.toOrderTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) _inst_2)) (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u3, u2} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5))) f a) (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (InfTopHomClass.toInfHomClass.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (OrderTop.toTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) (BoundedOrder.toOrderTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) _inst_2)) (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u3, u2} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5))) f b))
Case conversion may be inaccurate. Consider using '#align disjoint.map Disjoint.mapₓ'. -/
theorem Disjoint.map (h : Disjoint a b) : Disjoint (f a) (f b) := by
  rw [disjoint_iff, ← map_inf, h.eq_bot, map_bot]
#align disjoint.map Disjoint.map

/- warning: codisjoint.map -> Codisjoint.map is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : Lattice.{u2} α] [_inst_2 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_3 : Lattice.{u3} β] [_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3))))] [_inst_5 : BoundedLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 _inst_2 _inst_4] (f : F) {a : α} {b : α}, (Codisjoint.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_2) a b) -> (Codisjoint.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5)))) f a) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5)))) f b))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u3}} {β : Type.{u2}} [_inst_1 : Lattice.{u3} α] [_inst_2 : BoundedOrder.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1))))] [_inst_3 : Lattice.{u2} β] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3))))] [_inst_5 : BoundedLatticeHomClass.{u1, u3, u2} F α β _inst_1 _inst_3 _inst_2 _inst_4] (f : F) {a : α} {b : α}, (Codisjoint.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)) (BoundedOrder.toOrderTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) _inst_2) a b) -> (Codisjoint.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (SemilatticeInf.toPartialOrder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (Lattice.toSemilatticeInf.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) _inst_3)) (BoundedOrder.toOrderTop.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (SemilatticeInf.toPartialOrder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (Lattice.toSemilatticeInf.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) _inst_3)))) _inst_4) (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (InfTopHomClass.toInfHomClass.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (OrderTop.toTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) (BoundedOrder.toOrderTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) _inst_2)) (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u3, u2} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5))) f a) (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (InfTopHomClass.toInfHomClass.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (OrderTop.toTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) (BoundedOrder.toOrderTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) _inst_2)) (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u3, u2} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5))) f b))
Case conversion may be inaccurate. Consider using '#align codisjoint.map Codisjoint.mapₓ'. -/
theorem Codisjoint.map (h : Codisjoint a b) : Codisjoint (f a) (f b) := by
  rw [codisjoint_iff, ← map_sup, h.eq_top, map_top]
#align codisjoint.map Codisjoint.map

/- warning: is_compl.map -> IsCompl.map is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : Lattice.{u2} α] [_inst_2 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_3 : Lattice.{u3} β] [_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3))))] [_inst_5 : BoundedLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 _inst_2 _inst_4] (f : F) {a : α} {b : α}, (IsCompl.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) _inst_2 a b) -> (IsCompl.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)) _inst_4 (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5)))) f a) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5)))) f b))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u3}} {β : Type.{u2}} [_inst_1 : Lattice.{u3} α] [_inst_2 : BoundedOrder.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1))))] [_inst_3 : Lattice.{u2} β] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3))))] [_inst_5 : BoundedLatticeHomClass.{u1, u3, u2} F α β _inst_1 _inst_3 _inst_2 _inst_4] (f : F) {a : α} {b : α}, (IsCompl.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)) _inst_2 a b) -> (IsCompl.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (SemilatticeInf.toPartialOrder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (Lattice.toSemilatticeInf.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) _inst_3)) _inst_4 (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (InfTopHomClass.toInfHomClass.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (OrderTop.toTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) (BoundedOrder.toOrderTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) _inst_2)) (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u3, u2} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5))) f a) (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (InfTopHomClass.toInfHomClass.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α _inst_1) (Lattice.toHasInf.{u2} β _inst_3) (OrderTop.toTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) (BoundedOrder.toOrderTop.{u3} α (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α _inst_1)))) _inst_2)) (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u3, u2} F α β _inst_1 _inst_3 _inst_2 _inst_4 _inst_5))) f b))
Case conversion may be inaccurate. Consider using '#align is_compl.map IsCompl.mapₓ'. -/
theorem IsCompl.map (h : IsCompl a b) : IsCompl (f a) (f b) :=
  ⟨h.1.map _, h.2.map _⟩
#align is_compl.map IsCompl.map

end BoundedLattice

section BooleanAlgebra

variable [BooleanAlgebra α] [BooleanAlgebra β] [BoundedLatticeHomClass F α β] (f : F)

include β

#print map_compl' /-
/-- Special case of `map_compl` for boolean algebras. -/
theorem map_compl' (a : α) : f (aᶜ) = f aᶜ :=
  (isCompl_compl.map _).compl_eq.symm
#align map_compl' map_compl'
-/

/- warning: map_sdiff' -> map_sdiff' is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : BooleanAlgebra.{u2} α] [_inst_2 : BooleanAlgebra.{u3} β] [_inst_3 : BoundedLatticeHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2)] (f : F) (a : α) (b : α), Eq.{succ u3} β (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))))) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))))) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3)))) f (SDiff.sdiff.{u2} α (BooleanAlgebra.toHasSdiff.{u2} α _inst_1) a b)) (SDiff.sdiff.{u3} β (BooleanAlgebra.toHasSdiff.{u3} β _inst_2) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))))) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))))) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3)))) f a) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))))) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))))) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3)))) f b))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : BooleanAlgebra.{u2} α] [_inst_2 : BooleanAlgebra.{u3} β] [_inst_3 : BoundedLatticeHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2)] (f : F) (a : α) (b : α), Eq.{succ u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) (SDiff.sdiff.{u2} α (BooleanAlgebra.toSDiff.{u2} α _inst_1) a b)) (FunLike.coe.{succ u1, succ u2, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (InfTopHomClass.toInfHomClass.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1))) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2))) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3))) f (SDiff.sdiff.{u2} α (BooleanAlgebra.toSDiff.{u2} α _inst_1) a b)) (SDiff.sdiff.{u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (BooleanAlgebra.toSDiff.{u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) _inst_2) (FunLike.coe.{succ u1, succ u2, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (InfTopHomClass.toInfHomClass.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1))) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2))) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3))) f a) (FunLike.coe.{succ u1, succ u2, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (InfTopHomClass.toInfHomClass.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1))) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2))) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3))) f b))
Case conversion may be inaccurate. Consider using '#align map_sdiff' map_sdiff'ₓ'. -/
/-- Special case of `map_sdiff` for boolean algebras. -/
theorem map_sdiff' (a b : α) : f (a \ b) = f a \ f b := by
  rw [sdiff_eq, sdiff_eq, map_inf, map_compl']
#align map_sdiff' map_sdiff'

/- warning: map_symm_diff' -> map_symm_diff' is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : BooleanAlgebra.{u2} α] [_inst_2 : BooleanAlgebra.{u3} β] [_inst_3 : BoundedLatticeHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2)] (f : F) (a : α) (b : α), Eq.{succ u3} β (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))))) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))))) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3)))) f (symmDiff.{u2} α (SemilatticeSup.toHasSup.{u2} α (Lattice.toSemilatticeSup.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))))) (BooleanAlgebra.toHasSdiff.{u2} α _inst_1) a b)) (symmDiff.{u3} β (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))))) (BooleanAlgebra.toHasSdiff.{u3} β _inst_2) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))))) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))))) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3)))) f a) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (InfHomClass.toFunLike.{u1, u2, u3} F α β (SemilatticeInf.toHasInf.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))))) (SemilatticeInf.toHasInf.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))))) (LatticeHomClass.toInfHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BoundedLatticeHomClass.toLatticeHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} α _inst_1))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} β _inst_2))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3)))) f b))
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : BooleanAlgebra.{u2} α] [_inst_2 : BooleanAlgebra.{u3} β] [_inst_3 : BoundedLatticeHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2)] (f : F) (a : α) (b : α), Eq.{succ u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) (symmDiff.{u2} α (SemilatticeSup.toHasSup.{u2} α (Lattice.toSemilatticeSup.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))) (BooleanAlgebra.toSDiff.{u2} α _inst_1) a b)) (FunLike.coe.{succ u1, succ u2, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (InfTopHomClass.toInfHomClass.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1))) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2))) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3))) f (symmDiff.{u2} α (SemilatticeSup.toHasSup.{u2} α (Lattice.toSemilatticeSup.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))) (BooleanAlgebra.toSDiff.{u2} α _inst_1) a b)) (symmDiff.{u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (SemilatticeSup.toHasSup.{u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (Lattice.toSemilatticeSup.{u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (GeneralizedCoheytingAlgebra.toLattice.{u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (BiheytingAlgebra.toCoheytingAlgebra.{u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (BooleanAlgebra.toBiheytingAlgebra.{u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) _inst_2)))))) (BooleanAlgebra.toSDiff.{u3} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) _inst_2) (FunLike.coe.{succ u1, succ u2, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (InfTopHomClass.toInfHomClass.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1))) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2))) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3))) f a) (FunLike.coe.{succ u1, succ u2, succ u3} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (InfTopHomClass.toInfHomClass.{u1, u2, u3} F α β (Lattice.toHasInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1))))) (Lattice.toHasInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2))))) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))))))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1))) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))))))) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2))) (BoundedLatticeHomClass.toInfTopHomClass.{u1, u2, u3} F α β (GeneralizedCoheytingAlgebra.toLattice.{u2} α (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u2} α (BiheytingAlgebra.toCoheytingAlgebra.{u2} α (BooleanAlgebra.toBiheytingAlgebra.{u2} α _inst_1)))) (GeneralizedCoheytingAlgebra.toLattice.{u3} β (CoheytingAlgebra.toGeneralizedCoheytingAlgebra.{u3} β (BiheytingAlgebra.toCoheytingAlgebra.{u3} β (BooleanAlgebra.toBiheytingAlgebra.{u3} β _inst_2)))) (BooleanAlgebra.toBoundedOrder.{u2} α _inst_1) (BooleanAlgebra.toBoundedOrder.{u3} β _inst_2) _inst_3))) f b))
Case conversion may be inaccurate. Consider using '#align map_symm_diff' map_symm_diff'ₓ'. -/
/-- Special case of `map_symm_diff` for boolean algebras. -/
theorem map_symm_diff' (a b : α) : f (a ∆ b) = f a ∆ f b := by
  rw [symmDiff, symmDiff, map_sup, map_sdiff', map_sdiff']
#align map_symm_diff' map_symm_diff'

end BooleanAlgebra

instance [HasSup α] [HasSup β] [SupHomClass F α β] : CoeTC F (SupHom α β) :=
  ⟨fun f => ⟨f, map_sup f⟩⟩

instance [HasInf α] [HasInf β] [InfHomClass F α β] : CoeTC F (InfHom α β) :=
  ⟨fun f => ⟨f, map_inf f⟩⟩

instance [HasSup α] [HasSup β] [Bot α] [Bot β] [SupBotHomClass F α β] : CoeTC F (SupBotHom α β) :=
  ⟨fun f => ⟨f, map_bot f⟩⟩

instance [HasInf α] [HasInf β] [Top α] [Top β] [InfTopHomClass F α β] : CoeTC F (InfTopHom α β) :=
  ⟨fun f => ⟨f, map_top f⟩⟩

instance [Lattice α] [Lattice β] [LatticeHomClass F α β] : CoeTC F (LatticeHom α β) :=
  ⟨fun f =>
    { toFun := f
      map_sup' := map_sup f
      map_inf' := map_inf f }⟩

instance [Lattice α] [Lattice β] [BoundedOrder α] [BoundedOrder β] [BoundedLatticeHomClass F α β] :
    CoeTC F (BoundedLatticeHom α β) :=
  ⟨fun f =>
    { (f : LatticeHom α β) with
      toFun := f
      map_top' := map_top f
      map_bot' := map_bot f }⟩

/-! ### Supremum homomorphisms -/


namespace SupHom

variable [HasSup α]

section HasSup

variable [HasSup β] [HasSup γ] [HasSup δ]

instance : SupHomClass (SupHom α β) α β
    where
  coe := SupHom.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
  map_sup := SupHom.map_sup'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (SupHom α β) fun _ => α → β :=
  ⟨fun f => f.toFun⟩

/- warning: sup_hom.to_fun_eq_coe -> SupHom.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] {f : SupHom.{u1, u2} α β _inst_1 _inst_2}, Eq.{max (succ u1) (succ u2)} (α -> β) (SupHom.toFun.{u1, u2} α β _inst_1 _inst_2 f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : SupHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : HasSup.{u1} β] {f : SupHom.{u2, u1} α β _inst_1 _inst_2}, Eq.{max (succ u2) (succ u1)} (α -> β) (SupHom.toFun.{u2, u1} α β _inst_1 _inst_2 f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 _inst_2) f)
Case conversion may be inaccurate. Consider using '#align sup_hom.to_fun_eq_coe SupHom.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe {f : SupHom α β} : f.toFun = (f : α → β) :=
  rfl
#align sup_hom.to_fun_eq_coe SupHom.toFun_eq_coe

/- warning: sup_hom.ext -> SupHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] {f : SupHom.{u1, u2} α β _inst_1 _inst_2} {g : SupHom.{u1, u2} α β _inst_1 _inst_2}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : SupHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : SupHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a)) -> (Eq.{max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : HasSup.{u1} β] {f : SupHom.{u2, u1} α β _inst_1 _inst_2} {g : SupHom.{u2, u1} α β _inst_1 _inst_2}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 _inst_2) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 _inst_2) g a)) -> (Eq.{max (succ u2) (succ u1)} (SupHom.{u2, u1} α β _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align sup_hom.ext SupHom.extₓ'. -/
@[ext]
theorem ext {f g : SupHom α β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align sup_hom.ext SupHom.ext

#print SupHom.copy /-
/-- Copy of a `sup_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : SupHom α β) (f' : α → β) (h : f' = f) : SupHom α β
    where
  toFun := f'
  map_sup' := h.symm ▸ f.map_sup'
#align sup_hom.copy SupHom.copy
-/

/- warning: sup_hom.coe_copy -> SupHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] (f : SupHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : SupHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : SupHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (SupHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : HasSup.{u1} β] (f : SupHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 _inst_2) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 _inst_2) (SupHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align sup_hom.coe_copy SupHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : SupHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align sup_hom.coe_copy SupHom.coe_copy

/- warning: sup_hom.copy_eq -> SupHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] (f : SupHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : SupHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (SupHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : HasSup.{u1} β] (f : SupHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 _inst_2) f)), Eq.{max (succ u2) (succ u1)} (SupHom.{u2, u1} α β _inst_1 _inst_2) (SupHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h) f
Case conversion may be inaccurate. Consider using '#align sup_hom.copy_eq SupHom.copy_eqₓ'. -/
theorem copy_eq (f : SupHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align sup_hom.copy_eq SupHom.copy_eq

variable (α)

#print SupHom.id /-
/-- `id` as a `sup_hom`. -/
protected def id : SupHom α α :=
  ⟨id, fun a b => rfl⟩
#align sup_hom.id SupHom.id
-/

instance : Inhabited (SupHom α α) :=
  ⟨SupHom.id α⟩

#print SupHom.coe_id /-
@[simp]
theorem coe_id : ⇑(SupHom.id α) = id :=
  rfl
#align sup_hom.coe_id SupHom.coe_id
-/

variable {α}

#print SupHom.id_apply /-
@[simp]
theorem id_apply (a : α) : SupHom.id α a = a :=
  rfl
#align sup_hom.id_apply SupHom.id_apply
-/

#print SupHom.comp /-
/-- Composition of `sup_hom`s as a `sup_hom`. -/
def comp (f : SupHom β γ) (g : SupHom α β) : SupHom α γ
    where
  toFun := f ∘ g
  map_sup' a b := by rw [comp_apply, map_sup, map_sup]
#align sup_hom.comp SupHom.comp
-/

/- warning: sup_hom.coe_comp -> SupHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] [_inst_3 : HasSup.{u3} γ] (f : SupHom.{u2, u3} β γ _inst_2 _inst_3) (g : SupHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} ((fun (_x : SupHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (SupHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : SupHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (SupHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : SupHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (SupHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : SupHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u3} β] [_inst_3 : HasSup.{u2} γ] (f : SupHom.{u3, u2} β γ _inst_2 _inst_3) (g : SupHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (SupHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => γ) _x) (SupHom.instFunLikeSupHom.{u1, u2} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (SupHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : β) => γ) _x) (SupHom.instFunLikeSupHom.{u3, u2} β γ _inst_2 _inst_3) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (SupHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u1, u3} α β _inst_1 _inst_2) g))
Case conversion may be inaccurate. Consider using '#align sup_hom.coe_comp SupHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (f : SupHom β γ) (g : SupHom α β) : (f.comp g : α → γ) = f ∘ g :=
  rfl
#align sup_hom.coe_comp SupHom.coe_comp

/- warning: sup_hom.comp_apply -> SupHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] [_inst_3 : HasSup.{u3} γ] (f : SupHom.{u2, u3} β γ _inst_2 _inst_3) (g : SupHom.{u1, u2} α β _inst_1 _inst_2) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : SupHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (SupHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : SupHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (SupHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : SupHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u3} β] [_inst_3 : HasSup.{u2} γ] (f : SupHom.{u3, u2} β γ _inst_2 _inst_3) (g : SupHom.{u1, u3} α β _inst_1 _inst_2) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (SupHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => γ) _x) (SupHom.instFunLikeSupHom.{u1, u2} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (SupHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : β) => γ) _x) (SupHom.instFunLikeSupHom.{u3, u2} β γ _inst_2 _inst_3) f (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (SupHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u1, u3} α β _inst_1 _inst_2) g a))
Case conversion may be inaccurate. Consider using '#align sup_hom.comp_apply SupHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (f : SupHom β γ) (g : SupHom α β) (a : α) : (f.comp g) a = f (g a) :=
  rfl
#align sup_hom.comp_apply SupHom.comp_apply

/- warning: sup_hom.comp_assoc -> SupHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] [_inst_3 : HasSup.{u3} γ] [_inst_4 : HasSup.{u4} δ] (f : SupHom.{u3, u4} γ δ _inst_3 _inst_4) (g : SupHom.{u2, u3} β γ _inst_2 _inst_3) (h : SupHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u4)} (SupHom.{u1, u4} α δ _inst_1 _inst_4) (SupHom.comp.{u1, u2, u4} α β δ _inst_1 _inst_2 _inst_4 (SupHom.comp.{u2, u3, u4} β γ δ _inst_2 _inst_3 _inst_4 f g) h) (SupHom.comp.{u1, u3, u4} α γ δ _inst_1 _inst_3 _inst_4 f (SupHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u4}} {δ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] [_inst_3 : HasSup.{u4} γ] [_inst_4 : HasSup.{u3} δ] (f : SupHom.{u4, u3} γ δ _inst_3 _inst_4) (g : SupHom.{u2, u4} β γ _inst_2 _inst_3) (h : SupHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (SupHom.{u1, u3} α δ _inst_1 _inst_4) (SupHom.comp.{u1, u2, u3} α β δ _inst_1 _inst_2 _inst_4 (SupHom.comp.{u2, u4, u3} β γ δ _inst_2 _inst_3 _inst_4 f g) h) (SupHom.comp.{u1, u4, u3} α γ δ _inst_1 _inst_3 _inst_4 f (SupHom.comp.{u1, u2, u4} α β γ _inst_1 _inst_2 _inst_3 g h))
Case conversion may be inaccurate. Consider using '#align sup_hom.comp_assoc SupHom.comp_assocₓ'. -/
@[simp]
theorem comp_assoc (f : SupHom γ δ) (g : SupHom β γ) (h : SupHom α β) :
    (f.comp g).comp h = f.comp (g.comp h) :=
  rfl
#align sup_hom.comp_assoc SupHom.comp_assoc

/- warning: sup_hom.comp_id -> SupHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] (f : SupHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (SupHom.comp.{u1, u1, u2} α α β _inst_1 _inst_1 _inst_2 f (SupHom.id.{u1} α _inst_1)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : HasSup.{u1} β] (f : SupHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (SupHom.{u2, u1} α β _inst_1 _inst_2) (SupHom.comp.{u2, u2, u1} α α β _inst_1 _inst_1 _inst_2 f (SupHom.id.{u2} α _inst_1)) f
Case conversion may be inaccurate. Consider using '#align sup_hom.comp_id SupHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : SupHom α β) : f.comp (SupHom.id α) = f :=
  SupHom.ext fun a => rfl
#align sup_hom.comp_id SupHom.comp_id

/- warning: sup_hom.id_comp -> SupHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] (f : SupHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (SupHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_2 (SupHom.id.{u2} β _inst_2) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : HasSup.{u1} β] (f : SupHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (SupHom.{u2, u1} α β _inst_1 _inst_2) (SupHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_2 (SupHom.id.{u1} β _inst_2) f) f
Case conversion may be inaccurate. Consider using '#align sup_hom.id_comp SupHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : SupHom α β) : (SupHom.id β).comp f = f :=
  SupHom.ext fun a => rfl
#align sup_hom.id_comp SupHom.id_comp

/- warning: sup_hom.cancel_right -> SupHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] [_inst_3 : HasSup.{u3} γ] {g₁ : SupHom.{u2, u3} β γ _inst_2 _inst_3} {g₂ : SupHom.{u2, u3} β γ _inst_2 _inst_3} {f : SupHom.{u1, u2} α β _inst_1 _inst_2}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : SupHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₁ f) (SupHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₂ f)) (Eq.{max (succ u2) (succ u3)} (SupHom.{u2, u3} β γ _inst_2 _inst_3) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u3} β] [_inst_3 : HasSup.{u2} γ] {g₁ : SupHom.{u3, u2} β γ _inst_2 _inst_3} {g₂ : SupHom.{u3, u2} β γ _inst_2 _inst_3} {f : SupHom.{u1, u3} α β _inst_1 _inst_2}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (SupHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u1, u3} α β _inst_1 _inst_2) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (SupHom.{u1, u2} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₁ f) (SupHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₂ f)) (Eq.{max (succ u3) (succ u2)} (SupHom.{u3, u2} β γ _inst_2 _inst_3) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align sup_hom.cancel_right SupHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : SupHom β γ} {f : SupHom α β} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => SupHom.ext <| hf.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align sup_hom.cancel_right SupHom.cancel_right

/- warning: sup_hom.cancel_left -> SupHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] [_inst_3 : HasSup.{u3} γ] {g : SupHom.{u2, u3} β γ _inst_2 _inst_3} {f₁ : SupHom.{u1, u2} α β _inst_1 _inst_2} {f₂ : SupHom.{u1, u2} α β _inst_1 _inst_2}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : SupHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (SupHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f₁) (SupHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f₂)) (Eq.{max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u3} β] [_inst_3 : HasSup.{u2} γ] {g : SupHom.{u3, u2} β γ _inst_2 _inst_3} {f₁ : SupHom.{u1, u3} α β _inst_1 _inst_2} {f₂ : SupHom.{u1, u3} α β _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (SupHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : β) => γ) _x) (SupHom.instFunLikeSupHom.{u3, u2} β γ _inst_2 _inst_3) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (SupHom.{u1, u2} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f₁) (SupHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f₂)) (Eq.{max (succ u1) (succ u3)} (SupHom.{u1, u3} α β _inst_1 _inst_2) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align sup_hom.cancel_left SupHom.cancel_leftₓ'. -/
theorem cancel_left {g : SupHom β γ} {f₁ f₂ : SupHom α β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => SupHom.ext fun a => hg <| by rw [← SupHom.comp_apply, h, SupHom.comp_apply],
    congr_arg _⟩
#align sup_hom.cancel_left SupHom.cancel_left

end HasSup

variable (α) [SemilatticeSup β]

#print SupHom.const /-
/-- The constant function as a `sup_hom`. -/
def const (b : β) : SupHom α β :=
  ⟨fun _ => b, fun _ _ => sup_idem.symm⟩
#align sup_hom.const SupHom.const
-/

/- warning: sup_hom.coe_const -> SupHom.coe_const is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] (b : β), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (fun (_x : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (SupHom.const.{u1, u2} α β _inst_1 _inst_2 b)) (Function.const.{succ u2, succ u1} β α b)
but is expected to have type
  forall (α : Type.{u2}) {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : SemilatticeSup.{u1} β] (b : β), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) (SupHom.const.{u2, u1} α β _inst_1 _inst_2 b)) (Function.const.{succ u1, succ u2} β α b)
Case conversion may be inaccurate. Consider using '#align sup_hom.coe_const SupHom.coe_constₓ'. -/
@[simp]
theorem coe_const (b : β) : ⇑(const α b) = Function.const α b :=
  rfl
#align sup_hom.coe_const SupHom.coe_const

#print SupHom.const_apply /-
@[simp]
theorem const_apply (b : β) (a : α) : const α b a = b :=
  rfl
#align sup_hom.const_apply SupHom.const_apply
-/

variable {α}

instance : HasSup (SupHom α β) :=
  ⟨fun f g =>
    ⟨f ⊔ g, fun a b => by
      rw [Pi.sup_apply, map_sup, map_sup]
      exact sup_sup_sup_comm _ _ _ _⟩⟩

instance : SemilatticeSup (SupHom α β) :=
  FunLike.coe_injective.SemilatticeSup _ fun f g => rfl

instance [Bot β] : Bot (SupHom α β) :=
  ⟨SupHom.const α ⊥⟩

instance [Top β] : Top (SupHom α β) :=
  ⟨SupHom.const α ⊤⟩

instance [OrderBot β] : OrderBot (SupHom α β) :=
  OrderBot.lift (coeFn : _ → α → β) (fun _ _ => id) rfl

instance [OrderTop β] : OrderTop (SupHom α β) :=
  OrderTop.lift (coeFn : _ → α → β) (fun _ _ => id) rfl

instance [BoundedOrder β] : BoundedOrder (SupHom α β) :=
  BoundedOrder.lift (coeFn : _ → α → β) (fun _ _ => id) rfl rfl

/- warning: sup_hom.coe_sup -> SupHom.coe_sup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] (f : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (g : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (fun (_x : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (HasSup.sup.{max u1 u2} (SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (SupHom.hasSup.{u1, u2} α β _inst_1 _inst_2) f g)) (HasSup.sup.{max u1 u2} (α -> β) (Pi.hasSup.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeSup.toHasSup.{u2} β _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (fun (_x : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (fun (_x : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) g))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : SemilatticeSup.{u1} β] (f : SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) (g : SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)), Eq.{max (succ u2) (succ u1)} (α -> β) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) α (fun (_x : α) => β) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) (HasSup.sup.{max u2 u1} (SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) (SupHom.instHasSupSupHomToHasSup.{u2, u1} α β _inst_1 _inst_2) f g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) a) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) (HasSup.sup.{max u2 u1} (SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) (SupHom.instHasSupSupHomToHasSup.{u2, u1} α β _inst_1 _inst_2) f g))
Case conversion may be inaccurate. Consider using '#align sup_hom.coe_sup SupHom.coe_supₓ'. -/
@[simp]
theorem coe_sup (f g : SupHom α β) : ⇑(f ⊔ g) = f ⊔ g :=
  rfl
#align sup_hom.coe_sup SupHom.coe_sup

#print SupHom.coe_bot /-
@[simp]
theorem coe_bot [Bot β] : ⇑(⊥ : SupHom α β) = ⊥ :=
  rfl
#align sup_hom.coe_bot SupHom.coe_bot
-/

#print SupHom.coe_top /-
@[simp]
theorem coe_top [Top β] : ⇑(⊤ : SupHom α β) = ⊤ :=
  rfl
#align sup_hom.coe_top SupHom.coe_top
-/

/- warning: sup_hom.sup_apply -> SupHom.sup_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : SemilatticeSup.{u2} β] (f : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (g : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (fun (_x : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (HasSup.sup.{max u1 u2} (SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (SupHom.hasSup.{u1, u2} α β _inst_1 _inst_2) f g) a) (HasSup.sup.{u2} β (SemilatticeSup.toHasSup.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (fun (_x : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) (fun (_x : SupHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) => α -> β) (SupHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_2)) g a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : SemilatticeSup.{u1} β] (f : SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) (g : SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) (HasSup.sup.{max u2 u1} (SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) (SupHom.instHasSupSupHomToHasSup.{u2, u1} α β _inst_1 _inst_2) f g) a) (HasSup.sup.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) a) (SemilatticeSup.toHasSup.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) a) _inst_2) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.2768 : α) => β) _x) (SupHom.instFunLikeSupHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_2)) g a))
Case conversion may be inaccurate. Consider using '#align sup_hom.sup_apply SupHom.sup_applyₓ'. -/
@[simp]
theorem sup_apply (f g : SupHom α β) (a : α) : (f ⊔ g) a = f a ⊔ g a :=
  rfl
#align sup_hom.sup_apply SupHom.sup_apply

#print SupHom.bot_apply /-
@[simp]
theorem bot_apply [Bot β] (a : α) : (⊥ : SupHom α β) a = ⊥ :=
  rfl
#align sup_hom.bot_apply SupHom.bot_apply
-/

#print SupHom.top_apply /-
@[simp]
theorem top_apply [Top β] (a : α) : (⊤ : SupHom α β) a = ⊤ :=
  rfl
#align sup_hom.top_apply SupHom.top_apply
-/

end SupHom

/-! ### Infimum homomorphisms -/


namespace InfHom

variable [HasInf α]

section HasInf

variable [HasInf β] [HasInf γ] [HasInf δ]

instance : InfHomClass (InfHom α β) α β
    where
  coe := InfHom.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
  map_inf := InfHom.map_inf'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (InfHom α β) fun _ => α → β :=
  ⟨fun f => f.toFun⟩

/- warning: inf_hom.to_fun_eq_coe -> InfHom.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] {f : InfHom.{u1, u2} α β _inst_1 _inst_2}, Eq.{max (succ u1) (succ u2)} (α -> β) (InfHom.toFun.{u1, u2} α β _inst_1 _inst_2 f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : InfHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : HasInf.{u1} β] {f : InfHom.{u2, u1} α β _inst_1 _inst_2}, Eq.{max (succ u2) (succ u1)} (α -> β) (InfHom.toFun.{u2, u1} α β _inst_1 _inst_2 f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 _inst_2) f)
Case conversion may be inaccurate. Consider using '#align inf_hom.to_fun_eq_coe InfHom.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe {f : InfHom α β} : f.toFun = (f : α → β) :=
  rfl
#align inf_hom.to_fun_eq_coe InfHom.toFun_eq_coe

/- warning: inf_hom.ext -> InfHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] {f : InfHom.{u1, u2} α β _inst_1 _inst_2} {g : InfHom.{u1, u2} α β _inst_1 _inst_2}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : InfHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : InfHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a)) -> (Eq.{max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : HasInf.{u1} β] {f : InfHom.{u2, u1} α β _inst_1 _inst_2} {g : InfHom.{u2, u1} α β _inst_1 _inst_2}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 _inst_2) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 _inst_2) g a)) -> (Eq.{max (succ u2) (succ u1)} (InfHom.{u2, u1} α β _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align inf_hom.ext InfHom.extₓ'. -/
@[ext]
theorem ext {f g : InfHom α β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align inf_hom.ext InfHom.ext

#print InfHom.copy /-
/-- Copy of an `inf_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : InfHom α β) (f' : α → β) (h : f' = f) : InfHom α β
    where
  toFun := f'
  map_inf' := h.symm ▸ f.map_inf'
#align inf_hom.copy InfHom.copy
-/

/- warning: inf_hom.coe_copy -> InfHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] (f : InfHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : InfHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : InfHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (InfHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : HasInf.{u1} β] (f : InfHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 _inst_2) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 _inst_2) (InfHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align inf_hom.coe_copy InfHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : InfHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align inf_hom.coe_copy InfHom.coe_copy

/- warning: inf_hom.copy_eq -> InfHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] (f : InfHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : InfHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (InfHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : HasInf.{u1} β] (f : InfHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 _inst_2) f)), Eq.{max (succ u2) (succ u1)} (InfHom.{u2, u1} α β _inst_1 _inst_2) (InfHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h) f
Case conversion may be inaccurate. Consider using '#align inf_hom.copy_eq InfHom.copy_eqₓ'. -/
theorem copy_eq (f : InfHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align inf_hom.copy_eq InfHom.copy_eq

variable (α)

#print InfHom.id /-
/-- `id` as an `inf_hom`. -/
protected def id : InfHom α α :=
  ⟨id, fun a b => rfl⟩
#align inf_hom.id InfHom.id
-/

instance : Inhabited (InfHom α α) :=
  ⟨InfHom.id α⟩

#print InfHom.coe_id /-
@[simp]
theorem coe_id : ⇑(InfHom.id α) = id :=
  rfl
#align inf_hom.coe_id InfHom.coe_id
-/

variable {α}

#print InfHom.id_apply /-
@[simp]
theorem id_apply (a : α) : InfHom.id α a = a :=
  rfl
#align inf_hom.id_apply InfHom.id_apply
-/

#print InfHom.comp /-
/-- Composition of `inf_hom`s as an `inf_hom`. -/
def comp (f : InfHom β γ) (g : InfHom α β) : InfHom α γ
    where
  toFun := f ∘ g
  map_inf' a b := by rw [comp_apply, map_inf, map_inf]
#align inf_hom.comp InfHom.comp
-/

/- warning: inf_hom.coe_comp -> InfHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] [_inst_3 : HasInf.{u3} γ] (f : InfHom.{u2, u3} β γ _inst_2 _inst_3) (g : InfHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} ((fun (_x : InfHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (InfHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : InfHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (InfHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : InfHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (InfHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : InfHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u3} β] [_inst_3 : HasInf.{u2} γ] (f : InfHom.{u3, u2} β γ _inst_2 _inst_3) (g : InfHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (InfHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => γ) _x) (InfHom.instFunLikeInfHom.{u1, u2} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (InfHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : β) => γ) _x) (InfHom.instFunLikeInfHom.{u3, u2} β γ _inst_2 _inst_3) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (InfHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u1, u3} α β _inst_1 _inst_2) g))
Case conversion may be inaccurate. Consider using '#align inf_hom.coe_comp InfHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (f : InfHom β γ) (g : InfHom α β) : (f.comp g : α → γ) = f ∘ g :=
  rfl
#align inf_hom.coe_comp InfHom.coe_comp

/- warning: inf_hom.comp_apply -> InfHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] [_inst_3 : HasInf.{u3} γ] (f : InfHom.{u2, u3} β γ _inst_2 _inst_3) (g : InfHom.{u1, u2} α β _inst_1 _inst_2) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : InfHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (InfHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : InfHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (InfHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : InfHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u3} β] [_inst_3 : HasInf.{u2} γ] (f : InfHom.{u3, u2} β γ _inst_2 _inst_3) (g : InfHom.{u1, u3} α β _inst_1 _inst_2) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (InfHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => γ) _x) (InfHom.instFunLikeInfHom.{u1, u2} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (InfHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : β) => γ) _x) (InfHom.instFunLikeInfHom.{u3, u2} β γ _inst_2 _inst_3) f (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (InfHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u1, u3} α β _inst_1 _inst_2) g a))
Case conversion may be inaccurate. Consider using '#align inf_hom.comp_apply InfHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (f : InfHom β γ) (g : InfHom α β) (a : α) : (f.comp g) a = f (g a) :=
  rfl
#align inf_hom.comp_apply InfHom.comp_apply

/- warning: inf_hom.comp_assoc -> InfHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] [_inst_3 : HasInf.{u3} γ] [_inst_4 : HasInf.{u4} δ] (f : InfHom.{u3, u4} γ δ _inst_3 _inst_4) (g : InfHom.{u2, u3} β γ _inst_2 _inst_3) (h : InfHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u4)} (InfHom.{u1, u4} α δ _inst_1 _inst_4) (InfHom.comp.{u1, u2, u4} α β δ _inst_1 _inst_2 _inst_4 (InfHom.comp.{u2, u3, u4} β γ δ _inst_2 _inst_3 _inst_4 f g) h) (InfHom.comp.{u1, u3, u4} α γ δ _inst_1 _inst_3 _inst_4 f (InfHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u4}} {δ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] [_inst_3 : HasInf.{u4} γ] [_inst_4 : HasInf.{u3} δ] (f : InfHom.{u4, u3} γ δ _inst_3 _inst_4) (g : InfHom.{u2, u4} β γ _inst_2 _inst_3) (h : InfHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (InfHom.{u1, u3} α δ _inst_1 _inst_4) (InfHom.comp.{u1, u2, u3} α β δ _inst_1 _inst_2 _inst_4 (InfHom.comp.{u2, u4, u3} β γ δ _inst_2 _inst_3 _inst_4 f g) h) (InfHom.comp.{u1, u4, u3} α γ δ _inst_1 _inst_3 _inst_4 f (InfHom.comp.{u1, u2, u4} α β γ _inst_1 _inst_2 _inst_3 g h))
Case conversion may be inaccurate. Consider using '#align inf_hom.comp_assoc InfHom.comp_assocₓ'. -/
@[simp]
theorem comp_assoc (f : InfHom γ δ) (g : InfHom β γ) (h : InfHom α β) :
    (f.comp g).comp h = f.comp (g.comp h) :=
  rfl
#align inf_hom.comp_assoc InfHom.comp_assoc

/- warning: inf_hom.comp_id -> InfHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] (f : InfHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (InfHom.comp.{u1, u1, u2} α α β _inst_1 _inst_1 _inst_2 f (InfHom.id.{u1} α _inst_1)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : HasInf.{u1} β] (f : InfHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (InfHom.{u2, u1} α β _inst_1 _inst_2) (InfHom.comp.{u2, u2, u1} α α β _inst_1 _inst_1 _inst_2 f (InfHom.id.{u2} α _inst_1)) f
Case conversion may be inaccurate. Consider using '#align inf_hom.comp_id InfHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : InfHom α β) : f.comp (InfHom.id α) = f :=
  InfHom.ext fun a => rfl
#align inf_hom.comp_id InfHom.comp_id

/- warning: inf_hom.id_comp -> InfHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] (f : InfHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (InfHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_2 (InfHom.id.{u2} β _inst_2) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : HasInf.{u1} β] (f : InfHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (InfHom.{u2, u1} α β _inst_1 _inst_2) (InfHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_2 (InfHom.id.{u1} β _inst_2) f) f
Case conversion may be inaccurate. Consider using '#align inf_hom.id_comp InfHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : InfHom α β) : (InfHom.id β).comp f = f :=
  InfHom.ext fun a => rfl
#align inf_hom.id_comp InfHom.id_comp

/- warning: inf_hom.cancel_right -> InfHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] [_inst_3 : HasInf.{u3} γ] {g₁ : InfHom.{u2, u3} β γ _inst_2 _inst_3} {g₂ : InfHom.{u2, u3} β γ _inst_2 _inst_3} {f : InfHom.{u1, u2} α β _inst_1 _inst_2}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : InfHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₁ f) (InfHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₂ f)) (Eq.{max (succ u2) (succ u3)} (InfHom.{u2, u3} β γ _inst_2 _inst_3) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u3} β] [_inst_3 : HasInf.{u2} γ] {g₁ : InfHom.{u3, u2} β γ _inst_2 _inst_3} {g₂ : InfHom.{u3, u2} β γ _inst_2 _inst_3} {f : InfHom.{u1, u3} α β _inst_1 _inst_2}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (InfHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u1, u3} α β _inst_1 _inst_2) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (InfHom.{u1, u2} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₁ f) (InfHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₂ f)) (Eq.{max (succ u3) (succ u2)} (InfHom.{u3, u2} β γ _inst_2 _inst_3) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align inf_hom.cancel_right InfHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : InfHom β γ} {f : InfHom α β} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => InfHom.ext <| hf.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align inf_hom.cancel_right InfHom.cancel_right

/- warning: inf_hom.cancel_left -> InfHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] [_inst_3 : HasInf.{u3} γ] {g : InfHom.{u2, u3} β γ _inst_2 _inst_3} {f₁ : InfHom.{u1, u2} α β _inst_1 _inst_2} {f₂ : InfHom.{u1, u2} α β _inst_1 _inst_2}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : InfHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (InfHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f₁) (InfHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f₂)) (Eq.{max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u3} β] [_inst_3 : HasInf.{u2} γ] {g : InfHom.{u3, u2} β γ _inst_2 _inst_3} {f₁ : InfHom.{u1, u3} α β _inst_1 _inst_2} {f₂ : InfHom.{u1, u3} α β _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (InfHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : β) => γ) _x) (InfHom.instFunLikeInfHom.{u3, u2} β γ _inst_2 _inst_3) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (InfHom.{u1, u2} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f₁) (InfHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f₂)) (Eq.{max (succ u1) (succ u3)} (InfHom.{u1, u3} α β _inst_1 _inst_2) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align inf_hom.cancel_left InfHom.cancel_leftₓ'. -/
theorem cancel_left {g : InfHom β γ} {f₁ f₂ : InfHom α β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => InfHom.ext fun a => hg <| by rw [← InfHom.comp_apply, h, InfHom.comp_apply],
    congr_arg _⟩
#align inf_hom.cancel_left InfHom.cancel_left

end HasInf

variable (α) [SemilatticeInf β]

#print InfHom.const /-
/-- The constant function as an `inf_hom`. -/
def const (b : β) : InfHom α β :=
  ⟨fun _ => b, fun _ _ => inf_idem.symm⟩
#align inf_hom.const InfHom.const
-/

/- warning: inf_hom.coe_const -> InfHom.coe_const is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] (b : β), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (fun (_x : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (InfHom.const.{u1, u2} α β _inst_1 _inst_2 b)) (Function.const.{succ u2, succ u1} β α b)
but is expected to have type
  forall (α : Type.{u2}) {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : SemilatticeInf.{u1} β] (b : β), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) (InfHom.const.{u2, u1} α β _inst_1 _inst_2 b)) (Function.const.{succ u1, succ u2} β α b)
Case conversion may be inaccurate. Consider using '#align inf_hom.coe_const InfHom.coe_constₓ'. -/
@[simp]
theorem coe_const (b : β) : ⇑(const α b) = Function.const α b :=
  rfl
#align inf_hom.coe_const InfHom.coe_const

#print InfHom.const_apply /-
@[simp]
theorem const_apply (b : β) (a : α) : const α b a = b :=
  rfl
#align inf_hom.const_apply InfHom.const_apply
-/

variable {α}

instance : HasInf (InfHom α β) :=
  ⟨fun f g =>
    ⟨f ⊓ g, fun a b => by
      rw [Pi.inf_apply, map_inf, map_inf]
      exact inf_inf_inf_comm _ _ _ _⟩⟩

instance : SemilatticeInf (InfHom α β) :=
  FunLike.coe_injective.SemilatticeInf _ fun f g => rfl

instance [Bot β] : Bot (InfHom α β) :=
  ⟨InfHom.const α ⊥⟩

instance [Top β] : Top (InfHom α β) :=
  ⟨InfHom.const α ⊤⟩

instance [OrderBot β] : OrderBot (InfHom α β) :=
  OrderBot.lift (coeFn : _ → α → β) (fun _ _ => id) rfl

instance [OrderTop β] : OrderTop (InfHom α β) :=
  OrderTop.lift (coeFn : _ → α → β) (fun _ _ => id) rfl

instance [BoundedOrder β] : BoundedOrder (InfHom α β) :=
  BoundedOrder.lift (coeFn : _ → α → β) (fun _ _ => id) rfl rfl

/- warning: inf_hom.coe_inf -> InfHom.coe_inf is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] (f : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (g : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (fun (_x : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (HasInf.inf.{max u1 u2} (InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (InfHom.hasInf.{u1, u2} α β _inst_1 _inst_2) f g)) (HasInf.inf.{max u1 u2} (α -> β) (Pi.hasInf.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeInf.toHasInf.{u2} β _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (fun (_x : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (fun (_x : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) g))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : SemilatticeInf.{u1} β] (f : InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) (g : InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)), Eq.{max (succ u2) (succ u1)} (α -> β) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) α (fun (_x : α) => β) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) (HasInf.inf.{max u2 u1} (InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) (InfHom.instHasInfInfHomToHasInf.{u2, u1} α β _inst_1 _inst_2) f g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) a) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) (HasInf.inf.{max u2 u1} (InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) (InfHom.instHasInfInfHomToHasInf.{u2, u1} α β _inst_1 _inst_2) f g))
Case conversion may be inaccurate. Consider using '#align inf_hom.coe_inf InfHom.coe_infₓ'. -/
@[simp]
theorem coe_inf (f g : InfHom α β) : ⇑(f ⊓ g) = f ⊓ g :=
  rfl
#align inf_hom.coe_inf InfHom.coe_inf

#print InfHom.coe_bot /-
@[simp]
theorem coe_bot [Bot β] : ⇑(⊥ : InfHom α β) = ⊥ :=
  rfl
#align inf_hom.coe_bot InfHom.coe_bot
-/

#print InfHom.coe_top /-
@[simp]
theorem coe_top [Top β] : ⇑(⊤ : InfHom α β) = ⊤ :=
  rfl
#align inf_hom.coe_top InfHom.coe_top
-/

/- warning: inf_hom.inf_apply -> InfHom.inf_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : SemilatticeInf.{u2} β] (f : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (g : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (fun (_x : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (HasInf.inf.{max u1 u2} (InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (InfHom.hasInf.{u1, u2} α β _inst_1 _inst_2) f g) a) (HasInf.inf.{u2} β (SemilatticeInf.toHasInf.{u2} β _inst_2) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (fun (_x : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) (fun (_x : InfHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) => α -> β) (InfHom.hasCoeToFun.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_2)) g a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : SemilatticeInf.{u1} β] (f : InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) (g : InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) (HasInf.inf.{max u2 u1} (InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) (InfHom.instHasInfInfHomToHasInf.{u2, u1} α β _inst_1 _inst_2) f g) a) (HasInf.inf.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) a) (SemilatticeInf.toHasInf.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) a) _inst_2) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.4340 : α) => β) _x) (InfHom.instFunLikeInfHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_2)) g a))
Case conversion may be inaccurate. Consider using '#align inf_hom.inf_apply InfHom.inf_applyₓ'. -/
@[simp]
theorem inf_apply (f g : InfHom α β) (a : α) : (f ⊓ g) a = f a ⊓ g a :=
  rfl
#align inf_hom.inf_apply InfHom.inf_apply

#print InfHom.bot_apply /-
@[simp]
theorem bot_apply [Bot β] (a : α) : (⊥ : InfHom α β) a = ⊥ :=
  rfl
#align inf_hom.bot_apply InfHom.bot_apply
-/

#print InfHom.top_apply /-
@[simp]
theorem top_apply [Top β] (a : α) : (⊤ : InfHom α β) a = ⊤ :=
  rfl
#align inf_hom.top_apply InfHom.top_apply
-/

end InfHom

/-! ### Finitary supremum homomorphisms -/


namespace SupBotHom

variable [HasSup α] [Bot α]

section HasSup

variable [HasSup β] [Bot β] [HasSup γ] [Bot γ] [HasSup δ] [Bot δ]

#print SupBotHom.toBotHom /-
/-- Reinterpret a `sup_bot_hom` as a `bot_hom`. -/
def toBotHom (f : SupBotHom α β) : BotHom α β :=
  { f with }
#align sup_bot_hom.to_bot_hom SupBotHom.toBotHom
-/

instance : SupBotHomClass (SupBotHom α β) α β
    where
  coe f := f.toFun
  coe_injective' f g h := by
    obtain ⟨⟨_, _⟩, _⟩ := f
    obtain ⟨⟨_, _⟩, _⟩ := g
    congr
  map_sup f := f.map_sup'
  map_bot f := f.map_bot'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (SupBotHom α β) fun _ => α → β :=
  FunLike.hasCoeToFun

/- warning: sup_bot_hom.to_fun_eq_coe -> SupBotHom.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] {f : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4}, Eq.{max (succ u1) (succ u2)} (α -> β) (SupHom.toFun.{u1, u2} α β _inst_1 _inst_3 (SupBotHom.toSupHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4 f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : Bot.{u2} α] [_inst_3 : HasSup.{u1} β] [_inst_4 : Bot.{u1} β] {f : SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4}, Eq.{max (succ u2) (succ u1)} (α -> β) (SupHom.toFun.{u2, u1} α β _inst_1 _inst_3 (SupBotHom.toSupHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f)
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.to_fun_eq_coe SupBotHom.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe {f : SupBotHom α β} : f.toFun = (f : α → β) :=
  rfl
#align sup_bot_hom.to_fun_eq_coe SupBotHom.toFun_eq_coe

/- warning: sup_bot_hom.ext -> SupBotHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] {f : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4} {g : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g a)) -> (Eq.{max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : Bot.{u2} α] [_inst_3 : HasSup.{u1} β] [_inst_4 : Bot.{u1} β] {f : SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4} {g : SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) g a)) -> (Eq.{max (succ u2) (succ u1)} (SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) f g)
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.ext SupBotHom.extₓ'. -/
@[ext]
theorem ext {f g : SupBotHom α β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align sup_bot_hom.ext SupBotHom.ext

/- warning: sup_bot_hom.copy -> SupBotHom.copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] (f : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)) -> (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] (f : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)) -> (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.copy SupBotHom.copyₓ'. -/
/-- Copy of a `sup_bot_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : SupBotHom α β) (f' : α → β) (h : f' = f) : SupBotHom α β :=
  { f.toBotHom.copy f' h with toSupHom := f.toSupHom.copy f' h }
#align sup_bot_hom.copy SupBotHom.copy

/- warning: sup_bot_hom.coe_copy -> SupBotHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] (f : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (SupBotHom.copy.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : Bot.{u2} α] [_inst_3 : HasSup.{u1} β] [_inst_4 : Bot.{u1} β] (f : SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (SupBotHom.copy.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.coe_copy SupBotHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : SupBotHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align sup_bot_hom.coe_copy SupBotHom.coe_copy

/- warning: sup_bot_hom.copy_eq -> SupBotHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] (f : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)), Eq.{max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.copy.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : Bot.{u2} α] [_inst_3 : HasSup.{u1} β] [_inst_4 : Bot.{u1} β] (f : SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f)), Eq.{max (succ u2) (succ u1)} (SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.copy.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h) f
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.copy_eq SupBotHom.copy_eqₓ'. -/
theorem copy_eq (f : SupBotHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align sup_bot_hom.copy_eq SupBotHom.copy_eq

variable (α)

#print SupBotHom.id /-
/-- `id` as a `sup_bot_hom`. -/
@[simps]
protected def id : SupBotHom α α :=
  ⟨SupHom.id α, rfl⟩
#align sup_bot_hom.id SupBotHom.id
-/

instance : Inhabited (SupBotHom α α) :=
  ⟨SupBotHom.id α⟩

/- warning: sup_bot_hom.coe_id -> SupBotHom.coe_id is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (SupBotHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) (fun (_x : SupBotHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) => α -> α) (SupBotHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (SupBotHom.id.{u1} α _inst_1 _inst_2)) (id.{succ u1} α)
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (SupBotHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => α) _x) (SupBotHom.instFunLikeSupBotHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (SupBotHom.id.{u1} α _inst_1 _inst_2)) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.coe_id SupBotHom.coe_idₓ'. -/
@[simp]
theorem coe_id : ⇑(SupBotHom.id α) = id :=
  rfl
#align sup_bot_hom.coe_id SupBotHom.coe_id

variable {α}

/- warning: sup_bot_hom.id_apply -> SupBotHom.id_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (SupBotHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) (fun (_x : SupBotHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) => α -> α) (SupBotHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (SupBotHom.id.{u1} α _inst_1 _inst_2) a) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (SupBotHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => α) _x) (SupBotHom.instFunLikeSupBotHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (SupBotHom.id.{u1} α _inst_1 _inst_2) a) a
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.id_apply SupBotHom.id_applyₓ'. -/
@[simp]
theorem id_apply (a : α) : SupBotHom.id α a = a :=
  rfl
#align sup_bot_hom.id_apply SupBotHom.id_apply

#print SupBotHom.comp /-
/-- Composition of `sup_bot_hom`s as a `sup_bot_hom`. -/
def comp (f : SupBotHom β γ) (g : SupBotHom α β) : SupBotHom α γ :=
  { f.toSupHom.comp g.toSupHom, f.toBotHom.comp g.toBotHom with }
#align sup_bot_hom.comp SupBotHom.comp
-/

/- warning: sup_bot_hom.coe_comp -> SupBotHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] [_inst_5 : HasSup.{u3} γ] [_inst_6 : Bot.{u3} γ] (f : SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (g : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u3)} ((fun (_x : SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) => α -> γ) (SupBotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (fun (_x : SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) => α -> γ) (SupBotHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (SupBotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) => β -> γ) (SupBotHom.hasCoeToFun.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u3} β] [_inst_4 : Bot.{u3} β] [_inst_5 : HasSup.{u2} γ] [_inst_6 : Bot.{u2} γ] (f : SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (g : SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => γ) _x) (SupBotHom.instFunLikeSupBotHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (SupBotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : β) => γ) _x) (SupBotHom.instFunLikeSupBotHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) g))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.coe_comp SupBotHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (f : SupBotHom β γ) (g : SupBotHom α β) : (f.comp g : α → γ) = f ∘ g :=
  rfl
#align sup_bot_hom.coe_comp SupBotHom.coe_comp

/- warning: sup_bot_hom.comp_apply -> SupBotHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] [_inst_5 : HasSup.{u3} γ] [_inst_6 : Bot.{u3} γ] (f : SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (g : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (fun (_x : SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) => α -> γ) (SupBotHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (SupBotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) => β -> γ) (SupBotHom.hasCoeToFun.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u3} β] [_inst_4 : Bot.{u3} β] [_inst_5 : HasSup.{u2} γ] [_inst_6 : Bot.{u2} γ] (f : SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (g : SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => γ) _x) (SupBotHom.instFunLikeSupBotHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (SupBotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : β) => γ) _x) (SupBotHom.instFunLikeSupBotHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) f (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) g a))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.comp_apply SupBotHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (f : SupBotHom β γ) (g : SupBotHom α β) (a : α) : (f.comp g) a = f (g a) :=
  rfl
#align sup_bot_hom.comp_apply SupBotHom.comp_apply

/- warning: sup_bot_hom.comp_assoc -> SupBotHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] [_inst_5 : HasSup.{u3} γ] [_inst_6 : Bot.{u3} γ] [_inst_7 : HasSup.{u4} δ] [_inst_8 : Bot.{u4} δ] (f : SupBotHom.{u3, u4} γ δ _inst_5 _inst_7 _inst_6 _inst_8) (g : SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (h : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u4)} (SupBotHom.{u1, u4} α δ _inst_1 _inst_7 _inst_2 _inst_8) (SupBotHom.comp.{u1, u2, u4} α β δ _inst_1 _inst_2 _inst_3 _inst_4 _inst_7 _inst_8 (SupBotHom.comp.{u2, u3, u4} β γ δ _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 f g) h) (SupBotHom.comp.{u1, u3, u4} α γ δ _inst_1 _inst_2 _inst_5 _inst_6 _inst_7 _inst_8 f (SupBotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u4}} {δ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] [_inst_5 : HasSup.{u4} γ] [_inst_6 : Bot.{u4} γ] [_inst_7 : HasSup.{u3} δ] [_inst_8 : Bot.{u3} δ] (f : SupBotHom.{u4, u3} γ δ _inst_5 _inst_7 _inst_6 _inst_8) (g : SupBotHom.{u2, u4} β γ _inst_3 _inst_5 _inst_4 _inst_6) (h : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α δ _inst_1 _inst_7 _inst_2 _inst_8) (SupBotHom.comp.{u1, u2, u3} α β δ _inst_1 _inst_2 _inst_3 _inst_4 _inst_7 _inst_8 (SupBotHom.comp.{u2, u4, u3} β γ δ _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 f g) h) (SupBotHom.comp.{u1, u4, u3} α γ δ _inst_1 _inst_2 _inst_5 _inst_6 _inst_7 _inst_8 f (SupBotHom.comp.{u1, u2, u4} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g h))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.comp_assoc SupBotHom.comp_assocₓ'. -/
@[simp]
theorem comp_assoc (f : SupBotHom γ δ) (g : SupBotHom β γ) (h : SupBotHom α β) :
    (f.comp g).comp h = f.comp (g.comp h) :=
  rfl
#align sup_bot_hom.comp_assoc SupBotHom.comp_assoc

/- warning: sup_bot_hom.comp_id -> SupBotHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] (f : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.comp.{u1, u1, u2} α α β _inst_1 _inst_2 _inst_1 _inst_2 _inst_3 _inst_4 f (SupBotHom.id.{u1} α _inst_1 _inst_2)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : Bot.{u2} α] [_inst_3 : HasSup.{u1} β] [_inst_4 : Bot.{u1} β] (f : SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u2) (succ u1)} (SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.comp.{u2, u2, u1} α α β _inst_1 _inst_2 _inst_1 _inst_2 _inst_3 _inst_4 f (SupBotHom.id.{u2} α _inst_1 _inst_2)) f
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.comp_id SupBotHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : SupBotHom α β) : f.comp (SupBotHom.id α) = f :=
  ext fun a => rfl
#align sup_bot_hom.comp_id SupBotHom.comp_id

/- warning: sup_bot_hom.id_comp -> SupBotHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] (f : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_3 _inst_4 _inst_3 _inst_4 (SupBotHom.id.{u2} β _inst_3 _inst_4) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : Bot.{u2} α] [_inst_3 : HasSup.{u1} β] [_inst_4 : Bot.{u1} β] (f : SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u2) (succ u1)} (SupBotHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_3 _inst_4 _inst_3 _inst_4 (SupBotHom.id.{u1} β _inst_3 _inst_4) f) f
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.id_comp SupBotHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : SupBotHom α β) : (SupBotHom.id β).comp f = f :=
  ext fun a => rfl
#align sup_bot_hom.id_comp SupBotHom.id_comp

/- warning: sup_bot_hom.cancel_right -> SupBotHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] [_inst_5 : HasSup.{u3} γ] [_inst_6 : Bot.{u3} γ] {g₁ : SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6} {g₂ : SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6} {f : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g₁ f) (SupBotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g₂ f)) (Eq.{max (succ u2) (succ u3)} (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u3} β] [_inst_4 : Bot.{u3} β] [_inst_5 : HasSup.{u2} γ] [_inst_6 : Bot.{u2} γ] {g₁ : SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6} {g₂ : SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6} {f : SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g₁ f) (SupBotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g₂ f)) (Eq.{max (succ u3) (succ u2)} (SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.cancel_right SupBotHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : SupBotHom β γ} {f : SupBotHom α β} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => ext <| hf.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align sup_bot_hom.cancel_right SupBotHom.cancel_right

/- warning: sup_bot_hom.cancel_left -> SupBotHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] [_inst_5 : HasSup.{u3} γ] [_inst_6 : Bot.{u3} γ] {g : SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6} {f₁ : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4} {f₂ : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) => β -> γ) (SupBotHom.hasCoeToFun.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f₁) (SupBotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f₂)) (Eq.{max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u3} β] [_inst_4 : Bot.{u3} β] [_inst_5 : HasSup.{u2} γ] [_inst_6 : Bot.{u2} γ] {g : SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6} {f₁ : SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4} {f₂ : SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : β) => γ) _x) (SupBotHom.instFunLikeSupBotHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f₁) (SupBotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f₂)) (Eq.{max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.cancel_left SupBotHom.cancel_leftₓ'. -/
theorem cancel_left {g : SupBotHom β γ} {f₁ f₂ : SupBotHom α β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => SupBotHom.ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
#align sup_bot_hom.cancel_left SupBotHom.cancel_left

end HasSup

variable [SemilatticeSup β] [OrderBot β]

instance : HasSup (SupBotHom α β) :=
  ⟨fun f g => { f.toBotHom ⊔ g.toBotHom with toSupHom := f.toSupHom ⊔ g.toSupHom }⟩

instance : SemilatticeSup (SupBotHom α β) :=
  FunLike.coe_injective.SemilatticeSup _ fun f g => rfl

instance : OrderBot (SupBotHom α β) where
  bot := ⟨⊥, rfl⟩
  bot_le f := bot_le

/- warning: sup_bot_hom.coe_sup -> SupBotHom.coe_sup is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : SemilatticeSup.{u2} β] [_inst_4 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))] (f : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (g : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u2} β _inst_3) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (HasSup.sup.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SupBotHom.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f g)) (HasSup.sup.{max u1 u2} (α -> β) (Pi.hasSup.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeSup.toHasSup.{u2} β _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u2} β _inst_3) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u2} β _inst_3) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) g))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : Bot.{u2} α] [_inst_3 : SemilatticeSup.{u1} β] [_inst_4 : OrderBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3)))] (f : SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (g : SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)), Eq.{max (succ u2) (succ u1)} (α -> β) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (_x : α) => β) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u1} β _inst_3) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (HasSup.sup.{max u2 u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (SupBotHom.instHasSupSupBotHomToHasSupToBotToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u1} β _inst_3) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (HasSup.sup.{max u2 u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (SupBotHom.instHasSupSupBotHomToHasSupToBotToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f g))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.coe_sup SupBotHom.coe_supₓ'. -/
@[simp]
theorem coe_sup (f g : SupBotHom α β) : ⇑(f ⊔ g) = f ⊔ g :=
  rfl
#align sup_bot_hom.coe_sup SupBotHom.coe_sup

/- warning: sup_bot_hom.coe_bot -> SupBotHom.coe_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : SemilatticeSup.{u2} β] [_inst_4 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))], Eq.{succ (max u1 u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), succ (max u1 u2)} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u2} β _inst_3) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Bot.bot.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (OrderBot.toHasBot.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Preorder.toLE.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SemilatticeSup.toPartialOrder.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SupBotHom.semilatticeSup.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (SupBotHom.orderBot.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (Bot.bot.{max u1 u2} (α -> β) (Pi.hasBot.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : Bot.{u2} α] [_inst_3 : SemilatticeSup.{u1} β] [_inst_4 : OrderBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3)))], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u1} β _inst_3) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (Bot.bot.{max u2 u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (OrderBot.toBot.{max u2 u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (Preorder.toLE.{max u2 u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (PartialOrder.toPreorder.{max u2 u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (SemilatticeSup.toPartialOrder.{max u2 u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (SupBotHom.instSemilatticeSupSupBotHomToHasSupToBotToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (SupBotHom.instOrderBotSupBotHomToHasSupToBotToLEToPreorderToPartialOrderToLEToPreorderToPartialOrderInstSemilatticeSupSupBotHomToHasSupToBotToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (Bot.bot.{max u2 u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) ᾰ) (Pi.instBotForAll.{u2, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) ᾰ) (fun (i : α) => OrderBot.toBot.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) i) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) i) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) i) (SemilatticeSup.toPartialOrder.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) i) _inst_3))) _inst_4)))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.coe_bot SupBotHom.coe_botₓ'. -/
@[simp]
theorem coe_bot : ⇑(⊥ : SupBotHom α β) = ⊥ :=
  rfl
#align sup_bot_hom.coe_bot SupBotHom.coe_bot

/- warning: sup_bot_hom.sup_apply -> SupBotHom.sup_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : SemilatticeSup.{u2} β] [_inst_4 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))] (f : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (g : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u2} β _inst_3) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (HasSup.sup.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SupBotHom.hasSup.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f g) a) (HasSup.sup.{u2} β (SemilatticeSup.toHasSup.{u2} β _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u2} β _inst_3) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u2} β _inst_3) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) g a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasSup.{u2} α] [_inst_2 : Bot.{u2} α] [_inst_3 : SemilatticeSup.{u1} β] [_inst_4 : OrderBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3)))] (f : SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (g : SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u1} β _inst_3) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (HasSup.sup.{max u2 u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) (SupBotHom.instHasSupSupBotHomToHasSupToBotToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f g) a) (HasSup.sup.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) (SemilatticeSup.toHasSup.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u1} β _inst_3) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (SupBotHom.{u2, u1} α β _inst_1 (SemilatticeSup.toHasSup.{u1} β _inst_3) _inst_2 (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u1} β _inst_3) (OrderBot.toBot.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeSup.toPartialOrder.{u1} β _inst_3))) _inst_4)) g a))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.sup_apply SupBotHom.sup_applyₓ'. -/
@[simp]
theorem sup_apply (f g : SupBotHom α β) (a : α) : (f ⊔ g) a = f a ⊔ g a :=
  rfl
#align sup_bot_hom.sup_apply SupBotHom.sup_apply

/- warning: sup_bot_hom.bot_apply -> SupBotHom.bot_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : SemilatticeSup.{u2} β] [_inst_4 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))] (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (SupBotHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u2} β _inst_3) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Bot.bot.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (OrderBot.toHasBot.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Preorder.toLE.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SemilatticeSup.toPartialOrder.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SupBotHom.semilatticeSup.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (SupBotHom.orderBot.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))) a) (Bot.bot.{u2} β (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : SemilatticeSup.{u2} β] [_inst_4 : OrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3)))] (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) _x) (SupBotHom.instFunLikeSupBotHom.{u1, u2} α β _inst_1 _inst_2 (SemilatticeSup.toHasSup.{u2} β _inst_3) (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Bot.bot.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (OrderBot.toBot.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Preorder.toLE.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SemilatticeSup.toPartialOrder.{max u1 u2} (SupBotHom.{u1, u2} α β _inst_1 (SemilatticeSup.toHasSup.{u2} β _inst_3) _inst_2 (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeSup.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SupBotHom.instSemilatticeSupSupBotHomToHasSupToBotToLEToPreorderToPartialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (SupBotHom.instOrderBotSupBotHomToHasSupToBotToLEToPreorderToPartialOrderToLEToPreorderToPartialOrderInstSemilatticeSupSupBotHomToHasSupToBotToLEToPreorderToPartialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))) a) (Bot.bot.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) (OrderBot.toBot.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) (SemilatticeSup.toPartialOrder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.6018 : α) => β) a) _inst_3))) _inst_4))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.bot_apply SupBotHom.bot_applyₓ'. -/
@[simp]
theorem bot_apply (a : α) : (⊥ : SupBotHom α β) a = ⊥ :=
  rfl
#align sup_bot_hom.bot_apply SupBotHom.bot_apply

end SupBotHom

/-! ### Finitary infimum homomorphisms -/


namespace InfTopHom

variable [HasInf α] [Top α]

section HasInf

variable [HasInf β] [Top β] [HasInf γ] [Top γ] [HasInf δ] [Top δ]

#print InfTopHom.toTopHom /-
/-- Reinterpret an `inf_top_hom` as a `top_hom`. -/
def toTopHom (f : InfTopHom α β) : TopHom α β :=
  { f with }
#align inf_top_hom.to_top_hom InfTopHom.toTopHom
-/

instance : InfTopHomClass (InfTopHom α β) α β
    where
  coe f := f.toFun
  coe_injective' f g h := by
    obtain ⟨⟨_, _⟩, _⟩ := f
    obtain ⟨⟨_, _⟩, _⟩ := g
    congr
  map_inf f := f.map_inf'
  map_top f := f.map_top'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (InfTopHom α β) fun _ => α → β :=
  FunLike.hasCoeToFun

/- warning: inf_top_hom.to_fun_eq_coe -> InfTopHom.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] {f : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4}, Eq.{max (succ u1) (succ u2)} (α -> β) (InfHom.toFun.{u1, u2} α β _inst_1 _inst_3 (InfTopHom.toInfHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4 f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : Top.{u2} α] [_inst_3 : HasInf.{u1} β] [_inst_4 : Top.{u1} β] {f : InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4}, Eq.{max (succ u2) (succ u1)} (α -> β) (InfHom.toFun.{u2, u1} α β _inst_1 _inst_3 (InfTopHom.toInfHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f)
Case conversion may be inaccurate. Consider using '#align inf_top_hom.to_fun_eq_coe InfTopHom.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe {f : InfTopHom α β} : f.toFun = (f : α → β) :=
  rfl
#align inf_top_hom.to_fun_eq_coe InfTopHom.toFun_eq_coe

/- warning: inf_top_hom.ext -> InfTopHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] {f : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4} {g : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g a)) -> (Eq.{max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : Top.{u2} α] [_inst_3 : HasInf.{u1} β] [_inst_4 : Top.{u1} β] {f : InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4} {g : InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) g a)) -> (Eq.{max (succ u2) (succ u1)} (InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) f g)
Case conversion may be inaccurate. Consider using '#align inf_top_hom.ext InfTopHom.extₓ'. -/
@[ext]
theorem ext {f g : InfTopHom α β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align inf_top_hom.ext InfTopHom.ext

/- warning: inf_top_hom.copy -> InfTopHom.copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] (f : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)) -> (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] (f : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)) -> (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)
Case conversion may be inaccurate. Consider using '#align inf_top_hom.copy InfTopHom.copyₓ'. -/
/-- Copy of an `inf_top_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : InfTopHom α β) (f' : α → β) (h : f' = f) : InfTopHom α β :=
  { f.toTopHom.copy f' h with toInfHom := f.toInfHom.copy f' h }
#align inf_top_hom.copy InfTopHom.copy

/- warning: inf_top_hom.coe_copy -> InfTopHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] (f : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (InfTopHom.copy.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : Top.{u2} α] [_inst_3 : HasInf.{u1} β] [_inst_4 : Top.{u1} β] (f : InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (InfTopHom.copy.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align inf_top_hom.coe_copy InfTopHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : InfTopHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align inf_top_hom.coe_copy InfTopHom.coe_copy

/- warning: inf_top_hom.copy_eq -> InfTopHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] (f : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)), Eq.{max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.copy.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : Top.{u2} α] [_inst_3 : HasInf.{u1} β] [_inst_4 : Top.{u1} β] (f : InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f)), Eq.{max (succ u2) (succ u1)} (InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.copy.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h) f
Case conversion may be inaccurate. Consider using '#align inf_top_hom.copy_eq InfTopHom.copy_eqₓ'. -/
theorem copy_eq (f : InfTopHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align inf_top_hom.copy_eq InfTopHom.copy_eq

variable (α)

#print InfTopHom.id /-
/-- `id` as an `inf_top_hom`. -/
@[simps]
protected def id : InfTopHom α α :=
  ⟨InfHom.id α, rfl⟩
#align inf_top_hom.id InfTopHom.id
-/

instance : Inhabited (InfTopHom α α) :=
  ⟨InfTopHom.id α⟩

/- warning: inf_top_hom.coe_id -> InfTopHom.coe_id is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (InfTopHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) (fun (_x : InfTopHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) => α -> α) (InfTopHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (InfTopHom.id.{u1} α _inst_1 _inst_2)) (id.{succ u1} α)
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (InfTopHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => α) _x) (InfTopHom.instFunLikeInfTopHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (InfTopHom.id.{u1} α _inst_1 _inst_2)) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align inf_top_hom.coe_id InfTopHom.coe_idₓ'. -/
@[simp]
theorem coe_id : ⇑(InfTopHom.id α) = id :=
  rfl
#align inf_top_hom.coe_id InfTopHom.coe_id

variable {α}

/- warning: inf_top_hom.id_apply -> InfTopHom.id_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (InfTopHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) (fun (_x : InfTopHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) => α -> α) (InfTopHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (InfTopHom.id.{u1} α _inst_1 _inst_2) a) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (InfTopHom.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => α) _x) (InfTopHom.instFunLikeInfTopHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (InfTopHom.id.{u1} α _inst_1 _inst_2) a) a
Case conversion may be inaccurate. Consider using '#align inf_top_hom.id_apply InfTopHom.id_applyₓ'. -/
@[simp]
theorem id_apply (a : α) : InfTopHom.id α a = a :=
  rfl
#align inf_top_hom.id_apply InfTopHom.id_apply

#print InfTopHom.comp /-
/-- Composition of `inf_top_hom`s as an `inf_top_hom`. -/
def comp (f : InfTopHom β γ) (g : InfTopHom α β) : InfTopHom α γ :=
  { f.toInfHom.comp g.toInfHom, f.toTopHom.comp g.toTopHom with }
#align inf_top_hom.comp InfTopHom.comp
-/

/- warning: inf_top_hom.coe_comp -> InfTopHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] [_inst_5 : HasInf.{u3} γ] [_inst_6 : Top.{u3} γ] (f : InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (g : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u3)} ((fun (_x : InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) => α -> γ) (InfTopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (fun (_x : InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) => α -> γ) (InfTopHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (InfTopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) => β -> γ) (InfTopHom.hasCoeToFun.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u3} β] [_inst_4 : Top.{u3} β] [_inst_5 : HasInf.{u2} γ] [_inst_6 : Top.{u2} γ] (f : InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (g : InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => γ) _x) (InfTopHom.instFunLikeInfTopHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (InfTopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : β) => γ) _x) (InfTopHom.instFunLikeInfTopHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) g))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.coe_comp InfTopHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (f : InfTopHom β γ) (g : InfTopHom α β) : (f.comp g : α → γ) = f ∘ g :=
  rfl
#align inf_top_hom.coe_comp InfTopHom.coe_comp

/- warning: inf_top_hom.comp_apply -> InfTopHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] [_inst_5 : HasInf.{u3} γ] [_inst_6 : Top.{u3} γ] (f : InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (g : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (fun (_x : InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) => α -> γ) (InfTopHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (InfTopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) => β -> γ) (InfTopHom.hasCoeToFun.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u3} β] [_inst_4 : Top.{u3} β] [_inst_5 : HasInf.{u2} γ] [_inst_6 : Top.{u2} γ] (f : InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (g : InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => γ) _x) (InfTopHom.instFunLikeInfTopHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (InfTopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : β) => γ) _x) (InfTopHom.instFunLikeInfTopHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) f (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) g a))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.comp_apply InfTopHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (f : InfTopHom β γ) (g : InfTopHom α β) (a : α) : (f.comp g) a = f (g a) :=
  rfl
#align inf_top_hom.comp_apply InfTopHom.comp_apply

/- warning: inf_top_hom.comp_assoc -> InfTopHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] [_inst_5 : HasInf.{u3} γ] [_inst_6 : Top.{u3} γ] [_inst_7 : HasInf.{u4} δ] [_inst_8 : Top.{u4} δ] (f : InfTopHom.{u3, u4} γ δ _inst_5 _inst_7 _inst_6 _inst_8) (g : InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (h : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u4)} (InfTopHom.{u1, u4} α δ _inst_1 _inst_7 _inst_2 _inst_8) (InfTopHom.comp.{u1, u2, u4} α β δ _inst_1 _inst_2 _inst_3 _inst_4 _inst_7 _inst_8 (InfTopHom.comp.{u2, u3, u4} β γ δ _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 f g) h) (InfTopHom.comp.{u1, u3, u4} α γ δ _inst_1 _inst_2 _inst_5 _inst_6 _inst_7 _inst_8 f (InfTopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u4}} {δ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] [_inst_5 : HasInf.{u4} γ] [_inst_6 : Top.{u4} γ] [_inst_7 : HasInf.{u3} δ] [_inst_8 : Top.{u3} δ] (f : InfTopHom.{u4, u3} γ δ _inst_5 _inst_7 _inst_6 _inst_8) (g : InfTopHom.{u2, u4} β γ _inst_3 _inst_5 _inst_4 _inst_6) (h : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α δ _inst_1 _inst_7 _inst_2 _inst_8) (InfTopHom.comp.{u1, u2, u3} α β δ _inst_1 _inst_2 _inst_3 _inst_4 _inst_7 _inst_8 (InfTopHom.comp.{u2, u4, u3} β γ δ _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 f g) h) (InfTopHom.comp.{u1, u4, u3} α γ δ _inst_1 _inst_2 _inst_5 _inst_6 _inst_7 _inst_8 f (InfTopHom.comp.{u1, u2, u4} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g h))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.comp_assoc InfTopHom.comp_assocₓ'. -/
@[simp]
theorem comp_assoc (f : InfTopHom γ δ) (g : InfTopHom β γ) (h : InfTopHom α β) :
    (f.comp g).comp h = f.comp (g.comp h) :=
  rfl
#align inf_top_hom.comp_assoc InfTopHom.comp_assoc

/- warning: inf_top_hom.comp_id -> InfTopHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] (f : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.comp.{u1, u1, u2} α α β _inst_1 _inst_2 _inst_1 _inst_2 _inst_3 _inst_4 f (InfTopHom.id.{u1} α _inst_1 _inst_2)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : Top.{u2} α] [_inst_3 : HasInf.{u1} β] [_inst_4 : Top.{u1} β] (f : InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u2) (succ u1)} (InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.comp.{u2, u2, u1} α α β _inst_1 _inst_2 _inst_1 _inst_2 _inst_3 _inst_4 f (InfTopHom.id.{u2} α _inst_1 _inst_2)) f
Case conversion may be inaccurate. Consider using '#align inf_top_hom.comp_id InfTopHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : InfTopHom α β) : f.comp (InfTopHom.id α) = f :=
  ext fun a => rfl
#align inf_top_hom.comp_id InfTopHom.comp_id

/- warning: inf_top_hom.id_comp -> InfTopHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] (f : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_3 _inst_4 _inst_3 _inst_4 (InfTopHom.id.{u2} β _inst_3 _inst_4) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : Top.{u2} α] [_inst_3 : HasInf.{u1} β] [_inst_4 : Top.{u1} β] (f : InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u2) (succ u1)} (InfTopHom.{u2, u1} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_3 _inst_4 _inst_3 _inst_4 (InfTopHom.id.{u1} β _inst_3 _inst_4) f) f
Case conversion may be inaccurate. Consider using '#align inf_top_hom.id_comp InfTopHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : InfTopHom α β) : (InfTopHom.id β).comp f = f :=
  ext fun a => rfl
#align inf_top_hom.id_comp InfTopHom.id_comp

/- warning: inf_top_hom.cancel_right -> InfTopHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] [_inst_5 : HasInf.{u3} γ] [_inst_6 : Top.{u3} γ] {g₁ : InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6} {g₂ : InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6} {f : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g₁ f) (InfTopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g₂ f)) (Eq.{max (succ u2) (succ u3)} (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u3} β] [_inst_4 : Top.{u3} β] [_inst_5 : HasInf.{u2} γ] [_inst_6 : Top.{u2} γ] {g₁ : InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6} {g₂ : InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6} {f : InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g₁ f) (InfTopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g₂ f)) (Eq.{max (succ u3) (succ u2)} (InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.cancel_right InfTopHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : InfTopHom β γ} {f : InfTopHom α β} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => ext <| hf.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align inf_top_hom.cancel_right InfTopHom.cancel_right

/- warning: inf_top_hom.cancel_left -> InfTopHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] [_inst_5 : HasInf.{u3} γ] [_inst_6 : Top.{u3} γ] {g : InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6} {f₁ : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4} {f₂ : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) => β -> γ) (InfTopHom.hasCoeToFun.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f₁) (InfTopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f₂)) (Eq.{max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u3} β] [_inst_4 : Top.{u3} β] [_inst_5 : HasInf.{u2} γ] [_inst_6 : Top.{u2} γ] {g : InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6} {f₁ : InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4} {f₂ : InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : β) => γ) _x) (InfTopHom.instFunLikeInfTopHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f₁) (InfTopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f₂)) (Eq.{max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.cancel_left InfTopHom.cancel_leftₓ'. -/
theorem cancel_left {g : InfTopHom β γ} {f₁ f₂ : InfTopHom α β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => InfTopHom.ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
#align inf_top_hom.cancel_left InfTopHom.cancel_left

end HasInf

variable [SemilatticeInf β] [OrderTop β]

instance : HasInf (InfTopHom α β) :=
  ⟨fun f g => { f.toTopHom ⊓ g.toTopHom with toInfHom := f.toInfHom ⊓ g.toInfHom }⟩

instance : SemilatticeInf (InfTopHom α β) :=
  FunLike.coe_injective.SemilatticeInf _ fun f g => rfl

instance : OrderTop (InfTopHom α β) where
  top := ⟨⊤, rfl⟩
  le_top f := le_top

/- warning: inf_top_hom.coe_inf -> InfTopHom.coe_inf is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : SemilatticeInf.{u2} β] [_inst_4 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))] (f : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (g : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)), Eq.{succ (max u1 u2)} (α -> β) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u2} β _inst_3) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (HasInf.inf.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (InfTopHom.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f g)) (HasInf.inf.{max u1 u2} (α -> β) (Pi.hasInf.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => SemilatticeInf.toHasInf.{u2} β _inst_3)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u2} β _inst_3) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u2} β _inst_3) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) g))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : Top.{u2} α] [_inst_3 : SemilatticeInf.{u1} β] [_inst_4 : OrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3)))] (f : InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (g : InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)), Eq.{max (succ u2) (succ u1)} (α -> β) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (_x : α) => β) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u1} β _inst_3) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (HasInf.inf.{max u2 u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (InfTopHom.instHasInfInfTopHomToHasInfToTopToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f g)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u1} β _inst_3) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (HasInf.inf.{max u2 u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (InfTopHom.instHasInfInfTopHomToHasInfToTopToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f g))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.coe_inf InfTopHom.coe_infₓ'. -/
@[simp]
theorem coe_inf (f g : InfTopHom α β) : ⇑(f ⊓ g) = f ⊓ g :=
  rfl
#align inf_top_hom.coe_inf InfTopHom.coe_inf

/- warning: inf_top_hom.coe_top -> InfTopHom.coe_top is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : SemilatticeInf.{u2} β] [_inst_4 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))], Eq.{succ (max u1 u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), succ (max u1 u2)} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u2} β _inst_3) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Top.top.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (OrderTop.toHasTop.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Preorder.toLE.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SemilatticeInf.toPartialOrder.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (InfTopHom.semilatticeInf.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (InfTopHom.orderTop.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (Top.top.{max u1 u2} (α -> β) (Pi.hasTop.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : Top.{u2} α] [_inst_3 : SemilatticeInf.{u1} β] [_inst_4 : OrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3)))], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u1} β _inst_3) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (Top.top.{max u2 u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (OrderTop.toTop.{max u2 u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (Preorder.toLE.{max u2 u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (PartialOrder.toPreorder.{max u2 u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (SemilatticeInf.toPartialOrder.{max u2 u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (InfTopHom.instSemilatticeInfInfTopHomToHasInfToTopToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (InfTopHom.instOrderTopInfTopHomToHasInfToTopToLEToPreorderToPartialOrderToLEToPreorderToPartialOrderInstSemilatticeInfInfTopHomToHasInfToTopToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (Top.top.{max u2 u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) ᾰ) (Pi.instTopForAll.{u2, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) ᾰ) (fun (i : α) => OrderTop.toTop.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) i) (Preorder.toLE.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) i) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) i) (SemilatticeInf.toPartialOrder.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) i) _inst_3))) _inst_4)))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.coe_top InfTopHom.coe_topₓ'. -/
@[simp]
theorem coe_top : ⇑(⊤ : InfTopHom α β) = ⊤ :=
  rfl
#align inf_top_hom.coe_top InfTopHom.coe_top

/- warning: inf_top_hom.inf_apply -> InfTopHom.inf_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : SemilatticeInf.{u2} β] [_inst_4 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))] (f : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (g : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u2} β _inst_3) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (HasInf.inf.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (InfTopHom.hasInf.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f g) a) (HasInf.inf.{u2} β (SemilatticeInf.toHasInf.{u2} β _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u2} β _inst_3) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u2} β _inst_3) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) g a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : HasInf.{u2} α] [_inst_2 : Top.{u2} α] [_inst_3 : SemilatticeInf.{u1} β] [_inst_4 : OrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3)))] (f : InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (g : InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u1} β _inst_3) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (HasInf.inf.{max u2 u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) (InfTopHom.instHasInfInfTopHomToHasInfToTopToLEToPreorderToPartialOrder.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f g) a) (HasInf.inf.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) (SemilatticeInf.toHasInf.{u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) _inst_3) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u1} β _inst_3) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (InfTopHom.{u2, u1} α β _inst_1 (SemilatticeInf.toHasInf.{u1} β _inst_3) _inst_2 (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u2, u1} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u1} β _inst_3) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β _inst_3))) _inst_4)) g a))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.inf_apply InfTopHom.inf_applyₓ'. -/
@[simp]
theorem inf_apply (f g : InfTopHom α β) (a : α) : (f ⊓ g) a = f a ⊓ g a :=
  rfl
#align inf_top_hom.inf_apply InfTopHom.inf_apply

/- warning: inf_top_hom.top_apply -> InfTopHom.top_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : SemilatticeInf.{u2} β] [_inst_4 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))] (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (fun (_x : InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) => α -> β) (InfTopHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u2} β _inst_3) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Top.top.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (OrderTop.toHasTop.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Preorder.toLE.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SemilatticeInf.toPartialOrder.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (InfTopHom.semilatticeInf.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (InfTopHom.orderTop.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))) a) (Top.top.{u2} β (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : SemilatticeInf.{u2} β] [_inst_4 : OrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3)))] (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) _x) (InfTopHom.instFunLikeInfTopHom.{u1, u2} α β _inst_1 _inst_2 (SemilatticeInf.toHasInf.{u2} β _inst_3) (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Top.top.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (OrderTop.toTop.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (Preorder.toLE.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (SemilatticeInf.toPartialOrder.{max u1 u2} (InfTopHom.{u1, u2} α β _inst_1 (SemilatticeInf.toHasInf.{u2} β _inst_3) _inst_2 (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β _inst_3))) _inst_4)) (InfTopHom.instSemilatticeInfInfTopHomToHasInfToTopToLEToPreorderToPartialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (InfTopHom.instOrderTopInfTopHomToHasInfToTopToLEToPreorderToPartialOrderToLEToPreorderToPartialOrderInstSemilatticeInfInfTopHomToHasInfToTopToLEToPreorderToPartialOrder.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))) a) (Top.top.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) (OrderTop.toTop.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) (SemilatticeInf.toPartialOrder.{u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.7705 : α) => β) a) _inst_3))) _inst_4))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.top_apply InfTopHom.top_applyₓ'. -/
@[simp]
theorem top_apply (a : α) : (⊤ : InfTopHom α β) a = ⊤ :=
  rfl
#align inf_top_hom.top_apply InfTopHom.top_apply

end InfTopHom

/-! ### Lattice homomorphisms -/


namespace LatticeHom

variable [Lattice α] [Lattice β] [Lattice γ] [Lattice δ]

#print LatticeHom.toInfHom /-
/-- Reinterpret a `lattice_hom` as an `inf_hom`. -/
def toInfHom (f : LatticeHom α β) : InfHom α β :=
  { f with }
#align lattice_hom.to_inf_hom LatticeHom.toInfHom
-/

instance : LatticeHomClass (LatticeHom α β) α β
    where
  coe f := f.toFun
  coe_injective' f g h := by obtain ⟨⟨_, _⟩, _⟩ := f <;> obtain ⟨⟨_, _⟩, _⟩ := g <;> congr
  map_sup f := f.map_sup'
  map_inf f := f.map_inf'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (LatticeHom α β) fun _ => α → β :=
  ⟨fun f => f.toFun⟩

/- warning: lattice_hom.to_fun_eq_coe -> LatticeHom.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] {f : LatticeHom.{u1, u2} α β _inst_1 _inst_2}, Eq.{max (succ u1) (succ u2)} (α -> β) (SupHom.toFun.{u1, u2} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (LatticeHom.toSupHom.{u1, u2} α β _inst_1 _inst_2 f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : LatticeHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (LatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] {f : LatticeHom.{u2, u1} α β _inst_1 _inst_2}, Eq.{max (succ u2) (succ u1)} (α -> β) (SupHom.toFun.{u2, u1} α β (SemilatticeSup.toHasSup.{u2} α (Lattice.toSemilatticeSup.{u2} α _inst_1)) (SemilatticeSup.toHasSup.{u1} β (Lattice.toSemilatticeSup.{u1} β _inst_2)) (LatticeHom.toSupHom.{u2, u1} α β _inst_1 _inst_2 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LatticeHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) _x) (LatticeHom.instFunLikeLatticeHom.{u2, u1} α β _inst_1 _inst_2) f)
Case conversion may be inaccurate. Consider using '#align lattice_hom.to_fun_eq_coe LatticeHom.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe {f : LatticeHom α β} : f.toFun = (f : α → β) :=
  rfl
#align lattice_hom.to_fun_eq_coe LatticeHom.toFun_eq_coe

/- warning: lattice_hom.ext -> LatticeHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] {f : LatticeHom.{u1, u2} α β _inst_1 _inst_2} {g : LatticeHom.{u1, u2} α β _inst_1 _inst_2}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : LatticeHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (LatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : LatticeHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (LatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a)) -> (Eq.{max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] {f : LatticeHom.{u2, u1} α β _inst_1 _inst_2} {g : LatticeHom.{u2, u1} α β _inst_1 _inst_2}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LatticeHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) _x) (LatticeHom.instFunLikeLatticeHom.{u2, u1} α β _inst_1 _inst_2) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LatticeHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) _x) (LatticeHom.instFunLikeLatticeHom.{u2, u1} α β _inst_1 _inst_2) g a)) -> (Eq.{max (succ u2) (succ u1)} (LatticeHom.{u2, u1} α β _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align lattice_hom.ext LatticeHom.extₓ'. -/
@[ext]
theorem ext {f g : LatticeHom α β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align lattice_hom.ext LatticeHom.ext

#print LatticeHom.copy /-
/-- Copy of a `lattice_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : LatticeHom α β) (f' : α → β) (h : f' = f) : LatticeHom α β :=
  { f.toSupHom.copy f' h, f.toInfHom.copy f' h with }
#align lattice_hom.copy LatticeHom.copy
-/

/- warning: lattice_hom.coe_copy -> LatticeHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] (f : LatticeHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : LatticeHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (LatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : LatticeHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (LatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) (LatticeHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] (f : LatticeHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LatticeHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) _x) (LatticeHom.instFunLikeLatticeHom.{u2, u1} α β _inst_1 _inst_2) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LatticeHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) _x) (LatticeHom.instFunLikeLatticeHom.{u2, u1} α β _inst_1 _inst_2) (LatticeHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align lattice_hom.coe_copy LatticeHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : LatticeHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align lattice_hom.coe_copy LatticeHom.coe_copy

/- warning: lattice_hom.copy_eq -> LatticeHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] (f : LatticeHom.{u1, u2} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : LatticeHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (LatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)), Eq.{max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (LatticeHom.copy.{u1, u2} α β _inst_1 _inst_2 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] (f : LatticeHom.{u2, u1} α β _inst_1 _inst_2) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LatticeHom.{u2, u1} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) _x) (LatticeHom.instFunLikeLatticeHom.{u2, u1} α β _inst_1 _inst_2) f)), Eq.{max (succ u2) (succ u1)} (LatticeHom.{u2, u1} α β _inst_1 _inst_2) (LatticeHom.copy.{u2, u1} α β _inst_1 _inst_2 f f' h) f
Case conversion may be inaccurate. Consider using '#align lattice_hom.copy_eq LatticeHom.copy_eqₓ'. -/
theorem copy_eq (f : LatticeHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align lattice_hom.copy_eq LatticeHom.copy_eq

variable (α)

#print LatticeHom.id /-
/-- `id` as a `lattice_hom`. -/
protected def id : LatticeHom α α where
  toFun := id
  map_sup' _ _ := rfl
  map_inf' _ _ := rfl
#align lattice_hom.id LatticeHom.id
-/

instance : Inhabited (LatticeHom α α) :=
  ⟨LatticeHom.id α⟩

#print LatticeHom.coe_id /-
@[simp]
theorem coe_id : ⇑(LatticeHom.id α) = id :=
  rfl
#align lattice_hom.coe_id LatticeHom.coe_id
-/

variable {α}

#print LatticeHom.id_apply /-
@[simp]
theorem id_apply (a : α) : LatticeHom.id α a = a :=
  rfl
#align lattice_hom.id_apply LatticeHom.id_apply
-/

#print LatticeHom.comp /-
/-- Composition of `lattice_hom`s as a `lattice_hom`. -/
def comp (f : LatticeHom β γ) (g : LatticeHom α β) : LatticeHom α γ :=
  { f.toSupHom.comp g.toSupHom, f.toInfHom.comp g.toInfHom with }
#align lattice_hom.comp LatticeHom.comp
-/

/- warning: lattice_hom.coe_comp -> LatticeHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] (f : LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (g : LatticeHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} ((fun (_x : LatticeHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : LatticeHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (LatticeHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : LatticeHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (LatticeHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : LatticeHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (LatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] (f : LatticeHom.{u3, u2} β γ _inst_2 _inst_3) (g : LatticeHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => γ) _x) (LatticeHom.instFunLikeLatticeHom.{u1, u2} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : β) => γ) _x) (LatticeHom.instFunLikeLatticeHom.{u3, u2} β γ _inst_2 _inst_3) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) _x) (LatticeHom.instFunLikeLatticeHom.{u1, u3} α β _inst_1 _inst_2) g))
Case conversion may be inaccurate. Consider using '#align lattice_hom.coe_comp LatticeHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (f : LatticeHom β γ) (g : LatticeHom α β) : (f.comp g : α → γ) = f ∘ g :=
  rfl
#align lattice_hom.coe_comp LatticeHom.coe_comp

/- warning: lattice_hom.comp_apply -> LatticeHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] (f : LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (g : LatticeHom.{u1, u2} α β _inst_1 _inst_2) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (fun (_x : LatticeHom.{u1, u3} α γ _inst_1 _inst_3) => α -> γ) (LatticeHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : LatticeHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (LatticeHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : LatticeHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (LatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] (f : LatticeHom.{u3, u2} β γ _inst_2 _inst_3) (g : LatticeHom.{u1, u3} α β _inst_1 _inst_2) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => γ) _x) (LatticeHom.instFunLikeLatticeHom.{u1, u2} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : β) => γ) _x) (LatticeHom.instFunLikeLatticeHom.{u3, u2} β γ _inst_2 _inst_3) f (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) _x) (LatticeHom.instFunLikeLatticeHom.{u1, u3} α β _inst_1 _inst_2) g a))
Case conversion may be inaccurate. Consider using '#align lattice_hom.comp_apply LatticeHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (f : LatticeHom β γ) (g : LatticeHom α β) (a : α) : (f.comp g) a = f (g a) :=
  rfl
#align lattice_hom.comp_apply LatticeHom.comp_apply

/- warning: lattice_hom.coe_comp_sup_hom -> LatticeHom.coe_comp_sup_hom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] (f : LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (g : LatticeHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (SupHom.{u1, u3} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (SupHom.{u1, u3} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (SupHom.{u1, u3} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (SupHom.hasCoeT.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) α γ _inst_1 _inst_3 (LatticeHom.latticeHomClass.{u1, u3} α γ _inst_1 _inst_3))))) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (SupHom.comp.{u1, u2, u3} α β γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (SupHom.{u2, u3} β γ (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (SupHom.{u2, u3} β γ (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (SupHom.{u2, u3} β γ (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (SupHom.hasCoeT.{max u2 u3, u2, u3} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) β γ (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u2 u3, u2, u3} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (LatticeHom.latticeHomClass.{u2, u3} β γ _inst_2 _inst_3))))) f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (SupHom.{u1, u2} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (SupHom.{u1, u2} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (SupHom.{u1, u2} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2))) (SupHom.hasCoeT.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (LatticeHomClass.toSupHomClass.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (LatticeHom.latticeHomClass.{u1, u2} α β _inst_1 _inst_2))))) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] (f : LatticeHom.{u3, u2} β γ _inst_2 _inst_3) (g : LatticeHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (SupHom.{u1, u2} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3))) (SupHom.mk.{u1, u2} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (FunLike.coe.{succ (max u1 u2), succ u1, succ u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.429 : α) => γ) a) (SupHomClass.toFunLike.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α γ _inst_1 _inst_3 (LatticeHom.instLatticeHomClassLatticeHom.{u1, u2} α γ _inst_1 _inst_3))) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g)) (SupHomClass.map_sup.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α γ _inst_1 _inst_3 (LatticeHom.instLatticeHomClassLatticeHom.{u1, u2} α γ _inst_1 _inst_3)) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g))) (SupHom.comp.{u1, u3, u2} α β γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (SupHom.mk.{u3, u2} β γ (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (FunLike.coe.{succ (max u3 u2), succ u3, succ u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (a : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.429 : β) => γ) a) (SupHomClass.toFunLike.{max u3 u2, u3, u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β γ (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u3 u2, u3, u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (LatticeHom.instLatticeHomClassLatticeHom.{u3, u2} β γ _inst_2 _inst_3))) f) (SupHomClass.map_sup.{max u3 u2, u3, u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β γ (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u3 u2, u3, u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (LatticeHom.instLatticeHomClassLatticeHom.{u3, u2} β γ _inst_2 _inst_3)) f)) (SupHom.mk.{u1, u3} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (FunLike.coe.{succ (max u1 u3), succ u1, succ u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.429 : α) => β) a) (SupHomClass.toFunLike.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (LatticeHomClass.toSupHomClass.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (LatticeHom.instLatticeHomClassLatticeHom.{u1, u3} α β _inst_1 _inst_2))) g) (SupHomClass.map_sup.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (LatticeHomClass.toSupHomClass.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (LatticeHom.instLatticeHomClassLatticeHom.{u1, u3} α β _inst_1 _inst_2)) g)))
Case conversion may be inaccurate. Consider using '#align lattice_hom.coe_comp_sup_hom LatticeHom.coe_comp_sup_homₓ'. -/
@[simp]
theorem coe_comp_sup_hom (f : LatticeHom β γ) (g : LatticeHom α β) :
    (f.comp g : SupHom α γ) = (f : SupHom β γ).comp g :=
  rfl
#align lattice_hom.coe_comp_sup_hom LatticeHom.coe_comp_sup_hom

/- warning: lattice_hom.coe_comp_inf_hom -> LatticeHom.coe_comp_inf_hom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] (f : LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (g : LatticeHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (InfHom.{u1, u3} α γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (InfHom.{u1, u3} α γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (InfHom.{u1, u3} α γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (InfHom.hasCoeT.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) α γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3)) (LatticeHomClass.toInfHomClass.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) α γ _inst_1 _inst_3 (LatticeHom.latticeHomClass.{u1, u3} α γ _inst_1 _inst_3))))) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 f g)) (InfHom.comp.{u1, u2, u3} α β γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (InfHom.{u2, u3} β γ (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (InfHom.{u2, u3} β γ (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (InfHom.{u2, u3} β γ (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (InfHom.hasCoeT.{max u2 u3, u2, u3} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) β γ (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3)) (LatticeHomClass.toInfHomClass.{max u2 u3, u2, u3} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (LatticeHom.latticeHomClass.{u2, u3} β γ _inst_2 _inst_3))))) f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (InfHom.{u1, u2} α β (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (InfHom.{u1, u2} α β (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (InfHom.{u1, u2} α β (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))) (InfHom.hasCoeT.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) α β (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (LatticeHomClass.toInfHomClass.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (LatticeHom.latticeHomClass.{u1, u2} α β _inst_1 _inst_2))))) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] (f : LatticeHom.{u3, u2} β γ _inst_2 _inst_3) (g : LatticeHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (InfHom.{u1, u2} α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3)) (InfHom.mk.{u1, u2} α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (FunLike.coe.{succ (max u1 u2), succ u1, succ u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => γ) a) (InfHomClass.toFunLike.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (LatticeHomClass.toInfHomClass.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α γ _inst_1 _inst_3 (LatticeHom.instLatticeHomClassLatticeHom.{u1, u2} α γ _inst_1 _inst_3))) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g)) (InfHomClass.map_inf.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (LatticeHomClass.toInfHomClass.{max u1 u2, u1, u2} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) α γ _inst_1 _inst_3 (LatticeHom.instLatticeHomClassLatticeHom.{u1, u2} α γ _inst_1 _inst_3)) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 f g))) (InfHom.comp.{u1, u3, u2} α β γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (InfHom.mk.{u3, u2} β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (FunLike.coe.{succ (max u3 u2), succ u3, succ u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (a : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : β) => γ) a) (InfHomClass.toFunLike.{max u3 u2, u3, u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (LatticeHomClass.toInfHomClass.{max u3 u2, u3, u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (LatticeHom.instLatticeHomClassLatticeHom.{u3, u2} β γ _inst_2 _inst_3))) f) (InfHomClass.map_inf.{max u3 u2, u3, u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (LatticeHomClass.toInfHomClass.{max u3 u2, u3, u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β γ _inst_2 _inst_3 (LatticeHom.instLatticeHomClassLatticeHom.{u3, u2} β γ _inst_2 _inst_3)) f)) (InfHom.mk.{u1, u3} α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (FunLike.coe.{succ (max u1 u3), succ u1, succ u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (InfHomClass.toFunLike.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (LatticeHomClass.toInfHomClass.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (LatticeHom.instLatticeHomClassLatticeHom.{u1, u3} α β _inst_1 _inst_2))) g) (InfHomClass.map_inf.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (LatticeHomClass.toInfHomClass.{max u1 u3, u1, u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α β _inst_1 _inst_2 (LatticeHom.instLatticeHomClassLatticeHom.{u1, u3} α β _inst_1 _inst_2)) g)))
Case conversion may be inaccurate. Consider using '#align lattice_hom.coe_comp_inf_hom LatticeHom.coe_comp_inf_homₓ'. -/
@[simp]
theorem coe_comp_inf_hom (f : LatticeHom β γ) (g : LatticeHom α β) :
    (f.comp g : InfHom α γ) = (f : InfHom β γ).comp g :=
  rfl
#align lattice_hom.coe_comp_inf_hom LatticeHom.coe_comp_inf_hom

/- warning: lattice_hom.comp_assoc -> LatticeHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] [_inst_4 : Lattice.{u4} δ] (f : LatticeHom.{u3, u4} γ δ _inst_3 _inst_4) (g : LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (h : LatticeHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u4)} (LatticeHom.{u1, u4} α δ _inst_1 _inst_4) (LatticeHom.comp.{u1, u2, u4} α β δ _inst_1 _inst_2 _inst_4 (LatticeHom.comp.{u2, u3, u4} β γ δ _inst_2 _inst_3 _inst_4 f g) h) (LatticeHom.comp.{u1, u3, u4} α γ δ _inst_1 _inst_3 _inst_4 f (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u4}} {δ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u4} γ] [_inst_4 : Lattice.{u3} δ] (f : LatticeHom.{u4, u3} γ δ _inst_3 _inst_4) (g : LatticeHom.{u2, u4} β γ _inst_2 _inst_3) (h : LatticeHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α δ _inst_1 _inst_4) (LatticeHom.comp.{u1, u2, u3} α β δ _inst_1 _inst_2 _inst_4 (LatticeHom.comp.{u2, u4, u3} β γ δ _inst_2 _inst_3 _inst_4 f g) h) (LatticeHom.comp.{u1, u4, u3} α γ δ _inst_1 _inst_3 _inst_4 f (LatticeHom.comp.{u1, u2, u4} α β γ _inst_1 _inst_2 _inst_3 g h))
Case conversion may be inaccurate. Consider using '#align lattice_hom.comp_assoc LatticeHom.comp_assocₓ'. -/
@[simp]
theorem comp_assoc (f : LatticeHom γ δ) (g : LatticeHom β γ) (h : LatticeHom α β) :
    (f.comp g).comp h = f.comp (g.comp h) :=
  rfl
#align lattice_hom.comp_assoc LatticeHom.comp_assoc

/- warning: lattice_hom.comp_id -> LatticeHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] (f : LatticeHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (LatticeHom.comp.{u1, u1, u2} α α β _inst_1 _inst_1 _inst_2 f (LatticeHom.id.{u1} α _inst_1)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] (f : LatticeHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (LatticeHom.{u2, u1} α β _inst_1 _inst_2) (LatticeHom.comp.{u2, u2, u1} α α β _inst_1 _inst_1 _inst_2 f (LatticeHom.id.{u2} α _inst_1)) f
Case conversion may be inaccurate. Consider using '#align lattice_hom.comp_id LatticeHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : LatticeHom α β) : f.comp (LatticeHom.id α) = f :=
  LatticeHom.ext fun a => rfl
#align lattice_hom.comp_id LatticeHom.comp_id

/- warning: lattice_hom.id_comp -> LatticeHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] (f : LatticeHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (LatticeHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_2 (LatticeHom.id.{u2} β _inst_2) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] (f : LatticeHom.{u2, u1} α β _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (LatticeHom.{u2, u1} α β _inst_1 _inst_2) (LatticeHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_2 (LatticeHom.id.{u1} β _inst_2) f) f
Case conversion may be inaccurate. Consider using '#align lattice_hom.id_comp LatticeHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : LatticeHom α β) : (LatticeHom.id β).comp f = f :=
  LatticeHom.ext fun a => rfl
#align lattice_hom.id_comp LatticeHom.id_comp

/- warning: lattice_hom.cancel_right -> LatticeHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] {g₁ : LatticeHom.{u2, u3} β γ _inst_2 _inst_3} {g₂ : LatticeHom.{u2, u3} β γ _inst_2 _inst_3} {f : LatticeHom.{u1, u2} α β _inst_1 _inst_2}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (fun (_x : LatticeHom.{u1, u2} α β _inst_1 _inst_2) => α -> β) (LatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₁ f) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g₂ f)) (Eq.{max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] {g₁ : LatticeHom.{u3, u2} β γ _inst_2 _inst_3} {g₂ : LatticeHom.{u3, u2} β γ _inst_2 _inst_3} {f : LatticeHom.{u1, u3} α β _inst_1 _inst_2}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) _x) (LatticeHom.instFunLikeLatticeHom.{u1, u3} α β _inst_1 _inst_2) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₁ f) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g₂ f)) (Eq.{max (succ u3) (succ u2)} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align lattice_hom.cancel_right LatticeHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : LatticeHom β γ} {f : LatticeHom α β} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => LatticeHom.ext <| hf.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align lattice_hom.cancel_right LatticeHom.cancel_right

/- warning: lattice_hom.cancel_left -> LatticeHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] {g : LatticeHom.{u2, u3} β γ _inst_2 _inst_3} {f₁ : LatticeHom.{u1, u2} α β _inst_1 _inst_2} {f₂ : LatticeHom.{u1, u2} α β _inst_1 _inst_2}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (fun (_x : LatticeHom.{u2, u3} β γ _inst_2 _inst_3) => β -> γ) (LatticeHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f₁) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f₂)) (Eq.{max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] {g : LatticeHom.{u3, u2} β γ _inst_2 _inst_3} {f₁ : LatticeHom.{u1, u3} α β _inst_1 _inst_2} {f₂ : LatticeHom.{u1, u3} α β _inst_1 _inst_2}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : β) => γ) _x) (LatticeHom.instFunLikeLatticeHom.{u3, u2} β γ _inst_2 _inst_3) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f₁) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f₂)) (Eq.{max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align lattice_hom.cancel_left LatticeHom.cancel_leftₓ'. -/
theorem cancel_left {g : LatticeHom β γ} {f₁ f₂ : LatticeHom α β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => LatticeHom.ext fun a => hg <| by rw [← LatticeHom.comp_apply, h, LatticeHom.comp_apply],
    congr_arg _⟩
#align lattice_hom.cancel_left LatticeHom.cancel_left

end LatticeHom

namespace OrderHomClass

variable (α β) [LinearOrder α] [Lattice β] [OrderHomClass F α β]

#print OrderHomClass.toLatticeHomClass /-
/-- An order homomorphism from a linear order is a lattice homomorphism. -/
@[reducible]
def toLatticeHomClass : LatticeHomClass F α β :=
  {
    ‹OrderHomClass F α
        β› with
    map_sup := fun f a b => by
      obtain h | h := le_total a b
      · rw [sup_eq_right.2 h, sup_eq_right.2 (OrderHomClass.mono f h : f a ≤ f b)]
      · rw [sup_eq_left.2 h, sup_eq_left.2 (OrderHomClass.mono f h : f b ≤ f a)]
    map_inf := fun f a b => by
      obtain h | h := le_total a b
      · rw [inf_eq_left.2 h, inf_eq_left.2 (OrderHomClass.mono f h : f a ≤ f b)]
      · rw [inf_eq_right.2 h, inf_eq_right.2 (OrderHomClass.mono f h : f b ≤ f a)] }
#align order_hom_class.to_lattice_hom_class OrderHomClass.toLatticeHomClass
-/

#print OrderHomClass.toLatticeHom /-
/-- Reinterpret an order homomorphism to a linear order as a `lattice_hom`. -/
def toLatticeHom (f : F) : LatticeHom α β :=
  haveI : LatticeHomClass F α β := OrderHomClass.toLatticeHomClass α β
  f
#align order_hom_class.to_lattice_hom OrderHomClass.toLatticeHom
-/

/- warning: order_hom_class.coe_to_lattice_hom -> OrderHomClass.coe_to_lattice_hom is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} (α : Type.{u2}) (β : Type.{u3}) [_inst_1 : LinearOrder.{u2} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : OrderHomClass.{u1, u2, u3} F α β (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_1))))) (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))] (f : F), Eq.{max (succ u2) (succ u3)} (α -> β) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} α β (LinearOrder.toLattice.{u2} α _inst_1) _inst_2) (fun (_x : LatticeHom.{u2, u3} α β (LinearOrder.toLattice.{u2} α _inst_1) _inst_2) => α -> β) (LatticeHom.hasCoeToFun.{u2, u3} α β (LinearOrder.toLattice.{u2} α _inst_1) _inst_2) (OrderHomClass.toLatticeHom.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 f)) (coeFn.{succ u1, max (succ u2) (succ u3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u1, succ u2, succ u3} F α (fun (_x : α) => β) (RelHomClass.toFunLike.{u1, u2, u3} F α β (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_1)))))) (LE.le.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))) _inst_3)) f)
but is expected to have type
  forall {F : Type.{u1}} (α : Type.{u3}) (β : Type.{u2}) [_inst_1 : LinearOrder.{u3} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : OrderHomClass.{u1, u3, u2} F α β (Preorder.toLE.{u3} α (PartialOrder.toPreorder.{u3} α (SemilatticeInf.toPartialOrder.{u3} α (Lattice.toSemilatticeInf.{u3} α (DistribLattice.toLattice.{u3} α (instDistribLattice.{u3} α _inst_1)))))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] (f : F), Eq.{max (succ u3) (succ u2)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) ᾰ) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LatticeHom.{u3, u2} α β (DistribLattice.toLattice.{u3} α (instDistribLattice.{u3} α _inst_1)) _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.9326 : α) => β) _x) (LatticeHom.instFunLikeLatticeHom.{u3, u2} α β (DistribLattice.toLattice.{u3} α (instDistribLattice.{u3} α _inst_1)) _inst_2) (OrderHomClass.toLatticeHom.{u1, u3, u2} F α β _inst_1 _inst_2 _inst_3 f)) (FunLike.coe.{succ u1, succ u3, succ u2} F α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{u1, u3, u2} F α β (Lattice.toHasInf.{u3} α (DistribLattice.toLattice.{u3} α (instDistribLattice.{u3} α _inst_1))) (Lattice.toHasInf.{u2} β _inst_2) (LatticeHomClass.toInfHomClass.{u1, u3, u2} F α β (DistribLattice.toLattice.{u3} α (instDistribLattice.{u3} α _inst_1)) _inst_2 (OrderHomClass.toLatticeHomClass.{u1, u3, u2} F α β _inst_1 _inst_2 _inst_3))) f)
Case conversion may be inaccurate. Consider using '#align order_hom_class.coe_to_lattice_hom OrderHomClass.coe_to_lattice_homₓ'. -/
@[simp]
theorem coe_to_lattice_hom (f : F) : ⇑(toLatticeHom α β f) = f :=
  rfl
#align order_hom_class.coe_to_lattice_hom OrderHomClass.coe_to_lattice_hom

#print OrderHomClass.to_lattice_hom_apply /-
@[simp]
theorem to_lattice_hom_apply (f : F) (a : α) : toLatticeHom α β f a = f a :=
  rfl
#align order_hom_class.to_lattice_hom_apply OrderHomClass.to_lattice_hom_apply
-/

end OrderHomClass

/-! ### Bounded lattice homomorphisms -/


namespace BoundedLatticeHom

variable [Lattice α] [Lattice β] [Lattice γ] [Lattice δ] [BoundedOrder α] [BoundedOrder β]
  [BoundedOrder γ] [BoundedOrder δ]

/- warning: bounded_lattice_hom.to_sup_bot_hom -> BoundedLatticeHom.toSupBotHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))], (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) -> (SupBotHom.{u1, u2} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (OrderBot.toHasBot.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderBot.toHasBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))) _inst_6)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))], (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) -> (SupBotHom.{u1, u2} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (OrderBot.toBot.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderBot.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderBot.toBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))) (BoundedOrder.toOrderBot.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))) _inst_6)))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.to_sup_bot_hom BoundedLatticeHom.toSupBotHomₓ'. -/
/-- Reinterpret a `bounded_lattice_hom` as a `sup_bot_hom`. -/
def toSupBotHom (f : BoundedLatticeHom α β) : SupBotHom α β :=
  { f with }
#align bounded_lattice_hom.to_sup_bot_hom BoundedLatticeHom.toSupBotHom

/- warning: bounded_lattice_hom.to_inf_top_hom -> BoundedLatticeHom.toInfTopHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))], (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) -> (InfTopHom.{u1, u2} α β (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toHasTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))) _inst_6)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))], (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) -> (InfTopHom.{u1, u2} α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} β _inst_2) (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))) (BoundedOrder.toOrderTop.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)))) _inst_6)))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.to_inf_top_hom BoundedLatticeHom.toInfTopHomₓ'. -/
/-- Reinterpret a `bounded_lattice_hom` as an `inf_top_hom`. -/
def toInfTopHom (f : BoundedLatticeHom α β) : InfTopHom α β :=
  { f with }
#align bounded_lattice_hom.to_inf_top_hom BoundedLatticeHom.toInfTopHom

#print BoundedLatticeHom.toBoundedOrderHom /-
/-- Reinterpret a `bounded_lattice_hom` as a `bounded_order_hom`. -/
def toBoundedOrderHom (f : BoundedLatticeHom α β) : BoundedOrderHom α β :=
  { f, (f.toLatticeHom : α →o β) with }
#align bounded_lattice_hom.to_bounded_order_hom BoundedLatticeHom.toBoundedOrderHom
-/

instance : BoundedLatticeHomClass (BoundedLatticeHom α β) α β
    where
  coe f := f.toFun
  coe_injective' f g h := by obtain ⟨⟨⟨_, _⟩, _⟩, _⟩ := f <;> obtain ⟨⟨⟨_, _⟩, _⟩, _⟩ := g <;> congr
  map_sup f := f.map_sup'
  map_inf f := f.map_inf'
  map_top f := f.map_top'
  map_bot f := f.map_bot'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (BoundedLatticeHom α β) fun _ => α → β :=
  ⟨fun f => f.toFun⟩

/- warning: bounded_lattice_hom.to_fun_eq_coe -> BoundedLatticeHom.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] {f : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6}, Eq.{max (succ u1) (succ u2)} (α -> β) (SupHom.toFun.{u1, u2} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (LatticeHom.toSupHom.{u1, u2} α β _inst_1 _inst_2 (BoundedLatticeHom.toLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6 f))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedLatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))] {f : BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6}, Eq.{max (succ u2) (succ u1)} (α -> β) (SupHom.toFun.{u2, u1} α β (SemilatticeSup.toHasSup.{u2} α (Lattice.toSemilatticeSup.{u2} α _inst_1)) (SemilatticeSup.toHasSup.{u1} β (Lattice.toSemilatticeSup.{u1} β _inst_2)) (LatticeHom.toSupHom.{u2, u1} α β _inst_1 _inst_2 (BoundedLatticeHom.toLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6 f))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (InfTopHomClass.toInfHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) (BoundedOrder.toOrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6)))) f)
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.to_fun_eq_coe BoundedLatticeHom.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe {f : BoundedLatticeHom α β} : f.toFun = (f : α → β) :=
  rfl
#align bounded_lattice_hom.to_fun_eq_coe BoundedLatticeHom.toFun_eq_coe

/- warning: bounded_lattice_hom.ext -> BoundedLatticeHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] {f : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6} {g : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedLatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedLatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) g a)) -> (Eq.{max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))] {f : BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6} {g : BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (InfTopHomClass.toInfHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) (BoundedOrder.toOrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6)))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (InfTopHomClass.toInfHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) (BoundedOrder.toOrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6)))) g a)) -> (Eq.{max (succ u2) (succ u1)} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) f g)
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.ext BoundedLatticeHom.extₓ'. -/
@[ext]
theorem ext {f g : BoundedLatticeHom α β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align bounded_lattice_hom.ext BoundedLatticeHom.ext

#print BoundedLatticeHom.copy /-
/-- Copy of a `bounded_lattice_hom` with a new `to_fun` equal to the old one. Useful to fix
definitional equalities. -/
protected def copy (f : BoundedLatticeHom α β) (f' : α → β) (h : f' = f) : BoundedLatticeHom α β :=
  { f.toLatticeHom.copy f' h, f.toBoundedOrderHom.copy f' h with }
#align bounded_lattice_hom.copy BoundedLatticeHom.copy
-/

/- warning: bounded_lattice_hom.coe_copy -> BoundedLatticeHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] (f : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedLatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedLatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedLatticeHom.copy.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))] (f : BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (InfTopHomClass.toInfHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) (BoundedOrder.toOrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6)))) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (InfTopHomClass.toInfHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) (BoundedOrder.toOrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6)))) (BoundedLatticeHom.copy.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.coe_copy BoundedLatticeHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : BoundedLatticeHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align bounded_lattice_hom.coe_copy BoundedLatticeHom.coe_copy

/- warning: bounded_lattice_hom.copy_eq -> BoundedLatticeHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] (f : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedLatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f)), Eq.{max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedLatticeHom.copy.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))] (f : BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (InfTopHomClass.toInfHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u2} α _inst_1) (Lattice.toHasInf.{u1} β _inst_2) (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) (BoundedOrder.toOrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) (BoundedOrder.toOrderTop.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u2 u1, u2, u1} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6)))) f)), Eq.{max (succ u2) (succ u1)} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedLatticeHom.copy.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6 f f' h) f
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.copy_eq BoundedLatticeHom.copy_eqₓ'. -/
theorem copy_eq (f : BoundedLatticeHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align bounded_lattice_hom.copy_eq BoundedLatticeHom.copy_eq

variable (α)

#print BoundedLatticeHom.id /-
/-- `id` as a `bounded_lattice_hom`. -/
protected def id : BoundedLatticeHom α α :=
  { LatticeHom.id α, BoundedOrderHom.id α with }
#align bounded_lattice_hom.id BoundedLatticeHom.id
-/

instance : Inhabited (BoundedLatticeHom α α) :=
  ⟨BoundedLatticeHom.id α⟩

#print BoundedLatticeHom.coe_id /-
@[simp]
theorem coe_id : ⇑(BoundedLatticeHom.id α) = id :=
  rfl
#align bounded_lattice_hom.coe_id BoundedLatticeHom.coe_id
-/

variable {α}

#print BoundedLatticeHom.id_apply /-
@[simp]
theorem id_apply (a : α) : BoundedLatticeHom.id α a = a :=
  rfl
#align bounded_lattice_hom.id_apply BoundedLatticeHom.id_apply
-/

#print BoundedLatticeHom.comp /-
/-- Composition of `bounded_lattice_hom`s as a `bounded_lattice_hom`. -/
def comp (f : BoundedLatticeHom β γ) (g : BoundedLatticeHom α β) : BoundedLatticeHom α γ :=
  { f.toLatticeHom.comp g.toLatticeHom, f.toBoundedOrderHom.comp g.toBoundedOrderHom with }
#align bounded_lattice_hom.comp BoundedLatticeHom.comp
-/

/- warning: bounded_lattice_hom.coe_comp -> BoundedLatticeHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))))] (f : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} ((fun (_x : BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) => α -> γ) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (fun (_x : BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) => α -> γ) (BoundedLatticeHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (fun (_x : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) => β -> γ) (BoundedLatticeHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedLatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3))))] (f : BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => γ) _x) (InfHomClass.toFunLike.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (InfTopHomClass.toInfHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) _inst_7)) (BoundedLatticeHomClass.toInfTopHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7)))) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : β) => γ) _x) (InfHomClass.toFunLike.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (InfTopHomClass.toInfHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_6)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) _inst_7)) (BoundedLatticeHomClass.toInfTopHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)))) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (InfTopHomClass.toInfHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)))) g))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.coe_comp BoundedLatticeHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (f : BoundedLatticeHom β γ) (g : BoundedLatticeHom α β) :
    (f.comp g : α → γ) = f ∘ g :=
  rfl
#align bounded_lattice_hom.coe_comp BoundedLatticeHom.coe_comp

/- warning: bounded_lattice_hom.comp_apply -> BoundedLatticeHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))))] (f : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (fun (_x : BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) => α -> γ) (BoundedLatticeHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (fun (_x : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) => β -> γ) (BoundedLatticeHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedLatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3))))] (f : BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => γ) _x) (InfHomClass.toFunLike.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (InfTopHomClass.toInfHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) _inst_7)) (BoundedLatticeHomClass.toInfTopHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7)))) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : β) => γ) _x) (InfHomClass.toFunLike.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (InfTopHomClass.toInfHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_6)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) _inst_7)) (BoundedLatticeHomClass.toInfTopHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)))) f (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (InfTopHomClass.toInfHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)))) g a))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.comp_apply BoundedLatticeHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (f : BoundedLatticeHom β γ) (g : BoundedLatticeHom α β) (a : α) :
    (f.comp g) a = f (g a) :=
  rfl
#align bounded_lattice_hom.comp_apply BoundedLatticeHom.comp_apply

/- warning: bounded_lattice_hom.coe_comp_lattice_hom -> BoundedLatticeHom.coe_comp_lattice_hom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))))] (f : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (LatticeHom.hasCoeT.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.boundedLatticeHomClass.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7))))) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (LatticeHom.hasCoeT.{max u2 u3, u2, u3} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u2 u3, u2, u3} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.boundedLatticeHomClass.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7))))) f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (LatticeHom.hasCoeT.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.boundedLatticeHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6))))) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3))))] (f : BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) (LatticeHom.mk.{u1, u2} α γ _inst_1 _inst_3 (SupHom.mk.{u1, u2} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (FunLike.coe.{succ (max u1 u2), succ u1, succ u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => γ) a) (InfHomClass.toFunLike.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (LatticeHomClass.toInfHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7)))) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (instCoeTCLatticeHom.proof_1.{u2, u1, max u1 u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7)) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g))) (instCoeTCLatticeHom.proof_2.{u2, u1, max u1 u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7)) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g))) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 (LatticeHom.mk.{u3, u2} β γ _inst_2 _inst_3 (SupHom.mk.{u3, u2} β γ (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (FunLike.coe.{succ (max u3 u2), succ u3, succ u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β (fun (a : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : β) => γ) a) (InfHomClass.toFunLike.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (LatticeHomClass.toInfHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)))) f) (instCoeTCLatticeHom.proof_1.{u2, u3, max u3 u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)) f)) (instCoeTCLatticeHom.proof_2.{u2, u3, max u3 u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)) f)) (LatticeHom.mk.{u1, u3} α β _inst_1 _inst_2 (SupHom.mk.{u1, u3} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (FunLike.coe.{succ (max u1 u3), succ u1, succ u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (InfHomClass.toFunLike.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (LatticeHomClass.toInfHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)))) g) (instCoeTCLatticeHom.proof_1.{u3, u1, max u1 u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)) g)) (instCoeTCLatticeHom.proof_2.{u3, u1, max u1 u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)) g)))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.coe_comp_lattice_hom BoundedLatticeHom.coe_comp_lattice_homₓ'. -/
@[simp]
theorem coe_comp_lattice_hom (f : BoundedLatticeHom β γ) (g : BoundedLatticeHom α β) :
    (f.comp g : LatticeHom α γ) = (f : LatticeHom β γ).comp g :=
  rfl
#align bounded_lattice_hom.coe_comp_lattice_hom BoundedLatticeHom.coe_comp_lattice_hom

/- warning: bounded_lattice_hom.coe_comp_sup_hom -> BoundedLatticeHom.coe_comp_sup_hom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))))] (f : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (SupHom.{u1, u3} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (SupHom.{u1, u3} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (SupHom.{u1, u3} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (SupHom.hasCoeT.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.boundedLatticeHomClass.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7)))))) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (SupHom.comp.{u1, u2, u3} α β γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (SupHom.{u2, u3} β γ (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (SupHom.{u2, u3} β γ (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (SupHom.{u2, u3} β γ (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3))) (SupHom.hasCoeT.{max u2 u3, u2, u3} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (SemilatticeSup.toHasSup.{u3} γ (Lattice.toSemilatticeSup.{u3} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u2 u3, u2, u3} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u2 u3, u2, u3} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.boundedLatticeHomClass.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7)))))) f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (SupHom.{u1, u2} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (SupHom.{u1, u2} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (SupHom.{u1, u2} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2))) (SupHom.hasCoeT.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} β (Lattice.toSemilatticeSup.{u2} β _inst_2)) (LatticeHomClass.toSupHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.boundedLatticeHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6)))))) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3))))] (f : BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (SupHom.{u1, u2} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3))) (SupHom.mk.{u1, u2} α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (FunLike.coe.{succ (max u1 u2), succ u1, succ u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.429 : α) => γ) a) (SupHomClass.toFunLike.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7)))) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (SupHomClass.map_sup.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7))) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g))) (SupHom.comp.{u1, u3, u2} α β γ (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (SupHom.mk.{u3, u2} β γ (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (FunLike.coe.{succ (max u3 u2), succ u3, succ u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β (fun (a : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.429 : β) => γ) a) (SupHomClass.toFunLike.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)))) f) (SupHomClass.map_sup.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (SemilatticeSup.toHasSup.{u2} γ (Lattice.toSemilatticeSup.{u2} γ _inst_3)) (LatticeHomClass.toSupHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7))) f)) (SupHom.mk.{u1, u3} α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (FunLike.coe.{succ (max u1 u3), succ u1, succ u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.429 : α) => β) a) (SupHomClass.toFunLike.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (LatticeHomClass.toSupHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)))) g) (SupHomClass.map_sup.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α _inst_1)) (SemilatticeSup.toHasSup.{u3} β (Lattice.toSemilatticeSup.{u3} β _inst_2)) (LatticeHomClass.toSupHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6))) g)))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.coe_comp_sup_hom BoundedLatticeHom.coe_comp_sup_homₓ'. -/
@[simp]
theorem coe_comp_sup_hom (f : BoundedLatticeHom β γ) (g : BoundedLatticeHom α β) :
    (f.comp g : SupHom α γ) = (f : SupHom β γ).comp g :=
  rfl
#align bounded_lattice_hom.coe_comp_sup_hom BoundedLatticeHom.coe_comp_sup_hom

/- warning: bounded_lattice_hom.coe_comp_inf_hom -> BoundedLatticeHom.coe_comp_inf_hom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))))] (f : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u1) (succ u3)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u1) (succ u3)} a b] => self.0) (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (InfHom.{u1, u3} α γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (InfHom.{u1, u3} α γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (InfHom.{u1, u3} α γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (InfHom.hasCoeT.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3)) (LatticeHomClass.toInfHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.boundedLatticeHomClass.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7)))))) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (InfHom.comp.{u1, u2, u3} α β γ (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (InfHom.{u2, u3} β γ (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (InfHom.{u2, u3} β γ (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (InfHom.{u2, u3} β γ (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))) (InfHom.hasCoeT.{max u2 u3, u2, u3} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (SemilatticeInf.toHasInf.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3)) (LatticeHomClass.toInfHomClass.{max u2 u3, u2, u3} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 (BoundedLatticeHomClass.toLatticeHomClass.{max u2 u3, u2, u3} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.boundedLatticeHomClass.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7)))))) f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (InfHom.{u1, u2} α β (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (InfHom.{u1, u2} α β (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (InfHom.{u1, u2} α β (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))) (InfHom.hasCoeT.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (SemilatticeInf.toHasInf.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)) (SemilatticeInf.toHasInf.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2)) (LatticeHomClass.toInfHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 (BoundedLatticeHomClass.toLatticeHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.boundedLatticeHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6)))))) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3))))] (f : BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) (g : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (InfHom.{u1, u2} α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3)) (InfHom.mk.{u1, u2} α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (FunLike.coe.{succ (max u1 u2), succ u1, succ u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => γ) a) (InfHomClass.toFunLike.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (InfTopHomClass.toInfHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) _inst_7)) (BoundedLatticeHomClass.toInfTopHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7)))) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g)) (InfHomClass.map_inf.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (InfTopHomClass.toInfHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u2} γ _inst_3) (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) _inst_7)) (BoundedLatticeHomClass.toInfTopHomClass.{max u1 u2, u1, u2} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) α γ _inst_1 _inst_3 _inst_5 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7))) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 f g))) (InfHom.comp.{u1, u3, u2} α β γ (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (InfHom.mk.{u3, u2} β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (FunLike.coe.{succ (max u3 u2), succ u3, succ u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β (fun (a : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : β) => γ) a) (InfHomClass.toFunLike.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (InfTopHomClass.toInfHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_6)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) _inst_7)) (BoundedLatticeHomClass.toInfTopHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)))) f) (InfHomClass.map_inf.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (InfTopHomClass.toInfHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_6)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) _inst_7)) (BoundedLatticeHomClass.toInfTopHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7))) f)) (InfHom.mk.{u1, u3} α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (FunLike.coe.{succ (max u1 u3), succ u1, succ u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (a : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) a) (InfHomClass.toFunLike.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (InfTopHomClass.toInfHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)))) g) (InfHomClass.map_inf.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (InfTopHomClass.toInfHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6))) g)))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.coe_comp_inf_hom BoundedLatticeHom.coe_comp_inf_homₓ'. -/
@[simp]
theorem coe_comp_inf_hom (f : BoundedLatticeHom β γ) (g : BoundedLatticeHom α β) :
    (f.comp g : InfHom α γ) = (f : InfHom β γ).comp g :=
  rfl
#align bounded_lattice_hom.coe_comp_inf_hom BoundedLatticeHom.coe_comp_inf_hom

/- warning: bounded_lattice_hom.comp_assoc -> BoundedLatticeHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] [_inst_4 : Lattice.{u4} δ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))))] [_inst_8 : BoundedOrder.{u4} δ (Preorder.toLE.{u4} δ (PartialOrder.toPreorder.{u4} δ (SemilatticeInf.toPartialOrder.{u4} δ (Lattice.toSemilatticeInf.{u4} δ _inst_4))))] (f : BoundedLatticeHom.{u3, u4} γ δ _inst_3 _inst_4 _inst_7 _inst_8) (g : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (h : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u4)} (BoundedLatticeHom.{u1, u4} α δ _inst_1 _inst_4 _inst_5 _inst_8) (BoundedLatticeHom.comp.{u1, u2, u4} α β δ _inst_1 _inst_2 _inst_4 _inst_5 _inst_6 _inst_8 (BoundedLatticeHom.comp.{u2, u3, u4} β γ δ _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g) h) (BoundedLatticeHom.comp.{u1, u3, u4} α γ δ _inst_1 _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 f (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u4}} {δ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u4} γ] [_inst_4 : Lattice.{u3} δ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] [_inst_7 : BoundedOrder.{u4} γ (Preorder.toLE.{u4} γ (PartialOrder.toPreorder.{u4} γ (SemilatticeInf.toPartialOrder.{u4} γ (Lattice.toSemilatticeInf.{u4} γ _inst_3))))] [_inst_8 : BoundedOrder.{u3} δ (Preorder.toLE.{u3} δ (PartialOrder.toPreorder.{u3} δ (SemilatticeInf.toPartialOrder.{u3} δ (Lattice.toSemilatticeInf.{u3} δ _inst_4))))] (f : BoundedLatticeHom.{u4, u3} γ δ _inst_3 _inst_4 _inst_7 _inst_8) (g : BoundedLatticeHom.{u2, u4} β γ _inst_2 _inst_3 _inst_6 _inst_7) (h : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α δ _inst_1 _inst_4 _inst_5 _inst_8) (BoundedLatticeHom.comp.{u1, u2, u3} α β δ _inst_1 _inst_2 _inst_4 _inst_5 _inst_6 _inst_8 (BoundedLatticeHom.comp.{u2, u4, u3} β γ δ _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g) h) (BoundedLatticeHom.comp.{u1, u4, u3} α γ δ _inst_1 _inst_3 _inst_4 _inst_5 _inst_7 _inst_8 f (BoundedLatticeHom.comp.{u1, u2, u4} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g h))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.comp_assoc BoundedLatticeHom.comp_assocₓ'. -/
@[simp]
theorem comp_assoc (f : BoundedLatticeHom γ δ) (g : BoundedLatticeHom β γ)
    (h : BoundedLatticeHom α β) : (f.comp g).comp h = f.comp (g.comp h) :=
  rfl
#align bounded_lattice_hom.comp_assoc BoundedLatticeHom.comp_assoc

/- warning: bounded_lattice_hom.comp_id -> BoundedLatticeHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] (f : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedLatticeHom.comp.{u1, u1, u2} α α β _inst_1 _inst_1 _inst_2 _inst_5 _inst_5 _inst_6 f (BoundedLatticeHom.id.{u1} α _inst_1 _inst_5)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))] (f : BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u2) (succ u1)} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedLatticeHom.comp.{u2, u2, u1} α α β _inst_1 _inst_1 _inst_2 _inst_5 _inst_5 _inst_6 f (BoundedLatticeHom.id.{u2} α _inst_1 _inst_5)) f
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.comp_id BoundedLatticeHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : BoundedLatticeHom α β) : f.comp (BoundedLatticeHom.id α) = f :=
  BoundedLatticeHom.ext fun a => rfl
#align bounded_lattice_hom.comp_id BoundedLatticeHom.comp_id

/- warning: bounded_lattice_hom.id_comp -> BoundedLatticeHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] (f : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedLatticeHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_2 _inst_5 _inst_6 _inst_6 (BoundedLatticeHom.id.{u2} β _inst_2 _inst_6) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Lattice.{u2} α] [_inst_2 : Lattice.{u1} β] [_inst_5 : BoundedOrder.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α _inst_1))))] [_inst_6 : BoundedOrder.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (SemilatticeInf.toPartialOrder.{u1} β (Lattice.toSemilatticeInf.{u1} β _inst_2))))] (f : BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6), Eq.{max (succ u2) (succ u1)} (BoundedLatticeHom.{u2, u1} α β _inst_1 _inst_2 _inst_5 _inst_6) (BoundedLatticeHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_2 _inst_5 _inst_6 _inst_6 (BoundedLatticeHom.id.{u1} β _inst_2 _inst_6) f) f
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.id_comp BoundedLatticeHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : BoundedLatticeHom α β) : (BoundedLatticeHom.id β).comp f = f :=
  BoundedLatticeHom.ext fun a => rfl
#align bounded_lattice_hom.id_comp BoundedLatticeHom.id_comp

/- warning: bounded_lattice_hom.cancel_right -> BoundedLatticeHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))))] {g₁ : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7} {g₂ : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7} {f : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) => α -> β) (BoundedLatticeHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g₁ f) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g₂ f)) (Eq.{max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3))))] {g₁ : BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7} {g₂ : BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7} {f : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : α) => β) _x) (InfHomClass.toFunLike.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (InfTopHomClass.toInfHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β (Lattice.toHasInf.{u1} α _inst_1) (Lattice.toHasInf.{u3} β _inst_2) (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) (BoundedOrder.toOrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_5)) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_6)) (BoundedLatticeHomClass.toInfTopHomClass.{max u1 u3, u1, u3} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_5 _inst_6 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6)))) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g₁ f) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g₂ f)) (Eq.{max (succ u3) (succ u2)} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.cancel_right BoundedLatticeHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : BoundedLatticeHom β γ} {f : BoundedLatticeHom α β}
    (hf : Surjective f) : g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => BoundedLatticeHom.ext <| hf.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align bounded_lattice_hom.cancel_right BoundedLatticeHom.cancel_right

/- warning: bounded_lattice_hom.cancel_left -> BoundedLatticeHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_2))))] [_inst_7 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_3))))] {g : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7} {f₁ : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6} {f₂ : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) (fun (_x : BoundedLatticeHom.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) => β -> γ) (BoundedLatticeHom.hasCoeToFun.{u2, u3} β γ _inst_2 _inst_3 _inst_6 _inst_7) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g f₁) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g f₂)) (Eq.{max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_2 _inst_5 _inst_6) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] [_inst_5 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_6 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2))))] [_inst_7 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3))))] {g : BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7} {f₁ : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6} {f₂ : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β (fun (_x : β) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.487 : β) => γ) _x) (InfHomClass.toFunLike.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (InfTopHomClass.toInfHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ (Lattice.toHasInf.{u3} β _inst_2) (Lattice.toHasInf.{u2} γ _inst_3) (OrderTop.toTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) (BoundedOrder.toOrderTop.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_2)))) _inst_6)) (OrderTop.toTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) (BoundedOrder.toOrderTop.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_3)))) _inst_7)) (BoundedLatticeHomClass.toInfTopHomClass.{max u3 u2, u3, u2} (BoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7) β γ _inst_2 _inst_3 _inst_6 _inst_7 (BoundedLatticeHom.instBoundedLatticeHomClassBoundedLatticeHom.{u3, u2} β γ _inst_2 _inst_3 _inst_6 _inst_7)))) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_3 _inst_5 _inst_7) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g f₁) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 _inst_7 g f₂)) (Eq.{max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_2 _inst_5 _inst_6) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.cancel_left BoundedLatticeHom.cancel_leftₓ'. -/
theorem cancel_left {g : BoundedLatticeHom β γ} {f₁ f₂ : BoundedLatticeHom α β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
#align bounded_lattice_hom.cancel_left BoundedLatticeHom.cancel_left

end BoundedLatticeHom

/-! ### Dual homs -/


namespace SupHom

variable [HasSup α] [HasSup β] [HasSup γ]

#print SupHom.dual /-
/-- Reinterpret a supremum homomorphism as an infimum homomorphism between the dual lattices. -/
@[simps]
protected def dual : SupHom α β ≃ InfHom αᵒᵈ βᵒᵈ
    where
  toFun f := ⟨f, f.map_sup'⟩
  invFun f := ⟨f, f.map_inf'⟩
  left_inv f := SupHom.ext fun _ => rfl
  right_inv f := InfHom.ext fun _ => rfl
#align sup_hom.dual SupHom.dual
-/

#print SupHom.dual_id /-
@[simp]
theorem dual_id : (SupHom.id α).dual = InfHom.id _ :=
  rfl
#align sup_hom.dual_id SupHom.dual_id
-/

/- warning: sup_hom.dual_comp -> SupHom.dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] [_inst_3 : HasSup.{u3} γ] (g : SupHom.{u2, u3} β γ _inst_2 _inst_3) (f : SupHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_3)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ _inst_1 _inst_3) (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_3))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ _inst_1 _inst_3) (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_3))) => (SupHom.{u1, u3} α γ _inst_1 _inst_3) -> (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_3))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ _inst_1 _inst_3) (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_3))) (SupHom.dual.{u1, u3} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f)) (InfHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u2, u3} β γ _inst_2 _inst_3) (InfHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u2, u3} β γ _inst_2 _inst_3) (InfHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3))) => (SupHom.{u2, u3} β γ _inst_2 _inst_3) -> (InfHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u2, u3} β γ _inst_2 _inst_3) (InfHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3))) (SupHom.dual.{u2, u3} β γ _inst_2 _inst_3) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2))) => (SupHom.{u1, u2} α β _inst_1 _inst_2) -> (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2))) (SupHom.dual.{u1, u2} α β _inst_1 _inst_2) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u3} β] [_inst_3 : HasSup.{u2} γ] (g : SupHom.{u3, u2} β γ _inst_2 _inst_3) (f : SupHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupHom.{u1, u2} α γ _inst_1 _inst_3) => InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3)) (SupHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (SupHom.{u1, u2} α γ _inst_1 _inst_3) (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3))) (SupHom.{u1, u2} α γ _inst_1 _inst_3) (fun (_x : SupHom.{u1, u2} α γ _inst_1 _inst_3) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupHom.{u1, u2} α γ _inst_1 _inst_3) => InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (SupHom.{u1, u2} α γ _inst_1 _inst_3) (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3))) (SupHom.dual.{u1, u2} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f)) (InfHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u3, u2} β γ _inst_2 _inst_3) (InfHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3))) (SupHom.{u3, u2} β γ _inst_2 _inst_3) (fun (_x : SupHom.{u3, u2} β γ _inst_2 _inst_3) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupHom.{u3, u2} β γ _inst_2 _inst_3) => InfHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u3, u2} β γ _inst_2 _inst_3) (InfHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3))) (SupHom.dual.{u3, u2} β γ _inst_2 _inst_3) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (SupHom.{u1, u3} α β _inst_1 _inst_2) (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2))) (SupHom.{u1, u3} α β _inst_1 _inst_2) (fun (_x : SupHom.{u1, u3} α β _inst_1 _inst_2) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupHom.{u1, u3} α β _inst_1 _inst_2) => InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2)) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (SupHom.{u1, u3} α β _inst_1 _inst_2) (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2))) (SupHom.dual.{u1, u3} α β _inst_1 _inst_2) f))
Case conversion may be inaccurate. Consider using '#align sup_hom.dual_comp SupHom.dual_compₓ'. -/
@[simp]
theorem dual_comp (g : SupHom β γ) (f : SupHom α β) : (g.comp f).dual = g.dual.comp f.dual :=
  rfl
#align sup_hom.dual_comp SupHom.dual_comp

#print SupHom.symm_dual_id /-
@[simp]
theorem symm_dual_id : SupHom.dual.symm (InfHom.id _) = SupHom.id α :=
  rfl
#align sup_hom.symm_dual_id SupHom.symm_dual_id
-/

/- warning: sup_hom.symm_dual_comp -> SupHom.symm_dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u2} β] [_inst_3 : HasSup.{u3} γ] (g : InfHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3)) (f : InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2)), Eq.{max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ _inst_1 _inst_3) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_3)) (SupHom.{u1, u3} α γ _inst_1 _inst_3)) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_3)) (SupHom.{u1, u3} α γ _inst_1 _inst_3)) => (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_3)) -> (SupHom.{u1, u3} α γ _inst_1 _inst_3)) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_3)) (SupHom.{u1, u3} α γ _inst_1 _inst_3)) (Equiv.symm.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupHom.{u1, u3} α γ _inst_1 _inst_3) (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_3)) (SupHom.dual.{u1, u3} α γ _inst_1 _inst_3)) (InfHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3) g f)) (SupHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3)) (SupHom.{u2, u3} β γ _inst_2 _inst_3)) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3)) (SupHom.{u2, u3} β γ _inst_2 _inst_3)) => (InfHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3)) -> (SupHom.{u2, u3} β γ _inst_2 _inst_3)) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3)) (SupHom.{u2, u3} β γ _inst_2 _inst_3)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u2, u3} β γ _inst_2 _inst_3) (InfHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_2) (OrderDual.hasInf.{u3} γ _inst_3)) (SupHom.dual.{u2, u3} β γ _inst_2 _inst_3)) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2)) (SupHom.{u1, u2} α β _inst_1 _inst_2)) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2)) (SupHom.{u1, u2} α β _inst_1 _inst_2)) => (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2)) -> (SupHom.{u1, u2} α β _inst_1 _inst_2)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2)) (SupHom.{u1, u2} α β _inst_1 _inst_2)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} α β _inst_1 _inst_2) (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_2)) (SupHom.dual.{u1, u2} α β _inst_1 _inst_2)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : HasSup.{u3} β] [_inst_3 : HasSup.{u2} γ] (g : InfHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3)) (f : InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3)) => SupHom.{u1, u2} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3)) (SupHom.{u1, u2} α γ _inst_1 _inst_3)) (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3)) (fun (_x : InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3)) => SupHom.{u1, u2} α γ _inst_1 _inst_3) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3)) (SupHom.{u1, u2} α γ _inst_1 _inst_3)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (SupHom.{u1, u2} α γ _inst_1 _inst_3) (InfHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_3)) (SupHom.dual.{u1, u2} α γ _inst_1 _inst_3)) (InfHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3) g f)) (SupHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3)) (SupHom.{u3, u2} β γ _inst_2 _inst_3)) (InfHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3)) (fun (_x : InfHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3)) => SupHom.{u3, u2} β γ _inst_2 _inst_3) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3)) (SupHom.{u3, u2} β γ _inst_2 _inst_3)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u3, u2} β γ _inst_2 _inst_3) (InfHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_2) (instHasInfOrderDual.{u2} γ _inst_3)) (SupHom.dual.{u3, u2} β γ _inst_2 _inst_3)) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2)) (SupHom.{u1, u3} α β _inst_1 _inst_2)) (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2)) (fun (_x : InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2)) => SupHom.{u1, u3} α β _inst_1 _inst_2) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2)) (SupHom.{u1, u3} α β _inst_1 _inst_2)) (Equiv.symm.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (SupHom.{u1, u3} α β _inst_1 _inst_2) (InfHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_2)) (SupHom.dual.{u1, u3} α β _inst_1 _inst_2)) f))
Case conversion may be inaccurate. Consider using '#align sup_hom.symm_dual_comp SupHom.symm_dual_compₓ'. -/
@[simp]
theorem symm_dual_comp (g : InfHom βᵒᵈ γᵒᵈ) (f : InfHom αᵒᵈ βᵒᵈ) :
    SupHom.dual.symm (g.comp f) = (SupHom.dual.symm g).comp (SupHom.dual.symm f) :=
  rfl
#align sup_hom.symm_dual_comp SupHom.symm_dual_comp

end SupHom

namespace InfHom

variable [HasInf α] [HasInf β] [HasInf γ]

#print InfHom.dual /-
/-- Reinterpret an infimum homomorphism as a supremum homomorphism between the dual lattices. -/
@[simps]
protected def dual : InfHom α β ≃ SupHom αᵒᵈ βᵒᵈ
    where
  toFun f := ⟨f, f.map_inf'⟩
  invFun f := ⟨f, f.map_sup'⟩
  left_inv f := InfHom.ext fun _ => rfl
  right_inv f := SupHom.ext fun _ => rfl
#align inf_hom.dual InfHom.dual
-/

#print InfHom.dual_id /-
@[simp]
theorem dual_id : (InfHom.id α).dual = SupHom.id _ :=
  rfl
#align inf_hom.dual_id InfHom.dual_id
-/

/- warning: inf_hom.dual_comp -> InfHom.dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] [_inst_3 : HasInf.{u3} γ] (g : InfHom.{u2, u3} β γ _inst_2 _inst_3) (f : InfHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_3)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ _inst_1 _inst_3) (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_3))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ _inst_1 _inst_3) (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_3))) => (InfHom.{u1, u3} α γ _inst_1 _inst_3) -> (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_3))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ _inst_1 _inst_3) (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_3))) (InfHom.dual.{u1, u3} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f)) (SupHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u2, u3} β γ _inst_2 _inst_3) (SupHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u2, u3} β γ _inst_2 _inst_3) (SupHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3))) => (InfHom.{u2, u3} β γ _inst_2 _inst_3) -> (SupHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u2, u3} β γ _inst_2 _inst_3) (SupHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3))) (InfHom.dual.{u2, u3} β γ _inst_2 _inst_3) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2))) => (InfHom.{u1, u2} α β _inst_1 _inst_2) -> (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2))) (InfHom.dual.{u1, u2} α β _inst_1 _inst_2) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u3} β] [_inst_3 : HasInf.{u2} γ] (g : InfHom.{u3, u2} β γ _inst_2 _inst_3) (f : InfHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfHom.{u1, u2} α γ _inst_1 _inst_3) => SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3)) (InfHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (InfHom.{u1, u2} α γ _inst_1 _inst_3) (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3))) (InfHom.{u1, u2} α γ _inst_1 _inst_3) (fun (_x : InfHom.{u1, u2} α γ _inst_1 _inst_3) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfHom.{u1, u2} α γ _inst_1 _inst_3) => SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (InfHom.{u1, u2} α γ _inst_1 _inst_3) (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3))) (InfHom.dual.{u1, u2} α γ _inst_1 _inst_3) (InfHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f)) (SupHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u3, u2} β γ _inst_2 _inst_3) (SupHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3))) (InfHom.{u3, u2} β γ _inst_2 _inst_3) (fun (_x : InfHom.{u3, u2} β γ _inst_2 _inst_3) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfHom.{u3, u2} β γ _inst_2 _inst_3) => SupHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u3, u2} β γ _inst_2 _inst_3) (SupHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3))) (InfHom.dual.{u3, u2} β γ _inst_2 _inst_3) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (InfHom.{u1, u3} α β _inst_1 _inst_2) (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2))) (InfHom.{u1, u3} α β _inst_1 _inst_2) (fun (_x : InfHom.{u1, u3} α β _inst_1 _inst_2) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfHom.{u1, u3} α β _inst_1 _inst_2) => SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2)) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (InfHom.{u1, u3} α β _inst_1 _inst_2) (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2))) (InfHom.dual.{u1, u3} α β _inst_1 _inst_2) f))
Case conversion may be inaccurate. Consider using '#align inf_hom.dual_comp InfHom.dual_compₓ'. -/
@[simp]
theorem dual_comp (g : InfHom β γ) (f : InfHom α β) : (g.comp f).dual = g.dual.comp f.dual :=
  rfl
#align inf_hom.dual_comp InfHom.dual_comp

#print InfHom.symm_dual_id /-
@[simp]
theorem symm_dual_id : InfHom.dual.symm (SupHom.id _) = InfHom.id α :=
  rfl
#align inf_hom.symm_dual_id InfHom.symm_dual_id
-/

/- warning: inf_hom.symm_dual_comp -> InfHom.symm_dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u2} β] [_inst_3 : HasInf.{u3} γ] (g : SupHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3)) (f : SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2)), Eq.{max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ _inst_1 _inst_3) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_3)) (InfHom.{u1, u3} α γ _inst_1 _inst_3)) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_3)) (InfHom.{u1, u3} α γ _inst_1 _inst_3)) => (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_3)) -> (InfHom.{u1, u3} α γ _inst_1 _inst_3)) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_3)) (InfHom.{u1, u3} α γ _inst_1 _inst_3)) (Equiv.symm.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfHom.{u1, u3} α γ _inst_1 _inst_3) (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_3)) (InfHom.dual.{u1, u3} α γ _inst_1 _inst_3)) (SupHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3) g f)) (InfHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3)) (InfHom.{u2, u3} β γ _inst_2 _inst_3)) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3)) (InfHom.{u2, u3} β γ _inst_2 _inst_3)) => (SupHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3)) -> (InfHom.{u2, u3} β γ _inst_2 _inst_3)) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3)) (InfHom.{u2, u3} β γ _inst_2 _inst_3)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u2, u3} β γ _inst_2 _inst_3) (SupHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_2) (OrderDual.hasSup.{u3} γ _inst_3)) (InfHom.dual.{u2, u3} β γ _inst_2 _inst_3)) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2)) (InfHom.{u1, u2} α β _inst_1 _inst_2)) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2)) (InfHom.{u1, u2} α β _inst_1 _inst_2)) => (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2)) -> (InfHom.{u1, u2} α β _inst_1 _inst_2)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2)) (InfHom.{u1, u2} α β _inst_1 _inst_2)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfHom.{u1, u2} α β _inst_1 _inst_2) (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_2)) (InfHom.dual.{u1, u2} α β _inst_1 _inst_2)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : HasInf.{u3} β] [_inst_3 : HasInf.{u2} γ] (g : SupHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3)) (f : SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3)) => InfHom.{u1, u2} α γ _inst_1 _inst_3) (SupHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3)) (InfHom.{u1, u2} α γ _inst_1 _inst_3)) (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3)) (fun (_x : SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3)) => InfHom.{u1, u2} α γ _inst_1 _inst_3) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3)) (InfHom.{u1, u2} α γ _inst_1 _inst_3)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (InfHom.{u1, u2} α γ _inst_1 _inst_3) (SupHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_3)) (InfHom.dual.{u1, u2} α γ _inst_1 _inst_3)) (SupHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3) g f)) (InfHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3)) (InfHom.{u3, u2} β γ _inst_2 _inst_3)) (SupHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3)) (fun (_x : SupHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3)) => InfHom.{u3, u2} β γ _inst_2 _inst_3) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3)) (InfHom.{u3, u2} β γ _inst_2 _inst_3)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfHom.{u3, u2} β γ _inst_2 _inst_3) (SupHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_2) (instHasSupOrderDual.{u2} γ _inst_3)) (InfHom.dual.{u3, u2} β γ _inst_2 _inst_3)) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2)) (InfHom.{u1, u3} α β _inst_1 _inst_2)) (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2)) (fun (_x : SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2)) => InfHom.{u1, u3} α β _inst_1 _inst_2) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2)) (InfHom.{u1, u3} α β _inst_1 _inst_2)) (Equiv.symm.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (InfHom.{u1, u3} α β _inst_1 _inst_2) (SupHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_2)) (InfHom.dual.{u1, u3} α β _inst_1 _inst_2)) f))
Case conversion may be inaccurate. Consider using '#align inf_hom.symm_dual_comp InfHom.symm_dual_compₓ'. -/
@[simp]
theorem symm_dual_comp (g : SupHom βᵒᵈ γᵒᵈ) (f : SupHom αᵒᵈ βᵒᵈ) :
    InfHom.dual.symm (g.comp f) = (InfHom.dual.symm g).comp (InfHom.dual.symm f) :=
  rfl
#align inf_hom.symm_dual_comp InfHom.symm_dual_comp

end InfHom

namespace SupBotHom

variable [HasSup α] [Bot α] [HasSup β] [Bot β] [HasSup γ] [Bot γ]

#print SupBotHom.dual /-
/-- Reinterpret a finitary supremum homomorphism as a finitary infimum homomorphism between the dual
lattices. -/
def dual : SupBotHom α β ≃ InfTopHom αᵒᵈ βᵒᵈ
    where
  toFun f := ⟨f.toSupHom.dual, f.map_bot'⟩
  invFun f := ⟨SupHom.dual.symm f.toInfHom, f.map_top'⟩
  left_inv f := SupBotHom.ext fun _ => rfl
  right_inv f := InfTopHom.ext fun _ => rfl
#align sup_bot_hom.dual SupBotHom.dual
-/

#print SupBotHom.dual_id /-
@[simp]
theorem dual_id : (SupBotHom.id α).dual = InfTopHom.id _ :=
  rfl
#align sup_bot_hom.dual_id SupBotHom.dual_id
-/

/- warning: sup_bot_hom.dual_comp -> SupBotHom.dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] [_inst_5 : HasSup.{u3} γ] [_inst_6 : Bot.{u3} γ] (g : SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (f : SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u3)} (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u3} γ _inst_6)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u3} γ _inst_6))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u3} γ _inst_6))) => (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) -> (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u3} γ _inst_6))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u3} γ _inst_6))) (SupBotHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (SupBotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f)) (InfTopHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u3} γ _inst_6) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (InfTopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasTop.{u3} γ _inst_6))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (InfTopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasTop.{u3} γ _inst_6))) => (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) -> (InfTopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasTop.{u3} γ _inst_6))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (InfTopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasTop.{u3} γ _inst_6))) (SupBotHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u2} β _inst_4))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u2} β _inst_4))) => (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) -> (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u2} β _inst_4))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u2} β _inst_4))) (SupBotHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u3} β] [_inst_4 : Bot.{u3} β] [_inst_5 : HasSup.{u2} γ] [_inst_6 : Bot.{u2} γ] (g : SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (f : SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6)) (SupBotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6))) (SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (fun (_x : SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6))) (SupBotHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (SupBotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f)) (InfTopHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (OrderDual.top.{u1} α _inst_2) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u3} β _inst_4) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u2} γ _inst_6) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (InfTopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_3) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u3} β _inst_4) (OrderDual.top.{u2} γ _inst_6))) (SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) => InfTopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_3) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u3} β _inst_4) (OrderDual.top.{u2} γ _inst_6)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (InfTopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_3) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u3} β _inst_4) (OrderDual.top.{u2} γ _inst_6))) (SupBotHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u3} β _inst_4))) (SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) => InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u3} β _inst_4)) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u3} β _inst_4))) (SupBotHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.dual_comp SupBotHom.dual_compₓ'. -/
@[simp]
theorem dual_comp (g : SupBotHom β γ) (f : SupBotHom α β) : (g.comp f).dual = g.dual.comp f.dual :=
  rfl
#align sup_bot_hom.dual_comp SupBotHom.dual_comp

#print SupBotHom.symm_dual_id /-
@[simp]
theorem symm_dual_id : SupBotHom.dual.symm (InfTopHom.id _) = SupBotHom.id α :=
  rfl
#align sup_bot_hom.symm_dual_id SupBotHom.symm_dual_id
-/

/- warning: sup_bot_hom.symm_dual_comp -> SupBotHom.symm_dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u2} β] [_inst_4 : Bot.{u2} β] [_inst_5 : HasSup.{u3} γ] [_inst_6 : Bot.{u3} γ] (g : InfTopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasTop.{u3} γ _inst_6)) (f : InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u2} β _inst_4)), Eq.{max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u3} γ _inst_6)) (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u3} γ _inst_6)) (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) => (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u3} γ _inst_6)) -> (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u3} γ _inst_6)) (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.symm.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupBotHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u3} γ _inst_6)) (SupBotHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (InfTopHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u3} γ _inst_6) g f)) (SupBotHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasTop.{u3} γ _inst_6)) (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasTop.{u3} γ _inst_6)) (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) => (InfTopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasTop.{u3} γ _inst_6)) -> (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasTop.{u3} γ _inst_6)) (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (InfTopHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasInf.{u3} γ _inst_5) (OrderDual.hasTop.{u2} β _inst_4) (OrderDual.hasTop.{u3} γ _inst_6)) (SupBotHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u2} β _inst_4)) (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u2} β _inst_4)) (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) => (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u2} β _inst_4)) -> (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u2} β _inst_4)) (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasInf.{u1} α _inst_1) (OrderDual.hasInf.{u2} β _inst_3) (OrderDual.hasTop.{u1} α _inst_2) (OrderDual.hasTop.{u2} β _inst_4)) (SupBotHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasSup.{u1} α] [_inst_2 : Bot.{u1} α] [_inst_3 : HasSup.{u3} β] [_inst_4 : Bot.{u3} β] [_inst_5 : HasSup.{u2} γ] [_inst_6 : Bot.{u2} γ] (g : InfTopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_3) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u3} β _inst_4) (OrderDual.top.{u2} γ _inst_6)) (f : InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u3} β _inst_4)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6)) => SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (OrderDual.top.{u1} α _inst_2) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u3} β _inst_4) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u2} γ _inst_6) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6)) (SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6)) (fun (_x : InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6)) => SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6)) (SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (SupBotHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (InfTopHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u2} γ _inst_6)) (SupBotHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (InfTopHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u1} α _inst_1) (OrderDual.top.{u1} α _inst_2) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u3} β _inst_4) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u2} γ _inst_6) g f)) (SupBotHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_3) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u3} β _inst_4) (OrderDual.top.{u2} γ _inst_6)) (SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (InfTopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_3) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u3} β _inst_4) (OrderDual.top.{u2} γ _inst_6)) (fun (_x : InfTopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_3) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u3} β _inst_4) (OrderDual.top.{u2} γ _inst_6)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfTopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_3) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u3} β _inst_4) (OrderDual.top.{u2} γ _inst_6)) => SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_3) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u3} β _inst_4) (OrderDual.top.{u2} γ _inst_6)) (SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (InfTopHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasInfOrderDual.{u3} β _inst_3) (instHasInfOrderDual.{u2} γ _inst_5) (OrderDual.top.{u3} β _inst_4) (OrderDual.top.{u2} γ _inst_6)) (SupBotHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u3} β _inst_4)) (SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4)) (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u3} β _inst_4)) (fun (_x : InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u3} β _inst_4)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u3} β _inst_4)) => SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u3} β _inst_4)) (SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.symm.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (SupBotHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (InfTopHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasInfOrderDual.{u1} α _inst_1) (instHasInfOrderDual.{u3} β _inst_3) (OrderDual.top.{u1} α _inst_2) (OrderDual.top.{u3} β _inst_4)) (SupBotHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
Case conversion may be inaccurate. Consider using '#align sup_bot_hom.symm_dual_comp SupBotHom.symm_dual_compₓ'. -/
@[simp]
theorem symm_dual_comp (g : InfTopHom βᵒᵈ γᵒᵈ) (f : InfTopHom αᵒᵈ βᵒᵈ) :
    SupBotHom.dual.symm (g.comp f) = (SupBotHom.dual.symm g).comp (SupBotHom.dual.symm f) :=
  rfl
#align sup_bot_hom.symm_dual_comp SupBotHom.symm_dual_comp

end SupBotHom

namespace InfTopHom

variable [HasInf α] [Top α] [HasInf β] [Top β] [HasInf γ] [Top γ]

#print InfTopHom.dual /-
/-- Reinterpret a finitary infimum homomorphism as a finitary supremum homomorphism between the dual
lattices. -/
@[simps]
protected def dual : InfTopHom α β ≃ SupBotHom αᵒᵈ βᵒᵈ
    where
  toFun f := ⟨f.toInfHom.dual, f.map_top'⟩
  invFun f := ⟨InfHom.dual.symm f.toSupHom, f.map_bot'⟩
  left_inv f := InfTopHom.ext fun _ => rfl
  right_inv f := SupBotHom.ext fun _ => rfl
#align inf_top_hom.dual InfTopHom.dual
-/

#print InfTopHom.dual_id /-
@[simp]
theorem dual_id : (InfTopHom.id α).dual = SupBotHom.id _ :=
  rfl
#align inf_top_hom.dual_id InfTopHom.dual_id
-/

/- warning: inf_top_hom.dual_comp -> InfTopHom.dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] [_inst_5 : HasInf.{u3} γ] [_inst_6 : Top.{u3} γ] (g : InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (f : InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u3)} (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u3} γ _inst_6)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u3} γ _inst_6))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u3} γ _inst_6))) => (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) -> (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u3} γ _inst_6))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u3} γ _inst_6))) (InfTopHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (InfTopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f)) (SupBotHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u3} γ _inst_6) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (SupBotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasBot.{u3} γ _inst_6))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (SupBotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasBot.{u3} γ _inst_6))) => (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) -> (SupBotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasBot.{u3} γ _inst_6))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (SupBotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasBot.{u3} γ _inst_6))) (InfTopHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u2} β _inst_4))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u2} β _inst_4))) => (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) -> (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u2} β _inst_4))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u2} β _inst_4))) (InfTopHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u3} β] [_inst_4 : Top.{u3} β] [_inst_5 : HasInf.{u2} γ] [_inst_6 : Top.{u2} γ] (g : InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (f : InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6)) (InfTopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6))) (InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (fun (_x : InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6))) (InfTopHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (InfTopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g f)) (SupBotHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (OrderDual.bot.{u1} α _inst_2) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u3} β _inst_4) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u2} γ _inst_6) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (SupBotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_3) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u3} β _inst_4) (OrderDual.bot.{u2} γ _inst_6))) (InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) => SupBotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_3) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u3} β _inst_4) (OrderDual.bot.{u2} γ _inst_6)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (SupBotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_3) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u3} β _inst_4) (OrderDual.bot.{u2} γ _inst_6))) (InfTopHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u3} β _inst_4))) (InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) => SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u3} β _inst_4)) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u3} β _inst_4))) (InfTopHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.dual_comp InfTopHom.dual_compₓ'. -/
@[simp]
theorem dual_comp (g : InfTopHom β γ) (f : InfTopHom α β) : (g.comp f).dual = g.dual.comp f.dual :=
  rfl
#align inf_top_hom.dual_comp InfTopHom.dual_comp

#print InfTopHom.symm_dual_id /-
@[simp]
theorem symm_dual_id : InfTopHom.dual.symm (SupBotHom.id _) = InfTopHom.id α :=
  rfl
#align inf_top_hom.symm_dual_id InfTopHom.symm_dual_id
-/

/- warning: inf_top_hom.symm_dual_comp -> InfTopHom.symm_dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u2} β] [_inst_4 : Top.{u2} β] [_inst_5 : HasInf.{u3} γ] [_inst_6 : Top.{u3} γ] (g : SupBotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasBot.{u3} γ _inst_6)) (f : SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u2} β _inst_4)), Eq.{max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u3} γ _inst_6)) (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u3} γ _inst_6)) (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) => (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u3} γ _inst_6)) -> (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u3} γ _inst_6)) (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.symm.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (InfTopHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u3} γ _inst_6)) (InfTopHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (SupBotHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u3} γ _inst_6) g f)) (InfTopHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasBot.{u3} γ _inst_6)) (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasBot.{u3} γ _inst_6)) (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) => (SupBotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasBot.{u3} γ _inst_6)) -> (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasBot.{u3} γ _inst_6)) (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (SupBotHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasSup.{u3} γ _inst_5) (OrderDual.hasBot.{u2} β _inst_4) (OrderDual.hasBot.{u3} γ _inst_6)) (InfTopHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u2} β _inst_4)) (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u2} β _inst_4)) (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) => (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u2} β _inst_4)) -> (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u2} β _inst_4)) (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (InfTopHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.hasSup.{u1} α _inst_1) (OrderDual.hasSup.{u2} β _inst_3) (OrderDual.hasBot.{u1} α _inst_2) (OrderDual.hasBot.{u2} β _inst_4)) (InfTopHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : HasInf.{u1} α] [_inst_2 : Top.{u1} α] [_inst_3 : HasInf.{u3} β] [_inst_4 : Top.{u3} β] [_inst_5 : HasInf.{u2} γ] [_inst_6 : Top.{u2} γ] (g : SupBotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_3) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u3} β _inst_4) (OrderDual.bot.{u2} γ _inst_6)) (f : SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u3} β _inst_4)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6)) => InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (OrderDual.bot.{u1} α _inst_2) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u3} β _inst_4) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u2} γ _inst_6) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6)) (InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6)) (fun (_x : SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6)) => InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6)) (InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (InfTopHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (SupBotHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u2} γ _inst_6)) (InfTopHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (SupBotHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u1} α _inst_1) (OrderDual.bot.{u1} α _inst_2) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u3} β _inst_4) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u2} γ _inst_6) g f)) (InfTopHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_3) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u3} β _inst_4) (OrderDual.bot.{u2} γ _inst_6)) (InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (SupBotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_3) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u3} β _inst_4) (OrderDual.bot.{u2} γ _inst_6)) (fun (_x : SupBotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_3) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u3} β _inst_4) (OrderDual.bot.{u2} γ _inst_6)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupBotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_3) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u3} β _inst_4) (OrderDual.bot.{u2} γ _inst_6)) => InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (SupBotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_3) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u3} β _inst_4) (OrderDual.bot.{u2} γ _inst_6)) (InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (InfTopHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (SupBotHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (instHasSupOrderDual.{u3} β _inst_3) (instHasSupOrderDual.{u2} γ _inst_5) (OrderDual.bot.{u3} β _inst_4) (OrderDual.bot.{u2} γ _inst_6)) (InfTopHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u3} β _inst_4)) (InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4)) (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u3} β _inst_4)) (fun (_x : SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u3} β _inst_4)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u3} β _inst_4)) => InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u3} β _inst_4)) (InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.symm.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (InfTopHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (SupBotHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (instHasSupOrderDual.{u1} α _inst_1) (instHasSupOrderDual.{u3} β _inst_3) (OrderDual.bot.{u1} α _inst_2) (OrderDual.bot.{u3} β _inst_4)) (InfTopHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
Case conversion may be inaccurate. Consider using '#align inf_top_hom.symm_dual_comp InfTopHom.symm_dual_compₓ'. -/
@[simp]
theorem symm_dual_comp (g : SupBotHom βᵒᵈ γᵒᵈ) (f : SupBotHom αᵒᵈ βᵒᵈ) :
    InfTopHom.dual.symm (g.comp f) = (InfTopHom.dual.symm g).comp (InfTopHom.dual.symm f) :=
  rfl
#align inf_top_hom.symm_dual_comp InfTopHom.symm_dual_comp

end InfTopHom

namespace LatticeHom

variable [Lattice α] [Lattice β] [Lattice γ]

#print LatticeHom.dual /-
/-- Reinterpret a lattice homomorphism as a lattice homomorphism between the dual lattices. -/
@[simps]
protected def dual : LatticeHom α β ≃ LatticeHom αᵒᵈ βᵒᵈ
    where
  toFun f := ⟨f.toInfHom.dual, f.map_sup'⟩
  invFun f := ⟨f.toInfHom.dual, f.map_sup'⟩
  left_inv f := ext fun a => rfl
  right_inv f := ext fun a => rfl
#align lattice_hom.dual LatticeHom.dual
-/

#print LatticeHom.dual_id /-
@[simp]
theorem dual_id : (LatticeHom.id α).dual = LatticeHom.id _ :=
  rfl
#align lattice_hom.dual_id LatticeHom.dual_id
-/

/- warning: lattice_hom.dual_comp -> LatticeHom.dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] (g : LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (f : LatticeHom.{u1, u2} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u3)} (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_3)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_3))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_3))) => (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) -> (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_3))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_3))) (LatticeHom.dual.{u1, u3} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 g f)) (LatticeHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (LatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (LatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3))) => (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) -> (LatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (LatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3))) (LatticeHom.dual.{u2, u3} β γ _inst_2 _inst_3) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2))) => (LatticeHom.{u1, u2} α β _inst_1 _inst_2) -> (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2))) (LatticeHom.dual.{u1, u2} α β _inst_1 _inst_2) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] (g : LatticeHom.{u3, u2} β γ _inst_2 _inst_3) (f : LatticeHom.{u1, u3} α β _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : LatticeHom.{u1, u2} α γ _inst_1 _inst_3) => LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3)) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3))) (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) (fun (_x : LatticeHom.{u1, u2} α γ _inst_1 _inst_3) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : LatticeHom.{u1, u2} α γ _inst_1 _inst_3) => LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3))) (LatticeHom.dual.{u1, u2} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 g f)) (LatticeHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) (LatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3))) (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) (fun (_x : LatticeHom.{u3, u2} β γ _inst_2 _inst_3) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : LatticeHom.{u3, u2} β γ _inst_2 _inst_3) => LatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) (LatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3))) (LatticeHom.dual.{u3, u2} β γ _inst_2 _inst_3) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2))) (LatticeHom.{u1, u3} α β _inst_1 _inst_2) (fun (_x : LatticeHom.{u1, u3} α β _inst_1 _inst_2) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : LatticeHom.{u1, u3} α β _inst_1 _inst_2) => LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2)) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2))) (LatticeHom.dual.{u1, u3} α β _inst_1 _inst_2) f))
Case conversion may be inaccurate. Consider using '#align lattice_hom.dual_comp LatticeHom.dual_compₓ'. -/
@[simp]
theorem dual_comp (g : LatticeHom β γ) (f : LatticeHom α β) :
    (g.comp f).dual = g.dual.comp f.dual :=
  rfl
#align lattice_hom.dual_comp LatticeHom.dual_comp

#print LatticeHom.symm_dual_id /-
@[simp]
theorem symm_dual_id : LatticeHom.dual.symm (LatticeHom.id _) = LatticeHom.id α :=
  rfl
#align lattice_hom.symm_dual_id LatticeHom.symm_dual_id
-/

/- warning: lattice_hom.symm_dual_comp -> LatticeHom.symm_dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u2} β] [_inst_3 : Lattice.{u3} γ] (g : LatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3)) (f : LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2)), Eq.{max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_3)) (LatticeHom.{u1, u3} α γ _inst_1 _inst_3)) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_3)) (LatticeHom.{u1, u3} α γ _inst_1 _inst_3)) => (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_3)) -> (LatticeHom.{u1, u3} α γ _inst_1 _inst_3)) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_3)) (LatticeHom.{u1, u3} α γ _inst_1 _inst_3)) (Equiv.symm.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LatticeHom.{u1, u3} α γ _inst_1 _inst_3) (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_3)) (LatticeHom.dual.{u1, u3} α γ _inst_1 _inst_3)) (LatticeHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3) g f)) (LatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3)) (LatticeHom.{u2, u3} β γ _inst_2 _inst_3)) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3)) (LatticeHom.{u2, u3} β γ _inst_2 _inst_3)) => (LatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3)) -> (LatticeHom.{u2, u3} β γ _inst_2 _inst_3)) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3)) (LatticeHom.{u2, u3} β γ _inst_2 _inst_3)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u2, u3} β γ _inst_2 _inst_3) (LatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_2) (OrderDual.lattice.{u3} γ _inst_3)) (LatticeHom.dual.{u2, u3} β γ _inst_2 _inst_3)) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2)) (LatticeHom.{u1, u2} α β _inst_1 _inst_2)) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2)) (LatticeHom.{u1, u2} α β _inst_1 _inst_2)) => (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2)) -> (LatticeHom.{u1, u2} α β _inst_1 _inst_2)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2)) (LatticeHom.{u1, u2} α β _inst_1 _inst_2)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LatticeHom.{u1, u2} α β _inst_1 _inst_2) (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_2)) (LatticeHom.dual.{u1, u2} α β _inst_1 _inst_2)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : Lattice.{u3} β] [_inst_3 : Lattice.{u2} γ] (g : LatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3)) (f : LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3)) => LatticeHom.{u1, u2} α γ _inst_1 _inst_3) (LatticeHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3)) (LatticeHom.{u1, u2} α γ _inst_1 _inst_3)) (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3)) (fun (_x : LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3)) => LatticeHom.{u1, u2} α γ _inst_1 _inst_3) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3)) (LatticeHom.{u1, u2} α γ _inst_1 _inst_3)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LatticeHom.{u1, u2} α γ _inst_1 _inst_3) (LatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_3)) (LatticeHom.dual.{u1, u2} α γ _inst_1 _inst_3)) (LatticeHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3) g f)) (LatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3)) (LatticeHom.{u3, u2} β γ _inst_2 _inst_3)) (LatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3)) (fun (_x : LatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : LatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3)) => LatticeHom.{u3, u2} β γ _inst_2 _inst_3) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3)) (LatticeHom.{u3, u2} β γ _inst_2 _inst_3)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LatticeHom.{u3, u2} β γ _inst_2 _inst_3) (LatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_2) (OrderDual.lattice.{u2} γ _inst_3)) (LatticeHom.dual.{u3, u2} β γ _inst_2 _inst_3)) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2)) (LatticeHom.{u1, u3} α β _inst_1 _inst_2)) (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2)) (fun (_x : LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2)) => LatticeHom.{u1, u3} α β _inst_1 _inst_2) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2)) (LatticeHom.{u1, u3} α β _inst_1 _inst_2)) (Equiv.symm.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (LatticeHom.{u1, u3} α β _inst_1 _inst_2) (LatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_2)) (LatticeHom.dual.{u1, u3} α β _inst_1 _inst_2)) f))
Case conversion may be inaccurate. Consider using '#align lattice_hom.symm_dual_comp LatticeHom.symm_dual_compₓ'. -/
@[simp]
theorem symm_dual_comp (g : LatticeHom βᵒᵈ γᵒᵈ) (f : LatticeHom αᵒᵈ βᵒᵈ) :
    LatticeHom.dual.symm (g.comp f) = (LatticeHom.dual.symm g).comp (LatticeHom.dual.symm f) :=
  rfl
#align lattice_hom.symm_dual_comp LatticeHom.symm_dual_comp

end LatticeHom

namespace BoundedLatticeHom

variable [Lattice α] [BoundedOrder α] [Lattice β] [BoundedOrder β] [Lattice γ] [BoundedOrder γ]

#print BoundedLatticeHom.dual /-
/-- Reinterpret a bounded lattice homomorphism as a bounded lattice homomorphism between the dual
bounded lattices. -/
@[simps]
protected def dual : BoundedLatticeHom α β ≃ BoundedLatticeHom αᵒᵈ βᵒᵈ
    where
  toFun f := ⟨f.toLatticeHom.dual, f.map_bot', f.map_top'⟩
  invFun f := ⟨LatticeHom.dual.symm f.toLatticeHom, f.map_bot', f.map_top'⟩
  left_inv f := ext fun a => rfl
  right_inv f := ext fun a => rfl
#align bounded_lattice_hom.dual BoundedLatticeHom.dual
-/

#print BoundedLatticeHom.dual_id /-
@[simp]
theorem dual_id : (BoundedLatticeHom.id α).dual = BoundedLatticeHom.id _ :=
  rfl
#align bounded_lattice_hom.dual_id BoundedLatticeHom.dual_id
-/

/- warning: bounded_lattice_hom.dual_comp -> BoundedLatticeHom.dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_3 : Lattice.{u2} β] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3))))] [_inst_5 : Lattice.{u3} γ] [_inst_6 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5))))] (g : BoundedLatticeHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (f : BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6))) => (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) -> (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6))) (BoundedLatticeHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_3 _inst_5 _inst_2 _inst_4 _inst_6 g f)) (BoundedLatticeHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6) (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedLatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6))) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedLatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6))) => (BoundedLatticeHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) -> (BoundedLatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6))) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedLatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6))) (BoundedLatticeHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4))) => (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) -> (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4))) (BoundedLatticeHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_3 : Lattice.{u3} β] [_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3))))] [_inst_5 : Lattice.{u2} γ] [_inst_6 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5))))] (g : BoundedLatticeHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (f : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_3 _inst_5 _inst_2 _inst_4 _inst_6 g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6))) (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (fun (_x : BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) => BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6))) (BoundedLatticeHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_3 _inst_5 _inst_2 _inst_4 _inst_6 g f)) (BoundedLatticeHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedLatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6))) (BoundedLatticeHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : BoundedLatticeHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : BoundedLatticeHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) => BoundedLatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedLatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6))) (BoundedLatticeHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4))) (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (fun (_x : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) => BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4)) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4))) (BoundedLatticeHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) f))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.dual_comp BoundedLatticeHom.dual_compₓ'. -/
@[simp]
theorem dual_comp (g : BoundedLatticeHom β γ) (f : BoundedLatticeHom α β) :
    (g.comp f).dual = g.dual.comp f.dual :=
  rfl
#align bounded_lattice_hom.dual_comp BoundedLatticeHom.dual_comp

#print BoundedLatticeHom.symm_dual_id /-
@[simp]
theorem symm_dual_id :
    BoundedLatticeHom.dual.symm (BoundedLatticeHom.id _) = BoundedLatticeHom.id α :=
  rfl
#align bounded_lattice_hom.symm_dual_id BoundedLatticeHom.symm_dual_id
-/

/- warning: bounded_lattice_hom.symm_dual_comp -> BoundedLatticeHom.symm_dual_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Lattice.{u1} α] [_inst_2 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_3 : Lattice.{u2} β] [_inst_4 : BoundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3))))] [_inst_5 : Lattice.{u3} γ] [_inst_6 : BoundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5))))] (g : BoundedLatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) (f : BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)), Eq.{max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) => (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) -> (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.symm.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (BoundedLatticeHom.{u1, u3} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.dual.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (BoundedLatticeHom.comp.{u1, u2, u3} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6) g f)) (BoundedLatticeHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_3 _inst_5 _inst_2 _inst_4 _inst_6 (coeFn.{max 1 (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (fun (_x : Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) => (BoundedLatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) -> (BoundedLatticeHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.hasCoeToFun.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u2, u3} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedLatticeHom.{u2, u3} (OrderDual.{u2} β) (OrderDual.{u3} γ) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.lattice.{u3} γ _inst_5) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u3} γ (Preorder.toLE.{u3} γ (PartialOrder.toPreorder.{u3} γ (SemilatticeInf.toPartialOrder.{u3} γ (Lattice.toSemilatticeInf.{u3} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.dual.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) => (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) -> (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (BoundedLatticeHom.{u1, u2} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} β (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (SemilatticeInf.toPartialOrder.{u2} β (Lattice.toSemilatticeInf.{u2} β _inst_3)))) _inst_4)) (BoundedLatticeHom.dual.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : Lattice.{u1} α] [_inst_2 : BoundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1))))] [_inst_3 : Lattice.{u3} β] [_inst_4 : BoundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3))))] [_inst_5 : Lattice.{u2} γ] [_inst_6 : BoundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5))))] (g : BoundedLatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) (f : BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4)), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) => BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedLatticeHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6) g f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) (fun (_x : BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) => BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6)) (Equiv.symm.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (BoundedLatticeHom.{u1, u2} α γ _inst_1 _inst_5 _inst_2 _inst_6) (BoundedLatticeHom.{u1, u2} (OrderDual.{u1} α) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.dual.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6)) (BoundedLatticeHom.comp.{u1, u3, u2} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6) g f)) (BoundedLatticeHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_3 _inst_5 _inst_2 _inst_4 _inst_6 (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (Equiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (BoundedLatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) (fun (_x : BoundedLatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : BoundedLatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) => BoundedLatticeHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6)) (Equiv.symm.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (BoundedLatticeHom.{u3, u2} β γ _inst_3 _inst_5 _inst_4 _inst_6) (BoundedLatticeHom.{u3, u2} (OrderDual.{u3} β) (OrderDual.{u2} γ) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.lattice.{u2} γ _inst_5) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4) (OrderDual.boundedOrder.{u2} γ (Preorder.toLE.{u2} γ (PartialOrder.toPreorder.{u2} γ (SemilatticeInf.toPartialOrder.{u2} γ (Lattice.toSemilatticeInf.{u2} γ _inst_5)))) _inst_6)) (BoundedLatticeHom.dual.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6)) g) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4)) (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4)) (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4)) (fun (_x : BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4)) => BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4)) (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4)) (Equiv.symm.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (BoundedLatticeHom.{u1, u3} α β _inst_1 _inst_3 _inst_2 _inst_4) (BoundedLatticeHom.{u1, u3} (OrderDual.{u1} α) (OrderDual.{u3} β) (OrderDual.lattice.{u1} α _inst_1) (OrderDual.lattice.{u3} β _inst_3) (OrderDual.boundedOrder.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α _inst_1)))) _inst_2) (OrderDual.boundedOrder.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (SemilatticeInf.toPartialOrder.{u3} β (Lattice.toSemilatticeInf.{u3} β _inst_3)))) _inst_4)) (BoundedLatticeHom.dual.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4)) f))
Case conversion may be inaccurate. Consider using '#align bounded_lattice_hom.symm_dual_comp BoundedLatticeHom.symm_dual_compₓ'. -/
@[simp]
theorem symm_dual_comp (g : BoundedLatticeHom βᵒᵈ γᵒᵈ) (f : BoundedLatticeHom αᵒᵈ βᵒᵈ) :
    BoundedLatticeHom.dual.symm (g.comp f) =
      (BoundedLatticeHom.dual.symm g).comp (BoundedLatticeHom.dual.symm f) :=
  rfl
#align bounded_lattice_hom.symm_dual_comp BoundedLatticeHom.symm_dual_comp

end BoundedLatticeHom

