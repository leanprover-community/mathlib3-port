import Mathbin.Order.Filter.Bases 
import Mathbin.Data.Finset.Preimage

/-!
# `at_top` and `at_bot` filters on preorded sets, monoids and groups.

In this file we define the filters

* `at_top`: corresponds to `n ‚Üí +‚àû`;
* `at_bot`: corresponds to `n ‚Üí -‚àû`.

Then we prove many lemmas like ‚Äúif `f ‚Üí +‚àû`, then `f ¬± c ‚Üí +‚àû`‚Äù.
-/


variable{Œπ Œπ' Œ± Œ≤ Œ≥ : Type _}

open Set

open_locale Classical Filter BigOperators

namespace Filter

/-- `at_top` is the filter representing the limit `‚Üí ‚àû` on an ordered set.
  It is generated by the collection of up-sets `{b | a ‚â§ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def at_top [Preorder‚Çì Œ±] : Filter Œ± :=
  ‚®Öa, ùìü (Ici a)

/-- `at_bot` is the filter representing the limit `‚Üí -‚àû` on an ordered set.
  It is generated by the collection of down-sets `{b | b ‚â§ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def at_bot [Preorder‚Çì Œ±] : Filter Œ± :=
  ‚®Öa, ùìü (Iic a)

theorem mem_at_top [Preorder‚Çì Œ±] (a : Œ±) : { b:Œ± | a ‚â§ b } ‚àà @at_top Œ± _ :=
  mem_infi_of_mem a$ subset.refl _

theorem Ioi_mem_at_top [Preorder‚Çì Œ±] [NoTopOrder Œ±] (x : Œ±) : Ioi x ‚àà (at_top : Filter Œ±) :=
  let ‚ü®z, hz‚ü© := no_top x 
  mem_of_superset (mem_at_top z)$ fun y h => lt_of_lt_of_le‚Çì hz h

theorem mem_at_bot [Preorder‚Çì Œ±] (a : Œ±) : { b:Œ± | b ‚â§ a } ‚àà @at_bot Œ± _ :=
  mem_infi_of_mem a$ subset.refl _

theorem Iio_mem_at_bot [Preorder‚Çì Œ±] [NoBotOrder Œ±] (x : Œ±) : Iio x ‚àà (at_bot : Filter Œ±) :=
  let ‚ü®z, hz‚ü© := no_bot x 
  mem_of_superset (mem_at_bot z)$ fun y h => lt_of_le_of_lt‚Çì h hz

theorem at_top_basis [Nonempty Œ±] [SemilatticeSup Œ±] : (@at_top Œ± _).HasBasis (fun _ => True) Ici :=
  has_basis_infi_principal (directed_of_sup$ fun a b => Ici_subset_Ici.2)

theorem at_top_basis' [SemilatticeSup Œ±] (a : Œ±) : (@at_top Œ± _).HasBasis (fun x => a ‚â§ x) Ici :=
  ‚ü®fun t =>
      (@at_top_basis Œ± ‚ü®a‚ü© _).mem_iff.trans
        ‚ü®fun ‚ü®x, _, hx‚ü© => ‚ü®x‚äîa, le_sup_right, fun y hy => hx (le_trans‚Çì le_sup_left hy)‚ü©,
          fun ‚ü®x, _, hx‚ü© => ‚ü®x, trivial‚Çì, hx‚ü©‚ü©‚ü©

theorem at_bot_basis [Nonempty Œ±] [SemilatticeInf Œ±] : (@at_bot Œ± _).HasBasis (fun _ => True) Iic :=
  @at_top_basis (OrderDual Œ±) _ _

theorem at_bot_basis' [SemilatticeInf Œ±] (a : Œ±) : (@at_bot Œ± _).HasBasis (fun x => x ‚â§ a) Iic :=
  @at_top_basis' (OrderDual Œ±) _ _

@[instance]
theorem at_top_ne_bot [Nonempty Œ±] [SemilatticeSup Œ±] : ne_bot (at_top : Filter Œ±) :=
  at_top_basis.ne_bot_iff.2$ fun a _ => nonempty_Ici

@[instance]
theorem at_bot_ne_bot [Nonempty Œ±] [SemilatticeInf Œ±] : ne_bot (at_bot : Filter Œ±) :=
  @at_top_ne_bot (OrderDual Œ±) _ _

@[simp]
theorem mem_at_top_sets [Nonempty Œ±] [SemilatticeSup Œ±] {s : Set Œ±} :
  s ‚àà (at_top : Filter Œ±) ‚Üî ‚àÉ a : Œ±, ‚àÄ b (_ : b ‚â• a), b ‚àà s :=
  at_top_basis.mem_iff.trans$ exists_congr$ fun _ => exists_const _

@[simp]
theorem mem_at_bot_sets [Nonempty Œ±] [SemilatticeInf Œ±] {s : Set Œ±} :
  s ‚àà (at_bot : Filter Œ±) ‚Üî ‚àÉ a : Œ±, ‚àÄ b (_ : b ‚â§ a), b ‚àà s :=
  @mem_at_top_sets (OrderDual Œ±) _ _ _

@[simp]
theorem eventually_at_top [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂†x in at_top, p x) ‚Üî ‚àÉ a, ‚àÄ b (_ : b ‚â• a), p b :=
  mem_at_top_sets

@[simp]
theorem eventually_at_bot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂†x in at_bot, p x) ‚Üî ‚àÉ a, ‚àÄ b (_ : b ‚â§ a), p b :=
  mem_at_bot_sets

theorem eventually_ge_at_top [Preorder‚Çì Œ±] (a : Œ±) : ‚àÄ·∂†x in at_top, a ‚â§ x :=
  mem_at_top a

theorem eventually_le_at_bot [Preorder‚Çì Œ±] (a : Œ±) : ‚àÄ·∂†x in at_bot, x ‚â§ a :=
  mem_at_bot a

theorem eventually_gt_at_top [Preorder‚Çì Œ±] [NoTopOrder Œ±] (a : Œ±) : ‚àÄ·∂†x in at_top, a < x :=
  Ioi_mem_at_top a

theorem eventually_lt_at_bot [Preorder‚Çì Œ±] [NoBotOrder Œ±] (a : Œ±) : ‚àÄ·∂†x in at_bot, x < a :=
  Iio_mem_at_bot a

theorem at_top_basis_Ioi [Nonempty Œ±] [SemilatticeSup Œ±] [NoTopOrder Œ±] : (@at_top Œ± _).HasBasis (fun _ => True) Ioi :=
  (at_top_basis.to_has_basis fun a ha => ‚ü®a, ha, Ioi_subset_Ici_self‚ü©)$
    fun a ha => (no_top a).imp$ fun b hb => ‚ü®ha, Ici_subset_Ioi.2 hb‚ü©

theorem at_top_countable_basis [Nonempty Œ±] [SemilatticeSup Œ±] [Encodable Œ±] :
  has_countable_basis (at_top : Filter Œ±) (fun _ => True) Ici :=
  { at_top_basis with Countable := countable_encodable _ }

theorem at_bot_countable_basis [Nonempty Œ±] [SemilatticeInf Œ±] [Encodable Œ±] :
  has_countable_basis (at_bot : Filter Œ±) (fun _ => True) Iic :=
  { at_bot_basis with Countable := countable_encodable _ }

instance (priority := 200)at_top.is_countably_generated [Preorder‚Çì Œ±] [Encodable Œ±] :
  (at_top : Filter$ Œ±).IsCountablyGenerated :=
  is_countably_generated_seq _

instance (priority := 200)at_bot.is_countably_generated [Preorder‚Çì Œ±] [Encodable Œ±] :
  (at_bot : Filter$ Œ±).IsCountablyGenerated :=
  is_countably_generated_seq _

theorem order_top.at_top_eq Œ± [PartialOrder‚Çì Œ±] [OrderTop Œ±] : (at_top : Filter Œ±) = pure ‚ä§ :=
  le_antisymm‚Çì (le_pure_iff.2$ (eventually_ge_at_top ‚ä§).mono$ fun b => top_unique)
    (le_infi$ fun b => le_principal_iff.2 le_top)

theorem order_bot.at_bot_eq Œ± [PartialOrder‚Çì Œ±] [OrderBot Œ±] : (at_bot : Filter Œ±) = pure ‚ä• :=
  @order_top.at_top_eq (OrderDual Œ±) _ _

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[nontriviality #[]]
theorem subsingleton.at_top_eq (Œ±) [subsingleton Œ±] [preorder Œ±] : ¬´expr = ¬ª((at_top : filter Œ±), ¬´expr‚ä§¬ª()) :=
begin
  refine [expr top_unique (Œª s hs x, _)],
  letI [] [":", expr unique Œ±] [":=", expr ‚ü®‚ü®x‚ü©, Œª y, subsingleton.elim y x‚ü©],
  rw ["[", expr at_top, ",", expr infi_unique, ",", expr unique.default_eq x, ",", expr mem_principal, "]"] ["at", ident hs],
  exact [expr hs left_mem_Ici]
end

@[nontriviality]
theorem subsingleton.at_bot_eq Œ± [Subsingleton Œ±] [Preorder‚Çì Œ±] : (at_bot : Filter Œ±) = ‚ä§ :=
  @subsingleton.at_top_eq (OrderDual Œ±) _ _

theorem tendsto_at_top_pure [PartialOrder‚Çì Œ±] [OrderTop Œ±] (f : Œ± ‚Üí Œ≤) : tendsto f at_top (pure$ f ‚ä§) :=
  (order_top.at_top_eq Œ±).symm ‚ñ∏ tendsto_pure_pure _ _

theorem tendsto_at_bot_pure [PartialOrder‚Çì Œ±] [OrderBot Œ±] (f : Œ± ‚Üí Œ≤) : tendsto f at_bot (pure$ f ‚ä•) :=
  @tendsto_at_top_pure (OrderDual Œ±) _ _ _ _

theorem eventually.exists_forall_of_at_top [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂†x in at_top, p x) :
  ‚àÉ a, ‚àÄ b (_ : b ‚â• a), p b :=
  eventually_at_top.mp h

theorem eventually.exists_forall_of_at_bot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂†x in at_bot, p x) :
  ‚àÉ a, ‚àÄ b (_ : b ‚â§ a), p b :=
  eventually_at_bot.mp h

theorem frequently_at_top [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÉ·∂†x in at_top, p x) ‚Üî ‚àÄ a, ‚àÉ (b : _)(_ : b ‚â• a), p b :=
  by 
    simp [at_top_basis.frequently_iff]

theorem frequently_at_bot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÉ·∂†x in at_bot, p x) ‚Üî ‚àÄ a, ‚àÉ (b : _)(_ : b ‚â§ a), p b :=
  @frequently_at_top (OrderDual Œ±) _ _ _

theorem frequently_at_top' [SemilatticeSup Œ±] [Nonempty Œ±] [NoTopOrder Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÉ·∂†x in at_top, p x) ‚Üî ‚àÄ a, ‚àÉ (b : _)(_ : b > a), p b :=
  by 
    simp [at_top_basis_Ioi.frequently_iff]

theorem frequently_at_bot' [SemilatticeInf Œ±] [Nonempty Œ±] [NoBotOrder Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÉ·∂†x in at_bot, p x) ‚Üî ‚àÄ a, ‚àÉ (b : _)(_ : b < a), p b :=
  @frequently_at_top' (OrderDual Œ±) _ _ _ _

theorem frequently.forall_exists_of_at_top [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} (h : ‚àÉ·∂†x in at_top, p x) :
  ‚àÄ a, ‚àÉ (b : _)(_ : b ‚â• a), p b :=
  frequently_at_top.mp h

theorem frequently.forall_exists_of_at_bot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} (h : ‚àÉ·∂†x in at_bot, p x) :
  ‚àÄ a, ‚àÉ (b : _)(_ : b ‚â§ a), p b :=
  frequently_at_bot.mp h

theorem map_at_top_eq [Nonempty Œ±] [SemilatticeSup Œ±] {f : Œ± ‚Üí Œ≤} : at_top.map f = ‚®Öa, ùìü$ f '' { a' | a ‚â§ a' } :=
  (at_top_basis.map _).eq_infi

theorem map_at_bot_eq [Nonempty Œ±] [SemilatticeInf Œ±] {f : Œ± ‚Üí Œ≤} : at_bot.map f = ‚®Öa, ùìü$ f '' { a' | a' ‚â§ a } :=
  @map_at_top_eq (OrderDual Œ±) _ _ _ _

theorem tendsto_at_top [Preorder‚Çì Œ≤] {m : Œ± ‚Üí Œ≤} {f : Filter Œ±} : tendsto m f at_top ‚Üî ‚àÄ b, ‚àÄ·∂†a in f, b ‚â§ m a :=
  by 
    simp only [at_top, tendsto_infi, tendsto_principal, mem_Ici]

theorem tendsto_at_bot [Preorder‚Çì Œ≤] {m : Œ± ‚Üí Œ≤} {f : Filter Œ±} : tendsto m f at_bot ‚Üî ‚àÄ b, ‚àÄ·∂†a in f, m a ‚â§ b :=
  @tendsto_at_top Œ± (OrderDual Œ≤) _ m f

theorem tendsto_at_top_mono' [Preorder‚Çì Œ≤] (l : Filter Œ±) ‚¶Éf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤‚¶Ñ (h : f‚ÇÅ ‚â§·∂†[l] f‚ÇÇ) :
  tendsto f‚ÇÅ l at_top ‚Üí tendsto f‚ÇÇ l at_top :=
  fun h‚ÇÅ =>
    tendsto_at_top.2$ fun b => mp_mem (tendsto_at_top.1 h‚ÇÅ b) (monotone_mem (fun a ha ha‚ÇÅ => le_trans‚Çì ha‚ÇÅ ha) h)

theorem tendsto_at_bot_mono' [Preorder‚Çì Œ≤] (l : Filter Œ±) ‚¶Éf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤‚¶Ñ (h : f‚ÇÅ ‚â§·∂†[l] f‚ÇÇ) :
  tendsto f‚ÇÇ l at_bot ‚Üí tendsto f‚ÇÅ l at_bot :=
  @tendsto_at_top_mono' _ (OrderDual Œ≤) _ _ _ _ h

theorem tendsto_at_top_mono [Preorder‚Çì Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (h : ‚àÄ n, f n ‚â§ g n) :
  tendsto f l at_top ‚Üí tendsto g l at_top :=
  tendsto_at_top_mono' l$ eventually_of_forall h

theorem tendsto_at_bot_mono [Preorder‚Çì Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (h : ‚àÄ n, f n ‚â§ g n) :
  tendsto g l at_bot ‚Üí tendsto f l at_bot :=
  @tendsto_at_top_mono _ (OrderDual Œ≤) _ _ _ _ h

/-!
### Sequences
-/


theorem inf_map_at_top_ne_bot_iff [SemilatticeSup Œ±] [Nonempty Œ±] {F : Filter Œ≤} {u : Œ± ‚Üí Œ≤} :
  ne_bot (F‚äìmap u at_top) ‚Üî ‚àÄ U (_ : U ‚àà F), ‚àÄ N, ‚àÉ (n : _)(_ : n ‚â• N), u n ‚àà U :=
  by 
    simpRw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top] <;> rfl

theorem inf_map_at_bot_ne_bot_iff [SemilatticeInf Œ±] [Nonempty Œ±] {F : Filter Œ≤} {u : Œ± ‚Üí Œ≤} :
  ne_bot (F‚äìmap u at_bot) ‚Üî ‚àÄ U (_ : U ‚àà F), ‚àÄ N, ‚àÉ (n : _)(_ : n ‚â§ N), u n ‚àà U :=
  @inf_map_at_top_ne_bot_iff (OrderDual Œ±) _ _ _ _ _

theorem extraction_of_frequently_at_top' {P : ‚Ñï ‚Üí Prop} (h : ‚àÄ N, ‚àÉ (n : _)(_ : n > N), P n) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) :=
  by 
    choose u hu using h 
    cases' forall_and_distrib.mp hu with hu hu' 
    exact ‚ü®u ‚àò Nat.rec 0 fun n v => u v, strict_mono_nat_of_lt_succ fun n => hu _, fun n => hu' _‚ü©

theorem extraction_of_frequently_at_top {P : ‚Ñï ‚Üí Prop} (h : ‚àÉ·∂†n in at_top, P n) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) :=
  by 
    rw [frequently_at_top'] at h 
    exact extraction_of_frequently_at_top' h

theorem extraction_of_eventually_at_top {P : ‚Ñï ‚Üí Prop} (h : ‚àÄ·∂†n in at_top, P n) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) :=
  extraction_of_frequently_at_top h.frequently

theorem extraction_forall_of_frequently {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÉ·∂†k in at_top, P n k) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=
  by 
    simp only [frequently_at_top'] at h 
    choose u hu hu' using h 
    use (fun n => Nat.recOn n (u 0 0) fun n v => u (n+1) v : ‚Ñï ‚Üí ‚Ñï)
    split 
    ¬∑
      apply strict_mono_nat_of_lt_succ 
      intro n 
      apply hu
    ¬∑
      intro n 
      cases n <;> simp [hu']

theorem extraction_forall_of_eventually {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÄ·∂†k in at_top, P n k) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=
  extraction_forall_of_frequently fun n => (h n).Frequently

theorem extraction_forall_of_eventually' {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÉ N, ‚àÄ k (_ : k ‚â• N), P n k) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=
  extraction_forall_of_eventually
    (by 
      simp [eventually_at_top, h])

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem exists_le_of_tendsto_at_top
[semilattice_sup Œ±]
[preorder Œ≤]
{u : Œ± ‚Üí Œ≤}
(h : tendsto u at_top at_top)
(a : Œ±)
(b : Œ≤) : ¬´expr‚àÉ , ¬ª((a' ¬´expr ‚â• ¬ª a), ¬´expr ‚â§ ¬ª(b, u a')) :=
begin
  have [] [":", expr ¬´expr‚àÄ·∂† in , ¬ª((x), at_top, ¬´expr ‚àß ¬ª(¬´expr ‚â§ ¬ª(a, x), ¬´expr ‚â§ ¬ª(b, u x)))] [":=", expr (eventually_ge_at_top a).and ¬´expr $ ¬ª(h.eventually, eventually_ge_at_top b)],
  haveI [] [":", expr nonempty Œ±] [":=", expr ‚ü®a‚ü©],
  rcases [expr this.exists, "with", "‚ü®", ident a', ",", ident ha, ",", ident hb, "‚ü©"],
  exact [expr ‚ü®a', ha, hb‚ü©]
end

@[nolint ge_or_gt]
theorem exists_le_of_tendsto_at_bot [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] {u : Œ± ‚Üí Œ≤} (h : tendsto u at_top at_bot) :
  ‚àÄ a b, ‚àÉ (a' : _)(_ : a' ‚â• a), u a' ‚â§ b :=
  @exists_le_of_tendsto_at_top _ (OrderDual Œ≤) _ _ _ h

theorem exists_lt_of_tendsto_at_top [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] [NoTopOrder Œ≤] {u : Œ± ‚Üí Œ≤}
  (h : tendsto u at_top at_top) (a : Œ±) (b : Œ≤) : ‚àÉ (a' : _)(_ : a' ‚â• a), b < u a' :=
  by 
    cases' no_top b with b' hb' 
    rcases exists_le_of_tendsto_at_top h a b' with ‚ü®a', ha', ha''‚ü©
    exact ‚ü®a', ha', lt_of_lt_of_le‚Çì hb' ha''‚ü©

@[nolint ge_or_gt]
theorem exists_lt_of_tendsto_at_bot [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] [NoBotOrder Œ≤] {u : Œ± ‚Üí Œ≤}
  (h : tendsto u at_top at_bot) : ‚àÄ a b, ‚àÉ (a' : _)(_ : a' ‚â• a), u a' < b :=
  @exists_lt_of_tendsto_at_top _ (OrderDual Œ≤) _ _ _ _ h

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/--
If `u` is a sequence which is unbounded above,
then after any point, it reaches a value strictly greater than all previous values.
-/
theorem high_scores
[linear_order Œ≤]
[no_top_order Œ≤]
{u : expr‚Ñï() ‚Üí Œ≤}
(hu : tendsto u at_top at_top) : ‚àÄ N, ¬´expr‚àÉ , ¬ª((n ¬´expr ‚â• ¬ª N), ‚àÄ k ¬´expr < ¬ª n, ¬´expr < ¬ª(u k, u n)) :=
begin
  intros [ident N],
  obtain ["‚ü®", ident k, ":", expr expr‚Ñï(), ",", ident hkn, ":", expr ¬´expr ‚â§ ¬ª(k, N), ",", ident hku, ":", expr ‚àÄ
   l ¬´expr ‚â§ ¬ª N, ¬´expr ‚â§ ¬ª(u l, u k), "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((k ¬´expr ‚â§ ¬ª N), ‚àÄ
    l ¬´expr ‚â§ ¬ª N, ¬´expr ‚â§ ¬ª(u l, u k))],
  from [expr exists_max_image _ u (finite_le_nat N) ‚ü®N, le_refl N‚ü©],
  have [ident ex] [":", expr ¬´expr‚àÉ , ¬ª((n ¬´expr ‚â• ¬ª N), ¬´expr < ¬ª(u k, u n))] [],
  from [expr exists_lt_of_tendsto_at_top hu _ _],
  obtain ["‚ü®", ident n, ":", expr expr‚Ñï(), ",", ident hnN, ":", expr ¬´expr ‚â• ¬ª(n, N), ",", ident hnk, ":", expr ¬´expr < ¬ª(u k, u n), ",", ident hn_min, ":", expr ‚àÄ
   m, ¬´expr < ¬ª(m, n) ‚Üí ¬´expr ‚â§ ¬ª(N, m) ‚Üí ¬´expr ‚â§ ¬ª(u m, u k), "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((n ¬´expr ‚â• ¬ª N), ¬´expr ‚àß ¬ª(¬´expr < ¬ª(u k, u n), ‚àÄ
     m, ¬´expr < ¬ª(m, n) ‚Üí ¬´expr ‚â§ ¬ª(N, m) ‚Üí ¬´expr ‚â§ ¬ª(u m, u k)))],
  { rcases [expr nat.find_x ex, "with", "‚ü®", ident n, ",", "‚ü®", ident hnN, ",", ident hnk, "‚ü©", ",", ident hn_min, "‚ü©"],
    push_neg ["at", ident hn_min],
    exact [expr ‚ü®n, hnN, hnk, hn_min‚ü©] },
  use ["[", expr n, ",", expr hnN, "]"],
  rintros ["(", ident l, ":", expr expr‚Ñï(), ")", "(", ident hl, ":", expr ¬´expr < ¬ª(l, n), ")"],
  have [ident hlk] [":", expr ¬´expr ‚â§ ¬ª(u l, u k)] [],
  { cases [expr (le_total l N : ¬´expr ‚à® ¬ª(¬´expr ‚â§ ¬ª(l, N), ¬´expr ‚â§ ¬ª(N, l)))] ["with", ident H, ident H],
    { exact [expr hku l H] },
    { exact [expr hn_min l hl H] } },
  calc
    ¬´expr ‚â§ ¬ª(u l, u k) : hlk
    ¬´expr < ¬ª(..., u n) : hnk
end

/--
If `u` is a sequence which is unbounded below,
then after any point, it reaches a value strictly smaller than all previous values.
-/
@[nolint ge_or_gt]
theorem low_scores [LinearOrder‚Çì Œ≤] [NoBotOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : tendsto u at_top at_bot) :
  ‚àÄ N, ‚àÉ (n : _)(_ : n ‚â• N), ‚àÄ k (_ : k < n), u n < u k :=
  @high_scores (OrderDual Œ≤) _ _ _ hu

/--
If `u` is a sequence which is unbounded above,
then it `frequently` reaches a value strictly greater than all previous values.
-/
theorem frequently_high_scores [LinearOrder‚Çì Œ≤] [NoTopOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : tendsto u at_top at_top) :
  ‚àÉ·∂†n in at_top, ‚àÄ k (_ : k < n), u k < u n :=
  by 
    simpa [frequently_at_top] using high_scores hu

/--
If `u` is a sequence which is unbounded below,
then it `frequently` reaches a value strictly smaller than all previous values.
-/
theorem frequently_low_scores [LinearOrder‚Çì Œ≤] [NoBotOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : tendsto u at_top at_bot) :
  ‚àÉ·∂†n in at_top, ‚àÄ k (_ : k < n), u n < u k :=
  @frequently_high_scores (OrderDual Œ≤) _ _ _ hu

theorem strict_mono_subseq_of_tendsto_at_top {Œ≤ : Type _} [LinearOrder‚Çì Œ≤] [NoTopOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤}
  (hu : tendsto u at_top at_top) : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß StrictMono (u ‚àò œÜ) :=
  let ‚ü®œÜ, h, h'‚ü© := extraction_of_frequently_at_top (frequently_high_scores hu)
  ‚ü®œÜ, h, fun n m hnm => h' m _ (h hnm)‚ü©

theorem strict_mono_subseq_of_id_le {u : ‚Ñï ‚Üí ‚Ñï} (hu : ‚àÄ n, n ‚â§ u n) : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß StrictMono (u ‚àò œÜ) :=
  strict_mono_subseq_of_tendsto_at_top (tendsto_at_top_mono hu tendsto_id)

theorem _root_.strict_mono.tendsto_at_top {œÜ : ‚Ñï ‚Üí ‚Ñï} (h : StrictMono œÜ) : tendsto œÜ at_top at_top :=
  tendsto_at_top_mono h.id_le tendsto_id

section OrderedAddCommMonoid

variable[OrderedAddCommMonoid Œ≤]{l : Filter Œ±}{f g : Œ± ‚Üí Œ≤}

theorem tendsto_at_top_add_nonneg_left' (hf : ‚àÄ·∂†x in l, 0 ‚â§ f x) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_mono' l (hf.mono fun x => le_add_of_nonneg_left) hg

theorem tendsto_at_bot_add_nonpos_left' (hf : ‚àÄ·∂†x in l, f x ‚â§ 0) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_nonneg_left' _ (OrderDual Œ≤) _ _ _ _ hf hg

theorem tendsto_at_top_add_nonneg_left (hf : ‚àÄ x, 0 ‚â§ f x) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_add_nonneg_left' (eventually_of_forall hf) hg

theorem tendsto_at_bot_add_nonpos_left (hf : ‚àÄ x, f x ‚â§ 0) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_nonneg_left _ (OrderDual Œ≤) _ _ _ _ hf hg

theorem tendsto_at_top_add_nonneg_right' (hf : tendsto f l at_top) (hg : ‚àÄ·∂†x in l, 0 ‚â§ g x) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_mono' l (monotone_mem (fun x => le_add_of_nonneg_right) hg) hf

theorem tendsto_at_bot_add_nonpos_right' (hf : tendsto f l at_bot) (hg : ‚àÄ·∂†x in l, g x ‚â§ 0) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_nonneg_right' _ (OrderDual Œ≤) _ _ _ _ hf hg

theorem tendsto_at_top_add_nonneg_right (hf : tendsto f l at_top) (hg : ‚àÄ x, 0 ‚â§ g x) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_add_nonneg_right' hf (eventually_of_forall hg)

theorem tendsto_at_bot_add_nonpos_right (hf : tendsto f l at_bot) (hg : ‚àÄ x, g x ‚â§ 0) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_nonneg_right _ (OrderDual Œ≤) _ _ _ _ hf hg

theorem tendsto_at_top_add (hf : tendsto f l at_top) (hg : tendsto g l at_top) : tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_add_nonneg_left' (tendsto_at_top.mp hf 0) hg

theorem tendsto_at_bot_add (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) : tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add _ (OrderDual Œ≤) _ _ _ _ hf hg

theorem tendsto.nsmul_at_top (hf : tendsto f l at_top) {n : ‚Ñï} (hn : 0 < n) : tendsto (fun x => n ‚Ä¢ f x) l at_top :=
  tendsto_at_top.2$
    fun y =>
      (tendsto_at_top.1 hf y).mp$
        (tendsto_at_top.1 hf 0).mono$
          fun x h‚ÇÄ hy =>
            calc y ‚â§ f x := hy 
              _ = 1 ‚Ä¢ f x := (one_nsmul _).symm 
              _ ‚â§ n ‚Ä¢ f x := nsmul_le_nsmul h‚ÇÄ hn
              

theorem tendsto.nsmul_at_bot (hf : tendsto f l at_bot) {n : ‚Ñï} (hn : 0 < n) : tendsto (fun x => n ‚Ä¢ f x) l at_bot :=
  @tendsto.nsmul_at_top Œ± (OrderDual Œ≤) _ l f hf n hn

theorem tendsto_bit0_at_top : tendsto bit0 (at_top : Filter Œ≤) at_top :=
  tendsto_at_top_add tendsto_id tendsto_id

theorem tendsto_bit0_at_bot : tendsto bit0 (at_bot : Filter Œ≤) at_bot :=
  tendsto_at_bot_add tendsto_id tendsto_id

end OrderedAddCommMonoid

section OrderedCancelAddCommMonoid

variable[OrderedCancelAddCommMonoid Œ≤]{l : Filter Œ±}{f g : Œ± ‚Üí Œ≤}

theorem tendsto_at_top_of_add_const_left (C : Œ≤) (hf : tendsto (fun x => C+f x) l at_top) : tendsto f l at_top :=
  tendsto_at_top.2$ fun b => (tendsto_at_top.1 hf (C+b)).mono fun x => le_of_add_le_add_left

theorem tendsto_at_bot_of_add_const_left (C : Œ≤) (hf : tendsto (fun x => C+f x) l at_bot) : tendsto f l at_bot :=
  @tendsto_at_top_of_add_const_left _ (OrderDual Œ≤) _ _ _ C hf

theorem tendsto_at_top_of_add_const_right (C : Œ≤) (hf : tendsto (fun x => f x+C) l at_top) : tendsto f l at_top :=
  tendsto_at_top.2$ fun b => (tendsto_at_top.1 hf (b+C)).mono fun x => le_of_add_le_add_right

theorem tendsto_at_bot_of_add_const_right (C : Œ≤) (hf : tendsto (fun x => f x+C) l at_bot) : tendsto f l at_bot :=
  @tendsto_at_top_of_add_const_right _ (OrderDual Œ≤) _ _ _ C hf

theorem tendsto_at_top_of_add_bdd_above_left' C (hC : ‚àÄ·∂†x in l, f x ‚â§ C) (h : tendsto (fun x => f x+g x) l at_top) :
  tendsto g l at_top :=
  tendsto_at_top_of_add_const_left C (tendsto_at_top_mono' l (hC.mono fun x hx => add_le_add_right hx (g x)) h)

theorem tendsto_at_bot_of_add_bdd_below_left' C (hC : ‚àÄ·∂†x in l, C ‚â§ f x) (h : tendsto (fun x => f x+g x) l at_bot) :
  tendsto g l at_bot :=
  @tendsto_at_top_of_add_bdd_above_left' _ (OrderDual Œ≤) _ _ _ _ C hC h

theorem tendsto_at_top_of_add_bdd_above_left C (hC : ‚àÄ x, f x ‚â§ C) :
  tendsto (fun x => f x+g x) l at_top ‚Üí tendsto g l at_top :=
  tendsto_at_top_of_add_bdd_above_left' C (univ_mem' hC)

theorem tendsto_at_bot_of_add_bdd_below_left C (hC : ‚àÄ x, C ‚â§ f x) :
  tendsto (fun x => f x+g x) l at_bot ‚Üí tendsto g l at_bot :=
  @tendsto_at_top_of_add_bdd_above_left _ (OrderDual Œ≤) _ _ _ _ C hC

theorem tendsto_at_top_of_add_bdd_above_right' C (hC : ‚àÄ·∂†x in l, g x ‚â§ C) (h : tendsto (fun x => f x+g x) l at_top) :
  tendsto f l at_top :=
  tendsto_at_top_of_add_const_right C (tendsto_at_top_mono' l (hC.mono fun x hx => add_le_add_left hx (f x)) h)

theorem tendsto_at_bot_of_add_bdd_below_right' C (hC : ‚àÄ·∂†x in l, C ‚â§ g x) (h : tendsto (fun x => f x+g x) l at_bot) :
  tendsto f l at_bot :=
  @tendsto_at_top_of_add_bdd_above_right' _ (OrderDual Œ≤) _ _ _ _ C hC h

theorem tendsto_at_top_of_add_bdd_above_right C (hC : ‚àÄ x, g x ‚â§ C) :
  tendsto (fun x => f x+g x) l at_top ‚Üí tendsto f l at_top :=
  tendsto_at_top_of_add_bdd_above_right' C (univ_mem' hC)

theorem tendsto_at_bot_of_add_bdd_below_right C (hC : ‚àÄ x, C ‚â§ g x) :
  tendsto (fun x => f x+g x) l at_bot ‚Üí tendsto f l at_bot :=
  @tendsto_at_top_of_add_bdd_above_right _ (OrderDual Œ≤) _ _ _ _ C hC

end OrderedCancelAddCommMonoid

section OrderedGroup

variable[OrderedAddCommGroup Œ≤](l : Filter Œ±){f g : Œ± ‚Üí Œ≤}

theorem tendsto_at_top_add_left_of_le' (C : Œ≤) (hf : ‚àÄ·∂†x in l, C ‚â§ f x) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  @tendsto_at_top_of_add_bdd_above_left' _ _ _ l (fun x => -f x) (fun x => f x+g x) (-C)
    (by 
      simpa)
    (by 
      simpa)

theorem tendsto_at_bot_add_left_of_ge' (C : Œ≤) (hf : ‚àÄ·∂†x in l, f x ‚â§ C) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_left_of_le' _ (OrderDual Œ≤) _ _ _ _ C hf hg

theorem tendsto_at_top_add_left_of_le (C : Œ≤) (hf : ‚àÄ x, C ‚â§ f x) (hg : tendsto g l at_top) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_add_left_of_le' l C (univ_mem' hf) hg

theorem tendsto_at_bot_add_left_of_ge (C : Œ≤) (hf : ‚àÄ x, f x ‚â§ C) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_left_of_le _ (OrderDual Œ≤) _ _ _ _ C hf hg

theorem tendsto_at_top_add_right_of_le' (C : Œ≤) (hf : tendsto f l at_top) (hg : ‚àÄ·∂†x in l, C ‚â§ g x) :
  tendsto (fun x => f x+g x) l at_top :=
  @tendsto_at_top_of_add_bdd_above_right' _ _ _ l (fun x => f x+g x) (fun x => -g x) (-C)
    (by 
      simp [hg])
    (by 
      simp [hf])

theorem tendsto_at_bot_add_right_of_ge' (C : Œ≤) (hf : tendsto f l at_bot) (hg : ‚àÄ·∂†x in l, g x ‚â§ C) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_right_of_le' _ (OrderDual Œ≤) _ _ _ _ C hf hg

theorem tendsto_at_top_add_right_of_le (C : Œ≤) (hf : tendsto f l at_top) (hg : ‚àÄ x, C ‚â§ g x) :
  tendsto (fun x => f x+g x) l at_top :=
  tendsto_at_top_add_right_of_le' l C hf (univ_mem' hg)

theorem tendsto_at_bot_add_right_of_ge (C : Œ≤) (hf : tendsto f l at_bot) (hg : ‚àÄ x, g x ‚â§ C) :
  tendsto (fun x => f x+g x) l at_bot :=
  @tendsto_at_top_add_right_of_le _ (OrderDual Œ≤) _ _ _ _ C hf hg

theorem tendsto_at_top_add_const_left (C : Œ≤) (hf : tendsto f l at_top) : tendsto (fun x => C+f x) l at_top :=
  tendsto_at_top_add_left_of_le' l C (univ_mem'$ fun _ => le_refl‚Çì C) hf

theorem tendsto_at_bot_add_const_left (C : Œ≤) (hf : tendsto f l at_bot) : tendsto (fun x => C+f x) l at_bot :=
  @tendsto_at_top_add_const_left _ (OrderDual Œ≤) _ _ _ C hf

theorem tendsto_at_top_add_const_right (C : Œ≤) (hf : tendsto f l at_top) : tendsto (fun x => f x+C) l at_top :=
  tendsto_at_top_add_right_of_le' l C hf (univ_mem'$ fun _ => le_refl‚Çì C)

theorem tendsto_at_bot_add_const_right (C : Œ≤) (hf : tendsto f l at_bot) : tendsto (fun x => f x+C) l at_bot :=
  @tendsto_at_top_add_const_right _ (OrderDual Œ≤) _ _ _ C hf

theorem tendsto_neg_at_top_at_bot : tendsto (Neg.neg : Œ≤ ‚Üí Œ≤) at_top at_bot :=
  by 
    simp only [tendsto_at_bot, neg_le]
    exact fun b => eventually_ge_at_top _

theorem tendsto_neg_at_bot_at_top : tendsto (Neg.neg : Œ≤ ‚Üí Œ≤) at_bot at_top :=
  @tendsto_neg_at_top_at_bot (OrderDual Œ≤) _

end OrderedGroup

section OrderedSemiring

variable[OrderedSemiring Œ±]{l : Filter Œ≤}{f g : Œ≤ ‚Üí Œ±}

theorem tendsto_bit1_at_top : tendsto bit1 (at_top : Filter Œ±) at_top :=
  tendsto_at_top_add_nonneg_right tendsto_bit0_at_top fun _ => zero_le_one

theorem tendsto.at_top_mul_at_top (hf : tendsto f l at_top) (hg : tendsto g l at_top) :
  tendsto (fun x => f x*g x) l at_top :=
  by 
    refine' tendsto_at_top_mono' _ _ hg 
    filterUpwards [hg.eventually (eventually_ge_at_top 0), hf.eventually (eventually_ge_at_top 1)]
    exact fun x => le_mul_of_one_le_left

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem tendsto_mul_self_at_top : tendsto (Œª x : Œ±, ¬´expr * ¬ª(x, x)) at_top at_top :=
tendsto_id.at_top_mul_at_top tendsto_id

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- The monomial function `x^n` tends to `+‚àû` at `+‚àû` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_at_top`. -/
theorem tendsto_pow_at_top {n : expr‚Ñï()} (hn : ¬´expr ‚â§ ¬ª(1, n)) : tendsto (Œª x : Œ±, ¬´expr ^ ¬ª(x, n)) at_top at_top :=
begin
  refine [expr tendsto_at_top_mono' _ ¬´expr $ ¬ª((eventually_ge_at_top 1).mono, Œª x hx, _) tendsto_id],
  simpa [] [] ["only"] ["[", expr pow_one, "]"] [] ["using", expr pow_le_pow hx hn]
end

theorem eventually_ne_of_tendsto_at_top [Nontrivial Œ±] (hf : tendsto f l at_top) (c : Œ±) : ‚àÄ·∂†x in l, f x ‚â† c :=
  (tendsto_at_top.1 hf$ c+1).mono fun x hx => ne_of_gt‚Çì (lt_of_lt_of_le‚Çì (lt_add_one c) hx)

end OrderedSemiring

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem zero_pow_eventually_eq
[monoid_with_zero Œ±] : ¬´expr =·∂†[ ] ¬ª(Œª n : expr‚Ñï(), ¬´expr ^ ¬ª((0 : Œ±), n), at_top, Œª n, 0) :=
eventually_at_top.2 ‚ü®1, Œª n hn, zero_pow (zero_lt_one.trans_le hn)‚ü©

section OrderedRing

variable[OrderedRing Œ±]{l : Filter Œ≤}{f g : Œ≤ ‚Üí Œ±}

theorem eventually_ne_of_tendsto_at_bot [Nontrivial Œ±] (hf : tendsto f l at_bot) (c : Œ±) : ‚àÄ·∂†x in l, f x ‚â† c :=
  (tendsto_at_bot.1 hf$ c - 1).mono fun x hx => ne_of_lt‚Çì (lt_of_le_of_lt‚Çì hx ((sub_lt_self_iff c).2 zero_lt_one))

theorem tendsto.at_top_mul_at_bot (hf : tendsto f l at_top) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x*g x) l at_bot :=
  have  := hf.at_top_mul_at_top$ tendsto_neg_at_bot_at_top.comp hg 
  by 
    simpa only [¬∑ ‚àò ¬∑, neg_mul_eq_mul_neg, neg_neg‚Çì] using tendsto_neg_at_top_at_bot.comp this

theorem tendsto.at_bot_mul_at_top (hf : tendsto f l at_bot) (hg : tendsto g l at_top) :
  tendsto (fun x => f x*g x) l at_bot :=
  have  : tendsto (fun x => (-f x)*g x) l at_top := (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top hg 
  by 
    simpa only [¬∑ ‚àò ¬∑, neg_mul_eq_neg_mul, neg_neg‚Çì] using tendsto_neg_at_top_at_bot.comp this

theorem tendsto.at_bot_mul_at_bot (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) :
  tendsto (fun x => f x*g x) l at_top :=
  have  : tendsto (fun x => (-f x)*-g x) l at_top :=
    (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top (tendsto_neg_at_bot_at_top.comp hg)
  by 
    simpa only [neg_mul_neg] using this

end OrderedRing

section LinearOrderedAddCommGroup

variable[LinearOrderedAddCommGroup Œ±]

/-- $\lim_{x\to+\infty}|x|=+\infty$ -/
theorem tendsto_abs_at_top_at_top : tendsto (abs : Œ± ‚Üí Œ±) at_top at_top :=
  tendsto_at_top_mono le_abs_self tendsto_id

/-- $\lim_{x\to-\infty}|x|=+\infty$ -/
theorem tendsto_abs_at_bot_at_top : tendsto (abs : Œ± ‚Üí Œ±) at_bot at_top :=
  tendsto_at_top_mono neg_le_abs_self tendsto_neg_at_bot_at_top

end LinearOrderedAddCommGroup

section LinearOrderedSemiring

variable[LinearOrderedSemiring Œ±]{l : Filter Œ≤}{f : Œ≤ ‚Üí Œ±}

theorem tendsto.at_top_of_const_mul {c : Œ±} (hc : 0 < c) (hf : tendsto (fun x => c*f x) l at_top) :
  tendsto f l at_top :=
  tendsto_at_top.2$ fun b => (tendsto_at_top.1 hf (c*b)).mono$ fun x hx => le_of_mul_le_mul_left hx hc

theorem tendsto.at_top_of_mul_const {c : Œ±} (hc : 0 < c) (hf : tendsto (fun x => f x*c) l at_top) :
  tendsto f l at_top :=
  tendsto_at_top.2$ fun b => (tendsto_at_top.1 hf (b*c)).mono$ fun x hx => le_of_mul_le_mul_right hx hc

end LinearOrderedSemiring

theorem nonneg_of_eventually_pow_nonneg [LinearOrderedRing Œ±] {a : Œ±} (h : ‚àÄ·∂†n in at_top, 0 ‚â§ a ^ (n : ‚Ñï)) : 0 ‚â§ a :=
  let ‚ü®n, hn‚ü© := (tendsto_bit1_at_top.Eventually h).exists 
  pow_bit1_nonneg_iff.1 hn

section LinearOrderedField

variable[LinearOrderedField Œ±]{l : Filter Œ≤}{f : Œ≤ ‚Üí Œ±}{r : Œ±}

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`filter.tendsto.const_mul_at_top'` instead. -/
theorem tendsto.const_mul_at_top (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => r*f x) l at_top :=
  tendsto.at_top_of_const_mul (inv_pos.2 hr)$
    by 
      simpa only [inv_mul_cancel_left‚ÇÄ hr.ne']

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`filter.tendsto.at_top_mul_const'` instead. -/
theorem tendsto.at_top_mul_const (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => f x*r) l at_top :=
  by 
    simpa only [mul_comm‚Çì] using hf.const_mul_at_top hr

/-- If a function tends to infinity along a filter, then this function divided by a positive
constant also tends to infinity. -/
theorem tendsto.at_top_div_const (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun x => f x / r) l at_top :=
  by 
    simpa only [div_eq_mul_inv] using hf.at_top_mul_const (inv_pos.2 hr)

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the left) tends to negative infinity. -/
theorem tendsto.neg_const_mul_at_top (hr : r < 0) (hf : tendsto f l at_top) : tendsto (fun x => r*f x) l at_bot :=
  by 
    simpa only [¬∑ ‚àò ¬∑, neg_mul_eq_neg_mul, neg_neg‚Çì] using
      tendsto_neg_at_top_at_bot.comp (hf.const_mul_at_top (neg_pos.2 hr))

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the right) tends to negative infinity. -/
theorem tendsto.at_top_mul_neg_const (hr : r < 0) (hf : tendsto f l at_top) : tendsto (fun x => f x*r) l at_bot :=
  by 
    simpa only [mul_comm‚Çì] using hf.neg_const_mul_at_top hr

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the left) also tends to negative infinity. -/
theorem tendsto.const_mul_at_bot (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun x => r*f x) l at_bot :=
  by 
    simpa only [¬∑ ‚àò ¬∑, neg_mul_eq_mul_neg, neg_neg‚Çì] using
      tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).const_mul_at_top hr)

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the right) also tends to negative infinity. -/
theorem tendsto.at_bot_mul_const (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun x => f x*r) l at_bot :=
  by 
    simpa only [mul_comm‚Çì] using hf.const_mul_at_bot hr

/-- If a function tends to negative infinity along a filter, then this function divided by
a positive constant also tends to negative infinity. -/
theorem tendsto.at_bot_div_const (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun x => f x / r) l at_bot :=
  by 
    simpa only [div_eq_mul_inv] using hf.at_bot_mul_const (inv_pos.2 hr)

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the left) tends to positive infinity. -/
theorem tendsto.neg_const_mul_at_bot (hr : r < 0) (hf : tendsto f l at_bot) : tendsto (fun x => r*f x) l at_top :=
  by 
    simpa only [¬∑ ‚àò ¬∑, neg_mul_eq_neg_mul, neg_neg‚Çì] using
      tendsto_neg_at_bot_at_top.comp (hf.const_mul_at_bot (neg_pos.2 hr))

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the right) tends to positive infinity. -/
theorem tendsto.at_bot_mul_neg_const (hr : r < 0) (hf : tendsto f l at_bot) : tendsto (fun x => f x*r) l at_top :=
  by 
    simpa only [mul_comm‚Çì] using hf.neg_const_mul_at_bot hr

theorem tendsto_const_mul_pow_at_top {c : Œ±} {n : ‚Ñï} (hn : 1 ‚â§ n) (hc : 0 < c) :
  tendsto (fun x => c*x ^ n) at_top at_top :=
  tendsto.const_mul_at_top hc (tendsto_pow_at_top hn)

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem tendsto_const_mul_pow_at_top_iff
(c : Œ±)
(n : expr‚Ñï()) : ¬´expr ‚Üî ¬ª(tendsto (Œª
  x, ¬´expr * ¬ª(c, ¬´expr ^ ¬ª(x, n))) at_top at_top, ¬´expr ‚àß ¬ª(¬´expr ‚â§ ¬ª(1, n), ¬´expr < ¬ª(0, c))) :=
begin
  refine [expr ‚ü®Œª h, _, Œª h, tendsto_const_mul_pow_at_top h.1 h.2‚ü©],
  simp [] [] ["only"] ["[", expr tendsto_at_top, ",", expr eventually_at_top, "]"] [] ["at", ident h],
  have [] [":", expr ¬´expr < ¬ª(0, c)] [":=", expr let ‚ü®x, hx‚ü© := h 1 in
   pos_of_mul_pos_right (lt_of_lt_of_le zero_lt_one (hx (max x 1) (le_max_left x 1))) (pow_nonneg (le_trans zero_le_one (le_max_right x 1)) n)],
  refine [expr ‚ü®nat.succ_le_iff.mp (lt_of_le_of_ne (zero_le n) (ne.symm (Œª hn, _))), this‚ü©],
  obtain ["‚ü®", ident x, ",", ident hx, "‚ü©", ":=", expr h ¬´expr + ¬ª(c, 1)],
  specialize [expr hx x le_rfl],
  rw ["[", expr hn, ",", expr pow_zero, ",", expr mul_one, ",", expr add_le_iff_nonpos_right, "]"] ["at", ident hx],
  exact [expr absurd hx (not_le.mpr zero_lt_one)]
end

theorem tendsto_neg_const_mul_pow_at_top {c : Œ±} {n : ‚Ñï} (hn : 1 ‚â§ n) (hc : c < 0) :
  tendsto (fun x => c*x ^ n) at_top at_bot :=
  tendsto.neg_const_mul_at_top hc (tendsto_pow_at_top hn)

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem tendsto_neg_const_mul_pow_at_top_iff
(c : Œ±)
(n : expr‚Ñï()) : ¬´expr ‚Üî ¬ª(tendsto (Œª
  x, ¬´expr * ¬ª(c, ¬´expr ^ ¬ª(x, n))) at_top at_bot, ¬´expr ‚àß ¬ª(¬´expr ‚â§ ¬ª(1, n), ¬´expr < ¬ª(c, 0))) :=
begin
  refine [expr ‚ü®Œª h, _, Œª h, tendsto_neg_const_mul_pow_at_top h.1 h.2‚ü©],
  simp [] [] ["only"] ["[", expr tendsto_at_bot, ",", expr eventually_at_top, "]"] [] ["at", ident h],
  have [] [":", expr ¬´expr < ¬ª(c, 0)] [":=", expr let ‚ü®x, hx‚ü© := h ¬´expr- ¬ª(1) in
   neg_of_mul_neg_right (lt_of_le_of_lt (hx (max x 1) (le_max_left x 1)) (by simp [] [] [] ["[", expr zero_lt_one, "]"] [] [])) (pow_nonneg (le_trans zero_le_one (le_max_right x 1)) n)],
  refine [expr ‚ü®nat.succ_le_iff.mp (lt_of_le_of_ne (zero_le n) (ne.symm (Œª hn, _))), this‚ü©],
  obtain ["‚ü®", ident x, ",", ident hx, "‚ü©", ":=", expr h ¬´expr - ¬ª(c, 1)],
  specialize [expr hx x le_rfl],
  rw ["[", expr hn, ",", expr pow_zero, ",", expr mul_one, ",", expr le_sub, ",", expr sub_self, "]"] ["at", ident hx],
  exact [expr absurd hx (not_le.mpr zero_lt_one)]
end

end LinearOrderedField

open_locale Filter

theorem tendsto_at_top' [Nonempty Œ±] [SemilatticeSup Œ±] {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
  tendsto f at_top l ‚Üî ‚àÄ s (_ : s ‚àà l), ‚àÉ a, ‚àÄ b (_ : b ‚â• a), f b ‚àà s :=
  by 
    simp only [tendsto_def, mem_at_top_sets] <;> rfl

theorem tendsto_at_bot' [Nonempty Œ±] [SemilatticeInf Œ±] {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
  tendsto f at_bot l ‚Üî ‚àÄ s (_ : s ‚àà l), ‚àÉ a, ‚àÄ b (_ : b ‚â§ a), f b ‚àà s :=
  @tendsto_at_top' (OrderDual Œ±) _ _ _ _ _

theorem tendsto_at_top_principal [Nonempty Œ≤] [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ±} :
  tendsto f at_top (ùìü s) ‚Üî ‚àÉ N, ‚àÄ n (_ : n ‚â• N), f n ‚àà s :=
  by 
    rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets] <;> rfl

theorem tendsto_at_bot_principal [Nonempty Œ≤] [SemilatticeInf Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ±} :
  tendsto f at_bot (ùìü s) ‚Üî ‚àÉ N, ‚àÄ n (_ : n ‚â§ N), f n ‚àà s :=
  @tendsto_at_top_principal _ (OrderDual Œ≤) _ _ _ _

/-- A function `f` grows to `+‚àû` independent of an order-preserving embedding `e`. -/
theorem tendsto_at_top_at_top [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} :
  tendsto f at_top at_top ‚Üî ‚àÄ (b : Œ≤), ‚àÉ i : Œ±, ‚àÄ (a : Œ±), i ‚â§ a ‚Üí b ‚â§ f a :=
  Iff.trans tendsto_infi$ forall_congr‚Çì$ fun b => tendsto_at_top_principal

theorem tendsto_at_top_at_bot [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} :
  tendsto f at_top at_bot ‚Üî ‚àÄ (b : Œ≤), ‚àÉ i : Œ±, ‚àÄ (a : Œ±), i ‚â§ a ‚Üí f a ‚â§ b :=
  @tendsto_at_top_at_top Œ± (OrderDual Œ≤) _ _ _ f

theorem tendsto_at_bot_at_top [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} :
  tendsto f at_bot at_top ‚Üî ‚àÄ (b : Œ≤), ‚àÉ i : Œ±, ‚àÄ (a : Œ±), a ‚â§ i ‚Üí b ‚â§ f a :=
  @tendsto_at_top_at_top (OrderDual Œ±) Œ≤ _ _ _ f

theorem tendsto_at_bot_at_bot [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} :
  tendsto f at_bot at_bot ‚Üî ‚àÄ (b : Œ≤), ‚àÉ i : Œ±, ‚àÄ (a : Œ±), a ‚â§ i ‚Üí f a ‚â§ b :=
  @tendsto_at_top_at_top (OrderDual Œ±) (OrderDual Œ≤) _ _ _ f

theorem tendsto_at_top_at_top_of_monotone [Preorder‚Çì Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Monotone f)
  (h : ‚àÄ b, ‚àÉ a, b ‚â§ f a) : tendsto f at_top at_top :=
  tendsto_infi.2$
    fun b =>
      tendsto_principal.2$
        let ‚ü®a, ha‚ü© := h b 
        mem_of_superset (mem_at_top a)$ fun a' ha' => le_trans‚Çì ha (hf ha')

theorem tendsto_at_bot_at_bot_of_monotone [Preorder‚Çì Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Monotone f)
  (h : ‚àÄ b, ‚àÉ a, f a ‚â§ b) : tendsto f at_bot at_bot :=
  tendsto_infi.2$
    fun b =>
      tendsto_principal.2$
        let ‚ü®a, ha‚ü© := h b 
        mem_of_superset (mem_at_bot a)$ fun a' ha' => le_trans‚Çì (hf ha') ha

theorem tendsto_at_top_at_top_iff_of_monotone [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤}
  (hf : Monotone f) : tendsto f at_top at_top ‚Üî ‚àÄ (b : Œ≤), ‚àÉ a : Œ±, b ‚â§ f a :=
  tendsto_at_top_at_top.trans$
    forall_congr‚Çì$ fun b => exists_congr$ fun a => ‚ü®fun h => h a (le_refl‚Çì a), fun h a' ha' => le_trans‚Çì h$ hf ha'‚ü©

theorem tendsto_at_bot_at_bot_iff_of_monotone [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤}
  (hf : Monotone f) : tendsto f at_bot at_bot ‚Üî ‚àÄ (b : Œ≤), ‚àÉ a : Œ±, f a ‚â§ b :=
  tendsto_at_bot_at_bot.trans$
    forall_congr‚Çì$ fun b => exists_congr$ fun a => ‚ü®fun h => h a (le_refl‚Çì a), fun h a' ha' => le_trans‚Çì (hf ha') h‚ü©

alias tendsto_at_top_at_top_of_monotone ‚Üê Monotone.tendsto_at_top_at_top

alias tendsto_at_bot_at_bot_of_monotone ‚Üê Monotone.tendsto_at_bot_at_bot

alias tendsto_at_top_at_top_iff_of_monotone ‚Üê Monotone.tendsto_at_top_at_top_iff

alias tendsto_at_bot_at_bot_iff_of_monotone ‚Üê Monotone.tendsto_at_bot_at_bot_iff

theorem tendsto_at_top_embedding [Preorder‚Çì Œ≤] [Preorder‚Çì Œ≥] {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : Filter Œ±}
  (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, c ‚â§ e b) : tendsto (e ‚àò f) l at_top ‚Üî tendsto f l at_top :=
  by 
    refine' ‚ü®_, (tendsto_at_top_at_top_of_monotone (fun b‚ÇÅ b‚ÇÇ => (hm b‚ÇÅ b‚ÇÇ).2) hu).comp‚ü©
    rw [tendsto_at_top, tendsto_at_top]
    exact fun hc b => (hc (e b)).mono fun a => (hm b (f a)).1

/-- A function `f` goes to `-‚àû` independent of an order-preserving embedding `e`. -/
theorem tendsto_at_bot_embedding [Preorder‚Çì Œ≤] [Preorder‚Çì Œ≥] {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : Filter Œ±}
  (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, e b ‚â§ c) : tendsto (e ‚àò f) l at_bot ‚Üî tendsto f l at_bot :=
  @tendsto_at_top_embedding Œ± (OrderDual Œ≤) (OrderDual Œ≥) _ _ f e l (Function.swap hm) hu

theorem tendsto_finset_range : tendsto Finset.range at_top at_top :=
  Finset.range_mono.tendsto_at_top_at_top Finset.exists_nat_subset_range

theorem at_top_finset_eq_infi : (at_top : Filter$ Finset Œ±) = ‚®Öx : Œ±, ùìü (Ici {x}) :=
  by 
    refine' le_antisymm‚Çì (le_infi fun i => le_principal_iff.2$ mem_at_top {i}) _ 
    refine' le_infi fun s => le_principal_iff.2$ mem_infi_of_Inter s.finite_to_set (fun i => mem_principal_self _) _ 
    simp only [subset_def, mem_Inter, SetCoe.forall, mem_Ici, Finset.le_iff_subset, Finset.mem_singleton,
      Finset.subset_iff, forall_eq]
    dsimp 
    exact fun t => id

/-- If `f` is a monotone sequence of `finset`s and each `x` belongs to one of `f n`, then
`tendsto f at_top at_top`. -/
theorem tendsto_at_top_finset_of_monotone [Preorder‚Çì Œ≤] {f : Œ≤ ‚Üí Finset Œ±} (h : Monotone f)
  (h' : ‚àÄ (x : Œ±), ‚àÉ n, x ‚àà f n) : tendsto f at_top at_top :=
  by 
    simp only [at_top_finset_eq_infi, tendsto_infi, tendsto_principal]
    intro a 
    rcases h' a with ‚ü®b, hb‚ü©
    exact eventually.mono (mem_at_top b) fun b' hb' => le_trans‚Çì (Finset.singleton_subset_iff.2 hb) (h hb')

alias tendsto_at_top_finset_of_monotone ‚Üê Monotone.tendsto_at_top_finset

theorem tendsto_finset_image_at_top_at_top {i : Œ≤ ‚Üí Œ≥} {j : Œ≥ ‚Üí Œ≤} (h : Function.LeftInverse j i) :
  tendsto (Finset.image j) at_top at_top :=
  (Finset.image_mono j).tendsto_at_top_finset$
    fun a =>
      ‚ü®{i a},
        by 
          simp only [Finset.image_singleton, h a, Finset.mem_singleton]‚ü©

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem tendsto_finset_preimage_at_top_at_top
{f : Œ± ‚Üí Œ≤}
(hf : function.injective f) : tendsto (Œª s : finset Œ≤, s.preimage f (hf.inj_on _)) at_top at_top :=
¬´expr $ ¬ª((finset.monotone_preimage hf).tendsto_at_top_finset, Œª
 x, ‚ü®{f x}, ¬´expr $ ¬ª(finset.mem_preimage.2, finset.mem_singleton_self _)‚ü©)

theorem prod_at_top_at_top_eq {Œ≤‚ÇÅ Œ≤‚ÇÇ : Type _} [SemilatticeSup Œ≤‚ÇÅ] [SemilatticeSup Œ≤‚ÇÇ] :
  (at_top : Filter Œ≤‚ÇÅ) √ó·∂† (at_top : Filter Œ≤‚ÇÇ) = (at_top : Filter (Œ≤‚ÇÅ √ó Œ≤‚ÇÇ)) :=
  by 
    cases' (is_empty_or_nonempty Œ≤‚ÇÅ).symm 
    cases' (is_empty_or_nonempty Œ≤‚ÇÇ).symm
    ¬∑
      simp [at_top, prod_infi_left, prod_infi_right, infi_prod]
      exact infi_comm
    ¬∑
      simp only [at_top.filter_eq_bot_of_is_empty, prod_bot]
    ¬∑
      simp only [at_top.filter_eq_bot_of_is_empty, bot_prod]

theorem prod_at_bot_at_bot_eq {Œ≤‚ÇÅ Œ≤‚ÇÇ : Type _} [SemilatticeInf Œ≤‚ÇÅ] [SemilatticeInf Œ≤‚ÇÇ] :
  (at_bot : Filter Œ≤‚ÇÅ) √ó·∂† (at_bot : Filter Œ≤‚ÇÇ) = (at_bot : Filter (Œ≤‚ÇÅ √ó Œ≤‚ÇÇ)) :=
  @prod_at_top_at_top_eq (OrderDual Œ≤‚ÇÅ) (OrderDual Œ≤‚ÇÇ) _ _

theorem prod_map_at_top_eq {Œ±‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ : Type _} [SemilatticeSup Œ≤‚ÇÅ] [SemilatticeSup Œ≤‚ÇÇ] (u‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ)
  (u‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ) : map u‚ÇÅ at_top √ó·∂† map u‚ÇÇ at_top = map (Prod.map‚Çì u‚ÇÅ u‚ÇÇ) at_top :=
  by 
    rw [prod_map_map_eq, prod_at_top_at_top_eq, Prod.map_def‚Çì]

theorem prod_map_at_bot_eq {Œ±‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ : Type _} [SemilatticeInf Œ≤‚ÇÅ] [SemilatticeInf Œ≤‚ÇÇ] (u‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ)
  (u‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ) : map u‚ÇÅ at_bot √ó·∂† map u‚ÇÇ at_bot = map (Prod.map‚Çì u‚ÇÅ u‚ÇÇ) at_bot :=
  @prod_map_at_top_eq _ _ (OrderDual Œ≤‚ÇÅ) (OrderDual Œ≤‚ÇÇ) _ _ _ _

theorem tendsto.subseq_mem {F : Filter Œ±} {V : ‚Ñï ‚Üí Set Œ±} (h : ‚àÄ n, V n ‚àà F) {u : ‚Ñï ‚Üí Œ±} (hu : tendsto u at_top F) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, u (œÜ n) ‚àà V n :=
  extraction_forall_of_eventually' (fun n => tendsto_at_top'.mp hu _ (h n) : ‚àÄ n, ‚àÉ N, ‚àÄ k (_ : k ‚â• N), u k ‚àà V n)

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem tendsto_at_bot_diagonal [semilattice_inf Œ±] : tendsto (Œª a : Œ±, (a, a)) at_bot at_bot :=
by { rw ["<-", expr prod_at_bot_at_bot_eq] [],
  exact [expr tendsto_id.prod_mk tendsto_id] }

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
theorem tendsto_at_top_diagonal [semilattice_sup Œ±] : tendsto (Œª a : Œ±, (a, a)) at_top at_top :=
by { rw ["<-", expr prod_at_top_at_top_eq] [],
  exact [expr tendsto_id.prod_mk tendsto_id] }

theorem tendsto.prod_map_prod_at_bot [SemilatticeInf Œ≥] {F : Filter Œ±} {G : Filter Œ≤} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥}
  (hf : tendsto f F at_bot) (hg : tendsto g G at_bot) : tendsto (Prod.map‚Çì f g) (F √ó·∂† G) at_bot :=
  by 
    rw [‚Üêprod_at_bot_at_bot_eq]
    exact hf.prod_map hg

theorem tendsto.prod_map_prod_at_top [SemilatticeSup Œ≥] {F : Filter Œ±} {G : Filter Œ≤} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥}
  (hf : tendsto f F at_top) (hg : tendsto g G at_top) : tendsto (Prod.map‚Çì f g) (F √ó·∂† G) at_top :=
  by 
    rw [‚Üêprod_at_top_at_top_eq]
    exact hf.prod_map hg

theorem tendsto.prod_at_bot [SemilatticeInf Œ±] [SemilatticeInf Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : tendsto f at_bot at_bot)
  (hg : tendsto g at_bot at_bot) : tendsto (Prod.map‚Çì f g) at_bot at_bot :=
  by 
    rw [‚Üêprod_at_bot_at_bot_eq]
    exact hf.prod_map_prod_at_bot hg

theorem tendsto.prod_at_top [SemilatticeSup Œ±] [SemilatticeSup Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : tendsto f at_top at_top)
  (hg : tendsto g at_top at_top) : tendsto (Prod.map‚Çì f g) at_top at_top :=
  by 
    rw [‚Üêprod_at_top_at_top_eq]
    exact hf.prod_map_prod_at_top hg

theorem eventually_at_bot_prod_self [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
  (‚àÄ·∂†x in at_bot, p x) ‚Üî ‚àÉ a, ‚àÄ k l, k ‚â§ a ‚Üí l ‚â§ a ‚Üí p (k, l) :=
  by 
    simp [‚Üêprod_at_bot_at_bot_eq, at_bot_basis.prod_self.eventually_iff]

theorem eventually_at_top_prod_self [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
  (‚àÄ·∂†x in at_top, p x) ‚Üî ‚àÉ a, ‚àÄ k l, a ‚â§ k ‚Üí a ‚â§ l ‚Üí p (k, l) :=
  by 
    simp [‚Üêprod_at_top_at_top_eq, at_top_basis.prod_self.eventually_iff]

theorem eventually_at_bot_prod_self' [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
  (‚àÄ·∂†x in at_bot, p x) ‚Üî ‚àÉ a, ‚àÄ k (_ : k ‚â§ a), ‚àÄ l (_ : l ‚â§ a), p (k, l) :=
  by 
    rw [Filter.eventually_at_bot_prod_self]
    apply exists_congr 
    tauto

theorem eventually_at_top_prod_self' [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
  (‚àÄ·∂†x in at_top, p x) ‚Üî ‚àÉ a, ‚àÄ k (_ : k ‚â• a), ‚àÄ l (_ : l ‚â• a), p (k, l) :=
  by 
    rw [Filter.eventually_at_top_prod_self]
    apply exists_congr 
    tauto

/-- A function `f` maps upwards closed sets (at_top sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connetion above `b'`. -/
theorem map_at_top_eq_of_gc [SemilatticeSup Œ±] [SemilatticeSup Œ≤] {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b' : Œ≤) (hf : Monotone f)
  (gc : ‚àÄ a, ‚àÄ b (_ : b ‚â• b'), f a ‚â§ b ‚Üî a ‚â§ g b) (hgi : ‚àÄ b (_ : b ‚â• b'), b ‚â§ f (g b)) : map f at_top = at_top :=
  by 
    refine' le_antisymm‚Çì (hf.tendsto_at_top_at_top$ fun b => ‚ü®g (b‚äîb'), le_sup_left.trans$ hgi _ le_sup_right‚ü©) _ 
    rw [@map_at_top_eq _ _ ‚ü®g b'‚ü©]
    refine' le_infi fun a => infi_le_of_le (f a‚äîb')$ principal_mono.2$ fun b hb => _ 
    rw [mem_Ici, sup_le_iff] at hb 
    exact ‚ü®g b, (gc _ _ hb.2).1 hb.1, le_antisymm‚Çì ((gc _ _ hb.2).2 (le_refl‚Çì _)) (hgi _ hb.2)‚ü©

theorem map_at_bot_eq_of_gc [SemilatticeInf Œ±] [SemilatticeInf Œ≤] {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b' : Œ≤) (hf : Monotone f)
  (gc : ‚àÄ a, ‚àÄ b (_ : b ‚â§ b'), b ‚â§ f a ‚Üî g b ‚â§ a) (hgi : ‚àÄ b (_ : b ‚â§ b'), f (g b) ‚â§ b) : map f at_bot = at_bot :=
  @map_at_top_eq_of_gc (OrderDual Œ±) (OrderDual Œ≤) _ _ _ _ _ hf.dual gc hgi

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem map_coe_at_top_of_Ici_subset
[semilattice_sup Œ±]
{a : Œ±}
{s : set Œ±}
(h : ¬´expr ‚äÜ ¬ª(Ici a, s)) : ¬´expr = ¬ª(map (coe : s ‚Üí Œ±) at_top, at_top) :=
begin
  have [] [":", expr directed ((¬´expr ‚â• ¬ª)) (Œª x : s, exprùìü() (Ici x))] [],
  { intros [ident x, ident y],
    use [expr ‚ü®¬´expr ‚äî ¬ª(¬´expr ‚äî ¬ª(x, y), a), h le_sup_right‚ü©],
    simp [] [] ["only"] ["[", expr ge_iff_le, ",", expr principal_mono, ",", expr Ici_subset_Ici, ",", "<-", expr subtype.coe_le_coe, ",", expr subtype.coe_mk, "]"] [] [],
    exact [expr ‚ü®le_sup_left.trans le_sup_left, le_sup_right.trans le_sup_left‚ü©] },
  haveI [] [":", expr nonempty s] [":=", expr ‚ü®‚ü®a, h le_rfl‚ü©‚ü©],
  simp [] [] ["only"] ["[", expr le_antisymm_iff, ",", expr at_top, ",", expr le_infi_iff, ",", expr le_principal_iff, ",", expr mem_map, ",", expr mem_set_of_eq, ",", expr map_infi_eq this, ",", expr map_principal, "]"] [] [],
  split,
  { intro [ident x],
    refine [expr mem_of_superset (mem_infi_of_mem ‚ü®¬´expr ‚äî ¬ª(x, a), h le_sup_right‚ü© (mem_principal_self _)) _],
    rintro ["_", "‚ü®", ident y, ",", ident hy, ",", ident rfl, "‚ü©"],
    exact [expr le_trans le_sup_left (subtype.coe_le_coe.2 hy)] },
  { intro [ident x],
    filter_upwards ["[", expr mem_at_top ¬´expr ‚äî ¬ª(¬´expr‚Üë ¬ª(x), a), "]"] [],
    intros [ident b, ident hb],
    exact [expr ‚ü®‚ü®b, ¬´expr $ ¬ª(h, le_sup_right.trans hb)‚ü©, subtype.coe_le_coe.1 (le_sup_left.trans hb), rfl‚ü©] }
end

/-- The image of the filter `at_top` on `Ici a` under the coercion equals `at_top`. -/
@[simp]
theorem map_coe_Ici_at_top [SemilatticeSup Œ±] (a : Œ±) : map (coe‚Çì : Ici a ‚Üí Œ±) at_top = at_top :=
  map_coe_at_top_of_Ici_subset (subset.refl _)

/-- The image of the filter `at_top` on `Ioi a` under the coercion equals `at_top`. -/
@[simp]
theorem map_coe_Ioi_at_top [SemilatticeSup Œ±] [NoTopOrder Œ±] (a : Œ±) : map (coe‚Çì : Ioi a ‚Üí Œ±) at_top = at_top :=
  by 
    rcases no_top a with ‚ü®b, hb‚ü©
    exact map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb)

/-- The `at_top` filter for an open interval `Ioi a` comes from the `at_top` filter in the ambient
order. -/
theorem at_top_Ioi_eq [SemilatticeSup Œ±] (a : Œ±) : at_top = comap (coe‚Çì : Ioi a ‚Üí Œ±) at_top :=
  by 
    nontriviality 
    rcases nontrivial_iff_nonempty.1 ‚Äπ_‚Ä∫ with ‚ü®b, hb‚ü©
    rw [‚Üêmap_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map Subtype.coe_injective]

/-- The `at_top` filter for an open interval `Ici a` comes from the `at_top` filter in the ambient
order. -/
theorem at_top_Ici_eq [SemilatticeSup Œ±] (a : Œ±) : at_top = comap (coe‚Çì : Ici a ‚Üí Œ±) at_top :=
  by 
    rw [‚Üêmap_coe_Ici_at_top a, comap_map Subtype.coe_injective]

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
@[simp]
theorem map_coe_Iio_at_bot [SemilatticeInf Œ±] [NoBotOrder Œ±] (a : Œ±) : map (coe‚Çì : Iio a ‚Üí Œ±) at_bot = at_bot :=
  @map_coe_Ioi_at_top (OrderDual Œ±) _ _ _

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
theorem at_bot_Iio_eq [SemilatticeInf Œ±] (a : Œ±) : at_bot = comap (coe‚Çì : Iio a ‚Üí Œ±) at_bot :=
  @at_top_Ioi_eq (OrderDual Œ±) _ _

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
@[simp]
theorem map_coe_Iic_at_bot [SemilatticeInf Œ±] (a : Œ±) : map (coe‚Çì : Iic a ‚Üí Œ±) at_bot = at_bot :=
  @map_coe_Ici_at_top (OrderDual Œ±) _ _

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
theorem at_bot_Iic_eq [SemilatticeInf Œ±] (a : Œ±) : at_bot = comap (coe‚Çì : Iic a ‚Üí Œ±) at_bot :=
  @at_top_Ici_eq (OrderDual Œ±) _ _

theorem tendsto_Ioi_at_top [SemilatticeSup Œ±] {a : Œ±} {f : Œ≤ ‚Üí Ioi a} {l : Filter Œ≤} :
  tendsto f l at_top ‚Üî tendsto (fun x => (f x : Œ±)) l at_top :=
  by 
    rw [at_top_Ioi_eq, tendsto_comap_iff]

theorem tendsto_Iio_at_bot [SemilatticeInf Œ±] {a : Œ±} {f : Œ≤ ‚Üí Iio a} {l : Filter Œ≤} :
  tendsto f l at_bot ‚Üî tendsto (fun x => (f x : Œ±)) l at_bot :=
  by 
    rw [at_bot_Iio_eq, tendsto_comap_iff]

theorem tendsto_Ici_at_top [SemilatticeSup Œ±] {a : Œ±} {f : Œ≤ ‚Üí Ici a} {l : Filter Œ≤} :
  tendsto f l at_top ‚Üî tendsto (fun x => (f x : Œ±)) l at_top :=
  by 
    rw [at_top_Ici_eq, tendsto_comap_iff]

theorem tendsto_Iic_at_bot [SemilatticeInf Œ±] {a : Œ±} {f : Œ≤ ‚Üí Iic a} {l : Filter Œ≤} :
  tendsto f l at_bot ‚Üî tendsto (fun x => (f x : Œ±)) l at_bot :=
  by 
    rw [at_bot_Iic_eq, tendsto_comap_iff]

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp]
theorem tendsto_comp_coe_Ioi_at_top
[semilattice_sup Œ±]
[no_top_order Œ±]
{a : Œ±}
{f : Œ± ‚Üí Œ≤}
{l : filter Œ≤} : ¬´expr ‚Üî ¬ª(tendsto (Œª x : Ioi a, f x) at_top l, tendsto f at_top l) :=
by rw ["[", "<-", expr map_coe_Ioi_at_top a, ",", expr tendsto_map'_iff, "]"] []

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp]
theorem tendsto_comp_coe_Ici_at_top
[semilattice_sup Œ±]
{a : Œ±}
{f : Œ± ‚Üí Œ≤}
{l : filter Œ≤} : ¬´expr ‚Üî ¬ª(tendsto (Œª x : Ici a, f x) at_top l, tendsto f at_top l) :=
by rw ["[", "<-", expr map_coe_Ici_at_top a, ",", expr tendsto_map'_iff, "]"] []

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp]
theorem tendsto_comp_coe_Iio_at_bot
[semilattice_inf Œ±]
[no_bot_order Œ±]
{a : Œ±}
{f : Œ± ‚Üí Œ≤}
{l : filter Œ≤} : ¬´expr ‚Üî ¬ª(tendsto (Œª x : Iio a, f x) at_bot l, tendsto f at_bot l) :=
by rw ["[", "<-", expr map_coe_Iio_at_bot a, ",", expr tendsto_map'_iff, "]"] []

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp]
theorem tendsto_comp_coe_Iic_at_bot
[semilattice_inf Œ±]
{a : Œ±}
{f : Œ± ‚Üí Œ≤}
{l : filter Œ≤} : ¬´expr ‚Üî ¬ª(tendsto (Œª x : Iic a, f x) at_bot l, tendsto f at_bot l) :=
by rw ["[", "<-", expr map_coe_Iic_at_bot a, ",", expr tendsto_map'_iff, "]"] []

theorem map_add_at_top_eq_nat (k : ‚Ñï) : map (fun a => a+k) at_top = at_top :=
  map_at_top_eq_of_gc (fun a => a - k) k (fun a b h => add_le_add_right h k) (fun a b h => (le_tsub_iff_right h).symm)
    fun a h =>
      by 
        rw [tsub_add_cancel_of_le h]

theorem map_sub_at_top_eq_nat (k : ‚Ñï) : map (fun a => a - k) at_top = at_top :=
  map_at_top_eq_of_gc (fun a => a+k) 0 (fun a b h => tsub_le_tsub_right h _) (fun a b _ => tsub_le_iff_right)
    fun b _ =>
      by 
        rw [add_tsub_cancel_right]

theorem tendsto_add_at_top_nat (k : ‚Ñï) : tendsto (fun a => a+k) at_top at_top :=
  le_of_eq‚Çì (map_add_at_top_eq_nat k)

theorem tendsto_sub_at_top_nat (k : ‚Ñï) : tendsto (fun a => a - k) at_top at_top :=
  le_of_eq‚Çì (map_sub_at_top_eq_nat k)

theorem tendsto_add_at_top_iff_nat {f : ‚Ñï ‚Üí Œ±} {l : Filter Œ±} (k : ‚Ñï) :
  tendsto (fun n => f (n+k)) at_top l ‚Üî tendsto f at_top l :=
  show tendsto (f ‚àò fun n => n+k) at_top l ‚Üî tendsto f at_top l by 
    rw [‚Üêtendsto_map'_iff, map_add_at_top_eq_nat]

theorem map_div_at_top_eq_nat (k : ‚Ñï) (hk : 0 < k) : map (fun a => a / k) at_top = at_top :=
  map_at_top_eq_of_gc (fun b => (b*k)+k - 1) 1 (fun a b h => Nat.div_le_div_right h)
    (fun a b _ =>
      calc a / k ‚â§ b ‚Üî a / k < b+1 :=
        by 
          rw [‚ÜêNat.succ_eq_add_one, Nat.lt_succ_iff]
        _ ‚Üî a < (b+1)*k := Nat.div_lt_iff_lt_mul‚Çì _ _ hk 
        _ ‚Üî _ :=
        by 
          cases k 
          exact (lt_irrefl‚Çì _ hk).elim 
          rw [add_mul‚Çì, one_mul‚Çì, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.add_succ, Nat.lt_succ_iff]
        )
    fun b _ =>
      calc b = (b*k) / k :=
        by 
          rw [Nat.mul_div_cancel‚Çì b hk]
        _ ‚â§ ((b*k)+k - 1) / k := Nat.div_le_div_right$ Nat.le_add_right‚Çì _ _
        

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
above, then `tendsto u at_top at_top`. -/
theorem tendsto_at_top_at_top_of_monotone' [Preorder‚Çì Œπ] [LinearOrder‚Çì Œ±] {u : Œπ ‚Üí Œ±} (h : Monotone u)
  (H : ¬¨BddAbove (range u)) : tendsto u at_top at_top :=
  by 
    apply h.tendsto_at_top_at_top 
    intro b 
    rcases not_bdd_above_iff.1 H b with ‚ü®_, ‚ü®N, rfl‚ü©, hN‚ü©
    exact ‚ü®N, le_of_lt‚Çì hN‚ü©

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
below, then `tendsto u at_bot at_bot`. -/
theorem tendsto_at_bot_at_bot_of_monotone' [Preorder‚Çì Œπ] [LinearOrder‚Çì Œ±] {u : Œπ ‚Üí Œ±} (h : Monotone u)
  (H : ¬¨BddBelow (range u)) : tendsto u at_bot at_bot :=
  @tendsto_at_top_at_top_of_monotone' (OrderDual Œπ) (OrderDual Œ±) _ _ _ h.dual H

theorem unbounded_of_tendsto_at_top [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] [NoTopOrder Œ≤] {f : Œ± ‚Üí Œ≤}
  (h : tendsto f at_top at_top) : ¬¨BddAbove (range f) :=
  by 
    rintro ‚ü®M, hM‚ü©
    cases' mem_at_top_sets.mp (h$ Ioi_mem_at_top M) with a ha 
    apply lt_irrefl‚Çì M 
    calc M < f a := ha a (le_refl‚Çì _)_ ‚â§ M := hM (Set.mem_range_self a)

theorem unbounded_of_tendsto_at_bot [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] [NoBotOrder Œ≤] {f : Œ± ‚Üí Œ≤}
  (h : tendsto f at_top at_bot) : ¬¨BddBelow (range f) :=
  @unbounded_of_tendsto_at_top _ (OrderDual Œ≤) _ _ _ _ _ h

theorem unbounded_of_tendsto_at_top' [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder‚Çì Œ≤] [NoTopOrder Œ≤] {f : Œ± ‚Üí Œ≤}
  (h : tendsto f at_bot at_top) : ¬¨BddAbove (range f) :=
  @unbounded_of_tendsto_at_top (OrderDual Œ±) _ _ _ _ _ _ h

theorem unbounded_of_tendsto_at_bot' [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder‚Çì Œ≤] [NoBotOrder Œ≤] {f : Œ± ‚Üí Œ≤}
  (h : tendsto f at_bot at_bot) : ¬¨BddBelow (range f) :=
  @unbounded_of_tendsto_at_top (OrderDual Œ±) (OrderDual Œ≤) _ _ _ _ _ h

/-- If a monotone function `u : Œπ ‚Üí Œ±` tends to `at_top` along *some* non-trivial filter `l`, then
it tends to `at_top` along `at_top`. -/
theorem tendsto_at_top_of_monotone_of_filter [Preorder‚Çì Œπ] [Preorder‚Çì Œ±] {l : Filter Œπ} {u : Œπ ‚Üí Œ±} (h : Monotone u)
  [ne_bot l] (hu : tendsto u l at_top) : tendsto u at_top at_top :=
  h.tendsto_at_top_at_top$ fun b => (hu.eventually (mem_at_top b)).exists

/-- If a monotone function `u : Œπ ‚Üí Œ±` tends to `at_bot` along *some* non-trivial filter `l`, then
it tends to `at_bot` along `at_bot`. -/
theorem tendsto_at_bot_of_monotone_of_filter [Preorder‚Çì Œπ] [Preorder‚Çì Œ±] {l : Filter Œπ} {u : Œπ ‚Üí Œ±} (h : Monotone u)
  [ne_bot l] (hu : tendsto u l at_bot) : tendsto u at_bot at_bot :=
  @tendsto_at_top_of_monotone_of_filter (OrderDual Œπ) (OrderDual Œ±) _ _ _ _ h.dual _ hu

theorem tendsto_at_top_of_monotone_of_subseq [Preorder‚Çì Œπ] [Preorder‚Çì Œ±] {u : Œπ ‚Üí Œ±} {œÜ : Œπ' ‚Üí Œπ} (h : Monotone u)
  {l : Filter Œπ'} [ne_bot l] (H : tendsto (u ‚àò œÜ) l at_top) : tendsto u at_top at_top :=
  tendsto_at_top_of_monotone_of_filter h (tendsto_map' H)

theorem tendsto_at_bot_of_monotone_of_subseq [Preorder‚Çì Œπ] [Preorder‚Çì Œ±] {u : Œπ ‚Üí Œ±} {œÜ : Œπ' ‚Üí Œπ} (h : Monotone u)
  {l : Filter Œπ'} [ne_bot l] (H : tendsto (u ‚àò œÜ) l at_bot) : tendsto u at_bot at_bot :=
  tendsto_at_bot_of_monotone_of_filter h (tendsto_map' H)

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient
condition for comparison of the filter `at_top.map (Œª s, ‚àè b in s, f b)` with
`at_top.map (Œª s, ‚àè b in s, g b)`. This is useful to compare the set of limit points of
`Œ† b in s, f b` as `s ‚Üí at_top` with the similar set for `g`. -/
@[to_additive #[]]
theorem map_at_top_finset_prod_le_of_prod_eq
[comm_monoid Œ±]
{f : Œ≤ ‚Üí Œ±}
{g : Œ≥ ‚Üí Œ±}
(h_eq : ‚àÄ
 u : finset Œ≥, ¬´expr‚àÉ , ¬ª((v : finset Œ≤), ‚àÄ
  v', ¬´expr ‚äÜ ¬ª(v, v') ‚Üí ¬´expr‚àÉ , ¬ª((u'), ¬´expr ‚àß ¬ª(¬´expr ‚äÜ ¬ª(u, u'), ¬´expr = ¬ª(¬´expr‚àè in , ¬ª((x), u', g x), ¬´expr‚àè in , ¬ª((b), v', f b)))))) : ¬´expr ‚â§ ¬ª(at_top.map (Œª
  s : finset Œ≤, ¬´expr‚àè in , ¬ª((b), s, f b)), at_top.map (Œª s : finset Œ≥, ¬´expr‚àè in , ¬ª((x), s, g x))) :=
by rw ["[", expr map_at_top_eq, ",", expr map_at_top_eq, "]"] []; from [expr ¬´expr $ ¬ª(le_infi, assume
  b, let ‚ü®v, hv‚ü© := h_eq b in
  ¬´expr $ ¬ª(infi_le_of_le v, by simp [] [] [] ["[", expr set.image_subset_iff, "]"] [] []; exact [expr hv]))]

theorem has_antitone_basis.tendsto [SemilatticeSup Œπ] [Nonempty Œπ] {l : Filter Œ±} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±}
  (hl : l.has_antitone_basis p s) {œÜ : Œπ ‚Üí Œ±} (h : ‚àÄ (i : Œπ), œÜ i ‚àà s i) : tendsto œÜ at_top l :=
  (at_top_basis.tendsto_iff hl.to_has_basis).2$
    fun i hi => ‚ü®i, trivial‚Çì, fun j hij => hl.decreasing hi (hl.mono hij hi) hij (h j)‚ü©

/-- An abstract version of continuity of sequentially continuous functions on metric spaces:
if a filter `k` is countably generated then `tendsto f k l` iff for every sequence `u`
converging to `k`, `f ‚àò u` tends to `l`. -/
theorem tendsto_iff_seq_tendsto {f : Œ± ‚Üí Œ≤} {k : Filter Œ±} {l : Filter Œ≤} [k.is_countably_generated] :
  tendsto f k l ‚Üî ‚àÄ (x : ‚Ñï ‚Üí Œ±), tendsto x at_top k ‚Üí tendsto (f ‚àò x) at_top l :=
  suffices (‚àÄ (x : ‚Ñï ‚Üí Œ±), tendsto x at_top k ‚Üí tendsto (f ‚àò x) at_top l) ‚Üí tendsto f k l from
    ‚ü®by 
        intros  <;> apply tendsto.comp <;> assumption,
      by 
        assumption‚ü©
  by 
    obtain ‚ü®g, gbasis, gmon, -‚ü© := k.exists_antitone_basis 
    contrapose 
    simp only [not_forall, gbasis.tendsto_left_iff, exists_const, not_exists, not_imp]
    rintro ‚ü®B, hBl, hfBk‚ü©
    choose x h using hfBk 
    use x 
    split 
    ¬∑
      exact (at_top_basis.tendsto_iff gbasis).2 fun i _ => ‚ü®i, trivial‚Çì, fun j hj => gmon trivial‚Çì trivial‚Çì hj (h j).1‚ü©
    ¬∑
      simp only [tendsto_at_top', ¬∑ ‚àò ¬∑, not_forall, not_exists]
      use B, hBl 
      intro i 
      use i, le_refl‚Çì _ 
      apply (h i).right

theorem tendsto_of_seq_tendsto {f : Œ± ‚Üí Œ≤} {k : Filter Œ±} {l : Filter Œ≤} [k.is_countably_generated] :
  (‚àÄ (x : ‚Ñï ‚Üí Œ±), tendsto x at_top k ‚Üí tendsto (f ‚àò x) at_top l) ‚Üí tendsto f k l :=
  tendsto_iff_seq_tendsto.2

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- If `f` is a nontrivial countably generated basis, then there exists a sequence that converges
to `f`. -/
theorem exists_seq_tendsto
(f : filter Œ±)
[is_countably_generated f]
[ne_bot f] : ¬´expr‚àÉ , ¬ª((x : expr‚Ñï() ‚Üí Œ±), tendsto x at_top f) :=
begin
  obtain ["‚ü®", ident B, ",", ident h, ",", ident h_mono, ",", "-", "‚ü©", ":=", expr f.exists_antitone_basis],
  have [] [] [":=", expr Œª n, nonempty_of_mem (h.mem_of_mem trivial : ¬´expr ‚àà ¬ª(B n, f))],
  choose [] [ident x] [ident hx] [],
  exact [expr ‚ü®x, ¬´expr $ ¬ª(h.tendsto_right_iff.2, Œª
     n hn, eventually_at_top.2 ‚ü®n, Œª m hm, h_mono trivial trivial hm (hx m)‚ü©)‚ü©]
end

-- error in Order.Filter.AtTopBot: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem subseq_tendsto_of_ne_bot
{f : filter Œ±}
[is_countably_generated f]
{u : expr‚Ñï() ‚Üí Œ±}
(hx : ne_bot ¬´expr ‚äì ¬ª(f, map u at_top)) : ¬´expr‚àÉ , ¬ª((Œ∏ : expr‚Ñï() ‚Üí expr‚Ñï()), ¬´expr ‚àß ¬ª(strict_mono Œ∏, tendsto ¬´expr ‚àò ¬ª(u, Œ∏) at_top f)) :=
begin
  obtain ["‚ü®", ident B, ",", ident h, "‚ü©", ":=", expr f.exists_antitone_basis],
  have [] [":", expr ‚àÄ N, ¬´expr‚àÉ , ¬ª((n ¬´expr ‚â• ¬ª N), ¬´expr ‚àà ¬ª(u n, B N))] [],
  from [expr Œª N, filter.inf_map_at_top_ne_bot_iff.mp hx _ (h.to_has_basis.mem_of_mem trivial) N],
  choose [] [ident œÜ] [ident hœÜ] ["using", expr this],
  cases [expr forall_and_distrib.mp hœÜ] ["with", ident œÜ_ge, ident œÜ_in],
  have [ident lim_uœÜ] [":", expr tendsto ¬´expr ‚àò ¬ª(u, œÜ) at_top f] [],
  from [expr h.tendsto œÜ_in],
  have [ident lim_œÜ] [":", expr tendsto œÜ at_top at_top] [],
  from [expr tendsto_at_top_mono œÜ_ge tendsto_id],
  obtain ["‚ü®", ident œà, ",", ident hœà, ",", ident hœàœÜ, "‚ü©", ":", expr ¬´expr‚àÉ , ¬ª((œà : expr‚Ñï() ‚Üí expr‚Ñï()), ¬´expr ‚àß ¬ª(strict_mono œà, strict_mono ¬´expr ‚àò ¬ª(œÜ, œà)))],
  from [expr strict_mono_subseq_of_tendsto_at_top lim_œÜ],
  exact [expr ‚ü®¬´expr ‚àò ¬ª(œÜ, œà), hœàœÜ, lim_uœÜ.comp hœà.tendsto_at_top‚ü©]
end

end Filter

open Filter Finset

section 

variable{R : Type _}[LinearOrderedSemiring R]

theorem exists_lt_mul_self (a : R) : ‚àÉ (x : _)(_ : x ‚â• 0), a < x*x :=
  let ‚ü®x, hxa, hx0‚ü© :=
    ((tendsto_mul_self_at_top.Eventually (eventually_gt_at_top a)).And (eventually_ge_at_top 0)).exists
  ‚ü®x, hx0, hxa‚ü©

theorem exists_le_mul_self (a : R) : ‚àÉ (x : _)(_ : x ‚â• 0), a ‚â§ x*x :=
  let ‚ü®x, hx0, hxa‚ü© := exists_lt_mul_self a
  ‚ü®x, hx0, hxa.le‚ü©

end 

namespace OrderIso

variable[Preorder‚Çì Œ±][Preorder‚Çì Œ≤]

@[simp]
theorem comap_at_top (e : Œ± ‚âÉo Œ≤) : comap e at_top = at_top :=
  by 
    simp [at_top, ‚Üêe.surjective.infi_comp]

@[simp]
theorem comap_at_bot (e : Œ± ‚âÉo Œ≤) : comap e at_bot = at_bot :=
  e.dual.comap_at_top

@[simp]
theorem map_at_top (e : Œ± ‚âÉo Œ≤) : map (e : Œ± ‚Üí Œ≤) at_top = at_top :=
  by 
    rw [‚Üêe.comap_at_top, map_comap_of_surjective e.surjective]

@[simp]
theorem map_at_bot (e : Œ± ‚âÉo Œ≤) : map (e : Œ± ‚Üí Œ≤) at_bot = at_bot :=
  e.dual.map_at_top

theorem tendsto_at_top (e : Œ± ‚âÉo Œ≤) : tendsto e at_top at_top :=
  e.map_at_top.le

theorem tendsto_at_bot (e : Œ± ‚âÉo Œ≤) : tendsto e at_bot at_bot :=
  e.map_at_bot.le

@[simp]
theorem tendsto_at_top_iff {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} (e : Œ± ‚âÉo Œ≤) :
  tendsto (fun x => e (f x)) l at_top ‚Üî tendsto f l at_top :=
  by 
    rw [‚Üêe.comap_at_top, tendsto_comap_iff]

@[simp]
theorem tendsto_at_bot_iff {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} (e : Œ± ‚âÉo Œ≤) :
  tendsto (fun x => e (f x)) l at_bot ‚Üî tendsto f l at_bot :=
  e.dual.tendsto_at_top_iff

end OrderIso

/-- Let `g : Œ≥ ‚Üí Œ≤` be an injective function and `f : Œ≤ ‚Üí Œ±` be a function from the codomain of `g`
to a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters
`at_top.map (Œª s, ‚àè i in s, f (g i))` and `at_top.map (Œª s, ‚àè i in s, f i)` coincide.

The additive version of this lemma is used to prove the equality `‚àë' x, f (g x) = ‚àë' y, f y` under
the same assumptions.-/
@[toAdditive]
theorem Function.Injective.map_at_top_finset_prod_eq [CommMonoid‚Çì Œ±] {g : Œ≥ ‚Üí Œ≤} (hg : Function.Injective g) {f : Œ≤ ‚Üí Œ±}
  (hf : ‚àÄ x (_ : x ‚àâ Set.Range g), f x = 1) :
  map (fun s => ‚àèi in s, f (g i)) at_top = map (fun s => ‚àèi in s, f i) at_top :=
  by 
    apply le_antisymm‚Çì <;> refine' map_at_top_finset_prod_le_of_prod_eq fun s => _
    ¬∑
      refine' ‚ü®s.preimage g (hg.inj_on _), fun t ht => _‚ü©
      refine' ‚ü®t.image g ‚à™ s, Finset.subset_union_right _ _, _‚ü©
      rw [‚ÜêFinset.prod_image (hg.inj_on _)]
      refine' (prod_subset (subset_union_left _ _) _).symm 
      simp only [Finset.mem_union, Finset.mem_image]
      refine' fun y hy hyt => hf y (mt _ hyt)
      rintro ‚ü®x, rfl‚ü©
      exact ‚ü®x, ht (Finset.mem_preimage.2$ hy.resolve_left hyt), rfl‚ü©
    ¬∑
      refine' ‚ü®s.image g, fun t ht => _‚ü©
      simp only [‚Üêprod_preimage _ _ (hg.inj_on _) _ fun x _ => hf x]
      exact ‚ü®_, (image_subset_iff_subset_preimage _).1 ht, rfl‚ü©

/-- Let `g : Œ≥ ‚Üí Œ≤` be an injective function and `f : Œ≤ ‚Üí Œ±` be a function from the codomain of `g`
to an additive commutative monoid. Suppose that `f x = 0` outside of the range of `g`. Then the
filters `at_top.map (Œª s, ‚àë i in s, f (g i))` and `at_top.map (Œª s, ‚àë i in s, f i)` coincide.

This lemma is used to prove the equality `‚àë' x, f (g x) = ‚àë' y, f y` under
the same assumptions.-/
add_decl_doc Function.Injective.map_at_top_finset_sum_eq

