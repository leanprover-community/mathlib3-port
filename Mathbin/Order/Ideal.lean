import Mathbin.Data.Equiv.Encodable.Basic 
import Mathbin.Order.Atoms

/-!
# Order ideals, cofinal sets, and the Rasiowa–Sikorski lemma

## Main definitions

Throughout this file, `P` is at least a preorder, but some sections require more
structure, such as a bottom element, a top element, or a join-semilattice structure.
- `order.ideal P`: the type of nonempty, upward directed, and downward closed subsets of `P`.
  Dual to the notion of a filter on a preorder.
- `order.is_ideal P`: a predicate for when a `set P` is an ideal.
- `order.ideal.principal p`: the principal ideal generated by `p : P`.
- `order.ideal.is_proper P`: a predicate for proper ideals.
  Dual to the notion of a proper filter.
- `order.ideal.is_maximal`: a predicate for maximal ideals.
  Dual to the notion of an ultrafilter.
- `ideal_inter_nonempty P`: a predicate for when the intersection of any two ideals of
  `P` is nonempty.
- `ideal_Inter_nonempty P`: a predicate for when the intersection of all ideals of
  `P` is nonempty.
- `order.cofinal P`: the type of subsets of `P` containing arbitrarily large elements.
  Dual to the notion of 'dense set' used in forcing.
- `order.ideal_of_cofinals p 𝒟`, where `p : P`, and `𝒟` is a countable family of cofinal
  subsets of P: an ideal in `P` which contains `p` and intersects every set in `𝒟`. (This a form
  of the Rasiowa–Sikorski lemma.)

## References

- <https://en.wikipedia.org/wiki/Ideal_(order_theory)>
- <https://en.wikipedia.org/wiki/Cofinal_(mathematics)>
- <https://en.wikipedia.org/wiki/Rasiowa%E2%80%93Sikorski_lemma>

Note that for the Rasiowa–Sikorski lemma, Wikipedia uses the opposite ordering on `P`,
in line with most presentations of forcing.

## Tags

ideal, cofinal, dense, countable, generic

-/


namespace Order

variable{P : Type _}

/-- An ideal on a preorder `P` is a subset of `P` that is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
structure ideal(P)[Preorderₓ P] where 
  Carrier : Set P 
  Nonempty : carrier.nonempty 
  Directed : DirectedOn (· ≤ ·) carrier 
  mem_of_le : ∀ {x y : P}, x ≤ y → y ∈ carrier → x ∈ carrier

/-- A subset of a preorder `P` is an ideal if it is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
@[mkIff]
structure is_ideal{P}[Preorderₓ P](I : Set P) : Prop where 
  Nonempty : I.nonempty 
  Directed : DirectedOn (· ≤ ·) I 
  mem_of_le : ∀ {x y : P}, x ≤ y → y ∈ I → x ∈ I

/-- Create an element of type `order.ideal` from a set satisfying the predicate
`order.is_ideal`. -/
def is_ideal.to_ideal [Preorderₓ P] {I : Set P} (h : is_ideal I) : ideal P :=
  ⟨I, h.1, h.2, h.3⟩

namespace Ideal

section Preorderₓ

variable[Preorderₓ P]{x y : P}{I J : ideal P}

/-- The smallest ideal containing a given element. -/
def principal (p : P) : ideal P :=
  { Carrier := { x | x ≤ p }, Nonempty := ⟨p, le_reflₓ _⟩, Directed := fun x hx y hy => ⟨p, le_reflₓ _, hx, hy⟩,
    mem_of_le := fun x y hxy hy => le_transₓ hxy hy }

instance  [Inhabited P] : Inhabited (ideal P) :=
  ⟨ideal.principal$ default P⟩

/-- An ideal of `P` can be viewed as a subset of `P`. -/
instance  : Coe (ideal P) (Set P) :=
  ⟨carrier⟩

/-- For the notation `x ∈ I`. -/
instance  : HasMem P (ideal P) :=
  ⟨fun x I => x ∈ (I : Set P)⟩

@[simp]
theorem mem_coe : x ∈ (I : Set P) ↔ x ∈ I :=
  iff_of_eq rfl

@[simp]
theorem mem_principal : x ∈ principal y ↔ x ≤ y :=
  by 
    rfl

/-- Two ideals are equal when their underlying sets are equal. -/
@[ext]
theorem ext : ∀ (I J : ideal P), (I : Set P) = J → I = J
| ⟨_, _, _, _⟩, ⟨_, _, _, _⟩, rfl => rfl

@[simp, normCast]
theorem ext_set_eq {I J : ideal P} : (I : Set P) = J ↔ I = J :=
  ⟨by 
      ext,
    congr_argₓ _⟩

theorem ext'_iff {I J : ideal P} : I = J ↔ (I : Set P) = J :=
  ext_set_eq.symm

theorem is_ideal (I : ideal P) : is_ideal (I : Set P) :=
  ⟨I.2, I.3, I.4⟩

/-- The partial ordering by subset inclusion, inherited from `set P`. -/
instance  : PartialOrderₓ (ideal P) :=
  PartialOrderₓ.lift coeₓ ext

@[trans]
theorem mem_of_mem_of_le : x ∈ I → I ≤ J → x ∈ J :=
  @Set.mem_of_mem_of_subset P x I J

-- error in Order.Ideal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
@[simp] theorem principal_le_iff : «expr ↔ »(«expr ≤ »(principal x, I), «expr ∈ »(x, I)) :=
⟨λ
 h : ∀
 {y}, «expr ≤ »(y, x) → «expr ∈ »(y, I), h (le_refl x), λ (h_mem y) (h_le : «expr ≤ »(y, x)), I.mem_of_le h_le h_mem⟩

theorem mem_compl_of_ge {x y : P} : x ≤ y → x ∈ «expr ᶜ» (I : Set P) → y ∈ «expr ᶜ» (I : Set P) :=
  fun h => mt (I.mem_of_le h)

/-- A proper ideal is one that is not the whole set.
    Note that the whole set might not be an ideal. -/
@[mkIff]
class is_proper(I : ideal P) : Prop where 
  ne_univ : (I : Set P) ≠ Set.Univ

theorem is_proper_of_not_mem {I : ideal P} {p : P} (nmem : p ∉ I) : is_proper I :=
  ⟨fun hp =>
      by 
        change p ∉ «expr↑ » I at nmem 
        rw [hp] at nmem 
        exact nmem (Set.mem_univ p)⟩

/-- An ideal is maximal if it is maximal in the collection of proper ideals.
  Note that we cannot use the `is_coatom` class because `P` might not have a `top` element.
-/
@[mkIff]
class is_maximal(I : ideal P) extends is_proper I : Prop where 
  maximal_proper : ∀ ⦃J : ideal P⦄, I < J → (J : Set P) = Set.Univ

variable(P)

/-- A preorder `P` has the `ideal_inter_nonempty` property if the
    intersection of any two ideals is nonempty.
    Most importantly, a `semilattice_sup` preorder with this property
    satisfies that its ideal poset is a lattice.
-/
class ideal_inter_nonempty : Prop where 
  inter_nonempty : ∀ (I J : ideal P), ((I : Set P) ∩ (J : Set P)).Nonempty

/-- A preorder `P` has the `ideal_Inter_nonempty` property if the
    intersection of all ideals is nonempty.
    Most importantly, a `semilattice_sup` preorder with this property
    satisfies that its ideal poset is a complete lattice.
-/
class ideal_Inter_nonempty : Prop where 
  Inter_nonempty : (⋂I : ideal P, (I : Set P)).Nonempty

variable{P}

theorem inter_nonempty [ideal_inter_nonempty P] : ∀ (I J : ideal P), ((I : Set P) ∩ (J : Set P)).Nonempty :=
  ideal_inter_nonempty.inter_nonempty

theorem Inter_nonempty [ideal_Inter_nonempty P] : (⋂I : ideal P, (I : Set P)).Nonempty :=
  ideal_Inter_nonempty.Inter_nonempty

theorem ideal_Inter_nonempty.exists_all_mem [ideal_Inter_nonempty P] : ∃ a : P, ∀ (I : ideal P), a ∈ I :=
  by 
    change ∃ a : P, ∀ (I : ideal P), a ∈ (I : Set P)
    rw [←Set.nonempty_Inter]
    exact Inter_nonempty

theorem ideal_Inter_nonempty_of_exists_all_mem (h : ∃ a : P, ∀ (I : ideal P), a ∈ I) : ideal_Inter_nonempty P :=
  { Inter_nonempty :=
      by 
        rwa [Set.nonempty_Inter] }

theorem ideal_Inter_nonempty_iff : ideal_Inter_nonempty P ↔ ∃ a : P, ∀ (I : ideal P), a ∈ I :=
  ⟨fun _ =>
      by 
        exact ideal_Inter_nonempty.exists_all_mem,
    ideal_Inter_nonempty_of_exists_all_mem⟩

end Preorderₓ

section OrderBot

variable[Preorderₓ P][OrderBot P]{I : ideal P}

/-- A specific witness of `I.nonempty` when `P` has a bottom element. -/
@[simp]
theorem bot_mem : ⊥ ∈ I :=
  I.mem_of_le bot_le I.nonempty.some_mem

/-- There is a bottom ideal when `P` has a bottom element. -/
instance  : OrderBot (ideal P) :=
  { bot := principal ⊥,
    bot_le :=
      by 
        simp  }

instance (priority := 100)order_bot.ideal_Inter_nonempty : ideal_Inter_nonempty P :=
  by 
    rw [ideal_Inter_nonempty_iff]
    exact ⟨⊥, fun I => bot_mem⟩

end OrderBot

section OrderTop

variable[Preorderₓ P][OrderTop P]

/-- There is a top ideal when `P` has a top element. -/
instance  : OrderTop (ideal P) :=
  { top := principal ⊤, le_top := fun I x h => le_top }

@[simp]
theorem coe_top : ((⊤ : ideal P) : Set P) = Set.Univ :=
  Set.univ_subset_iff.1 fun p _ => le_top

theorem top_of_mem_top {I : ideal P} (mem_top : ⊤ ∈ I) : I = ⊤ :=
  by 
    ext 
    change x ∈ I ↔ x ∈ ((⊤ : ideal P) : Set P)
    split 
    ·
      simp [coe_top]
    ·
      exact fun _ => I.mem_of_le le_top mem_top

theorem is_proper_of_ne_top {I : ideal P} (ne_top : I ≠ ⊤) : is_proper I :=
  is_proper_of_not_mem fun h => ne_top (top_of_mem_top h)

theorem is_proper.ne_top {I : ideal P} (hI : is_proper I) : I ≠ ⊤ :=
  by 
    intro h 
    rw [ext'_iff, coe_top] at h 
    apply hI.ne_univ 
    assumption

theorem is_proper.top_not_mem {I : ideal P} (hI : is_proper I) : ⊤ ∉ I :=
  by 
    byContra 
    exact hI.ne_top (top_of_mem_top h)

theorem _root_.is_coatom.is_proper {I : ideal P} (hI : IsCoatom I) : is_proper I :=
  is_proper_of_ne_top hI.1

theorem is_proper_iff_ne_top {I : ideal P} : is_proper I ↔ I ≠ ⊤ :=
  ⟨fun h => h.ne_top, fun h => is_proper_of_ne_top h⟩

theorem is_maximal.is_coatom {I : ideal P} (h : is_maximal I) : IsCoatom I :=
  ⟨is_maximal.to_is_proper.ne_top,
    fun _ _ =>
      by 
        rw [ext'_iff, coe_top]
        exact is_maximal.maximal_proper ‹_›⟩

theorem is_maximal.is_coatom' {I : ideal P} [is_maximal I] : IsCoatom I :=
  is_maximal.is_coatom ‹_›

theorem _root_.is_coatom.is_maximal {I : ideal P} (hI : IsCoatom I) : is_maximal I :=
  { IsCoatom.is_proper ‹_› with
    maximal_proper :=
      fun _ _ =>
        by 
          simp [hI.2 _ ‹_›] }

theorem is_maximal_iff_is_coatom {I : ideal P} : is_maximal I ↔ IsCoatom I :=
  ⟨fun h => h.is_coatom, fun h => h.is_maximal⟩

end OrderTop

section SemilatticeSup

variable[SemilatticeSup P]{x y : P}{I : ideal P}

/-- A specific witness of `I.directed` when `P` has joins. -/
theorem sup_mem x y (_ : x ∈ I) (_ : y ∈ I) : x⊔y ∈ I :=
  let ⟨z, h_mem, hx, hy⟩ := I.directed x ‹_› y ‹_›
  I.mem_of_le (sup_le hx hy) h_mem

@[simp]
theorem sup_mem_iff : x⊔y ∈ I ↔ x ∈ I ∧ y ∈ I :=
  ⟨fun h => ⟨I.mem_of_le le_sup_left h, I.mem_of_le le_sup_right h⟩, fun h => sup_mem x y h.left h.right⟩

end SemilatticeSup

section SemilatticeSupIdealInterNonempty

variable[SemilatticeSup P][ideal_inter_nonempty P]{x : P}{I J K : ideal P}

/-- The intersection of two ideals is an ideal, when it is nonempty and `P` has joins. -/
def inf (I J : ideal P) : ideal P :=
  { Carrier := I ∩ J, Nonempty := inter_nonempty I J,
    Directed :=
      fun x ⟨_, _⟩ y ⟨_, _⟩ =>
        ⟨x⊔y, ⟨sup_mem x y ‹_› ‹_›, sup_mem x y ‹_› ‹_›⟩,
          by 
            simp ⟩,
    mem_of_le := fun x y h ⟨_, _⟩ => ⟨mem_of_le I h ‹_›, mem_of_le J h ‹_›⟩ }

/-- There is a smallest ideal containing two ideals, when their intersection is nonempty and
    `P` has joins. -/
def sup (I J : ideal P) : ideal P :=
  { Carrier := { x | ∃ (i : _)(_ : i ∈ I)(j : _)(_ : j ∈ J), x ≤ i⊔j },
    Nonempty :=
      by 
        cases inter_nonempty I J 
        exact ⟨w, w, h.1, w, h.2, le_sup_left⟩,
    Directed :=
      fun x ⟨xi, _, xj, _, _⟩ y ⟨yi, _, yj, _, _⟩ =>
        ⟨x⊔y,
          ⟨xi⊔yi, sup_mem xi yi ‹_› ‹_›, xj⊔yj, sup_mem xj yj ‹_› ‹_›,
            sup_le
              (calc x ≤ xi⊔xj := ‹_›
                _ ≤ xi⊔yi⊔(xj⊔yj) := sup_le_sup le_sup_left le_sup_left
                )
              (calc y ≤ yi⊔yj := ‹_›
                _ ≤ xi⊔yi⊔(xj⊔yj) := sup_le_sup le_sup_right le_sup_right
                )⟩,
          le_sup_left, le_sup_right⟩,
    mem_of_le := fun x y _ ⟨yi, _, yj, _, _⟩ => ⟨yi, ‹_›, yj, ‹_›, le_transₓ ‹x ≤ y› ‹_›⟩ }

theorem sup_le : I ≤ K → J ≤ K → sup I J ≤ K :=
  fun hIK hJK x ⟨i, hiI, j, hjJ, hxij⟩ =>
    K.mem_of_le hxij$ sup_mem i j (mem_of_mem_of_le hiI hIK) (mem_of_mem_of_le hjJ hJK)

-- error in Order.Ideal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Parser.Term.explicitBinder'
instance : lattice (ideal P) :=
{ sup := sup,
  le_sup_left := λ (I J) (i «expr ∈ » I), by { cases [expr nonempty J] [],
    exact [expr ⟨i, «expr‹ ›»(_), w, «expr‹ ›»(_), le_sup_left⟩] },
  le_sup_right := λ (I J) (j «expr ∈ » J), by { cases [expr nonempty I] [],
    exact [expr ⟨w, «expr‹ ›»(_), j, «expr‹ ›»(_), le_sup_right⟩] },
  sup_le := @sup_le _ _ _,
  inf := inf,
  inf_le_left := λ I J, set.inter_subset_left I J,
  inf_le_right := λ I J, set.inter_subset_right I J,
  le_inf := λ I J K, set.subset_inter,
  ..ideal.partial_order }

@[simp]
theorem mem_inf : x ∈ I⊓J ↔ x ∈ I ∧ x ∈ J :=
  iff_of_eq rfl

@[simp]
theorem mem_sup : x ∈ I⊔J ↔ ∃ (i : _)(_ : i ∈ I)(j : _)(_ : j ∈ J), x ≤ i⊔j :=
  iff_of_eq rfl

theorem lt_sup_principal_of_not_mem (hx : x ∉ I) : I < I⊔principal x :=
  by 
    apply lt_of_le_of_neₓ le_sup_left 
    intro h 
    simp  at h 
    exact hx h

end SemilatticeSupIdealInterNonempty

section IdealInterNonempty

variable[Preorderₓ P][ideal_Inter_nonempty P]

instance (priority := 100)ideal_Inter_nonempty.ideal_inter_nonempty : ideal_inter_nonempty P :=
  { inter_nonempty :=
      fun _ _ =>
        by 
          obtain ⟨a, ha⟩ : ∃ a : P, ∀ (I : ideal P), a ∈ I := ideal_Inter_nonempty.exists_all_mem 
          exact ⟨a, ha _, ha _⟩ }

variable{α β γ : Type _}{ι : Sort _}

theorem ideal_Inter_nonempty.all_Inter_nonempty {f : ι → ideal P} : (⋂x, (f x : Set P)).Nonempty :=
  by 
    obtain ⟨a, ha⟩ : ∃ a : P, ∀ (I : ideal P), a ∈ I := ideal_Inter_nonempty.exists_all_mem 
    exact
      ⟨a,
        by 
          simp [ha]⟩

theorem ideal_Inter_nonempty.all_bInter_nonempty {f : α → ideal P} {s : Set α} :
  (⋂(x : _)(_ : x ∈ s), (f x : Set P)).Nonempty :=
  by 
    obtain ⟨a, ha⟩ : ∃ a : P, ∀ (I : ideal P), a ∈ I := ideal_Inter_nonempty.exists_all_mem 
    exact
      ⟨a,
        by 
          simp [ha]⟩

end IdealInterNonempty

section SemilatticeSupIdealInterNonempty

variable[SemilatticeSup P][ideal_Inter_nonempty P]{x : P}{I J K : ideal P}

instance  : HasInfₓ (ideal P) :=
  { inf :=
      fun s =>
        { Carrier := ⋂(I : _)(_ : I ∈ s), (I : Set P), Nonempty := ideal_Inter_nonempty.all_bInter_nonempty,
          Directed :=
            fun x hx y hy =>
              ⟨x⊔y,
                ⟨fun S ⟨I, hS⟩ =>
                    by 
                      simp only [←hS, sup_mem_iff, mem_coe, Set.mem_Inter]
                      intro hI 
                      rw [Set.mem_bInter_iff] at *
                      exact ⟨hx _ hI, hy _ hI⟩,
                  le_sup_left, le_sup_right⟩⟩,
          mem_of_le :=
            fun x y hxy hy =>
              by 
                rw [Set.mem_bInter_iff] at *
                exact fun I hI => mem_of_le I ‹_› (hy I hI) } }

variable{s : Set (ideal P)}

@[simp]
theorem mem_Inf : x ∈ Inf s ↔ ∀ I (_ : I ∈ s), x ∈ I :=
  by 
    change (x ∈ ⋂(I : _)(_ : I ∈ s), (I : Set P)) ↔ ∀ I (_ : I ∈ s), x ∈ I 
    simp 

@[simp]
theorem coe_Inf : «expr↑ » (Inf s) = ⋂(I : _)(_ : I ∈ s), (I : Set P) :=
  rfl

theorem Inf_le (hI : I ∈ s) : Inf s ≤ I :=
  fun _ hx =>
    hx I
      ⟨I,
        by 
          simp [hI]⟩

theorem le_Inf (h : ∀ J (_ : J ∈ s), I ≤ J) : I ≤ Inf s :=
  fun _ _ =>
    by 
      simp only [mem_coe, coe_Inf, Set.mem_Inter]
      tauto

theorem is_glb_Inf : IsGlb s (Inf s) :=
  ⟨fun _ => Inf_le, fun _ => le_Inf⟩

instance  : CompleteLattice (ideal P) :=
  { ideal.lattice, completeLatticeOfInf (ideal P) fun _ => @is_glb_Inf _ _ _ _ with  }

end SemilatticeSupIdealInterNonempty

section SemilatticeInf

variable[SemilatticeInf P]

instance (priority := 100)semilattice_inf.ideal_inter_nonempty : ideal_inter_nonempty P :=
  { inter_nonempty :=
      fun I J =>
        by 
          cases' I.nonempty with i _ 
          cases' J.nonempty with j _ 
          exact ⟨i⊓j, I.mem_of_le inf_le_left ‹_›, J.mem_of_le inf_le_right ‹_›⟩ }

end SemilatticeInf

section DistribLattice

variable[DistribLattice P]

variable{I J : ideal P}

theorem eq_sup_of_le_sup {x i j : P} (hi : i ∈ I) (hj : j ∈ J) (hx : x ≤ i⊔j) :
  ∃ (i' : _)(_ : i' ∈ I)(j' : _)(_ : j' ∈ J), x = i'⊔j' :=
  by 
    refine' ⟨x⊓i, I.mem_of_le inf_le_right hi, x⊓j, J.mem_of_le inf_le_right hj, _⟩
    calc x = x⊓(i⊔j) := left_eq_inf.mpr hx _ = x⊓i⊔x⊓j := inf_sup_left

theorem coe_sup_eq : «expr↑ » (I⊔J) = { x | ∃ (i : _)(_ : i ∈ I), ∃ (j : _)(_ : j ∈ J), x = i⊔j } :=
  by 
    ext 
    rw [mem_coe, mem_sup]
    exact ⟨fun ⟨_, _, _, _, _⟩ => eq_sup_of_le_sup ‹_› ‹_› ‹_›, fun ⟨i, _, j, _, _⟩ => ⟨i, ‹_›, j, ‹_›, le_of_eqₓ ‹_›⟩⟩

end DistribLattice

section BooleanAlgebra

variable[BooleanAlgebra P]{x : P}{I : ideal P}

-- error in Order.Ideal: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_proper.not_mem_of_compl_mem (hI : is_proper I) (hxc : «expr ∈ »(«expr ᶜ»(x), I)) : «expr ∉ »(x, I) :=
begin
  intro [ident hx],
  apply [expr hI.top_not_mem],
  have [ident ht] [":", expr «expr ∈ »(«expr ⊔ »(x, «expr ᶜ»(x)), I)] [":=", expr sup_mem _ _ «expr‹ ›»(_) «expr‹ ›»(_)],
  rwa [expr sup_compl_eq_top] ["at", ident ht]
end

theorem is_proper.not_mem_or_compl_not_mem (hI : is_proper I) : x ∉ I ∨ «expr ᶜ» x ∉ I :=
  have h : «expr ᶜ» x ∈ I → x ∉ I := hI.not_mem_of_compl_mem 
  by 
    tauto

end BooleanAlgebra

end Ideal

/-- For a preorder `P`, `cofinal P` is the type of subsets of `P`
  containing arbitrarily large elements. They are the dense sets in
  the topology whose open sets are terminal segments. -/
structure cofinal(P)[Preorderₓ P] where 
  Carrier : Set P 
  mem_gt : ∀ (x : P), ∃ (y : _)(_ : y ∈ carrier), x ≤ y

namespace Cofinal

variable[Preorderₓ P]

instance  : Inhabited (cofinal P) :=
  ⟨{ Carrier := Set.Univ, mem_gt := fun x => ⟨x, trivialₓ, le_reflₓ _⟩ }⟩

instance  : HasMem P (cofinal P) :=
  ⟨fun x D => x ∈ D.carrier⟩

variable(D : cofinal P)(x : P)

/-- A (noncomputable) element of a cofinal set lying above a given element. -/
noncomputable def above : P :=
  Classical.some$ D.mem_gt x

theorem above_mem : D.above x ∈ D :=
  Exists.elim (Classical.some_spec$ D.mem_gt x)$ fun a _ => a

theorem le_above : x ≤ D.above x :=
  Exists.elim (Classical.some_spec$ D.mem_gt x)$ fun _ b => b

end Cofinal

section IdealOfCofinals

variable[Preorderₓ P](p : P){ι : Type _}[Encodable ι](𝒟 : ι → cofinal P)

/-- Given a starting point, and a countable family of cofinal sets,
  this is an increasing sequence that intersects each cofinal set. -/
noncomputable def sequence_of_cofinals : ℕ → P
| 0 => p
| n+1 =>
  match Encodable.decode ι n with 
  | none => sequence_of_cofinals n
  | some i => (𝒟 i).above (sequence_of_cofinals n)

theorem sequence_of_cofinals.monotone : Monotone (sequence_of_cofinals p 𝒟) :=
  by 
    apply monotone_nat_of_le_succ 
    intro n 
    dunfold sequence_of_cofinals 
    cases Encodable.decode ι n
    ·
      rfl
    ·
      apply cofinal.le_above

theorem sequence_of_cofinals.encode_mem (i : ι) : sequence_of_cofinals p 𝒟 (Encodable.encode i+1) ∈ 𝒟 i :=
  by 
    dunfold sequence_of_cofinals 
    rw [Encodable.encodek]
    apply cofinal.above_mem

/-- Given an element `p : P` and a family `𝒟` of cofinal subsets of a preorder `P`,
  indexed by a countable type, `ideal_of_cofinals p 𝒟` is an ideal in `P` which
  - contains `p`, according to `mem_ideal_of_cofinals p 𝒟`, and
  - intersects every set in `𝒟`, according to `cofinal_meets_ideal_of_cofinals p 𝒟`.

  This proves the Rasiowa–Sikorski lemma. -/
def ideal_of_cofinals : ideal P :=
  { Carrier := { x:P | ∃ n, x ≤ sequence_of_cofinals p 𝒟 n }, Nonempty := ⟨p, 0, le_reflₓ _⟩,
    Directed :=
      fun x ⟨n, hn⟩ y ⟨m, hm⟩ =>
        ⟨_, ⟨max n m, le_reflₓ _⟩, le_transₓ hn$ sequence_of_cofinals.monotone p 𝒟 (le_max_leftₓ _ _),
          le_transₓ hm$ sequence_of_cofinals.monotone p 𝒟 (le_max_rightₓ _ _)⟩,
    mem_of_le := fun x y hxy ⟨n, hn⟩ => ⟨n, le_transₓ hxy hn⟩ }

theorem mem_ideal_of_cofinals : p ∈ ideal_of_cofinals p 𝒟 :=
  ⟨0, le_reflₓ _⟩

/-- `ideal_of_cofinals p 𝒟` is `𝒟`-generic. -/
theorem cofinal_meets_ideal_of_cofinals (i : ι) : ∃ x : P, x ∈ 𝒟 i ∧ x ∈ ideal_of_cofinals p 𝒟 :=
  ⟨_, sequence_of_cofinals.encode_mem p 𝒟 i, _, le_reflₓ _⟩

end IdealOfCofinals

end Order

