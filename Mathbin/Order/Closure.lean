/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, Yaël Dillies

! This file was ported from Lean 3 source module order.closure
! leanprover-community/mathlib commit c3291da49cfa65f0d43b094750541c0731edc932
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Set.Lattice
import Mathbin.Data.SetLike.Basic
import Mathbin.Order.GaloisConnection
import Mathbin.Order.Hom.Basic

/-!
# Closure operators between preorders

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define (bundled) closure operators on a preorder as monotone (increasing), extensive
(inflationary) and idempotent functions.
We define closed elements for the operator as elements which are fixed by it.

Lower adjoints to a function between preorders `u : β → α` allow to generalise closure operators to
situations where the closure operator we are dealing with naturally decomposes as `u ∘ l` where `l`
is a worthy function to have on its own. Typical examples include
`l : set G → subgroup G := subgroup.closure`, `u : subgroup G → set G := coe`, where `G` is a group.
This shows there is a close connection between closure operators, lower adjoints and Galois
connections/insertions: every Galois connection induces a lower adjoint which itself induces a
closure operator by composition (see `galois_connection.lower_adjoint` and
`lower_adjoint.closure_operator`), and every closure operator on a partial order induces a Galois
insertion from the set of closed elements to the underlying type (see `closure_operator.gi`).

## Main definitions

* `closure_operator`: A closure operator is a monotone function `f : α → α` such that
  `∀ x, x ≤ f x` and `∀ x, f (f x) = f x`.
* `lower_adjoint`: A lower adjoint to `u : β → α` is a function `l : α → β` such that `l` and `u`
  form a Galois connection.

## Implementation details

Although `lower_adjoint` is technically a generalisation of `closure_operator` (by defining
`to_fun := id`), it is desirable to have both as otherwise `id`s would be carried all over the
place when using concrete closure operators such as `convex_hull`.

`lower_adjoint` really is a semibundled `structure` version of `galois_connection`.

## References

* https://en.wikipedia.org/wiki/Closure_operator#Closure_operators_on_partially_ordered_sets
-/


universe u

/-! ### Closure operator -/


variable (α : Type _) {ι : Sort _} {κ : ι → Sort _}

#print ClosureOperator /-
/-- A closure operator on the preorder `α` is a monotone function which is extensive (every `x`
is less than its closure) and idempotent. -/
structure ClosureOperator [Preorder α] extends α →o α where
  le_closure' : ∀ x, x ≤ to_fun x
  idempotent' : ∀ x, to_fun (to_fun x) = to_fun x
#align closure_operator ClosureOperator
-/

namespace ClosureOperator

instance [Preorder α] : CoeFun (ClosureOperator α) fun _ => α → α :=
  ⟨fun c => c.toFun⟩

/-- See Note [custom simps projection] -/
def Simps.apply [Preorder α] (f : ClosureOperator α) : α → α :=
  f
#align closure_operator.simps.apply ClosureOperator.Simps.apply

initialize_simps_projections ClosureOperator (to_order_hom_to_fun → apply, -toOrderHom)

section PartialOrder

variable [PartialOrder α]

#print ClosureOperator.id /-
/-- The identity function as a closure operator. -/
@[simps]
def id : ClosureOperator α where
  toOrderHom := OrderHom.id
  le_closure' _ := le_rfl
  idempotent' _ := rfl
#align closure_operator.id ClosureOperator.id
-/

instance : Inhabited (ClosureOperator α) :=
  ⟨id α⟩

variable {α} (c : ClosureOperator α)

#print ClosureOperator.ext /-
@[ext]
theorem ext : ∀ c₁ c₂ : ClosureOperator α, (c₁ : α → α) = (c₂ : α → α) → c₁ = c₂
  | ⟨⟨c₁, _⟩, _, _⟩, ⟨⟨c₂, _⟩, _, _⟩, h => by
    congr
    exact h
#align closure_operator.ext ClosureOperator.ext
-/

#print ClosureOperator.mk' /-
/-- Constructor for a closure operator using the weaker idempotency axiom: `f (f x) ≤ f x`. -/
@[simps]
def mk' (f : α → α) (hf₁ : Monotone f) (hf₂ : ∀ x, x ≤ f x) (hf₃ : ∀ x, f (f x) ≤ f x) :
    ClosureOperator α where
  toFun := f
  monotone' := hf₁
  le_closure' := hf₂
  idempotent' x := (hf₃ x).antisymm (hf₁ (hf₂ x))
#align closure_operator.mk' ClosureOperator.mk'
-/

#print ClosureOperator.mk₂ /-
/-- Convenience constructor for a closure operator using the weaker minimality axiom:
`x ≤ f y → f x ≤ f y`, which is sometimes easier to prove in practice. -/
@[simps]
def mk₂ (f : α → α) (hf : ∀ x, x ≤ f x) (hmin : ∀ ⦃x y⦄, x ≤ f y → f x ≤ f y) : ClosureOperator α
    where
  toFun := f
  monotone' x y hxy := hmin (hxy.trans (hf y))
  le_closure' := hf
  idempotent' x := (hmin le_rfl).antisymm (hf _)
#align closure_operator.mk₂ ClosureOperator.mk₂
-/

#print ClosureOperator.mk₃ /-
/-- Expanded out version of `mk₂`. `p` implies being closed. This constructor should be used when
you already know a sufficient condition for being closed and using `mem_mk₃_closed` will avoid you
the (slight) hassle of having to prove it both inside and outside the constructor. -/
@[simps]
def mk₃ (f : α → α) (p : α → Prop) (hf : ∀ x, x ≤ f x) (hfp : ∀ x, p (f x))
    (hmin : ∀ ⦃x y⦄, x ≤ y → p y → f x ≤ y) : ClosureOperator α :=
  mk₂ f hf fun x y hxy => hmin hxy (hfp y)
#align closure_operator.mk₃ ClosureOperator.mk₃
-/

#print ClosureOperator.closure_mem_mk₃ /-
/-- This lemma shows that the image of `x` of a closure operator built from the `mk₃` constructor
respects `p`, the property that was fed into it. -/
theorem closure_mem_mk₃ {f : α → α} {p : α → Prop} {hf : ∀ x, x ≤ f x} {hfp : ∀ x, p (f x)}
    {hmin : ∀ ⦃x y⦄, x ≤ y → p y → f x ≤ y} (x : α) : p (mk₃ f p hf hfp hmin x) :=
  hfp x
#align closure_operator.closure_mem_mk₃ ClosureOperator.closure_mem_mk₃
-/

#print ClosureOperator.closure_le_mk₃_iff /-
/-- Analogue of `closure_le_closed_iff_le` but with the `p` that was fed into the `mk₃` constructor.
-/
theorem closure_le_mk₃_iff {f : α → α} {p : α → Prop} {hf : ∀ x, x ≤ f x} {hfp : ∀ x, p (f x)}
    {hmin : ∀ ⦃x y⦄, x ≤ y → p y → f x ≤ y} {x y : α} (hxy : x ≤ y) (hy : p y) :
    mk₃ f p hf hfp hmin x ≤ y :=
  hmin hxy hy
#align closure_operator.closure_le_mk₃_iff ClosureOperator.closure_le_mk₃_iff
-/

#print ClosureOperator.monotone /-
@[mono]
theorem monotone : Monotone c :=
  c.monotone'
#align closure_operator.monotone ClosureOperator.monotone
-/

#print ClosureOperator.le_closure /-
/-- Every element is less than its closure. This property is sometimes referred to as extensivity or
inflationarity. -/
theorem le_closure (x : α) : x ≤ c x :=
  c.le_closure' x
#align closure_operator.le_closure ClosureOperator.le_closure
-/

#print ClosureOperator.idempotent /-
@[simp]
theorem idempotent (x : α) : c (c x) = c x :=
  c.idempotent' x
#align closure_operator.idempotent ClosureOperator.idempotent
-/

#print ClosureOperator.le_closure_iff /-
theorem le_closure_iff (x y : α) : x ≤ c y ↔ c x ≤ c y :=
  ⟨fun h => c.idempotent y ▸ c.Monotone h, fun h => (c.le_closure x).trans h⟩
#align closure_operator.le_closure_iff ClosureOperator.le_closure_iff
-/

#print ClosureOperator.closed /-
/-- An element `x` is closed for the closure operator `c` if it is a fixed point for it. -/
def closed : Set α := fun x => c x = x
#align closure_operator.closed ClosureOperator.closed
-/

#print ClosureOperator.mem_closed_iff /-
theorem mem_closed_iff (x : α) : x ∈ c.closed ↔ c x = x :=
  Iff.rfl
#align closure_operator.mem_closed_iff ClosureOperator.mem_closed_iff
-/

#print ClosureOperator.mem_closed_iff_closure_le /-
theorem mem_closed_iff_closure_le (x : α) : x ∈ c.closed ↔ c x ≤ x :=
  ⟨le_of_eq, fun h => h.antisymm (c.le_closure x)⟩
#align closure_operator.mem_closed_iff_closure_le ClosureOperator.mem_closed_iff_closure_le
-/

#print ClosureOperator.closure_eq_self_of_mem_closed /-
theorem closure_eq_self_of_mem_closed {x : α} (h : x ∈ c.closed) : c x = x :=
  h
#align closure_operator.closure_eq_self_of_mem_closed ClosureOperator.closure_eq_self_of_mem_closed
-/

#print ClosureOperator.closure_is_closed /-
@[simp]
theorem closure_is_closed (x : α) : c x ∈ c.closed :=
  c.idempotent x
#align closure_operator.closure_is_closed ClosureOperator.closure_is_closed
-/

#print ClosureOperator.closed_eq_range_close /-
/-- The set of closed elements for `c` is exactly its range. -/
theorem closed_eq_range_close : c.closed = Set.range c :=
  Set.ext fun x =>
    ⟨fun h => ⟨x, h⟩, by
      rintro ⟨y, rfl⟩
      apply c.idempotent⟩
#align closure_operator.closed_eq_range_close ClosureOperator.closed_eq_range_close
-/

#print ClosureOperator.toClosed /-
/-- Send an `x` to an element of the set of closed elements (by taking the closure). -/
def toClosed (x : α) : c.closed :=
  ⟨c x, c.closure_is_closed x⟩
#align closure_operator.to_closed ClosureOperator.toClosed
-/

#print ClosureOperator.closure_le_closed_iff_le /-
@[simp]
theorem closure_le_closed_iff_le (x : α) {y : α} (hy : c.closed y) : c x ≤ y ↔ x ≤ y := by
  rw [← c.closure_eq_self_of_mem_closed hy, ← le_closure_iff]
#align closure_operator.closure_le_closed_iff_le ClosureOperator.closure_le_closed_iff_le
-/

#print ClosureOperator.eq_mk₃_closed /-
/-- A closure operator is equal to the closure operator obtained by feeding `c.closed` into the
`mk₃` constructor. -/
theorem eq_mk₃_closed (c : ClosureOperator α) :
    c =
      mk₃ c c.closed c.le_closure c.closure_is_closed fun x y hxy hy =>
        (c.closure_le_closed_iff_le x hy).2 hxy :=
  by
  ext
  rfl
#align closure_operator.eq_mk₃_closed ClosureOperator.eq_mk₃_closed
-/

#print ClosureOperator.mem_mk₃_closed /-
/-- The property `p` fed into the `mk₃` constructor implies being closed. -/
theorem mem_mk₃_closed {f : α → α} {p : α → Prop} {hf : ∀ x, x ≤ f x} {hfp : ∀ x, p (f x)}
    {hmin : ∀ ⦃x y⦄, x ≤ y → p y → f x ≤ y} {x : α} (hx : p x) : x ∈ (mk₃ f p hf hfp hmin).closed :=
  (hmin le_rfl hx).antisymm (hf _)
#align closure_operator.mem_mk₃_closed ClosureOperator.mem_mk₃_closed
-/

end PartialOrder

variable {α}

section OrderTop

variable [PartialOrder α] [OrderTop α] (c : ClosureOperator α)

/- warning: closure_operator.closure_top -> ClosureOperator.closure_top is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : OrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) c (Top.top.{u1} α (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) _inst_2))) (Top.top.{u1} α (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) _inst_2))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : OrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)), Eq.{succ u1} α (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u1} α _inst_1) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1) c) (Top.top.{u1} α (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) _inst_2))) (Top.top.{u1} α (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) _inst_2))
Case conversion may be inaccurate. Consider using '#align closure_operator.closure_top ClosureOperator.closure_topₓ'. -/
@[simp]
theorem closure_top : c ⊤ = ⊤ :=
  le_top.antisymm (c.le_closure _)
#align closure_operator.closure_top ClosureOperator.closure_top

/- warning: closure_operator.top_mem_closed -> ClosureOperator.top_mem_closed is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : OrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)), Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) (Top.top.{u1} α (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) _inst_2)) (ClosureOperator.closed.{u1} α _inst_1 c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : OrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)), Membership.mem.{u1, u1} α (Set.{u1} α) (Set.instMembershipSet.{u1} α) (Top.top.{u1} α (OrderTop.toTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) _inst_2)) (ClosureOperator.closed.{u1} α _inst_1 c)
Case conversion may be inaccurate. Consider using '#align closure_operator.top_mem_closed ClosureOperator.top_mem_closedₓ'. -/
theorem top_mem_closed : ⊤ ∈ c.closed :=
  c.closure_top
#align closure_operator.top_mem_closed ClosureOperator.top_mem_closed

end OrderTop

/- warning: closure_operator.closure_inf_le -> ClosureOperator.closure_inf_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (x : α) (y : α), LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) c (Inf.inf.{u1} α (SemilatticeInf.toHasInf.{u1} α _inst_1) x y)) (Inf.inf.{u1} α (SemilatticeInf.toHasInf.{u1} α _inst_1) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) c x) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) c y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : SemilatticeInf.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (x : α) (y : α), LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) c) (Inf.inf.{u1} α (SemilatticeInf.toInf.{u1} α _inst_1) x y)) (Inf.inf.{u1} α (SemilatticeInf.toInf.{u1} α _inst_1) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) c) x) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) c) y))
Case conversion may be inaccurate. Consider using '#align closure_operator.closure_inf_le ClosureOperator.closure_inf_leₓ'. -/
theorem closure_inf_le [SemilatticeInf α] (c : ClosureOperator α) (x y : α) :
    c (x ⊓ y) ≤ c x ⊓ c y :=
  c.Monotone.map_inf_le _ _
#align closure_operator.closure_inf_le ClosureOperator.closure_inf_le

section SemilatticeSup

variable [SemilatticeSup α] (c : ClosureOperator α)

/- warning: closure_operator.closure_sup_closure_le -> ClosureOperator.closure_sup_closure_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (x : α) (y : α), LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c x) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c y)) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (x : α) (y : α), LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Sup.sup.{u1} α (SemilatticeSup.toSup.{u1} α _inst_1) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) x) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) y)) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) (Sup.sup.{u1} α (SemilatticeSup.toSup.{u1} α _inst_1) x y))
Case conversion may be inaccurate. Consider using '#align closure_operator.closure_sup_closure_le ClosureOperator.closure_sup_closure_leₓ'. -/
theorem closure_sup_closure_le (x y : α) : c x ⊔ c y ≤ c (x ⊔ y) :=
  c.Monotone.le_map_sup _ _
#align closure_operator.closure_sup_closure_le ClosureOperator.closure_sup_closure_le

/- warning: closure_operator.closure_sup_closure_left -> ClosureOperator.closure_sup_closure_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (x : α) (y : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c x) y)) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (x : α) (y : α), Eq.{succ u1} α (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) (Sup.sup.{u1} α (SemilatticeSup.toSup.{u1} α _inst_1) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) x) y)) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) (Sup.sup.{u1} α (SemilatticeSup.toSup.{u1} α _inst_1) x y))
Case conversion may be inaccurate. Consider using '#align closure_operator.closure_sup_closure_left ClosureOperator.closure_sup_closure_leftₓ'. -/
theorem closure_sup_closure_left (x y : α) : c (c x ⊔ y) = c (x ⊔ y) :=
  ((c.le_closure_iff _ _).1
        (sup_le (c.Monotone le_sup_left) (le_sup_right.trans (c.le_closure _)))).antisymm
    (c.Monotone (sup_le_sup_right (c.le_closure _) _))
#align closure_operator.closure_sup_closure_left ClosureOperator.closure_sup_closure_left

/- warning: closure_operator.closure_sup_closure_right -> ClosureOperator.closure_sup_closure_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (x : α) (y : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c y))) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (x : α) (y : α), Eq.{succ u1} α (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) (Sup.sup.{u1} α (SemilatticeSup.toSup.{u1} α _inst_1) x (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) y))) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) (Sup.sup.{u1} α (SemilatticeSup.toSup.{u1} α _inst_1) x y))
Case conversion may be inaccurate. Consider using '#align closure_operator.closure_sup_closure_right ClosureOperator.closure_sup_closure_rightₓ'. -/
theorem closure_sup_closure_right (x y : α) : c (x ⊔ c y) = c (x ⊔ y) := by
  rw [sup_comm, closure_sup_closure_left, sup_comm]
#align closure_operator.closure_sup_closure_right ClosureOperator.closure_sup_closure_right

/- warning: closure_operator.closure_sup_closure -> ClosureOperator.closure_sup_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (x : α) (y : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c x) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c y))) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) c (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : SemilatticeSup.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (x : α) (y : α), Eq.{succ u1} α (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) (Sup.sup.{u1} α (SemilatticeSup.toSup.{u1} α _inst_1) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) x) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) y))) (OrderHom.toFun.{u1, u1} α α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) (ClosureOperator.toOrderHom.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) c) (Sup.sup.{u1} α (SemilatticeSup.toSup.{u1} α _inst_1) x y))
Case conversion may be inaccurate. Consider using '#align closure_operator.closure_sup_closure ClosureOperator.closure_sup_closureₓ'. -/
theorem closure_sup_closure (x y : α) : c (c x ⊔ c y) = c (x ⊔ y) := by
  rw [closure_sup_closure_left, closure_sup_closure_right]
#align closure_operator.closure_sup_closure ClosureOperator.closure_sup_closure

end SemilatticeSup

section CompleteLattice

variable [CompleteLattice α] (c : ClosureOperator α)

/- warning: closure_operator.closure_supr_closure -> ClosureOperator.closure_supᵢ_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Sort.{u2}} [_inst_1 : CompleteLattice.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) (f : ι -> α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) c (supᵢ.{u1, u2} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) ι (fun (i : ι) => coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) c (f i)))) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) c (supᵢ.{u1, u2} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) ι (fun (i : ι) => f i)))
but is expected to have type
  forall {α : Type.{u2}} {ι : Sort.{u1}} [_inst_1 : CompleteLattice.{u2} α] (c : ClosureOperator.{u2} α (PartialOrder.toPreorder.{u2} α (CompleteSemilatticeInf.toPartialOrder.{u2} α (CompleteLattice.toCompleteSemilatticeInf.{u2} α _inst_1)))) (f : ι -> α), Eq.{succ u2} α (OrderHom.toFun.{u2, u2} α α (PartialOrder.toPreorder.{u2} α (CompleteSemilatticeInf.toPartialOrder.{u2} α (CompleteLattice.toCompleteSemilatticeInf.{u2} α _inst_1))) (PartialOrder.toPreorder.{u2} α (CompleteSemilatticeInf.toPartialOrder.{u2} α (CompleteLattice.toCompleteSemilatticeInf.{u2} α _inst_1))) (ClosureOperator.toOrderHom.{u2} α (PartialOrder.toPreorder.{u2} α (CompleteSemilatticeInf.toPartialOrder.{u2} α (CompleteLattice.toCompleteSemilatticeInf.{u2} α _inst_1))) c) (supᵢ.{u2, u1} α (CompleteLattice.toSupSet.{u2} α _inst_1) ι (fun (i : ι) => OrderHom.toFun.{u2, u2} α α (PartialOrder.toPreorder.{u2} α (CompleteSemilatticeInf.toPartialOrder.{u2} α (CompleteLattice.toCompleteSemilatticeInf.{u2} α _inst_1))) (PartialOrder.toPreorder.{u2} α (CompleteSemilatticeInf.toPartialOrder.{u2} α (CompleteLattice.toCompleteSemilatticeInf.{u2} α _inst_1))) (ClosureOperator.toOrderHom.{u2} α (PartialOrder.toPreorder.{u2} α (CompleteSemilatticeInf.toPartialOrder.{u2} α (CompleteLattice.toCompleteSemilatticeInf.{u2} α _inst_1))) c) (f i)))) (OrderHom.toFun.{u2, u2} α α (PartialOrder.toPreorder.{u2} α (CompleteSemilatticeInf.toPartialOrder.{u2} α (CompleteLattice.toCompleteSemilatticeInf.{u2} α _inst_1))) (PartialOrder.toPreorder.{u2} α (CompleteSemilatticeInf.toPartialOrder.{u2} α (CompleteLattice.toCompleteSemilatticeInf.{u2} α _inst_1))) (ClosureOperator.toOrderHom.{u2} α (PartialOrder.toPreorder.{u2} α (CompleteSemilatticeInf.toPartialOrder.{u2} α (CompleteLattice.toCompleteSemilatticeInf.{u2} α _inst_1))) c) (supᵢ.{u2, u1} α (CompleteLattice.toSupSet.{u2} α _inst_1) ι (fun (i : ι) => f i)))
Case conversion may be inaccurate. Consider using '#align closure_operator.closure_supr_closure ClosureOperator.closure_supᵢ_closureₓ'. -/
@[simp]
theorem closure_supᵢ_closure (f : ι → α) : c (⨆ i, c (f i)) = c (⨆ i, f i) :=
  le_antisymm ((c.le_closure_iff _ _).1 <| supᵢ_le fun i => c.Monotone <| le_supᵢ f i) <|
    c.Monotone <| supᵢ_mono fun i => c.le_closure _
#align closure_operator.closure_supr_closure ClosureOperator.closure_supᵢ_closure

/- warning: closure_operator.closure_supr₂_closure -> ClosureOperator.closure_supᵢ₂_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Sort.{u2}} {κ : ι -> Sort.{u3}} [_inst_1 : CompleteLattice.{u1} α] (c : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) (f : forall (i : ι), (κ i) -> α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) c (supᵢ.{u1, u2} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) ι (fun (i : ι) => supᵢ.{u1, u3} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) (κ i) (fun (j : κ i) => coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) c (f i j))))) (coeFn.{succ u1, succ u1} (ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) (fun (_x : ClosureOperator.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) => α -> α) (ClosureOperator.hasCoeToFun.{u1} α (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1)))) c (supᵢ.{u1, u2} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) ι (fun (i : ι) => supᵢ.{u1, u3} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) (κ i) (fun (j : κ i) => f i j))))
but is expected to have type
  forall {α : Type.{u3}} {ι : Sort.{u2}} {κ : ι -> Sort.{u1}} [_inst_1 : CompleteLattice.{u3} α] (c : ClosureOperator.{u3} α (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1)))) (f : forall (i : ι), (κ i) -> α), Eq.{succ u3} α (OrderHom.toFun.{u3, u3} α α (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) (ClosureOperator.toOrderHom.{u3} α (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) c) (supᵢ.{u3, u2} α (CompleteLattice.toSupSet.{u3} α _inst_1) ι (fun (i : ι) => supᵢ.{u3, u1} α (CompleteLattice.toSupSet.{u3} α _inst_1) (κ i) (fun (j : κ i) => OrderHom.toFun.{u3, u3} α α (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) (ClosureOperator.toOrderHom.{u3} α (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) c) (f i j))))) (OrderHom.toFun.{u3, u3} α α (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) (ClosureOperator.toOrderHom.{u3} α (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) c) (supᵢ.{u3, u2} α (CompleteLattice.toSupSet.{u3} α _inst_1) ι (fun (i : ι) => supᵢ.{u3, u1} α (CompleteLattice.toSupSet.{u3} α _inst_1) (κ i) (fun (j : κ i) => f i j))))
Case conversion may be inaccurate. Consider using '#align closure_operator.closure_supr₂_closure ClosureOperator.closure_supᵢ₂_closureₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem closure_supᵢ₂_closure (f : ∀ i, κ i → α) :
    c (⨆ (i) (j), c (f i j)) = c (⨆ (i) (j), f i j) :=
  le_antisymm ((c.le_closure_iff _ _).1 <| supᵢ₂_le fun i j => c.Monotone <| le_supᵢ₂ i j) <|
    c.Monotone <| supᵢ₂_mono fun i j => c.le_closure _
#align closure_operator.closure_supr₂_closure ClosureOperator.closure_supᵢ₂_closure

end CompleteLattice

end ClosureOperator

/-! ### Lower adjoint -/


variable {α} {β : Type _}

#print LowerAdjoint /-
/-- A lower adjoint of `u` on the preorder `α` is a function `l` such that `l` and `u` form a Galois
connection. It allows us to define closure operators whose output does not match the input. In
practice, `u` is often `coe : β → α`. -/
structure LowerAdjoint [Preorder α] [Preorder β] (u : β → α) where
  toFun : α → β
  gc' : GaloisConnection to_fun u
#align lower_adjoint LowerAdjoint
-/

namespace LowerAdjoint

variable (α)

#print LowerAdjoint.id /-
/-- The identity function as a lower adjoint to itself. -/
@[simps]
protected def id [Preorder α] : LowerAdjoint (id : α → α)
    where
  toFun x := x
  gc' := GaloisConnection.id
#align lower_adjoint.id LowerAdjoint.id
-/

variable {α}

instance [Preorder α] : Inhabited (LowerAdjoint (id : α → α)) :=
  ⟨LowerAdjoint.id α⟩

section Preorder

variable [Preorder α] [Preorder β] {u : β → α} (l : LowerAdjoint u)

instance : CoeFun (LowerAdjoint u) fun _ => α → β where coe := toFun

/-- See Note [custom simps projection] -/
def Simps.apply : α → β :=
  l
#align lower_adjoint.simps.apply LowerAdjoint.Simps.apply

/- warning: lower_adjoint.gc -> LowerAdjoint.gc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u), GaloisConnection.{u1, u2} α β _inst_1 _inst_2 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 u) l) u
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β _inst_1 _inst_2 u), GaloisConnection.{u2, u1} α β _inst_1 _inst_2 (LowerAdjoint.toFun.{u2, u1} α β _inst_1 _inst_2 u l) u
Case conversion may be inaccurate. Consider using '#align lower_adjoint.gc LowerAdjoint.gcₓ'. -/
theorem gc : GaloisConnection l u :=
  l.gc'
#align lower_adjoint.gc LowerAdjoint.gc

/- warning: lower_adjoint.ext -> LowerAdjoint.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l₁ : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) (l₂ : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u), (Eq.{max (succ u1) (succ u2)} ((fun (_x : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) => α -> β) l₁) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 u) l₁) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 u) l₂)) -> (Eq.{max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) l₁ l₂)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l₁ : LowerAdjoint.{u2, u1} α β _inst_1 _inst_2 u) (l₂ : LowerAdjoint.{u2, u1} α β _inst_1 _inst_2 u), (Eq.{max (succ u2) (succ u1)} (α -> β) (LowerAdjoint.toFun.{u2, u1} α β _inst_1 _inst_2 u l₁) (LowerAdjoint.toFun.{u2, u1} α β _inst_1 _inst_2 u l₂)) -> (Eq.{max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} α β _inst_1 _inst_2 u) l₁ l₂)
Case conversion may be inaccurate. Consider using '#align lower_adjoint.ext LowerAdjoint.extₓ'. -/
@[ext]
theorem ext : ∀ l₁ l₂ : LowerAdjoint u, (l₁ : α → β) = (l₂ : α → β) → l₁ = l₂
  | ⟨l₁, _⟩, ⟨l₂, _⟩, h => by
    congr
    exact h
#align lower_adjoint.ext LowerAdjoint.ext

/- warning: lower_adjoint.monotone -> LowerAdjoint.monotone is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u), Monotone.{u1, u1} α α _inst_1 _inst_1 (Function.comp.{succ u1, succ u2, succ u1} α β α u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 u) l))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β _inst_1 _inst_2 u), Monotone.{u2, u2} α α _inst_1 _inst_1 (Function.comp.{succ u2, succ u1, succ u2} α β α u (LowerAdjoint.toFun.{u2, u1} α β _inst_1 _inst_2 u l))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.monotone LowerAdjoint.monotoneₓ'. -/
@[mono]
theorem monotone : Monotone (u ∘ l) :=
  l.gc.monotone_u.comp l.gc.monotone_l
#align lower_adjoint.monotone LowerAdjoint.monotone

/- warning: lower_adjoint.le_closure -> LowerAdjoint.le_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) (x : α), LE.le.{u1} α (Preorder.toLE.{u1} α _inst_1) x (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 u) l x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β _inst_1 _inst_2 u) (x : α), LE.le.{u2} α (Preorder.toLE.{u2} α _inst_1) x (u (LowerAdjoint.toFun.{u2, u1} α β _inst_1 _inst_2 u l x))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.le_closure LowerAdjoint.le_closureₓ'. -/
/-- Every element is less than its closure. This property is sometimes referred to as extensivity or
inflationarity. -/
theorem le_closure (x : α) : x ≤ u (l x) :=
  l.gc.le_u_l _
#align lower_adjoint.le_closure LowerAdjoint.le_closure

end Preorder

section PartialOrder

variable [PartialOrder α] [Preorder β] {u : β → α} (l : LowerAdjoint u)

#print LowerAdjoint.closureOperator /-
/-- Every lower adjoint induces a closure operator given by the composition. This is the partial
order version of the statement that every adjunction induces a monad. -/
@[simps]
def closureOperator : ClosureOperator α
    where
  toFun x := u (l x)
  monotone' := l.Monotone
  le_closure' := l.le_closure
  idempotent' x := l.gc.u_l_u_eq_u (l x)
#align lower_adjoint.closure_operator LowerAdjoint.closureOperator
-/

/- warning: lower_adjoint.idempotent -> LowerAdjoint.idempotent is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) (x : α), Eq.{succ u1} α (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) l (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) l x)))) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) l x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_2 u) (x : α), Eq.{succ u2} α (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_2 u l (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_2 u l x)))) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_2 u l x))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.idempotent LowerAdjoint.idempotentₓ'. -/
theorem idempotent (x : α) : u (l (u (l x))) = u (l x) :=
  l.ClosureOperator.idempotent _
#align lower_adjoint.idempotent LowerAdjoint.idempotent

/- warning: lower_adjoint.le_closure_iff -> LowerAdjoint.le_closure_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) (x : α) (y : α), Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) x (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) l y))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) l x)) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_2 u) l y)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_2 u) (x : α) (y : α), Iff (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) x (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_2 u l y))) (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_2 u l x)) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_2 u l y)))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.le_closure_iff LowerAdjoint.le_closure_iffₓ'. -/
theorem le_closure_iff (x y : α) : x ≤ u (l y) ↔ u (l x) ≤ u (l y) :=
  l.ClosureOperator.le_closure_iff _ _
#align lower_adjoint.le_closure_iff LowerAdjoint.le_closure_iff

end PartialOrder

section Preorder

variable [Preorder α] [Preorder β] {u : β → α} (l : LowerAdjoint u)

#print LowerAdjoint.closed /-
/-- An element `x` is closed for `l : lower_adjoint u` if it is a fixed point: `u (l x) = x` -/
def closed : Set α := fun x => u (l x) = x
#align lower_adjoint.closed LowerAdjoint.closed
-/

/- warning: lower_adjoint.mem_closed_iff -> LowerAdjoint.mem_closed_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) (x : α), Iff (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x (LowerAdjoint.closed.{u1, u2} α β _inst_1 _inst_2 u l)) (Eq.{succ u1} α (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 u) l x)) x)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β _inst_1 _inst_2 u) (x : α), Iff (Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) x (LowerAdjoint.closed.{u2, u1} α β _inst_1 _inst_2 u l)) (Eq.{succ u2} α (u (LowerAdjoint.toFun.{u2, u1} α β _inst_1 _inst_2 u l x)) x)
Case conversion may be inaccurate. Consider using '#align lower_adjoint.mem_closed_iff LowerAdjoint.mem_closed_iffₓ'. -/
theorem mem_closed_iff (x : α) : x ∈ l.closed ↔ u (l x) = x :=
  Iff.rfl
#align lower_adjoint.mem_closed_iff LowerAdjoint.mem_closed_iff

/- warning: lower_adjoint.closure_eq_self_of_mem_closed -> LowerAdjoint.closure_eq_self_of_mem_closed is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Preorder.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) {x : α}, (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x (LowerAdjoint.closed.{u1, u2} α β _inst_1 _inst_2 u l)) -> (Eq.{succ u1} α (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β _inst_1 _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 u) l x)) x)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Preorder.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β _inst_1 _inst_2 u) {x : α}, (Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) x (LowerAdjoint.closed.{u2, u1} α β _inst_1 _inst_2 u l)) -> (Eq.{succ u2} α (u (LowerAdjoint.toFun.{u2, u1} α β _inst_1 _inst_2 u l x)) x)
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_eq_self_of_mem_closed LowerAdjoint.closure_eq_self_of_mem_closedₓ'. -/
theorem closure_eq_self_of_mem_closed {x : α} (h : x ∈ l.closed) : u (l x) = x :=
  h
#align lower_adjoint.closure_eq_self_of_mem_closed LowerAdjoint.closure_eq_self_of_mem_closed

end Preorder

section PartialOrder

variable [PartialOrder α] [PartialOrder β] {u : β → α} (l : LowerAdjoint u)

/- warning: lower_adjoint.mem_closed_iff_closure_le -> LowerAdjoint.mem_closed_iff_closure_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : PartialOrder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) (x : α), Iff (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x (LowerAdjoint.closed.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u l)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) l x)) x)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : PartialOrder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u) (x : α), Iff (Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) x (LowerAdjoint.closed.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u l)) (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u l x)) x)
Case conversion may be inaccurate. Consider using '#align lower_adjoint.mem_closed_iff_closure_le LowerAdjoint.mem_closed_iff_closure_leₓ'. -/
theorem mem_closed_iff_closure_le (x : α) : x ∈ l.closed ↔ u (l x) ≤ x :=
  l.ClosureOperator.mem_closed_iff_closure_le _
#align lower_adjoint.mem_closed_iff_closure_le LowerAdjoint.mem_closed_iff_closure_le

/- warning: lower_adjoint.closure_is_closed -> LowerAdjoint.closure_is_closed is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : PartialOrder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) (x : α), Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) l x)) (LowerAdjoint.closed.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u l)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : PartialOrder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u) (x : α), Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u l x)) (LowerAdjoint.closed.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u l)
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_is_closed LowerAdjoint.closure_is_closedₓ'. -/
@[simp]
theorem closure_is_closed (x : α) : u (l x) ∈ l.closed :=
  l.idempotent x
#align lower_adjoint.closure_is_closed LowerAdjoint.closure_is_closed

/- warning: lower_adjoint.closed_eq_range_close -> LowerAdjoint.closed_eq_range_close is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : PartialOrder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u), Eq.{succ u1} (Set.{u1} α) (LowerAdjoint.closed.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u l) (Set.range.{u1, succ u1} α α (Function.comp.{succ u1, succ u2, succ u1} α β α u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) l)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : PartialOrder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u), Eq.{succ u2} (Set.{u2} α) (LowerAdjoint.closed.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u l) (Set.range.{u2, succ u2} α α (Function.comp.{succ u2, succ u1, succ u2} α β α u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u l)))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closed_eq_range_close LowerAdjoint.closed_eq_range_closeₓ'. -/
/-- The set of closed elements for `l` is the range of `u ∘ l`. -/
theorem closed_eq_range_close : l.closed = Set.range (u ∘ l) :=
  l.ClosureOperator.closed_eq_range_close
#align lower_adjoint.closed_eq_range_close LowerAdjoint.closed_eq_range_close

#print LowerAdjoint.toClosed /-
/-- Send an `x` to an element of the set of closed elements (by taking the closure). -/
def toClosed (x : α) : l.closed :=
  ⟨u (l x), l.closure_is_closed x⟩
#align lower_adjoint.to_closed LowerAdjoint.toClosed
-/

/- warning: lower_adjoint.closure_le_closed_iff_le -> LowerAdjoint.closure_le_closed_iff_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : PartialOrder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) (x : α) {y : α}, (LowerAdjoint.closed.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u l y) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) (PartialOrder.toPreorder.{u2} β _inst_2) u) l x)) y) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) x y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : PartialOrder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u) (x : α) {y : α}, (LowerAdjoint.closed.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u l y) -> (Iff (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) (PartialOrder.toPreorder.{u1} β _inst_2) u l x)) y) (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) x y))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_le_closed_iff_le LowerAdjoint.closure_le_closed_iff_leₓ'. -/
@[simp]
theorem closure_le_closed_iff_le (x : α) {y : α} (hy : l.closed y) : u (l x) ≤ y ↔ x ≤ y :=
  l.ClosureOperator.closure_le_closed_iff_le x hy
#align lower_adjoint.closure_le_closed_iff_le LowerAdjoint.closure_le_closed_iff_le

end PartialOrder

/- warning: lower_adjoint.closure_top -> LowerAdjoint.closure_top is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : PartialOrder.{u1} α] [_inst_2 : OrderTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1))] [_inst_3 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_3 u), Eq.{succ u1} α (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_3 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_3 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α _inst_1) _inst_3 u) l (Top.top.{u1} α (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) _inst_2)))) (Top.top.{u1} α (OrderTop.toHasTop.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_1)) _inst_2))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : PartialOrder.{u2} α] [_inst_2 : OrderTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1))] [_inst_3 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_3 u), Eq.{succ u2} α (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α _inst_1) _inst_3 u l (Top.top.{u2} α (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) _inst_2)))) (Top.top.{u2} α (OrderTop.toTop.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α _inst_1)) _inst_2))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_top LowerAdjoint.closure_topₓ'. -/
theorem closure_top [PartialOrder α] [OrderTop α] [Preorder β] {u : β → α} (l : LowerAdjoint u) :
    u (l ⊤) = ⊤ :=
  l.ClosureOperator.closure_top
#align lower_adjoint.closure_top LowerAdjoint.closure_top

/- warning: lower_adjoint.closure_inf_le -> LowerAdjoint.closure_inf_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeInf.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (x : α) (y : α), LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1))) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l (Inf.inf.{u1} α (SemilatticeInf.toHasInf.{u1} α _inst_1) x y))) (Inf.inf.{u1} α (SemilatticeInf.toHasInf.{u1} α _inst_1) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l x)) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l y)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeInf.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1)) _inst_2 u) (x : α) (y : α), LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1))) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1)) _inst_2 u l (Inf.inf.{u2} α (SemilatticeInf.toInf.{u2} α _inst_1) x y))) (Inf.inf.{u2} α (SemilatticeInf.toInf.{u2} α _inst_1) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1)) _inst_2 u l x)) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α _inst_1)) _inst_2 u l y)))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_inf_le LowerAdjoint.closure_inf_leₓ'. -/
theorem closure_inf_le [SemilatticeInf α] [Preorder β] {u : β → α} (l : LowerAdjoint u) (x y : α) :
    u (l (x ⊓ y)) ≤ u (l x) ⊓ u (l y) :=
  l.ClosureOperator.closure_inf_le x y
#align lower_adjoint.closure_inf_le LowerAdjoint.closure_inf_le

section SemilatticeSup

variable [SemilatticeSup α] [Preorder β] {u : β → α} (l : LowerAdjoint u)

/- warning: lower_adjoint.closure_sup_closure_le -> LowerAdjoint.closure_sup_closure_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (x : α) (y : α), LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1))) (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l x)) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l y))) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x y)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u) (x : α) (y : α), LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1))) (Sup.sup.{u2} α (SemilatticeSup.toSup.{u2} α _inst_1) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l x)) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l y))) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l (Sup.sup.{u2} α (SemilatticeSup.toSup.{u2} α _inst_1) x y)))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_sup_closure_le LowerAdjoint.closure_sup_closure_leₓ'. -/
theorem closure_sup_closure_le (x y : α) : u (l x) ⊔ u (l y) ≤ u (l (x ⊔ y)) :=
  l.ClosureOperator.closure_sup_closure_le x y
#align lower_adjoint.closure_sup_closure_le LowerAdjoint.closure_sup_closure_le

/- warning: lower_adjoint.closure_sup_closure_left -> LowerAdjoint.closure_sup_closure_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (x : α) (y : α), Eq.{succ u1} α (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l x)) y))) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x y)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u) (x : α) (y : α), Eq.{succ u2} α (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l (Sup.sup.{u2} α (SemilatticeSup.toSup.{u2} α _inst_1) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l x)) y))) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l (Sup.sup.{u2} α (SemilatticeSup.toSup.{u2} α _inst_1) x y)))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_sup_closure_left LowerAdjoint.closure_sup_closure_leftₓ'. -/
theorem closure_sup_closure_left (x y : α) : u (l (u (l x) ⊔ y)) = u (l (x ⊔ y)) :=
  l.ClosureOperator.closure_sup_closure_left x y
#align lower_adjoint.closure_sup_closure_left LowerAdjoint.closure_sup_closure_left

/- warning: lower_adjoint.closure_sup_closure_right -> LowerAdjoint.closure_sup_closure_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (x : α) (y : α), Eq.{succ u1} α (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l y))))) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x y)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u) (x : α) (y : α), Eq.{succ u2} α (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l (Sup.sup.{u2} α (SemilatticeSup.toSup.{u2} α _inst_1) x (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l y))))) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l (Sup.sup.{u2} α (SemilatticeSup.toSup.{u2} α _inst_1) x y)))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_sup_closure_right LowerAdjoint.closure_sup_closure_rightₓ'. -/
theorem closure_sup_closure_right (x y : α) : u (l (x ⊔ u (l y))) = u (l (x ⊔ y)) :=
  l.ClosureOperator.closure_sup_closure_right x y
#align lower_adjoint.closure_sup_closure_right LowerAdjoint.closure_sup_closure_right

/- warning: lower_adjoint.closure_sup_closure -> LowerAdjoint.closure_sup_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SemilatticeSup.{u1} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (x : α) (y : α), Eq.{succ u1} α (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l x)) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l y))))) (u (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u2} α β (PartialOrder.toPreorder.{u1} α (SemilatticeSup.toPartialOrder.{u1} α _inst_1)) _inst_2 u) l (Sup.sup.{u1} α (SemilatticeSup.toHasSup.{u1} α _inst_1) x y)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SemilatticeSup.{u2} α] [_inst_2 : Preorder.{u1} β] {u : β -> α} (l : LowerAdjoint.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u) (x : α) (y : α), Eq.{succ u2} α (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l (Sup.sup.{u2} α (SemilatticeSup.toSup.{u2} α _inst_1) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l x)) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l y))))) (u (LowerAdjoint.toFun.{u2, u1} α β (PartialOrder.toPreorder.{u2} α (SemilatticeSup.toPartialOrder.{u2} α _inst_1)) _inst_2 u l (Sup.sup.{u2} α (SemilatticeSup.toSup.{u2} α _inst_1) x y)))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_sup_closure LowerAdjoint.closure_sup_closureₓ'. -/
theorem closure_sup_closure (x y : α) : u (l (u (l x) ⊔ u (l y))) = u (l (x ⊔ y)) :=
  l.ClosureOperator.closure_sup_closure x y
#align lower_adjoint.closure_sup_closure LowerAdjoint.closure_sup_closure

end SemilatticeSup

section CompleteLattice

variable [CompleteLattice α] [Preorder β] {u : β → α} (l : LowerAdjoint u)

/- warning: lower_adjoint.closure_supr_closure -> LowerAdjoint.closure_supᵢ_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Sort.{u2}} {β : Type.{u3}} [_inst_1 : CompleteLattice.{u1} α] [_inst_2 : Preorder.{u3} β] {u : β -> α} (l : LowerAdjoint.{u1, u3} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) (f : ι -> α), Eq.{succ u1} α (u (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LowerAdjoint.{u1, u3} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u3} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u3} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) l (supᵢ.{u1, u2} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) ι (fun (i : ι) => u (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LowerAdjoint.{u1, u3} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u3} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u3} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) l (f i)))))) (u (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (LowerAdjoint.{u1, u3} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u3} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u3} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) l (supᵢ.{u1, u2} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) ι (fun (i : ι) => f i))))
but is expected to have type
  forall {α : Type.{u3}} {ι : Sort.{u1}} {β : Type.{u2}} [_inst_1 : CompleteLattice.{u3} α] [_inst_2 : Preorder.{u2} β] {u : β -> α} (l : LowerAdjoint.{u3, u2} α β (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) _inst_2 u) (f : ι -> α), Eq.{succ u3} α (u (LowerAdjoint.toFun.{u3, u2} α β (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) _inst_2 u l (supᵢ.{u3, u1} α (CompleteLattice.toSupSet.{u3} α _inst_1) ι (fun (i : ι) => u (LowerAdjoint.toFun.{u3, u2} α β (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) _inst_2 u l (f i)))))) (u (LowerAdjoint.toFun.{u3, u2} α β (PartialOrder.toPreorder.{u3} α (CompleteSemilatticeInf.toPartialOrder.{u3} α (CompleteLattice.toCompleteSemilatticeInf.{u3} α _inst_1))) _inst_2 u l (supᵢ.{u3, u1} α (CompleteLattice.toSupSet.{u3} α _inst_1) ι (fun (i : ι) => f i))))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_supr_closure LowerAdjoint.closure_supᵢ_closureₓ'. -/
theorem closure_supᵢ_closure (f : ι → α) : u (l (⨆ i, u (l (f i)))) = u (l (⨆ i, f i)) :=
  l.ClosureOperator.closure_supᵢ_closure _
#align lower_adjoint.closure_supr_closure LowerAdjoint.closure_supᵢ_closure

/- warning: lower_adjoint.closure_supr₂_closure -> LowerAdjoint.closure_supᵢ₂_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Sort.{u2}} {κ : ι -> Sort.{u3}} {β : Type.{u4}} [_inst_1 : CompleteLattice.{u1} α] [_inst_2 : Preorder.{u4} β] {u : β -> α} (l : LowerAdjoint.{u1, u4} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) (f : forall (i : ι), (κ i) -> α), Eq.{succ u1} α (u (coeFn.{max (succ u1) (succ u4), max (succ u1) (succ u4)} (LowerAdjoint.{u1, u4} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u4} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u4} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) l (supᵢ.{u1, u2} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) ι (fun (i : ι) => supᵢ.{u1, u3} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) (κ i) (fun (j : κ i) => u (coeFn.{max (succ u1) (succ u4), max (succ u1) (succ u4)} (LowerAdjoint.{u1, u4} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u4} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u4} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) l (f i j))))))) (u (coeFn.{max (succ u1) (succ u4), max (succ u1) (succ u4)} (LowerAdjoint.{u1, u4} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) (fun (_x : LowerAdjoint.{u1, u4} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) => α -> β) (LowerAdjoint.hasCoeToFun.{u1, u4} α β (PartialOrder.toPreorder.{u1} α (CompleteSemilatticeInf.toPartialOrder.{u1} α (CompleteLattice.toCompleteSemilatticeInf.{u1} α _inst_1))) _inst_2 u) l (supᵢ.{u1, u2} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) ι (fun (i : ι) => supᵢ.{u1, u3} α (CompleteSemilatticeSup.toHasSup.{u1} α (CompleteLattice.toCompleteSemilatticeSup.{u1} α _inst_1)) (κ i) (fun (j : κ i) => f i j)))))
but is expected to have type
  forall {α : Type.{u4}} {ι : Sort.{u2}} {κ : ι -> Sort.{u1}} {β : Type.{u3}} [_inst_1 : CompleteLattice.{u4} α] [_inst_2 : Preorder.{u3} β] {u : β -> α} (l : LowerAdjoint.{u4, u3} α β (PartialOrder.toPreorder.{u4} α (CompleteSemilatticeInf.toPartialOrder.{u4} α (CompleteLattice.toCompleteSemilatticeInf.{u4} α _inst_1))) _inst_2 u) (f : forall (i : ι), (κ i) -> α), Eq.{succ u4} α (u (LowerAdjoint.toFun.{u4, u3} α β (PartialOrder.toPreorder.{u4} α (CompleteSemilatticeInf.toPartialOrder.{u4} α (CompleteLattice.toCompleteSemilatticeInf.{u4} α _inst_1))) _inst_2 u l (supᵢ.{u4, u2} α (CompleteLattice.toSupSet.{u4} α _inst_1) ι (fun (i : ι) => supᵢ.{u4, u1} α (CompleteLattice.toSupSet.{u4} α _inst_1) (κ i) (fun (j : κ i) => u (LowerAdjoint.toFun.{u4, u3} α β (PartialOrder.toPreorder.{u4} α (CompleteSemilatticeInf.toPartialOrder.{u4} α (CompleteLattice.toCompleteSemilatticeInf.{u4} α _inst_1))) _inst_2 u l (f i j))))))) (u (LowerAdjoint.toFun.{u4, u3} α β (PartialOrder.toPreorder.{u4} α (CompleteSemilatticeInf.toPartialOrder.{u4} α (CompleteLattice.toCompleteSemilatticeInf.{u4} α _inst_1))) _inst_2 u l (supᵢ.{u4, u2} α (CompleteLattice.toSupSet.{u4} α _inst_1) ι (fun (i : ι) => supᵢ.{u4, u1} α (CompleteLattice.toSupSet.{u4} α _inst_1) (κ i) (fun (j : κ i) => f i j)))))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_supr₂_closure LowerAdjoint.closure_supᵢ₂_closureₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
theorem closure_supᵢ₂_closure (f : ∀ i, κ i → α) :
    u (l <| ⨆ (i) (j), u (l <| f i j)) = u (l <| ⨆ (i) (j), f i j) :=
  l.ClosureOperator.closure_supᵢ₂_closure _
#align lower_adjoint.closure_supr₂_closure LowerAdjoint.closure_supᵢ₂_closure

end CompleteLattice

-- Lemmas for `lower_adjoint (coe : α → set β)`, where `set_like α β`
section CoeToSet

variable [SetLike α β] (l : LowerAdjoint (coe : α → Set β))

/- warning: lower_adjoint.subset_closure -> LowerAdjoint.subset_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (s : Set.{u2} β), HasSubset.Subset.{u2} (Set.{u2} β) (Set.hasSubset.{u2} β) s ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l s))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1)) (s : Set.{u2} β), HasSubset.Subset.{u2} (Set.{u2} β) (Set.instHasSubsetSet.{u2} β) s (SetLike.coe.{u1, u2} α β _inst_1 (LowerAdjoint.toFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1) l s))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.subset_closure LowerAdjoint.subset_closureₓ'. -/
theorem subset_closure (s : Set β) : s ⊆ l s :=
  l.le_closure s
#align lower_adjoint.subset_closure LowerAdjoint.subset_closure

/- warning: lower_adjoint.not_mem_of_not_mem_closure -> LowerAdjoint.not_mem_of_not_mem_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) {s : Set.{u2} β} {P : β}, (Not (Membership.Mem.{u2, u1} β α (SetLike.hasMem.{u1, u2} α β _inst_1) P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l s))) -> (Not (Membership.Mem.{u2, u2} β (Set.{u2} β) (Set.hasMem.{u2} β) P s))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1)) {s : Set.{u2} β} {P : β}, (Not (Membership.mem.{u2, u1} β α (SetLike.instMembership.{u1, u2} α β _inst_1) P (LowerAdjoint.toFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1) l s))) -> (Not (Membership.mem.{u2, u2} β (Set.{u2} β) (Set.instMembershipSet.{u2} β) P s))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.not_mem_of_not_mem_closure LowerAdjoint.not_mem_of_not_mem_closureₓ'. -/
theorem not_mem_of_not_mem_closure {s : Set β} {P : β} (hP : P ∉ l s) : P ∉ s := fun h =>
  hP (subset_closure _ s h)
#align lower_adjoint.not_mem_of_not_mem_closure LowerAdjoint.not_mem_of_not_mem_closure

/- warning: lower_adjoint.le_iff_subset -> LowerAdjoint.le_iff_subset is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (s : Set.{u2} β) (S : α), Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l s) S) (HasSubset.Subset.{u2} (Set.{u2} β) (Set.hasSubset.{u2} β) s ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) S))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1)) (s : Set.{u2} β) (S : α), Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1))) (LowerAdjoint.toFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1) l s) S) (HasSubset.Subset.{u2} (Set.{u2} β) (Set.instHasSubsetSet.{u2} β) s (SetLike.coe.{u1, u2} α β _inst_1 S))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.le_iff_subset LowerAdjoint.le_iff_subsetₓ'. -/
theorem le_iff_subset (s : Set β) (S : α) : l s ≤ S ↔ s ⊆ S :=
  l.gc s S
#align lower_adjoint.le_iff_subset LowerAdjoint.le_iff_subset

/- warning: lower_adjoint.mem_iff -> LowerAdjoint.mem_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (s : Set.{u2} β) (x : β), Iff (Membership.Mem.{u2, u1} β α (SetLike.hasMem.{u1, u2} α β _inst_1) x (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l s)) (forall (S : α), (HasSubset.Subset.{u2} (Set.{u2} β) (Set.hasSubset.{u2} β) s ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) S)) -> (Membership.Mem.{u2, u1} β α (SetLike.hasMem.{u1, u2} α β _inst_1) x S))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1)) (s : Set.{u2} β) (x : β), Iff (Membership.mem.{u2, u1} β α (SetLike.instMembership.{u1, u2} α β _inst_1) x (LowerAdjoint.toFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1) l s)) (forall (S : α), (HasSubset.Subset.{u2} (Set.{u2} β) (Set.instHasSubsetSet.{u2} β) s (SetLike.coe.{u1, u2} α β _inst_1 S)) -> (Membership.mem.{u2, u1} β α (SetLike.instMembership.{u1, u2} α β _inst_1) x S))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.mem_iff LowerAdjoint.mem_iffₓ'. -/
theorem mem_iff (s : Set β) (x : β) : x ∈ l s ↔ ∀ S : α, s ⊆ S → x ∈ S :=
  by
  simp_rw [← SetLike.mem_coe, ← Set.singleton_subset_iff, ← l.le_iff_subset]
  exact ⟨fun h S => h.trans, fun h => h _ le_rfl⟩
#align lower_adjoint.mem_iff LowerAdjoint.mem_iff

/- warning: lower_adjoint.eq_of_le -> LowerAdjoint.eq_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) {s : Set.{u2} β} {S : α}, (HasSubset.Subset.{u2} (Set.{u2} β) (Set.hasSubset.{u2} β) s ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) S)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1))) S (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l s)) -> (Eq.{succ u1} α (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l s) S)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1)) {s : Set.{u2} β} {S : α}, (HasSubset.Subset.{u2} (Set.{u2} β) (Set.instHasSubsetSet.{u2} β) s (SetLike.coe.{u1, u2} α β _inst_1 S)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1))) S (LowerAdjoint.toFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1) l s)) -> (Eq.{succ u1} α (LowerAdjoint.toFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1) l s) S)
Case conversion may be inaccurate. Consider using '#align lower_adjoint.eq_of_le LowerAdjoint.eq_of_leₓ'. -/
theorem eq_of_le {s : Set β} {S : α} (h₁ : s ⊆ S) (h₂ : S ≤ l s) : l s = S :=
  ((l.le_iff_subset _ _).2 h₁).antisymm h₂
#align lower_adjoint.eq_of_le LowerAdjoint.eq_of_le

/- warning: lower_adjoint.closure_union_closure_subset -> LowerAdjoint.closure_union_closure_subset is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (x : α) (y : α), HasSubset.Subset.{u2} (Set.{u2} β) (Set.hasSubset.{u2} β) (Union.union.{u2} (Set.{u2} β) (Set.hasUnion.{u2} β) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) x))) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) y)))) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l (Union.union.{u2} (Set.{u2} β) (Set.hasUnion.{u2} β) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) x) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) y))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1)) (x : α) (y : α), HasSubset.Subset.{u2} (Set.{u2} β) (Set.instHasSubsetSet.{u2} β) (Union.union.{u2} (Set.{u2} β) (Set.instUnionSet.{u2} β) (SetLike.coe.{u1, u2} α β _inst_1 (LowerAdjoint.toFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1) l (SetLike.coe.{u1, u2} α β _inst_1 x))) (SetLike.coe.{u1, u2} α β _inst_1 (LowerAdjoint.toFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1) l (SetLike.coe.{u1, u2} α β _inst_1 y)))) (SetLike.coe.{u1, u2} α β _inst_1 (LowerAdjoint.toFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.instPartialOrder.{u1, u2} α β _inst_1)) (SetLike.coe.{u1, u2} α β _inst_1) l (Union.union.{u2} (Set.{u2} β) (Set.instUnionSet.{u2} β) (SetLike.coe.{u1, u2} α β _inst_1 x) (SetLike.coe.{u1, u2} α β _inst_1 y))))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_union_closure_subset LowerAdjoint.closure_union_closure_subsetₓ'. -/
theorem closure_union_closure_subset (x y : α) : (l x : Set β) ∪ l y ⊆ l (x ∪ y) :=
  l.closure_sup_closure_le x y
#align lower_adjoint.closure_union_closure_subset LowerAdjoint.closure_union_closure_subset

/- warning: lower_adjoint.closure_union_closure_left -> LowerAdjoint.closure_union_closure_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (x : α) (y : α), Eq.{succ u1} α (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l (Union.union.{u2} (Set.{u2} β) (Set.hasUnion.{u2} β) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) x))) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) y))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l (Union.union.{u2} (Set.{u2} β) (Set.hasUnion.{u2} β) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) x) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) y)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SetLike.{u2, u1} α β] (l : LowerAdjoint.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1)) (x : α) (y : α), Eq.{succ u2} α (LowerAdjoint.toFun.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1) l (Union.union.{u1} (Set.{u1} β) (Set.instUnionSet.{u1} β) (SetLike.coe.{u2, u1} α β _inst_1 (LowerAdjoint.toFun.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1) l (SetLike.coe.{u2, u1} α β _inst_1 x))) (SetLike.coe.{u2, u1} α β _inst_1 y))) (LowerAdjoint.toFun.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1) l (Union.union.{u1} (Set.{u1} β) (Set.instUnionSet.{u1} β) (SetLike.coe.{u2, u1} α β _inst_1 x) (SetLike.coe.{u2, u1} α β _inst_1 y)))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_union_closure_left LowerAdjoint.closure_union_closure_leftₓ'. -/
@[simp]
theorem closure_union_closure_left (x y : α) : l (l x ∪ y) = l (x ∪ y) :=
  SetLike.coe_injective (l.closure_sup_closure_left x y)
#align lower_adjoint.closure_union_closure_left LowerAdjoint.closure_union_closure_left

/- warning: lower_adjoint.closure_union_closure_right -> LowerAdjoint.closure_union_closure_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (x : α) (y : α), Eq.{succ u1} α (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l (Union.union.{u2} (Set.{u2} β) (Set.hasUnion.{u2} β) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) x) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) y))))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l (Union.union.{u2} (Set.{u2} β) (Set.hasUnion.{u2} β) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) x) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) y)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SetLike.{u2, u1} α β] (l : LowerAdjoint.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1)) (x : α) (y : α), Eq.{succ u2} α (LowerAdjoint.toFun.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1) l (Union.union.{u1} (Set.{u1} β) (Set.instUnionSet.{u1} β) (SetLike.coe.{u2, u1} α β _inst_1 x) (SetLike.coe.{u2, u1} α β _inst_1 (LowerAdjoint.toFun.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1) l (SetLike.coe.{u2, u1} α β _inst_1 y))))) (LowerAdjoint.toFun.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1) l (Union.union.{u1} (Set.{u1} β) (Set.instUnionSet.{u1} β) (SetLike.coe.{u2, u1} α β _inst_1 x) (SetLike.coe.{u2, u1} α β _inst_1 y)))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_union_closure_right LowerAdjoint.closure_union_closure_rightₓ'. -/
@[simp]
theorem closure_union_closure_right (x y : α) : l (x ∪ l y) = l (x ∪ y) :=
  SetLike.coe_injective (l.closure_sup_closure_right x y)
#align lower_adjoint.closure_union_closure_right LowerAdjoint.closure_union_closure_right

/- warning: lower_adjoint.closure_union_closure -> LowerAdjoint.closure_union_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u1, u2} α β] (l : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (x : α) (y : α), Eq.{succ u1} α (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l (Union.union.{u2} (Set.{u2} β) (Set.hasUnion.{u2} β) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) x))) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) y))))) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) (fun (_x : LowerAdjoint.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) => (Set.{u2} β) -> α) (LowerAdjoint.hasCoeToFun.{u2, u1} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.completeBooleanAlgebra.{u2} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u2} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))))) l (Union.union.{u2} (Set.{u2} β) (Set.hasUnion.{u2} β) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) x) ((fun (a : Type.{u1}) (b : Type.{u2}) [self : HasLiftT.{succ u1, succ u2} a b] => self.0) α (Set.{u2} β) (HasLiftT.mk.{succ u1, succ u2} α (Set.{u2} β) (CoeTCₓ.coe.{succ u1, succ u2} α (Set.{u2} β) (SetLike.Set.hasCoeT.{u1, u2} α β _inst_1))) y)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : SetLike.{u2, u1} α β] (l : LowerAdjoint.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1)) (x : α) (y : α), Eq.{succ u2} α (LowerAdjoint.toFun.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1) l (Union.union.{u1} (Set.{u1} β) (Set.instUnionSet.{u1} β) (SetLike.coe.{u2, u1} α β _inst_1 (LowerAdjoint.toFun.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1) l (SetLike.coe.{u2, u1} α β _inst_1 x))) (SetLike.coe.{u2, u1} α β _inst_1 (LowerAdjoint.toFun.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1) l (SetLike.coe.{u2, u1} α β _inst_1 y))))) (LowerAdjoint.toFun.{u1, u2} (Set.{u1} β) α (PartialOrder.toPreorder.{u1} (Set.{u1} β) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} β) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} β) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} β) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} β) (Set.instCompleteBooleanAlgebraSet.{u1} β))))))) (PartialOrder.toPreorder.{u2} α (SetLike.instPartialOrder.{u2, u1} α β _inst_1)) (SetLike.coe.{u2, u1} α β _inst_1) l (Union.union.{u1} (Set.{u1} β) (Set.instUnionSet.{u1} β) (SetLike.coe.{u2, u1} α β _inst_1 x) (SetLike.coe.{u2, u1} α β _inst_1 y)))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_union_closure LowerAdjoint.closure_union_closureₓ'. -/
theorem closure_union_closure (x y : α) : l (l x ∪ l y) = l (x ∪ y) :=
  SetLike.coe_injective (l.ClosureOperator.closure_sup_closure x y)
#align lower_adjoint.closure_union_closure LowerAdjoint.closure_union_closure

/- warning: lower_adjoint.closure_Union_closure -> LowerAdjoint.closure_unionᵢ_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Sort.{u2}} {β : Type.{u3}} [_inst_1 : SetLike.{u1, u3} α β] (l : LowerAdjoint.{u3, u1} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.completeBooleanAlgebra.{u3} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u3} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))))) (f : ι -> α), Eq.{succ u1} α (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (LowerAdjoint.{u3, u1} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.completeBooleanAlgebra.{u3} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u3} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))))) (fun (_x : LowerAdjoint.{u3, u1} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.completeBooleanAlgebra.{u3} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u3} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))))) => (Set.{u3} β) -> α) (LowerAdjoint.hasCoeToFun.{u3, u1} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.completeBooleanAlgebra.{u3} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u3} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))))) l (Set.unionᵢ.{u3, u2} β ι (fun (i : ι) => (fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (LowerAdjoint.{u3, u1} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.completeBooleanAlgebra.{u3} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u3} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))))) (fun (_x : LowerAdjoint.{u3, u1} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.completeBooleanAlgebra.{u3} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u3} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))))) => (Set.{u3} β) -> α) (LowerAdjoint.hasCoeToFun.{u3, u1} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.completeBooleanAlgebra.{u3} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u3} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))))) l ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))) (f i)))))) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (LowerAdjoint.{u3, u1} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.completeBooleanAlgebra.{u3} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u3} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))))) (fun (_x : LowerAdjoint.{u3, u1} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.completeBooleanAlgebra.{u3} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u3} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))))) => (Set.{u3} β) -> α) (LowerAdjoint.hasCoeToFun.{u3, u1} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.completeBooleanAlgebra.{u3} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u3} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))))) l (Set.unionᵢ.{u3, u2} β ι (fun (i : ι) => (fun (a : Type.{u1}) (b : Type.{u3}) [self : HasLiftT.{succ u1, succ u3} a b] => self.0) α (Set.{u3} β) (HasLiftT.mk.{succ u1, succ u3} α (Set.{u3} β) (CoeTCₓ.coe.{succ u1, succ u3} α (Set.{u3} β) (SetLike.Set.hasCoeT.{u1, u3} α β _inst_1))) (f i))))
but is expected to have type
  forall {α : Type.{u3}} {ι : Sort.{u1}} {β : Type.{u2}} [_inst_1 : SetLike.{u3, u2} α β] (l : LowerAdjoint.{u2, u3} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u3} α (SetLike.instPartialOrder.{u3, u2} α β _inst_1)) (SetLike.coe.{u3, u2} α β _inst_1)) (f : ι -> α), Eq.{succ u3} α (LowerAdjoint.toFun.{u2, u3} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u3} α (SetLike.instPartialOrder.{u3, u2} α β _inst_1)) (SetLike.coe.{u3, u2} α β _inst_1) l (Set.unionᵢ.{u2, u1} β ι (fun (i : ι) => SetLike.coe.{u3, u2} α β _inst_1 (LowerAdjoint.toFun.{u2, u3} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u3} α (SetLike.instPartialOrder.{u3, u2} α β _inst_1)) (SetLike.coe.{u3, u2} α β _inst_1) l (SetLike.coe.{u3, u2} α β _inst_1 (f i)))))) (LowerAdjoint.toFun.{u2, u3} (Set.{u2} β) α (PartialOrder.toPreorder.{u2} (Set.{u2} β) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} β) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} β) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} β) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} β) (Set.instCompleteBooleanAlgebraSet.{u2} β))))))) (PartialOrder.toPreorder.{u3} α (SetLike.instPartialOrder.{u3, u2} α β _inst_1)) (SetLike.coe.{u3, u2} α β _inst_1) l (Set.unionᵢ.{u2, u1} β ι (fun (i : ι) => SetLike.coe.{u3, u2} α β _inst_1 (f i))))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_Union_closure LowerAdjoint.closure_unionᵢ_closureₓ'. -/
@[simp]
theorem closure_unionᵢ_closure (f : ι → α) : l (⋃ i, l (f i)) = l (⋃ i, f i) :=
  SetLike.coe_injective <| l.closure_supᵢ_closure _
#align lower_adjoint.closure_Union_closure LowerAdjoint.closure_unionᵢ_closure

/- warning: lower_adjoint.closure_Union₂_closure -> LowerAdjoint.closure_unionᵢ₂_closure is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Sort.{u2}} {κ : ι -> Sort.{u3}} {β : Type.{u4}} [_inst_1 : SetLike.{u1, u4} α β] (l : LowerAdjoint.{u4, u1} (Set.{u4} β) α (PartialOrder.toPreorder.{u4} (Set.{u4} β) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} β) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} β) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} β) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} β) (Set.completeBooleanAlgebra.{u4} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u4} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))))) (f : forall (i : ι), (κ i) -> α), Eq.{succ u1} α (coeFn.{max (succ u4) (succ u1), max (succ u4) (succ u1)} (LowerAdjoint.{u4, u1} (Set.{u4} β) α (PartialOrder.toPreorder.{u4} (Set.{u4} β) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} β) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} β) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} β) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} β) (Set.completeBooleanAlgebra.{u4} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u4} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))))) (fun (_x : LowerAdjoint.{u4, u1} (Set.{u4} β) α (PartialOrder.toPreorder.{u4} (Set.{u4} β) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} β) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} β) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} β) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} β) (Set.completeBooleanAlgebra.{u4} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u4} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))))) => (Set.{u4} β) -> α) (LowerAdjoint.hasCoeToFun.{u4, u1} (Set.{u4} β) α (PartialOrder.toPreorder.{u4} (Set.{u4} β) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} β) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} β) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} β) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} β) (Set.completeBooleanAlgebra.{u4} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u4} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))))) l (Set.unionᵢ.{u4, u2} β ι (fun (i : ι) => Set.unionᵢ.{u4, u3} β (κ i) (fun (j : κ i) => (fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))) (coeFn.{max (succ u4) (succ u1), max (succ u4) (succ u1)} (LowerAdjoint.{u4, u1} (Set.{u4} β) α (PartialOrder.toPreorder.{u4} (Set.{u4} β) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} β) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} β) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} β) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} β) (Set.completeBooleanAlgebra.{u4} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u4} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))))) (fun (_x : LowerAdjoint.{u4, u1} (Set.{u4} β) α (PartialOrder.toPreorder.{u4} (Set.{u4} β) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} β) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} β) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} β) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} β) (Set.completeBooleanAlgebra.{u4} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u4} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))))) => (Set.{u4} β) -> α) (LowerAdjoint.hasCoeToFun.{u4, u1} (Set.{u4} β) α (PartialOrder.toPreorder.{u4} (Set.{u4} β) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} β) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} β) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} β) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} β) (Set.completeBooleanAlgebra.{u4} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u4} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))))) l ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))) (f i j))))))) (coeFn.{max (succ u4) (succ u1), max (succ u4) (succ u1)} (LowerAdjoint.{u4, u1} (Set.{u4} β) α (PartialOrder.toPreorder.{u4} (Set.{u4} β) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} β) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} β) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} β) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} β) (Set.completeBooleanAlgebra.{u4} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u4} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))))) (fun (_x : LowerAdjoint.{u4, u1} (Set.{u4} β) α (PartialOrder.toPreorder.{u4} (Set.{u4} β) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} β) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} β) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} β) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} β) (Set.completeBooleanAlgebra.{u4} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u4} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))))) => (Set.{u4} β) -> α) (LowerAdjoint.hasCoeToFun.{u4, u1} (Set.{u4} β) α (PartialOrder.toPreorder.{u4} (Set.{u4} β) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} β) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} β) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} β) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} β) (Set.completeBooleanAlgebra.{u4} β))))))) (PartialOrder.toPreorder.{u1} α (SetLike.partialOrder.{u1, u4} α β _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))))) l (Set.unionᵢ.{u4, u2} β ι (fun (i : ι) => Set.unionᵢ.{u4, u3} β (κ i) (fun (j : κ i) => (fun (a : Type.{u1}) (b : Type.{u4}) [self : HasLiftT.{succ u1, succ u4} a b] => self.0) α (Set.{u4} β) (HasLiftT.mk.{succ u1, succ u4} α (Set.{u4} β) (CoeTCₓ.coe.{succ u1, succ u4} α (Set.{u4} β) (SetLike.Set.hasCoeT.{u1, u4} α β _inst_1))) (f i j)))))
but is expected to have type
  forall {α : Type.{u4}} {ι : Sort.{u2}} {κ : ι -> Sort.{u1}} {β : Type.{u3}} [_inst_1 : SetLike.{u4, u3} α β] (l : LowerAdjoint.{u3, u4} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.instCompleteBooleanAlgebraSet.{u3} β))))))) (PartialOrder.toPreorder.{u4} α (SetLike.instPartialOrder.{u4, u3} α β _inst_1)) (SetLike.coe.{u4, u3} α β _inst_1)) (f : forall (i : ι), (κ i) -> α), Eq.{succ u4} α (LowerAdjoint.toFun.{u3, u4} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.instCompleteBooleanAlgebraSet.{u3} β))))))) (PartialOrder.toPreorder.{u4} α (SetLike.instPartialOrder.{u4, u3} α β _inst_1)) (SetLike.coe.{u4, u3} α β _inst_1) l (Set.unionᵢ.{u3, u2} β ι (fun (i : ι) => Set.unionᵢ.{u3, u1} β (κ i) (fun (j : κ i) => SetLike.coe.{u4, u3} α β _inst_1 (LowerAdjoint.toFun.{u3, u4} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.instCompleteBooleanAlgebraSet.{u3} β))))))) (PartialOrder.toPreorder.{u4} α (SetLike.instPartialOrder.{u4, u3} α β _inst_1)) (SetLike.coe.{u4, u3} α β _inst_1) l (SetLike.coe.{u4, u3} α β _inst_1 (f i j))))))) (LowerAdjoint.toFun.{u3, u4} (Set.{u3} β) α (PartialOrder.toPreorder.{u3} (Set.{u3} β) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} β) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} β) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} β) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} β) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} β) (Set.instCompleteBooleanAlgebraSet.{u3} β))))))) (PartialOrder.toPreorder.{u4} α (SetLike.instPartialOrder.{u4, u3} α β _inst_1)) (SetLike.coe.{u4, u3} α β _inst_1) l (Set.unionᵢ.{u3, u2} β ι (fun (i : ι) => Set.unionᵢ.{u3, u1} β (κ i) (fun (j : κ i) => SetLike.coe.{u4, u3} α β _inst_1 (f i j)))))
Case conversion may be inaccurate. Consider using '#align lower_adjoint.closure_Union₂_closure LowerAdjoint.closure_unionᵢ₂_closureₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem closure_unionᵢ₂_closure (f : ∀ i, κ i → α) :
    l (⋃ (i) (j), l (f i j)) = l (⋃ (i) (j), f i j) :=
  SetLike.coe_injective <| l.closure_supᵢ₂_closure _
#align lower_adjoint.closure_Union₂_closure LowerAdjoint.closure_unionᵢ₂_closure

end CoeToSet

end LowerAdjoint

/-! ### Translations between `galois_connection`, `lower_adjoint`, `closure_operator` -/


variable {α}

#print GaloisConnection.lowerAdjoint /-
/-- Every Galois connection induces a lower adjoint. -/
@[simps]
def GaloisConnection.lowerAdjoint [Preorder α] [Preorder β] {l : α → β} {u : β → α}
    (gc : GaloisConnection l u) : LowerAdjoint u
    where
  toFun := l
  gc' := gc
#align galois_connection.lower_adjoint GaloisConnection.lowerAdjoint
-/

#print GaloisConnection.closureOperator /-
/-- Every Galois connection induces a closure operator given by the composition. This is the partial
order version of the statement that every adjunction induces a monad. -/
@[simps]
def GaloisConnection.closureOperator [PartialOrder α] [Preorder β] {l : α → β} {u : β → α}
    (gc : GaloisConnection l u) : ClosureOperator α :=
  gc.LowerAdjoint.ClosureOperator
#align galois_connection.closure_operator GaloisConnection.closureOperator
-/

#print ClosureOperator.gi /-
/-- The set of closed elements has a Galois insertion to the underlying type. -/
def ClosureOperator.gi [PartialOrder α] (c : ClosureOperator α) : GaloisInsertion c.toClosed coe
    where
  choice x hx := ⟨x, hx.antisymm (c.le_closure x)⟩
  gc x y := c.closure_le_closed_iff_le _ y.2
  le_l_u x := c.le_closure _
  choice_eq x hx := le_antisymm (c.le_closure x) hx
#align closure_operator.gi ClosureOperator.gi
-/

#print closureOperator_gi_self /-
/-- The Galois insertion associated to a closure operator can be used to reconstruct the closure
operator.
Note that the inverse in the opposite direction does not hold in general. -/
@[simp]
theorem closureOperator_gi_self [PartialOrder α] (c : ClosureOperator α) :
    c.gi.gc.ClosureOperator = c := by
  ext x
  rfl
#align closure_operator_gi_self closureOperator_gi_self
-/

