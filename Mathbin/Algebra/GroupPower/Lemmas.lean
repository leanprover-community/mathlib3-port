/-
Copyright (c) 2015 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Robert Y. Lewis

! This file was ported from Lean 3 source module algebra.group_power.lemmas
! leanprover-community/mathlib commit e655e4ea5c6d02854696f97494997ba4c31be802
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Invertible
import Mathbin.Algebra.GroupPower.Ring
import Mathbin.Algebra.Order.Monoid.WithTop
import Mathbin.Data.Nat.Pow
import Mathbin.Data.Int.Cast.Lemmas

/-!
# Lemmas about power operations on monoids and groups

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file contains lemmas about `monoid.pow`, `group.pow`, `nsmul`, `zsmul`
which require additional imports besides those available in `algebra.group_power.basic`.
-/


open Function Int Nat

universe u v w x y z u₁ u₂

variable {α : Type _} {M : Type u} {N : Type v} {G : Type w} {H : Type x} {A : Type y} {B : Type z}
  {R : Type u₁} {S : Type u₂}

/-!
### (Additive) monoid
-/


section Monoid

#print nsmul_one /-
@[simp]
theorem nsmul_one [AddMonoidWithOne A] : ∀ n : ℕ, n • (1 : A) = n :=
  by
  refine' eq_natCast' (⟨_, _, _⟩ : ℕ →+ A) _
  · show 0 • (1 : A) = 0
    simp [zero_nsmul]
  · show ∀ x y : ℕ, (x + y) • (1 : A) = x • 1 + y • 1
    simp [add_nsmul]
  · show 1 • (1 : A) = 1
    simp
#align nsmul_one nsmul_one
-/

variable [Monoid M] [Monoid N] [AddMonoid A] [AddMonoid B]

/- warning: invertible_pow -> invertiblePow is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (m : M) [_inst_5 : Invertible.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) m] (n : Nat), Invertible.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) m n)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (m : M) [_inst_5 : Invertible.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Monoid.toOne.{u1} M _inst_1) m] (n : Nat), Invertible.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Monoid.toOne.{u1} M _inst_1) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) m n)
Case conversion may be inaccurate. Consider using '#align invertible_pow invertiblePowₓ'. -/
instance invertiblePow (m : M) [Invertible m] (n : ℕ) : Invertible (m ^ n)
    where
  invOf := ⅟ m ^ n
  invOf_mul_self := by rw [← (commute_invOf m).symm.mul_pow, invOf_mul_self, one_pow]
  mul_invOf_self := by rw [← (commute_invOf m).mul_pow, mul_invOf_self, one_pow]
#align invertible_pow invertiblePow

/- warning: inv_of_pow -> invOf_pow is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (m : M) [_inst_5 : Invertible.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) m] (n : Nat) [_inst_6 : Invertible.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) m n)], Eq.{succ u1} M (Invertible.invOf.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) m n) _inst_6) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) (Invertible.invOf.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) m _inst_5) n)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (m : M) [_inst_5 : Invertible.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Monoid.toOne.{u1} M _inst_1) m] (n : Nat) [_inst_6 : Invertible.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Monoid.toOne.{u1} M _inst_1) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) m n)], Eq.{succ u1} M (Invertible.invOf.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Monoid.toOne.{u1} M _inst_1) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) m n) _inst_6) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) (Invertible.invOf.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Monoid.toOne.{u1} M _inst_1) m _inst_5) n)
Case conversion may be inaccurate. Consider using '#align inv_of_pow invOf_powₓ'. -/
theorem invOf_pow (m : M) [Invertible m] (n : ℕ) [Invertible (m ^ n)] : ⅟ (m ^ n) = ⅟ m ^ n :=
  @invertible_unique M _ (m ^ n) (m ^ n) _ (invertiblePow m n) rfl
#align inv_of_pow invOf_pow

#print IsUnit.pow /-
@[to_additive]
theorem IsUnit.pow {m : M} (n : ℕ) : IsUnit m → IsUnit (m ^ n) := fun ⟨u, hu⟩ =>
  ⟨u ^ n, hu ▸ u.val_pow_eq_pow_val _⟩
#align is_unit.pow IsUnit.pow
#align is_add_unit.nsmul IsAddUnit.nsmul
-/

#print Units.ofPow /-
/-- If a natural power of `x` is a unit, then `x` is a unit. -/
@[to_additive "If a natural multiple of `x` is an additive unit, then `x` is an additive unit."]
def Units.ofPow (u : Mˣ) (x : M) {n : ℕ} (hn : n ≠ 0) (hu : x ^ n = u) : Mˣ :=
  u.leftOfMul x (x ^ (n - 1))
    (by rwa [← pow_succ, Nat.sub_add_cancel (Nat.succ_le_of_lt <| Nat.pos_of_ne_zero hn)])
    (Commute.self_pow _ _)
#align units.of_pow Units.ofPow
#align add_units.of_nsmul AddUnits.ofNSMul
-/

#print isUnit_pow_iff /-
@[simp, to_additive]
theorem isUnit_pow_iff {a : M} {n : ℕ} (hn : n ≠ 0) : IsUnit (a ^ n) ↔ IsUnit a :=
  ⟨fun ⟨u, hu⟩ => (u.ofPow a hn hu.symm).IsUnit, fun h => h.pow n⟩
#align is_unit_pow_iff isUnit_pow_iff
#align is_add_unit_nsmul_iff isAddUnit_nsmul_iff
-/

#print isUnit_pow_succ_iff /-
@[to_additive]
theorem isUnit_pow_succ_iff {m : M} {n : ℕ} : IsUnit (m ^ (n + 1)) ↔ IsUnit m :=
  isUnit_pow_iff n.succ_ne_zero
#align is_unit_pow_succ_iff isUnit_pow_succ_iff
#align is_add_unit_nsmul_succ_iff isAddUnit_nsmul_succ_iff
-/

/- warning: units.of_pow_eq_one -> Units.ofPowEqOne is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (x : M) (n : Nat), (Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n) (OfNat.ofNat.{u1} M 1 (OfNat.mk.{u1} M 1 (One.one.{u1} M (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) -> (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Units.{u1} M _inst_1)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (x : M) (n : Nat), (Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n) (OfNat.ofNat.{u1} M 1 (One.toOfNat1.{u1} M (Monoid.toOne.{u1} M _inst_1)))) -> (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Units.{u1} M _inst_1)
Case conversion may be inaccurate. Consider using '#align units.of_pow_eq_one Units.ofPowEqOneₓ'. -/
/-- If `x ^ n = 1`, `n ≠ 0`, then `x` is a unit. -/
@[to_additive "If `n • x = 0`, `n ≠ 0`, then `x` is an additive unit.", simps]
def Units.ofPowEqOne (x : M) (n : ℕ) (hx : x ^ n = 1) (hn : n ≠ 0) : Mˣ :=
  Units.ofPow 1 x hn hx
#align units.of_pow_eq_one Units.ofPowEqOne
#align add_units.of_nsmul_eq_zero AddUnits.ofNSMulEqZero

/- warning: units.pow_of_pow_eq_one -> Units.pow_ofPowEqOne is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {x : M} {n : Nat} (hx : Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n) (OfNat.ofNat.{u1} M 1 (OfNat.mk.{u1} M 1 (One.one.{u1} M (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) (hn : Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))), Eq.{succ u1} (Units.{u1} M _inst_1) (HPow.hPow.{u1, 0, u1} (Units.{u1} M _inst_1) Nat (Units.{u1} M _inst_1) (instHPow.{u1, 0} (Units.{u1} M _inst_1) Nat (Monoid.Pow.{u1} (Units.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (Units.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (Units.{u1} M _inst_1) (Units.group.{u1} M _inst_1))))) (Units.ofPowEqOne.{u1} M _inst_1 x n hx hn) n) (OfNat.ofNat.{u1} (Units.{u1} M _inst_1) 1 (OfNat.mk.{u1} (Units.{u1} M _inst_1) 1 (One.one.{u1} (Units.{u1} M _inst_1) (MulOneClass.toHasOne.{u1} (Units.{u1} M _inst_1) (Units.mulOneClass.{u1} M _inst_1)))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {x : M} {n : Nat} (hx : Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n) (OfNat.ofNat.{u1} M 1 (One.toOfNat1.{u1} M (Monoid.toOne.{u1} M _inst_1)))) (hn : Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))), Eq.{succ u1} (Units.{u1} M _inst_1) (HPow.hPow.{u1, 0, u1} (Units.{u1} M _inst_1) Nat (Units.{u1} M _inst_1) (instHPow.{u1, 0} (Units.{u1} M _inst_1) Nat (Monoid.Pow.{u1} (Units.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (Units.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (Units.{u1} M _inst_1) (Units.instGroupUnits.{u1} M _inst_1))))) (Units.ofPowEqOne.{u1} M _inst_1 x n hx hn) n) (OfNat.ofNat.{u1} (Units.{u1} M _inst_1) 1 (One.toOfNat1.{u1} (Units.{u1} M _inst_1) (InvOneClass.toOne.{u1} (Units.{u1} M _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (Units.{u1} M _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (Units.{u1} M _inst_1) (Group.toDivisionMonoid.{u1} (Units.{u1} M _inst_1) (Units.instGroupUnits.{u1} M _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align units.pow_of_pow_eq_one Units.pow_ofPowEqOneₓ'. -/
@[simp, to_additive]
theorem Units.pow_ofPowEqOne {x : M} {n : ℕ} (hx : x ^ n = 1) (hn : n ≠ 0) :
    Units.ofPowEqOne x n hx hn ^ n = 1 :=
  Units.ext <| by rwa [Units.val_pow_eq_pow_val, Units.coe_ofPowEqOne, Units.val_one]
#align units.pow_of_pow_eq_one Units.pow_ofPowEqOne
#align add_units.nsmul_of_nsmul_eq_zero AddUnits.nsmul_ofNSMulEqZero

/- warning: is_unit_of_pow_eq_one -> isUnit_ofPowEqOne is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {x : M} {n : Nat}, (Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n) (OfNat.ofNat.{u1} M 1 (OfNat.mk.{u1} M 1 (One.one.{u1} M (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) -> (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (IsUnit.{u1} M _inst_1 x)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {x : M} {n : Nat}, (Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n) (OfNat.ofNat.{u1} M 1 (One.toOfNat1.{u1} M (Monoid.toOne.{u1} M _inst_1)))) -> (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (IsUnit.{u1} M _inst_1 x)
Case conversion may be inaccurate. Consider using '#align is_unit_of_pow_eq_one isUnit_ofPowEqOneₓ'. -/
@[to_additive]
theorem isUnit_ofPowEqOne {x : M} {n : ℕ} (hx : x ^ n = 1) (hn : n ≠ 0) : IsUnit x :=
  (Units.ofPowEqOne x n hx hn).IsUnit
#align is_unit_of_pow_eq_one isUnit_ofPowEqOne
#align is_add_unit_of_nsmul_eq_zero isAddUnit_ofNSMulEqZero

/- warning: invertible_of_pow_eq_one -> invertibleOfPowEqOne is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (x : M) (n : Nat), (Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n) (OfNat.ofNat.{u1} M 1 (OfNat.mk.{u1} M 1 (One.one.{u1} M (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)))))) -> (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Invertible.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) x)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (x : M) (n : Nat), (Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n) (OfNat.ofNat.{u1} M 1 (One.toOfNat1.{u1} M (Monoid.toOne.{u1} M _inst_1)))) -> (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Invertible.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Monoid.toOne.{u1} M _inst_1) x)
Case conversion may be inaccurate. Consider using '#align invertible_of_pow_eq_one invertibleOfPowEqOneₓ'. -/
/-- If `x ^ n = 1` then `x` has an inverse, `x^(n - 1)`. -/
def invertibleOfPowEqOne (x : M) (n : ℕ) (hx : x ^ n = 1) (hn : n ≠ 0) : Invertible x :=
  (Units.ofPowEqOne x n hx hn).Invertible
#align invertible_of_pow_eq_one invertibleOfPowEqOne

/- warning: smul_pow -> smul_pow is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {N : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Monoid.{u2} N] [_inst_5 : MulAction.{u1, u2} M N _inst_1] [_inst_6 : IsScalarTower.{u1, u2, u2} M N N (MulAction.toHasSmul.{u1, u2} M N _inst_1 _inst_5) (Mul.toSMul.{u2} N (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N _inst_2))) (MulAction.toHasSmul.{u1, u2} M N _inst_1 _inst_5)] [_inst_7 : SMulCommClass.{u1, u2, u2} M N N (MulAction.toHasSmul.{u1, u2} M N _inst_1 _inst_5) (Mul.toSMul.{u2} N (MulOneClass.toHasMul.{u2} N (Monoid.toMulOneClass.{u2} N _inst_2)))] (k : M) (x : N) (p : Nat), Eq.{succ u2} N (HPow.hPow.{u2, 0, u2} N Nat N (instHPow.{u2, 0} N Nat (Monoid.Pow.{u2} N _inst_2)) (SMul.smul.{u1, u2} M N (MulAction.toHasSmul.{u1, u2} M N _inst_1 _inst_5) k x) p) (SMul.smul.{u1, u2} M N (MulAction.toHasSmul.{u1, u2} M N _inst_1 _inst_5) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) k p) (HPow.hPow.{u2, 0, u2} N Nat N (instHPow.{u2, 0} N Nat (Monoid.Pow.{u2} N _inst_2)) x p))
but is expected to have type
  forall {M : Type.{u1}} {N : Type.{u2}} [_inst_1 : Monoid.{u1} M] [_inst_2 : Monoid.{u2} N] [_inst_5 : MulAction.{u1, u2} M N _inst_1] [_inst_6 : IsScalarTower.{u1, u2, u2} M N N (MulAction.toSMul.{u1, u2} M N _inst_1 _inst_5) (MulAction.toSMul.{u2, u2} N N _inst_2 (Monoid.toMulAction.{u2} N _inst_2)) (MulAction.toSMul.{u1, u2} M N _inst_1 _inst_5)] [_inst_7 : SMulCommClass.{u1, u2, u2} M N N (MulAction.toSMul.{u1, u2} M N _inst_1 _inst_5) (MulAction.toSMul.{u2, u2} N N _inst_2 (Monoid.toMulAction.{u2} N _inst_2))] (k : M) (x : N) (p : Nat), Eq.{succ u2} N (HPow.hPow.{u2, 0, u2} N Nat N (instHPow.{u2, 0} N Nat (Monoid.Pow.{u2} N _inst_2)) (HSMul.hSMul.{u1, u2, u2} M N N (instHSMul.{u1, u2} M N (MulAction.toSMul.{u1, u2} M N _inst_1 _inst_5)) k x) p) (HSMul.hSMul.{u1, u2, u2} M N N (instHSMul.{u1, u2} M N (MulAction.toSMul.{u1, u2} M N _inst_1 _inst_5)) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) k p) (HPow.hPow.{u2, 0, u2} N Nat N (instHPow.{u2, 0} N Nat (Monoid.Pow.{u2} N _inst_2)) x p))
Case conversion may be inaccurate. Consider using '#align smul_pow smul_powₓ'. -/
theorem smul_pow [MulAction M N] [IsScalarTower M N N] [SMulCommClass M N N] (k : M) (x : N)
    (p : ℕ) : (k • x) ^ p = k ^ p • x ^ p :=
  by
  induction' p with p IH
  · simp
  · rw [pow_succ', IH, smul_mul_smul, ← pow_succ', ← pow_succ']
#align smul_pow smul_pow

#print smul_pow' /-
@[simp]
theorem smul_pow' [MulDistribMulAction M N] (x : M) (m : N) (n : ℕ) : x • m ^ n = (x • m) ^ n :=
  by
  induction' n with n ih
  · rw [pow_zero, pow_zero]
    exact smul_one x
  · rw [pow_succ, pow_succ]
    exact (smul_mul' x m (m ^ n)).trans (congr_arg _ ih)
#align smul_pow' smul_pow'
-/

end Monoid

/- warning: zsmul_one -> zsmul_one is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : AddGroupWithOne.{u1} A] (n : Int), Eq.{succ u1} A (SMul.smul.{0, u1} Int A (SubNegMonoid.SMulInt.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddGroupWithOne.toAddGroup.{u1} A _inst_1))) n (OfNat.ofNat.{u1} A 1 (OfNat.mk.{u1} A 1 (One.one.{u1} A (AddMonoidWithOne.toOne.{u1} A (AddGroupWithOne.toAddMonoidWithOne.{u1} A _inst_1)))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int A (HasLiftT.mk.{1, succ u1} Int A (CoeTCₓ.coe.{1, succ u1} Int A (Int.castCoe.{u1} A (AddGroupWithOne.toHasIntCast.{u1} A _inst_1)))) n)
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : AddGroupWithOne.{u1} A] (n : Int), Eq.{succ u1} A (HSMul.hSMul.{0, u1, u1} Int A A (instHSMul.{0, u1} Int A (SubNegMonoid.SMulInt.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddGroupWithOne.toAddGroup.{u1} A _inst_1)))) n (OfNat.ofNat.{u1} A 1 (One.toOfNat1.{u1} A (AddMonoidWithOne.toOne.{u1} A (AddGroupWithOne.toAddMonoidWithOne.{u1} A _inst_1))))) (Int.cast.{u1} A (AddGroupWithOne.toIntCast.{u1} A _inst_1) n)
Case conversion may be inaccurate. Consider using '#align zsmul_one zsmul_oneₓ'. -/
theorem zsmul_one [AddGroupWithOne A] (n : ℤ) : n • (1 : A) = n := by cases n <;> simp
#align zsmul_one zsmul_one

section DivisionMonoid

variable [DivisionMonoid α]

#print zpow_mul /-
-- Note that `mul_zsmul` and `zpow_mul` have the primes swapped since their argument order,
-- and therefore the more "natural" choice of lemma, is reversed.
@[to_additive mul_zsmul']
theorem zpow_mul (a : α) : ∀ m n : ℤ, a ^ (m * n) = (a ^ m) ^ n
  | (m : ℕ), (n : ℕ) => by
    rw [zpow_ofNat, zpow_ofNat, ← pow_mul, ← zpow_ofNat]
    rfl
  | (m : ℕ), -[n+1] =>
    by
    rw [zpow_ofNat, zpow_negSucc, ← pow_mul, coe_nat_mul_neg_succ, zpow_neg, inv_inj, ← zpow_ofNat]
    rfl
  | -[m+1], (n : ℕ) =>
    by
    rw [zpow_ofNat, zpow_negSucc, ← inv_pow, ← pow_mul, neg_succ_mul_coe_nat, zpow_neg, inv_pow,
      inv_inj, ← zpow_ofNat]
    rfl
  | -[m+1], -[n+1] =>
    by
    rw [zpow_negSucc, zpow_negSucc, neg_succ_mul_neg_succ, inv_pow, inv_inv, ← pow_mul, ←
      zpow_ofNat]
    rfl
#align zpow_mul zpow_mul
#align mul_zsmul' mul_zsmul'
-/

#print zpow_mul' /-
@[to_additive mul_zsmul]
theorem zpow_mul' (a : α) (m n : ℤ) : a ^ (m * n) = (a ^ n) ^ m := by rw [mul_comm, zpow_mul]
#align zpow_mul' zpow_mul'
#align mul_zsmul mul_zsmul
-/

/- warning: zpow_bit0 -> zpow_bit0 is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} α] (a : α) (n : Int), Eq.{succ u1} α (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) a (bit0.{0} Int Int.hasAdd n)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toHasMul.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) a n) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) a n))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} α] (a : α) (n : Int), Eq.{succ u1} α (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) a (bit0.{0} Int Int.instAddInt n)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toMul.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) a n) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) a n))
Case conversion may be inaccurate. Consider using '#align zpow_bit0 zpow_bit0ₓ'. -/
@[to_additive bit0_zsmul]
theorem zpow_bit0 (a : α) : ∀ n : ℤ, a ^ bit0 n = a ^ n * a ^ n
  | (n : ℕ) => by simp only [zpow_ofNat, ← Int.ofNat_bit0, pow_bit0]
  | -[n+1] => by
    simp [← mul_inv_rev, ← pow_bit0]
    rw [neg_succ_of_nat_eq, bit0_neg, zpow_neg]
    norm_cast
#align zpow_bit0 zpow_bit0
#align bit0_zsmul bit0_zsmul

/- warning: zpow_bit0' -> zpow_bit0' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} α] (a : α) (n : Int), Eq.{succ u1} α (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) a (bit0.{0} Int Int.hasAdd n)) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toHasMul.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))))) a a) n)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} α] (a : α) (n : Int), Eq.{succ u1} α (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) a (bit0.{0} Int Int.instAddInt n)) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toMul.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))))) a a) n)
Case conversion may be inaccurate. Consider using '#align zpow_bit0' zpow_bit0'ₓ'. -/
@[to_additive bit0_zsmul']
theorem zpow_bit0' (a : α) (n : ℤ) : a ^ bit0 n = (a * a) ^ n :=
  (zpow_bit0 a n).trans ((Commute.refl a).mul_zpow n).symm
#align zpow_bit0' zpow_bit0'
#align bit0_zsmul' bit0_zsmul'

/- warning: zpow_bit0_neg -> zpow_bit0_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} α] [_inst_2 : HasDistribNeg.{u1} α (MulOneClass.toHasMul.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))))] (x : α) (n : Int), Eq.{succ u1} α (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) (Neg.neg.{u1} α (InvolutiveNeg.toHasNeg.{u1} α (HasDistribNeg.toHasInvolutiveNeg.{u1} α (MulOneClass.toHasMul.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1)))) _inst_2)) x) (bit0.{0} Int Int.hasAdd n)) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) x (bit0.{0} Int Int.hasAdd n))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} α] [_inst_2 : HasDistribNeg.{u1} α (MulOneClass.toMul.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))))] (x : α) (n : Int), Eq.{succ u1} α (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) (Neg.neg.{u1} α (InvolutiveNeg.toNeg.{u1} α (HasDistribNeg.toInvolutiveNeg.{u1} α (MulOneClass.toMul.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1)))) _inst_2)) x) (bit0.{0} Int Int.instAddInt n)) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (DivisionMonoid.toDivInvMonoid.{u1} α _inst_1))) x (bit0.{0} Int Int.instAddInt n))
Case conversion may be inaccurate. Consider using '#align zpow_bit0_neg zpow_bit0_negₓ'. -/
@[simp]
theorem zpow_bit0_neg [HasDistribNeg α] (x : α) (n : ℤ) : (-x) ^ bit0 n = x ^ bit0 n := by
  rw [zpow_bit0', zpow_bit0', neg_mul_neg]
#align zpow_bit0_neg zpow_bit0_neg

end DivisionMonoid

section Group

variable [Group G]

/- warning: zpow_add_one -> zpow_add_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (n : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) n (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n) a)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (n : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) n (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n) a)
Case conversion may be inaccurate. Consider using '#align zpow_add_one zpow_add_oneₓ'. -/
@[to_additive add_one_zsmul]
theorem zpow_add_one (a : G) : ∀ n : ℤ, a ^ (n + 1) = a ^ n * a
  | (n : ℕ) => by simp only [← Int.ofNat_succ, zpow_ofNat, pow_succ']
  | -[0+1] => by erw [zpow_zero, zpow_negSucc, pow_one, mul_left_inv]
  | -[n + 1+1] => by
    rw [zpow_negSucc, pow_succ, mul_inv_rev, inv_mul_cancel_right]
    rw [Int.negSucc_eq, neg_add, add_assoc, neg_add_self, add_zero]
    exact zpow_negSucc _ _
#align zpow_add_one zpow_add_one
#align add_one_zsmul add_one_zsmul

/- warning: zpow_sub_one -> zpow_sub_one is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (n : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) n (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) a))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (n : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) n (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) a))
Case conversion may be inaccurate. Consider using '#align zpow_sub_one zpow_sub_oneₓ'. -/
@[to_additive sub_one_zsmul]
theorem zpow_sub_one (a : G) (n : ℤ) : a ^ (n - 1) = a ^ n * a⁻¹ :=
  calc
    a ^ (n - 1) = a ^ (n - 1) * a * a⁻¹ := (mul_inv_cancel_right _ _).symm
    _ = a ^ n * a⁻¹ := by rw [← zpow_add_one, sub_add_cancel]
    
#align zpow_sub_one zpow_sub_one
#align sub_one_zsmul sub_one_zsmul

/- warning: zpow_add -> zpow_add is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (m : Int) (n : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) m n)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a m) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (m : Int) (n : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) m n)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a m) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n))
Case conversion may be inaccurate. Consider using '#align zpow_add zpow_addₓ'. -/
@[to_additive add_zsmul]
theorem zpow_add (a : G) (m n : ℤ) : a ^ (m + n) = a ^ m * a ^ n :=
  by
  induction' n using Int.induction_on with n ihn n ihn
  case hz => simp
  · simp only [← add_assoc, zpow_add_one, ihn, mul_assoc]
  · rw [zpow_sub_one, ← mul_assoc, ← ihn, ← zpow_sub_one, add_sub_assoc]
#align zpow_add zpow_add
#align add_zsmul add_zsmul

/- warning: mul_self_zpow -> mul_self_zpow is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (b : G) (m : Int), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) b (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b m)) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) m (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (b : G) (m : Int), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) b (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b m)) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) m (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))))
Case conversion may be inaccurate. Consider using '#align mul_self_zpow mul_self_zpowₓ'. -/
@[to_additive add_zsmul_self]
theorem mul_self_zpow (b : G) (m : ℤ) : b * b ^ m = b ^ (m + 1) :=
  by
  conv_lhs =>
    congr
    rw [← zpow_one b]
  rw [← zpow_add, add_comm]
#align mul_self_zpow mul_self_zpow
#align add_zsmul_self add_zsmul_self

/- warning: mul_zpow_self -> mul_zpow_self is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (b : G) (m : Int), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b m) b) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) m (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (b : G) (m : Int), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b m) b) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) b (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) m (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))))
Case conversion may be inaccurate. Consider using '#align mul_zpow_self mul_zpow_selfₓ'. -/
@[to_additive add_self_zsmul]
theorem mul_zpow_self (b : G) (m : ℤ) : b ^ m * b = b ^ (m + 1) :=
  by
  conv_lhs =>
    congr
    skip
    rw [← zpow_one b]
  rw [← zpow_add, add_comm]
#align mul_zpow_self mul_zpow_self
#align add_self_zsmul add_self_zsmul

/- warning: zpow_sub -> zpow_sub is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (m : Int) (n : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.hasSub) m n)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a m) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n)))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (m : Int) (n : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (HSub.hSub.{0, 0, 0} Int Int Int (instHSub.{0} Int Int.instSubInt) m n)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a m) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n)))
Case conversion may be inaccurate. Consider using '#align zpow_sub zpow_subₓ'. -/
@[to_additive sub_zsmul]
theorem zpow_sub (a : G) (m n : ℤ) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹ := by
  rw [sub_eq_add_neg, zpow_add, zpow_neg]
#align zpow_sub zpow_sub
#align sub_zsmul sub_zsmul

/- warning: zpow_one_add -> zpow_one_add is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (i : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.hasAdd) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))) i)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a i))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (i : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (HAdd.hAdd.{0, 0, 0} Int Int Int (instHAdd.{0} Int Int.instAddInt) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)) i)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a i))
Case conversion may be inaccurate. Consider using '#align zpow_one_add zpow_one_addₓ'. -/
@[to_additive one_add_zsmul]
theorem zpow_one_add (a : G) (i : ℤ) : a ^ (1 + i) = a * a ^ i := by rw [zpow_add, zpow_one]
#align zpow_one_add zpow_one_add
#align one_add_zsmul one_add_zsmul

/- warning: zpow_mul_comm -> zpow_mul_comm is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (i : Int) (j : Int), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a i) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a j)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a j) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a i))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (i : Int) (j : Int), Eq.{succ u1} G (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a i) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a j)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a j) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a i))
Case conversion may be inaccurate. Consider using '#align zpow_mul_comm zpow_mul_commₓ'. -/
@[to_additive]
theorem zpow_mul_comm (a : G) (i j : ℤ) : a ^ i * a ^ j = a ^ j * a ^ i :=
  (Commute.refl _).zpow_zpow _ _
#align zpow_mul_comm zpow_mul_comm
#align zsmul_add_comm zsmul_add_comm

/- warning: zpow_bit1 -> zpow_bit1 is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (n : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (bit1.{0} Int Int.hasOne Int.hasAdd n)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n)) a)
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (a : G) (n : Int), Eq.{succ u1} G (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a (bit1.{0} Int (Semiring.toOne.{0} Int Int.instSemiringInt) Int.instAddInt n)) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) a n)) a)
Case conversion may be inaccurate. Consider using '#align zpow_bit1 zpow_bit1ₓ'. -/
@[to_additive bit1_zsmul]
theorem zpow_bit1 (a : G) (n : ℤ) : a ^ bit1 n = a ^ n * a ^ n * a := by
  rw [bit1, zpow_add, zpow_bit0, zpow_one]
#align zpow_bit1 zpow_bit1
#align bit1_zsmul bit1_zsmul

/- warning: zpow_induction_left -> zpow_induction_left is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g : G} {P : G -> Prop}, (P (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) -> (forall (a : G), (P a) -> (P (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g a))) -> (forall (a : G), (P a) -> (P (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) g) a))) -> (forall (n : Int), P (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) g n))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g : G} {P : G -> Prop}, (P (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) -> (forall (a : G), (P a) -> (P (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) g a))) -> (forall (a : G), (P a) -> (P (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) g) a))) -> (forall (n : Int), P (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) g n))
Case conversion may be inaccurate. Consider using '#align zpow_induction_left zpow_induction_leftₓ'. -/
/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication
by `g` and `g⁻¹` on the left. For subgroups generated by more than one element, see
`subgroup.closure_induction_left`. -/
@[to_additive
      "To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the left. For additive subgroups generated by more than one element, see\n`add_subgroup.closure_induction_left`."]
theorem zpow_induction_left {g : G} {P : G → Prop} (h_one : P (1 : G))
    (h_mul : ∀ a, P a → P (g * a)) (h_inv : ∀ a, P a → P (g⁻¹ * a)) (n : ℤ) : P (g ^ n) :=
  by
  induction' n using Int.induction_on with n ih n ih
  · rwa [zpow_zero]
  · rw [add_comm, zpow_add, zpow_one]
    exact h_mul _ ih
  · rw [sub_eq_add_neg, add_comm, zpow_add, zpow_neg_one]
    exact h_inv _ ih
#align zpow_induction_left zpow_induction_left
#align zsmul_induction_left zsmul_induction_left

/- warning: zpow_induction_right -> zpow_induction_right is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g : G} {P : G -> Prop}, (P (OfNat.ofNat.{u1} G 1 (OfNat.mk.{u1} G 1 (One.one.{u1} G (MulOneClass.toHasOne.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))))) -> (forall (a : G), (P a) -> (P (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a g))) -> (forall (a : G), (P a) -> (P (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)) g)))) -> (forall (n : Int), P (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) g n))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] {g : G} {P : G -> Prop}, (P (OfNat.ofNat.{u1} G 1 (One.toOfNat1.{u1} G (InvOneClass.toOne.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1))))))) -> (forall (a : G), (P a) -> (P (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a g))) -> (forall (a : G), (P a) -> (P (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) a (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_1)))) g)))) -> (forall (n : Int), P (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) g n))
Case conversion may be inaccurate. Consider using '#align zpow_induction_right zpow_induction_rightₓ'. -/
/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication
by `g` and `g⁻¹` on the right. For subgroups generated by more than one element, see
`subgroup.closure_induction_right`. -/
@[to_additive
      "To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the right. For additive subgroups generated by more than one element,\nsee `add_subgroup.closure_induction_right`."]
theorem zpow_induction_right {g : G} {P : G → Prop} (h_one : P (1 : G))
    (h_mul : ∀ a, P a → P (a * g)) (h_inv : ∀ a, P a → P (a * g⁻¹)) (n : ℤ) : P (g ^ n) :=
  by
  induction' n using Int.induction_on with n ih n ih
  · rwa [zpow_zero]
  · rw [zpow_add_one]
    exact h_mul _ ih
  · rw [zpow_sub_one]
    exact h_inv _ ih
#align zpow_induction_right zpow_induction_right
#align zsmul_induction_right zsmul_induction_right

end Group

/-!
### `zpow`/`zsmul` and an order

Those lemmas are placed here (rather than in `algebra.group_power.order` with their friends) because
they require facts from `data.int.basic`.
-/


section OrderedAddCommGroup

variable [OrderedCommGroup α] {m n : ℤ} {a b : α}

/- warning: one_lt_zpow' -> one_lt_zpow' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {a : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))))))) a) -> (forall {k : Int}, (LT.lt.{0} Int Int.hasLt (OfNat.ofNat.{0} Int 0 (OfNat.mk.{0} Int 0 (Zero.zero.{0} Int Int.hasZero))) k) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))))))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a k)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {a : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroup.toDivisionCommMonoid.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1)))))))) a) -> (forall {k : Int}, (LT.lt.{0} Int Int.instLTInt (OfNat.ofNat.{0} Int 0 (instOfNatInt 0)) k) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroup.toDivisionCommMonoid.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1)))))))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a k)))
Case conversion may be inaccurate. Consider using '#align one_lt_zpow' one_lt_zpow'ₓ'. -/
@[to_additive zsmul_pos]
theorem one_lt_zpow' (ha : 1 < a) {k : ℤ} (hk : (0 : ℤ) < k) : 1 < a ^ k :=
  by
  lift k to ℕ using Int.le_of_lt hk
  rw [zpow_ofNat]
  exact one_lt_pow' ha (coe_nat_pos.mp hk).ne'
#align one_lt_zpow' one_lt_zpow'
#align zsmul_pos zsmul_pos

/- warning: zpow_strict_mono_right -> zpow_strictMono_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {a : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))))))) a) -> (StrictMono.{0, u1} Int α (PartialOrder.toPreorder.{0} Int (OrderedAddCommGroup.toPartialOrder.{0} Int (StrictOrderedRing.toOrderedAddCommGroup.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1)) (fun (n : Int) => HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {a : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroup.toDivisionCommMonoid.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1)))))))) a) -> (StrictMono.{0, u1} Int α (PartialOrder.toPreorder.{0} Int (StrictOrderedRing.toPartialOrder.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1)) (fun (n : Int) => HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n))
Case conversion may be inaccurate. Consider using '#align zpow_strict_mono_right zpow_strictMono_rightₓ'. -/
@[to_additive zsmul_strictMono_left]
theorem zpow_strictMono_right (ha : 1 < a) : StrictMono fun n : ℤ => a ^ n := fun m n h =>
  calc
    a ^ m = a ^ m * 1 := (mul_one _).symm
    _ < a ^ m * a ^ (n - m) := (mul_lt_mul_left' (one_lt_zpow' ha <| sub_pos_of_lt h) _)
    _ = a ^ n := by
      rw [← zpow_add]
      simp
    
#align zpow_strict_mono_right zpow_strictMono_right
#align zsmul_strict_mono_left zsmul_strictMono_left

/- warning: zpow_mono_right -> zpow_mono_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {a : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))))))) a) -> (Monotone.{0, u1} Int α (PartialOrder.toPreorder.{0} Int (OrderedAddCommGroup.toPartialOrder.{0} Int (StrictOrderedRing.toOrderedAddCommGroup.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1)) (fun (n : Int) => HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {a : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroup.toDivisionCommMonoid.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1)))))))) a) -> (Monotone.{0, u1} Int α (PartialOrder.toPreorder.{0} Int (StrictOrderedRing.toPartialOrder.{0} Int (LinearOrderedRing.toStrictOrderedRing.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)))) (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1)) (fun (n : Int) => HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n))
Case conversion may be inaccurate. Consider using '#align zpow_mono_right zpow_mono_rightₓ'. -/
@[to_additive zsmul_mono_left]
theorem zpow_mono_right (ha : 1 ≤ a) : Monotone fun n : ℤ => a ^ n := fun m n h =>
  calc
    a ^ m = a ^ m * 1 := (mul_one _).symm
    _ ≤ a ^ m * a ^ (n - m) := (mul_le_mul_left' (one_le_zpow ha <| sub_nonneg_of_le h) _)
    _ = a ^ n := by
      rw [← zpow_add]
      simp
    
#align zpow_mono_right zpow_mono_right
#align zsmul_mono_left zsmul_mono_left

/- warning: zpow_le_zpow -> zpow_le_zpow is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {m : Int} {n : Int} {a : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))))))) a) -> (LE.le.{0} Int Int.hasLe m n) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a m) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {m : Int} {n : Int} {a : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroup.toDivisionCommMonoid.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1)))))))) a) -> (LE.le.{0} Int Int.instLEInt m n) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a m) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n))
Case conversion may be inaccurate. Consider using '#align zpow_le_zpow zpow_le_zpowₓ'. -/
@[to_additive]
theorem zpow_le_zpow (ha : 1 ≤ a) (h : m ≤ n) : a ^ m ≤ a ^ n :=
  zpow_mono_right ha h
#align zpow_le_zpow zpow_le_zpow
#align zsmul_le_zsmul zsmul_le_zsmul

/- warning: zpow_lt_zpow -> zpow_lt_zpow is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {m : Int} {n : Int} {a : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))))))) a) -> (LT.lt.{0} Int Int.hasLt m n) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a m) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {m : Int} {n : Int} {a : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroup.toDivisionCommMonoid.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1)))))))) a) -> (LT.lt.{0} Int Int.instLTInt m n) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a m) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n))
Case conversion may be inaccurate. Consider using '#align zpow_lt_zpow zpow_lt_zpowₓ'. -/
@[to_additive]
theorem zpow_lt_zpow (ha : 1 < a) (h : m < n) : a ^ m < a ^ n :=
  zpow_strictMono_right ha h
#align zpow_lt_zpow zpow_lt_zpow
#align zsmul_lt_zsmul zsmul_lt_zsmul

/- warning: zpow_le_zpow_iff -> zpow_le_zpow_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {m : Int} {n : Int} {a : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))))))) a) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a m) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n)) (LE.le.{0} Int Int.hasLe m n))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {m : Int} {n : Int} {a : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroup.toDivisionCommMonoid.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1)))))))) a) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a m) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n)) (LE.le.{0} Int Int.instLEInt m n))
Case conversion may be inaccurate. Consider using '#align zpow_le_zpow_iff zpow_le_zpow_iffₓ'. -/
@[to_additive]
theorem zpow_le_zpow_iff (ha : 1 < a) : a ^ m ≤ a ^ n ↔ m ≤ n :=
  (zpow_strictMono_right ha).le_iff_le
#align zpow_le_zpow_iff zpow_le_zpow_iff
#align zsmul_le_zsmul_iff zsmul_le_zsmul_iff

/- warning: zpow_lt_zpow_iff -> zpow_lt_zpow_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {m : Int} {n : Int} {a : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (Monoid.toMulOneClass.{u1} α (DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))))))) a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a m) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n)) (LT.lt.{0} Int Int.hasLt m n))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : OrderedCommGroup.{u1} α] {m : Int} {n : Int} {a : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroup.toDivisionCommMonoid.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1)))))))) a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommGroup.toPartialOrder.{u1} α _inst_1))) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a m) (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int (DivInvMonoid.Pow.{u1} α (Group.toDivInvMonoid.{u1} α (CommGroup.toGroup.{u1} α (OrderedCommGroup.toCommGroup.{u1} α _inst_1))))) a n)) (LT.lt.{0} Int Int.instLTInt m n))
Case conversion may be inaccurate. Consider using '#align zpow_lt_zpow_iff zpow_lt_zpow_iffₓ'. -/
@[to_additive]
theorem zpow_lt_zpow_iff (ha : 1 < a) : a ^ m < a ^ n ↔ m < n :=
  (zpow_strictMono_right ha).lt_iff_lt
#align zpow_lt_zpow_iff zpow_lt_zpow_iff
#align zsmul_lt_zsmul_iff zsmul_lt_zsmul_iff

variable (α)

#print zpow_strictMono_left /-
@[to_additive zsmul_strictMono_right]
theorem zpow_strictMono_left (hn : 0 < n) : StrictMono ((· ^ n) : α → α) := fun a b hab =>
  by
  rw [← one_lt_div', ← div_zpow]
  exact one_lt_zpow' (one_lt_div'.2 hab) hn
#align zpow_strict_mono_left zpow_strictMono_left
#align zsmul_strict_mono_right zsmul_strictMono_right
-/

#print zpow_mono_left /-
@[to_additive zsmul_mono_right]
theorem zpow_mono_left (hn : 0 ≤ n) : Monotone ((· ^ n) : α → α) := fun a b hab =>
  by
  rw [← one_le_div', ← div_zpow]
  exact one_le_zpow (one_le_div'.2 hab) hn
#align zpow_mono_left zpow_mono_left
#align zsmul_mono_right zsmul_mono_right
-/

variable {α}

#print zpow_le_zpow' /-
@[to_additive]
theorem zpow_le_zpow' (hn : 0 ≤ n) (h : a ≤ b) : a ^ n ≤ b ^ n :=
  zpow_mono_left α hn h
#align zpow_le_zpow' zpow_le_zpow'
#align zsmul_le_zsmul' zsmul_le_zsmul'
-/

#print zpow_lt_zpow' /-
@[to_additive]
theorem zpow_lt_zpow' (hn : 0 < n) (h : a < b) : a ^ n < b ^ n :=
  zpow_strictMono_left α hn h
#align zpow_lt_zpow' zpow_lt_zpow'
#align zsmul_lt_zsmul' zsmul_lt_zsmul'
-/

end OrderedAddCommGroup

section LinearOrderedCommGroup

variable [LinearOrderedCommGroup α] {n : ℤ} {a b : α}

#print zpow_le_zpow_iff' /-
@[to_additive]
theorem zpow_le_zpow_iff' (hn : 0 < n) {a b : α} : a ^ n ≤ b ^ n ↔ a ≤ b :=
  (zpow_strictMono_left α hn).le_iff_le
#align zpow_le_zpow_iff' zpow_le_zpow_iff'
#align zsmul_le_zsmul_iff' zsmul_le_zsmul_iff'
-/

#print zpow_lt_zpow_iff' /-
@[to_additive]
theorem zpow_lt_zpow_iff' (hn : 0 < n) {a b : α} : a ^ n < b ^ n ↔ a < b :=
  (zpow_strictMono_left α hn).lt_iff_lt
#align zpow_lt_zpow_iff' zpow_lt_zpow_iff'
#align zsmul_lt_zsmul_iff' zsmul_lt_zsmul_iff'
-/

#print zpow_left_injective /-
@[nolint to_additive_doc,
  to_additive zsmul_right_injective
      "See also `smul_right_injective`. TODO: provide a `no_zero_smul_divisors` instance. We can't do that\nhere because importing that definition would create import cycles."]
theorem zpow_left_injective (hn : n ≠ 0) : Function.Injective ((· ^ n) : α → α) :=
  by
  cases hn.symm.lt_or_lt
  · exact (zpow_strictMono_left α h).Injective
  · refine' fun a b (hab : a ^ n = b ^ n) => (zpow_strictMono_left α (neg_pos.mpr h)).Injective _
    rw [zpow_neg, zpow_neg, hab]
#align zpow_left_injective zpow_left_injective
#align zsmul_right_injective zsmul_right_injective
-/

#print zpow_left_inj /-
@[to_additive zsmul_right_inj]
theorem zpow_left_inj (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b :=
  (zpow_left_injective hn).eq_iff
#align zpow_left_inj zpow_left_inj
#align zsmul_right_inj zsmul_right_inj
-/

#print zpow_eq_zpow_iff' /-
/-- Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and
`zsmul_lt_zsmul_iff'`. -/
@[to_additive
      "Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and\n`zsmul_lt_zsmul_iff'`."]
theorem zpow_eq_zpow_iff' (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b :=
  zpow_left_inj hn
#align zpow_eq_zpow_iff' zpow_eq_zpow_iff'
#align zsmul_eq_zsmul_iff' zsmul_eq_zsmul_iff'
-/

end LinearOrderedCommGroup

section LinearOrderedAddCommGroup

variable [LinearOrderedAddCommGroup α] {a b : α}

/- warning: abs_nsmul -> abs_nsmul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] (n : Nat) (a : α), Eq.{succ u1} α (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1))))) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))) n a)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))) n (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1))))) a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] (n : Nat) (a : α), Eq.{succ u1} α (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) (SemilatticeSup.toSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1)))))) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) n a)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) n (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) (SemilatticeSup.toSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1)))))) a))
Case conversion may be inaccurate. Consider using '#align abs_nsmul abs_nsmulₓ'. -/
theorem abs_nsmul (n : ℕ) (a : α) : |n • a| = n • |a| :=
  by
  cases' le_total a 0 with hneg hpos
  · rw [abs_of_nonpos hneg, ← abs_neg, ← neg_nsmul, abs_of_nonneg]
    exact nsmul_nonneg (neg_nonneg.mpr hneg) n
  · rw [abs_of_nonneg hpos, abs_of_nonneg]
    exact nsmul_nonneg hpos n
#align abs_nsmul abs_nsmul

/- warning: abs_zsmul -> abs_zsmul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] (n : Int) (a : α), Eq.{succ u1} α (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1))))) (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) n a)) (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (Abs.abs.{0} Int (Neg.toHasAbs.{0} Int Int.hasNeg (SemilatticeSup.toHasSup.{0} Int (Lattice.toSemilatticeSup.{0} Int (LinearOrder.toLattice.{0} Int Int.linearOrder)))) n) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1))))) a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] (n : Int) (a : α), Eq.{succ u1} α (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) (SemilatticeSup.toSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1)))))) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))) n a)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))) (Abs.abs.{0} Int (Neg.toHasAbs.{0} Int Int.instNegInt (SemilatticeSup.toSup.{0} Int (Lattice.toSemilatticeSup.{0} Int (DistribLattice.toLattice.{0} Int (instDistribLattice.{0} Int Int.instLinearOrderInt))))) n) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) (SemilatticeSup.toSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1)))))) a))
Case conversion may be inaccurate. Consider using '#align abs_zsmul abs_zsmulₓ'. -/
theorem abs_zsmul (n : ℤ) (a : α) : |n • a| = |n| • |a| :=
  by
  obtain n0 | n0 := le_total 0 n
  · lift n to ℕ using n0
    simp only [abs_nsmul, abs_coe_nat, coe_nat_zsmul]
  · lift -n to ℕ using neg_nonneg.2 n0 with m h
    rw [← abs_neg (n • a), ← neg_zsmul, ← abs_neg n, ← h, coe_nat_zsmul, abs_coe_nat, coe_nat_zsmul]
    exact abs_nsmul m _
#align abs_zsmul abs_zsmul

/- warning: abs_add_eq_add_abs_le -> abs_add_eq_add_abs_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) a b) -> (Iff (Eq.{succ u1} α (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) a b)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1))))) a) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1))))) b))) (Or (And (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) a) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) b)) (And (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) a b) -> (Iff (Eq.{succ u1} α (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) (SemilatticeSup.toSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1)))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) a b)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) (SemilatticeSup.toSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1)))))) a) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) (SemilatticeSup.toSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1)))))) b))) (Or (And (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (NegZeroClass.toZero.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))))) a) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (NegZeroClass.toZero.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))))) b)) (And (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (NegZeroClass.toZero.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (NegZeroClass.toZero.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))))))
Case conversion may be inaccurate. Consider using '#align abs_add_eq_add_abs_le abs_add_eq_add_abs_leₓ'. -/
theorem abs_add_eq_add_abs_le (hle : a ≤ b) : |a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 :=
  by
  obtain a0 | a0 := le_or_lt 0 a <;> obtain b0 | b0 := le_or_lt 0 b
  · simp [a0, b0, abs_of_nonneg, add_nonneg a0 b0]
  · exact (lt_irrefl (0 : α) <| a0.trans_lt <| hle.trans_lt b0).elim
  any_goals simp [a0.le, b0.le, abs_of_nonpos, add_nonpos, add_comm]
  have : (|a + b| = -a + b ↔ b ≤ 0) ↔ (|a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0) := by
    simp [a0, a0.le, a0.not_le, b0, abs_of_neg, abs_of_nonneg]
  refine' this.mp ⟨fun h => _, fun h => by simp only [le_antisymm h b0, abs_of_neg a0, add_zero]⟩
  obtain ab | ab := le_or_lt (a + b) 0
  · refine' le_of_eq (eq_zero_of_neg_eq _)
    rwa [abs_of_nonpos ab, neg_add_rev, add_comm, add_right_inj] at h
  · refine' (lt_irrefl (0 : α) _).elim
    rw [abs_of_pos ab, add_left_inj] at h
    rwa [eq_zero_of_neg_eq h.symm] at a0
#align abs_add_eq_add_abs_le abs_add_eq_add_abs_le

/- warning: abs_add_eq_add_abs_iff -> abs_add_eq_add_abs_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] (a : α) (b : α), Iff (Eq.{succ u1} α (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) a b)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1))))) a) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))) (SemilatticeSup.toHasSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (LinearOrder.toLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1))))) b))) (Or (And (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) a) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) b)) (And (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] (a : α) (b : α), Iff (Eq.{succ u1} α (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) (SemilatticeSup.toSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1)))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) a b)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) (SemilatticeSup.toSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1)))))) a) (Abs.abs.{u1} α (Neg.toHasAbs.{u1} α (NegZeroClass.toNeg.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) (SemilatticeSup.toSup.{u1} α (Lattice.toSemilatticeSup.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α (LinearOrderedAddCommGroup.toLinearOrder.{u1} α _inst_1)))))) b))) (Or (And (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (NegZeroClass.toZero.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))))) a) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (NegZeroClass.toZero.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))))) b)) (And (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (NegZeroClass.toZero.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (NegZeroClass.toZero.{u1} α (SubNegZeroMonoid.toNegZeroClass.{u1} α (SubtractionMonoid.toSubNegZeroMonoid.{u1} α (SubtractionCommMonoid.toSubtractionMonoid.{u1} α (AddCommGroup.toDivisionAddCommMonoid.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))))))))
Case conversion may be inaccurate. Consider using '#align abs_add_eq_add_abs_iff abs_add_eq_add_abs_iffₓ'. -/
theorem abs_add_eq_add_abs_iff (a b : α) : |a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 :=
  by
  obtain ab | ab := le_total a b
  · exact abs_add_eq_add_abs_le ab
  · rw [add_comm a, add_comm (abs _), abs_add_eq_add_abs_le ab, and_comm, @and_comm (b ≤ 0)]
#align abs_add_eq_add_abs_iff abs_add_eq_add_abs_iff

end LinearOrderedAddCommGroup

#print WithBot.coe_nsmul /-
@[simp]
theorem WithBot.coe_nsmul [AddMonoid A] (a : A) (n : ℕ) : ((n • a : A) : WithBot A) = n • a :=
  AddMonoidHom.map_nsmul ⟨(coe : A → WithBot A), WithBot.coe_zero, WithBot.coe_add⟩ a n
#align with_bot.coe_nsmul WithBot.coe_nsmul
-/

theorem nsmul_eq_mul' [NonAssocSemiring R] (a : R) (n : ℕ) : n • a = a * n := by
  induction' n with n ih <;> [rw [zero_nsmul, Nat.cast_zero, MulZeroClass.mul_zero],
    rw [succ_nsmul', ih, Nat.cast_succ, mul_add, mul_one]]
#align nsmul_eq_mul' nsmul_eq_mul'ₓ

@[simp]
theorem nsmul_eq_mul [NonAssocSemiring R] (n : ℕ) (a : R) : n • a = n * a := by
  rw [nsmul_eq_mul', (n.cast_commute a).Eq]
#align nsmul_eq_mul nsmul_eq_mulₓ

/- warning: non_unital_non_assoc_semiring.nat_smul_comm_class -> NonUnitalNonAssocSemiring.nat_smulCommClass is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], SMulCommClass.{0, u1, u1} Nat R R (AddMonoid.SMul.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], SMulCommClass.{0, u1, u1} Nat R R (AddMonoid.SMul.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (Mul.toSMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align non_unital_non_assoc_semiring.nat_smul_comm_class NonUnitalNonAssocSemiring.nat_smulCommClassₓ'. -/
/-- Note that `add_comm_monoid.nat_smul_comm_class` requires stronger assumptions on `R`. -/
instance NonUnitalNonAssocSemiring.nat_smulCommClass [NonUnitalNonAssocSemiring R] :
    SMulCommClass ℕ R R :=
  ⟨fun n x y =>
    match n with
    | 0 => by simp_rw [zero_nsmul, smul_eq_mul, MulZeroClass.mul_zero]
    | n + 1 => by simp_rw [succ_nsmul, smul_eq_mul, mul_add, ← smul_eq_mul, _match n]⟩
#align non_unital_non_assoc_semiring.nat_smul_comm_class NonUnitalNonAssocSemiring.nat_smulCommClass

/- warning: non_unital_non_assoc_semiring.nat_is_scalar_tower -> NonUnitalNonAssocSemiring.nat_isScalarTower is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], IsScalarTower.{0, u1, u1} Nat R R (AddMonoid.SMul.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R _inst_1))) (AddMonoid.SMul.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} R], IsScalarTower.{0, u1, u1} Nat R R (AddMonoid.SMul.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1))) (Mul.toSMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R _inst_1)) (AddMonoid.SMul.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align non_unital_non_assoc_semiring.nat_is_scalar_tower NonUnitalNonAssocSemiring.nat_isScalarTowerₓ'. -/
/-- Note that `add_comm_monoid.nat_is_scalar_tower` requires stronger assumptions on `R`. -/
instance NonUnitalNonAssocSemiring.nat_isScalarTower [NonUnitalNonAssocSemiring R] :
    IsScalarTower ℕ R R :=
  ⟨fun n x y =>
    match n with
    | 0 => by simp_rw [zero_nsmul, smul_eq_mul, MulZeroClass.zero_mul]
    | n + 1 => by simp_rw [succ_nsmul, ← _match n, smul_eq_mul, add_mul]⟩
#align non_unital_non_assoc_semiring.nat_is_scalar_tower NonUnitalNonAssocSemiring.nat_isScalarTower

#print Nat.cast_pow /-
@[simp, norm_cast]
theorem Nat.cast_pow [Semiring R] (n m : ℕ) : (↑(n ^ m) : R) = ↑n ^ m :=
  by
  induction' m with m ih
  · rw [pow_zero, pow_zero]
    exact Nat.cast_one
  · rw [pow_succ', pow_succ', Nat.cast_mul, ih]
#align nat.cast_pow Nat.cast_pow
-/

/- warning: int.coe_nat_pow -> Int.coe_nat_pow is a dubious translation:
lean 3 declaration is
  forall (n : Nat) (m : Nat), Eq.{1} Int ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) n m)) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) n) m)
but is expected to have type
  forall (n : Nat) (m : Nat), Eq.{1} Int (Nat.cast.{0} Int instNatCastInt (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) n m)) (HPow.hPow.{0, 0, 0} Int Nat Int Int.instHPowIntNat (Nat.cast.{0} Int instNatCastInt n) m)
Case conversion may be inaccurate. Consider using '#align int.coe_nat_pow Int.coe_nat_powₓ'. -/
@[simp, norm_cast]
theorem Int.coe_nat_pow (n m : ℕ) : ((n ^ m : ℕ) : ℤ) = n ^ m := by
  induction' m with m ih <;> [exact Int.ofNat_one, rw [pow_succ', pow_succ', Int.ofNat_mul, ih]]
#align int.coe_nat_pow Int.coe_nat_pow

/- warning: int.nat_abs_pow -> Int.natAbs_pow is a dubious translation:
lean 3 declaration is
  forall (n : Int) (k : Nat), Eq.{1} Nat (Int.natAbs (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) n k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (Monoid.Pow.{0} Nat Nat.monoid)) (Int.natAbs n) k)
but is expected to have type
  forall (n : Int) (k : Nat), Eq.{1} Nat (Int.natAbs (HPow.hPow.{0, 0, 0} Int Nat Int Int.instHPowIntNat n k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat instPowNat) (Int.natAbs n) k)
Case conversion may be inaccurate. Consider using '#align int.nat_abs_pow Int.natAbs_powₓ'. -/
theorem Int.natAbs_pow (n : ℤ) (k : ℕ) : Int.natAbs (n ^ k) = Int.natAbs n ^ k := by
  induction' k with k ih <;> [rfl, rw [pow_succ', Int.natAbs_mul, pow_succ', ih]]
#align int.nat_abs_pow Int.natAbs_pow

/- warning: bit0_mul -> bit0_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} R] {n : R} {r : R}, Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) n) r) (SMul.smul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1)))) (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) n r))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} R] {n : R} {r : R}, Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R _inst_1)) (bit0.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) n) r) (HSMul.hSMul.{0, u1, u1} Int R R (instHSMul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1))))) (OfNat.ofNat.{0} Int 2 (instOfNatInt 2)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R _inst_1)) n r))
Case conversion may be inaccurate. Consider using '#align bit0_mul bit0_mulₓ'. -/
-- The next four lemmas allow us to replace multiplication by a numeral with a `zsmul` expression.
-- They are used by the `noncomm_ring` tactic, to normalise expressions before passing to `abel`.
theorem bit0_mul [NonUnitalNonAssocRing R] {n r : R} : bit0 n * r = (2 : ℤ) • (n * r) :=
  by
  dsimp [bit0]
  rw [add_mul, add_zsmul, one_zsmul]
#align bit0_mul bit0_mul

/- warning: mul_bit0 -> mul_bit0 is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} R] {n : R} {r : R}, Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) r (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) n)) (SMul.smul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1)))) (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) r n))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} R] {n : R} {r : R}, Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R _inst_1)) r (bit0.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))) n)) (HSMul.hSMul.{0, u1, u1} Int R R (instHSMul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1))))) (OfNat.ofNat.{0} Int 2 (instOfNatInt 2)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R _inst_1)) r n))
Case conversion may be inaccurate. Consider using '#align mul_bit0 mul_bit0ₓ'. -/
theorem mul_bit0 [NonUnitalNonAssocRing R] {n r : R} : r * bit0 n = (2 : ℤ) • (r * n) :=
  by
  dsimp [bit0]
  rw [mul_add, add_zsmul, one_zsmul]
#align mul_bit0 mul_bit0

/- warning: bit1_mul -> bit1_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonAssocRing.{u1} R] {n : R} {r : R}, Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))))) (bit1.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (NonAssocRing.toAddCommGroupWithOne.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) n) r) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))))) (SMul.smul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (NonAssocRing.toAddCommGroupWithOne.{u1} R _inst_1))))) (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))))) n r)) r)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonAssocRing.{u1} R] {n : R} {r : R}, Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))) (bit1.{u1} R (NonAssocRing.toOne.{u1} R _inst_1) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) n) r) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))))) (HSMul.hSMul.{0, u1, u1} Int R R (instHSMul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (NonAssocRing.toAddCommGroupWithOne.{u1} R _inst_1)))))) (OfNat.ofNat.{0} Int 2 (instOfNatInt 2)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))) n r)) r)
Case conversion may be inaccurate. Consider using '#align bit1_mul bit1_mulₓ'. -/
theorem bit1_mul [NonAssocRing R] {n r : R} : bit1 n * r = (2 : ℤ) • (n * r) + r :=
  by
  dsimp [bit1]
  rw [add_mul, bit0_mul, one_mul]
#align bit1_mul bit1_mul

/- warning: mul_bit1 -> mul_bit1 is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonAssocRing.{u1} R] {n : R} {r : R}, Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))))) r (bit1.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (NonAssocRing.toAddCommGroupWithOne.{u1} R _inst_1)))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) n)) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))))) (SMul.smul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (NonAssocRing.toAddCommGroupWithOne.{u1} R _inst_1))))) (OfNat.ofNat.{0} Int 2 (OfNat.mk.{0} Int 2 (bit0.{0} Int Int.hasAdd (One.one.{0} Int Int.hasOne)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))))) r n)) r)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonAssocRing.{u1} R] {n : R} {r : R}, Eq.{succ u1} R (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))) r (bit1.{u1} R (NonAssocRing.toOne.{u1} R _inst_1) (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1)))) n)) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))))) (HSMul.hSMul.{0, u1, u1} Int R R (instHSMul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (NonAssocRing.toAddCommGroupWithOne.{u1} R _inst_1)))))) (OfNat.ofNat.{0} Int 2 (instOfNatInt 2)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R _inst_1))) r n)) r)
Case conversion may be inaccurate. Consider using '#align mul_bit1 mul_bit1ₓ'. -/
theorem mul_bit1 [NonAssocRing R] {n r : R} : r * bit1 n = (2 : ℤ) • (r * n) + r :=
  by
  dsimp [bit1]
  rw [mul_add, mul_bit0, mul_one]
#align mul_bit1 mul_bit1

/- warning: zsmul_eq_mul -> zsmul_eq_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (a : R) (n : Int), Eq.{succ u1} R (SMul.smul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))) n a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))) n) a)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (a : R) (n : Int), Eq.{succ u1} R (HSMul.hSMul.{0, u1, u1} Int R R (instHSMul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_1))))) n a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_1) n) a)
Case conversion may be inaccurate. Consider using '#align zsmul_eq_mul zsmul_eq_mulₓ'. -/
@[simp]
theorem zsmul_eq_mul [Ring R] (a : R) : ∀ n : ℤ, n • a = n * a
  | (n : ℕ) => by rw [coe_nat_zsmul, nsmul_eq_mul, Int.cast_ofNat]
  | -[n+1] => by simp [Nat.cast_succ, neg_add_rev, Int.cast_negSucc, add_mul]
#align zsmul_eq_mul zsmul_eq_mul

/- warning: zsmul_eq_mul' -> zsmul_eq_mul' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (a : R) (n : Int), Eq.{succ u1} R (SMul.smul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))) n a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1))) a ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))) n))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] (a : R) (n : Int), Eq.{succ u1} R (HSMul.hSMul.{0, u1, u1} Int R R (instHSMul.{0, u1} Int R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_1))))) n a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))) a (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_1) n))
Case conversion may be inaccurate. Consider using '#align zsmul_eq_mul' zsmul_eq_mul'ₓ'. -/
theorem zsmul_eq_mul' [Ring R] (a : R) (n : ℤ) : n • a = a * n := by
  rw [zsmul_eq_mul, (n.cast_commute a).Eq]
#align zsmul_eq_mul' zsmul_eq_mul'

/- warning: non_unital_non_assoc_ring.int_smul_comm_class -> NonUnitalNonAssocRing.int_smulCommClass is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} R], SMulCommClass.{0, u1, u1} Int R R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1)))) (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} R], SMulCommClass.{0, u1, u1} Int R R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1)))) (Mul.toSMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align non_unital_non_assoc_ring.int_smul_comm_class NonUnitalNonAssocRing.int_smulCommClassₓ'. -/
/-- Note that `add_comm_group.int_smul_comm_class` requires stronger assumptions on `R`. -/
instance NonUnitalNonAssocRing.int_smulCommClass [NonUnitalNonAssocRing R] : SMulCommClass ℤ R R :=
  ⟨fun n x y =>
    match n with
    | (n : ℕ) => by simp_rw [coe_nat_zsmul, smul_comm]
    | -[n+1] => by simp_rw [negSucc_zsmul, smul_eq_mul, mul_neg, mul_smul_comm]⟩
#align non_unital_non_assoc_ring.int_smul_comm_class NonUnitalNonAssocRing.int_smulCommClass

/- warning: non_unital_non_assoc_ring.int_is_scalar_tower -> NonUnitalNonAssocRing.int_isScalarTower is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} R], IsScalarTower.{0, u1, u1} Int R R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1)))) (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R _inst_1)))) (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} R], IsScalarTower.{0, u1, u1} Int R R (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1)))) (Mul.toSMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R _inst_1)) (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddCommGroup.toAddGroup.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align non_unital_non_assoc_ring.int_is_scalar_tower NonUnitalNonAssocRing.int_isScalarTowerₓ'. -/
/-- Note that `add_comm_group.int_is_scalar_tower` requires stronger assumptions on `R`. -/
instance NonUnitalNonAssocRing.int_isScalarTower [NonUnitalNonAssocRing R] : IsScalarTower ℤ R R :=
  ⟨fun n x y =>
    match n with
    | (n : ℕ) => by simp_rw [coe_nat_zsmul, smul_assoc]
    | -[n+1] => by simp_rw [negSucc_zsmul, smul_eq_mul, neg_mul, smul_mul_assoc]⟩
#align non_unital_non_assoc_ring.int_is_scalar_tower NonUnitalNonAssocRing.int_isScalarTower

/- warning: zsmul_int_int -> zsmul_int_int is a dubious translation:
lean 3 declaration is
  forall (a : Int) (b : Int), Eq.{1} Int (SMul.smul.{0, 0} Int Int (SubNegMonoid.SMulInt.{0} Int (AddGroup.toSubNegMonoid.{0} Int Int.addGroup)) a b) (HMul.hMul.{0, 0, 0} Int Int Int (instHMul.{0} Int Int.hasMul) a b)
but is expected to have type
  forall (a : Int) (b : Int), Eq.{1} Int (HSMul.hSMul.{0, 0, 0} Int Int Int (instHSMul.{0, 0} Int Int (SubNegMonoid.SMulInt.{0} Int (AddGroup.toSubNegMonoid.{0} Int Int.instAddGroupInt))) a b) (HMul.hMul.{0, 0, 0} Int Int Int (instHMul.{0} Int Int.instMulInt) a b)
Case conversion may be inaccurate. Consider using '#align zsmul_int_int zsmul_int_intₓ'. -/
theorem zsmul_int_int (a b : ℤ) : a • b = a * b := by simp
#align zsmul_int_int zsmul_int_int

/- warning: zsmul_int_one -> zsmul_int_one is a dubious translation:
lean 3 declaration is
  forall (n : Int), Eq.{1} Int (SMul.smul.{0, 0} Int Int (SubNegMonoid.SMulInt.{0} Int (AddGroup.toSubNegMonoid.{0} Int Int.addGroup)) n (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) n
but is expected to have type
  forall (n : Int), Eq.{1} Int (HSMul.hSMul.{0, 0, 0} Int Int Int (instHSMul.{0, 0} Int Int (SubNegMonoid.SMulInt.{0} Int (AddGroup.toSubNegMonoid.{0} Int Int.instAddGroupInt))) n (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) n
Case conversion may be inaccurate. Consider using '#align zsmul_int_one zsmul_int_oneₓ'. -/
theorem zsmul_int_one (n : ℤ) : n • 1 = n := by simp
#align zsmul_int_one zsmul_int_one

@[simp, norm_cast]
theorem Int.cast_pow [Ring R] (n : ℤ) (m : ℕ) : (↑(n ^ m) : R) = ↑n ^ m :=
  by
  induction' m with m ih
  · rw [pow_zero, pow_zero, Int.cast_one]
  · rw [pow_succ, pow_succ, Int.cast_mul, ih]
#align int.cast_pow Int.cast_powₓ

/- warning: neg_one_pow_eq_pow_mod_two -> neg_one_pow_eq_pow_mod_two is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {n : Nat}, Eq.{succ u1} R (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R _inst_1))) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) n) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R _inst_1))) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.hasMod) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {n : Nat}, Eq.{succ u1} R (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) n) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_1) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (HMod.hMod.{0, 0, 0} Nat Nat Nat (instHMod.{0} Nat Nat.instModNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))))
Case conversion may be inaccurate. Consider using '#align neg_one_pow_eq_pow_mod_two neg_one_pow_eq_pow_mod_twoₓ'. -/
theorem neg_one_pow_eq_pow_mod_two [Ring R] {n : ℕ} : (-1 : R) ^ n = (-1) ^ (n % 2) := by
  rw [← Nat.mod_add_div n 2, pow_add, pow_mul] <;> simp [sq]
#align neg_one_pow_eq_pow_mod_two neg_one_pow_eq_pow_mod_two

section StrictOrderedSemiring

variable [StrictOrderedSemiring R] {a : R}

/- warning: one_add_mul_le_pow' -> one_add_mul_le_pow' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) a a)) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) a) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) a))) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))))))) a)) -> (forall (n : Nat), LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) n) a)) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) a) n))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a a)) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))) a) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))) a))) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) a)) -> (forall (n : Nat), LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)) n) a)) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))) a) n))
Case conversion may be inaccurate. Consider using '#align one_add_mul_le_pow' one_add_mul_le_pow'ₓ'. -/
/-- Bernoulli's inequality. This version works for semirings but requires
additional hypotheses `0 ≤ a * a` and `0 ≤ (1 + a) * (1 + a)`. -/
theorem one_add_mul_le_pow' (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) :
    ∀ n : ℕ, 1 + (n : R) * a ≤ (1 + a) ^ n
  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ≤ (n : R) * (a * a * (2 + a)) + a * a :=
      add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq
    calc
      1 + (↑(n + 2) : R) * a ≤ 1 + ↑(n + 2) * a + (n * (a * a * (2 + a)) + a * a) :=
        (le_add_iff_nonneg_right _).2 this
      _ = (1 + a) * (1 + a) * (1 + n * a) :=
        by
        simp [add_mul, mul_add, bit0, mul_assoc, (n.cast_commute (_ : R)).and_left_comm]
        ac_rfl
      _ ≤ (1 + a) * (1 + a) * (1 + a) ^ n :=
        (mul_le_mul_of_nonneg_left (one_add_mul_le_pow' n) Hsq')
      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ, mul_assoc]
      
#align one_add_mul_le_pow' one_add_mul_le_pow'

#print pow_le_pow_of_le_one_aux /-
private theorem pow_le_pow_of_le_one_aux (h : 0 ≤ a) (ha : a ≤ 1) (i : ℕ) :
    ∀ k : ℕ, a ^ (i + k) ≤ a ^ i
  | 0 => by simp
  | k + 1 => by
    rw [← add_assoc, ← one_mul (a ^ i), pow_succ]
    exact mul_le_mul ha (pow_le_pow_of_le_one_aux _) (pow_nonneg h _) zero_le_one
#align pow_le_pow_of_le_one_aux pow_le_pow_of_le_one_aux
-/

/- warning: pow_le_pow_of_le_one -> pow_le_pow_of_le_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) a) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) a (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))))))) -> (forall {i : Nat} {j : Nat}, (LE.le.{0} Nat Nat.hasLe i j) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a j) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a i)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) a (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) -> (forall {i : Nat} {j : Nat}, (LE.le.{0} Nat instLENat i j) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a j) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a i)))
Case conversion may be inaccurate. Consider using '#align pow_le_pow_of_le_one pow_le_pow_of_le_oneₓ'. -/
theorem pow_le_pow_of_le_one (h : 0 ≤ a) (ha : a ≤ 1) {i j : ℕ} (hij : i ≤ j) : a ^ j ≤ a ^ i :=
  by
  let ⟨k, hk⟩ := Nat.exists_eq_add_of_le hij
  rw [hk] <;> exact pow_le_pow_of_le_one_aux h ha _ _
#align pow_le_pow_of_le_one pow_le_pow_of_le_one

/- warning: pow_le_of_le_one -> pow_le_of_le_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) a) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) a (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))))))) -> (forall {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a n) a))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) a (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) -> (forall {n : Nat}, (Ne.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a n) a))
Case conversion may be inaccurate. Consider using '#align pow_le_of_le_one pow_le_of_le_oneₓ'. -/
theorem pow_le_of_le_one (h₀ : 0 ≤ a) (h₁ : a ≤ 1) {n : ℕ} (hn : n ≠ 0) : a ^ n ≤ a :=
  (pow_one a).subst (pow_le_pow_of_le_one h₀ h₁ (Nat.pos_of_ne_zero hn))
#align pow_le_of_le_one pow_le_of_le_one

/- warning: sq_le -> sq_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) a) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) a (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))))))) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) a)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) a (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) a (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) a)
Case conversion may be inaccurate. Consider using '#align sq_le sq_leₓ'. -/
theorem sq_le (h₀ : 0 ≤ a) (h₁ : a ≤ 1) : a ^ 2 ≤ a :=
  pow_le_of_le_one h₀ h₁ two_ne_zero
#align sq_le sq_le

end StrictOrderedSemiring

section LinearOrderedSemiring

variable [LinearOrderedSemiring R]

/- warning: sign_cases_of_C_mul_pow_nonneg -> sign_cases_of_C_mul_pow_nonneg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedSemiring.{u1} R] {C : R} {r : R}, (forall (n : Nat), LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))))) C (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))) r n))) -> (Or (Eq.{succ u1} R C (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))))))) (And (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))))))) C) (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))))))) r)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedSemiring.{u1} R] {C : R} {r : R}, (forall (n : Nat), LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))) C (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))) r n))) -> (Or (Eq.{succ u1} R C (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1))))))) (And (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))) C) (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R _inst_1)))))) r)))
Case conversion may be inaccurate. Consider using '#align sign_cases_of_C_mul_pow_nonneg sign_cases_of_C_mul_pow_nonnegₓ'. -/
theorem sign_cases_of_C_mul_pow_nonneg {C r : R} (h : ∀ n : ℕ, 0 ≤ C * r ^ n) :
    C = 0 ∨ 0 < C ∧ 0 ≤ r :=
  by
  have : 0 ≤ C := by simpa only [pow_zero, mul_one] using h 0
  refine' this.eq_or_lt.elim (fun h => Or.inl h.symm) fun hC => Or.inr ⟨hC, _⟩
  refine' nonneg_of_mul_nonneg_right _ hC
  simpa only [pow_one] using h 1
#align sign_cases_of_C_mul_pow_nonneg sign_cases_of_C_mul_pow_nonneg

end LinearOrderedSemiring

section LinearOrderedRing

variable [LinearOrderedRing R] {a : R} {n : ℕ}

/- warning: abs_pow -> abs_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] (a : R) (n : Nat), Eq.{succ u1} R (Abs.abs.{u1} R (Neg.toHasAbs.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))) (SemilatticeSup.toHasSup.{u1} R (Lattice.toSemilatticeSup.{u1} R (LinearOrder.toLattice.{u1} R (LinearOrderedRing.toLinearOrder.{u1} R _inst_1))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) a n)) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (Abs.abs.{u1} R (Neg.toHasAbs.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))) (SemilatticeSup.toHasSup.{u1} R (Lattice.toSemilatticeSup.{u1} R (LinearOrder.toLattice.{u1} R (LinearOrderedRing.toLinearOrder.{u1} R _inst_1))))) a) n)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] (a : R) (n : Nat), Eq.{succ u1} R (Abs.abs.{u1} R (Neg.toHasAbs.{u1} R (Ring.toNeg.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))) (SemilatticeSup.toSup.{u1} R (Lattice.toSemilatticeSup.{u1} R (DistribLattice.toLattice.{u1} R (instDistribLattice.{u1} R (LinearOrderedRing.toLinearOrder.{u1} R _inst_1)))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) a n)) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) (Abs.abs.{u1} R (Neg.toHasAbs.{u1} R (Ring.toNeg.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))) (SemilatticeSup.toSup.{u1} R (Lattice.toSemilatticeSup.{u1} R (DistribLattice.toLattice.{u1} R (instDistribLattice.{u1} R (LinearOrderedRing.toLinearOrder.{u1} R _inst_1)))))) a) n)
Case conversion may be inaccurate. Consider using '#align abs_pow abs_powₓ'. -/
@[simp]
theorem abs_pow (a : R) (n : ℕ) : |a ^ n| = |a| ^ n :=
  (pow_abs a n).symm
#align abs_pow abs_pow

/- warning: pow_bit1_neg_iff -> pow_bit1_neg_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R} {n : Nat}, Iff (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) a (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))))))) (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R} {n : Nat}, Iff (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) a (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1)))))))) (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align pow_bit1_neg_iff pow_bit1_neg_iffₓ'. -/
@[simp]
theorem pow_bit1_neg_iff : a ^ bit1 n < 0 ↔ a < 0 :=
  ⟨fun h => not_le.1 fun h' => not_le.2 h <| pow_nonneg h' _, fun ha => pow_bit1_neg ha n⟩
#align pow_bit1_neg_iff pow_bit1_neg_iff

/- warning: pow_bit1_nonneg_iff -> pow_bit1_nonneg_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R} {n : Nat}, Iff (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) a (bit1.{0} Nat Nat.hasOne Nat.hasAdd n))) (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))))) a)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R} {n : Nat}, Iff (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) a (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n))) (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) a)
Case conversion may be inaccurate. Consider using '#align pow_bit1_nonneg_iff pow_bit1_nonneg_iffₓ'. -/
@[simp]
theorem pow_bit1_nonneg_iff : 0 ≤ a ^ bit1 n ↔ 0 ≤ a :=
  le_iff_le_iff_lt_iff_lt.2 pow_bit1_neg_iff
#align pow_bit1_nonneg_iff pow_bit1_nonneg_iff

/- warning: pow_bit1_nonpos_iff -> pow_bit1_nonpos_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R} {n : Nat}, Iff (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) a (bit1.{0} Nat Nat.hasOne Nat.hasAdd n)) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))))))) (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R} {n : Nat}, Iff (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) a (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n)) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1)))))))) (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align pow_bit1_nonpos_iff pow_bit1_nonpos_iffₓ'. -/
@[simp]
theorem pow_bit1_nonpos_iff : a ^ bit1 n ≤ 0 ↔ a ≤ 0 := by
  simp only [le_iff_lt_or_eq, pow_bit1_neg_iff, pow_eq_zero_iff (bit1_pos (zero_le n))]
#align pow_bit1_nonpos_iff pow_bit1_nonpos_iff

/- warning: pow_bit1_pos_iff -> pow_bit1_pos_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R} {n : Nat}, Iff (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) a (bit1.{0} Nat Nat.hasOne Nat.hasAdd n))) (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))))) a)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R} {n : Nat}, Iff (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) a (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n))) (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) a)
Case conversion may be inaccurate. Consider using '#align pow_bit1_pos_iff pow_bit1_pos_iffₓ'. -/
@[simp]
theorem pow_bit1_pos_iff : 0 < a ^ bit1 n ↔ 0 < a :=
  lt_iff_lt_of_le_iff_le pow_bit1_nonpos_iff
#align pow_bit1_pos_iff pow_bit1_pos_iff

/- warning: strict_mono_pow_bit1 -> strictMono_pow_bit1 is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] (n : Nat), StrictMono.{u1, u1} R R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (fun (a : R) => HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) a (bit1.{0} Nat Nat.hasOne Nat.hasAdd n))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] (n : Nat), StrictMono.{u1, u1} R R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))) (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))) (fun (a : R) => HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) a (bit1.{0} Nat (CanonicallyOrderedCommSemiring.toOne.{0} Nat Nat.canonicallyOrderedCommSemiring) instAddNat n))
Case conversion may be inaccurate. Consider using '#align strict_mono_pow_bit1 strictMono_pow_bit1ₓ'. -/
theorem strictMono_pow_bit1 (n : ℕ) : StrictMono fun a : R => a ^ bit1 n :=
  by
  intro a b hab
  cases' le_total a 0 with ha ha
  · cases' le_or_lt b 0 with hb hb
    · rw [← neg_lt_neg_iff, ← neg_pow_bit1, ← neg_pow_bit1]
      exact pow_lt_pow_of_lt_left (neg_lt_neg hab) (neg_nonneg.2 hb) (bit1_pos (zero_le n))
    · exact (pow_bit1_nonpos_iff.2 ha).trans_lt (pow_bit1_pos_iff.2 hb)
  · exact pow_lt_pow_of_lt_left hab ha (bit1_pos (zero_le n))
#align strict_mono_pow_bit1 strictMono_pow_bit1

/- warning: one_add_mul_le_pow -> one_add_mul_le_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))))))) a) -> (forall (n : Nat), LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))))) n) a)) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))))) a) n))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (Neg.neg.{u1} R (Ring.toNeg.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1)))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) a) -> (forall (n : Nat), LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1)))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1)))) n) a)) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1)))))) a) n))
Case conversion may be inaccurate. Consider using '#align one_add_mul_le_pow one_add_mul_le_powₓ'. -/
/-- Bernoulli's inequality for `n : ℕ`, `-2 ≤ a`. -/
theorem one_add_mul_le_pow (H : -2 ≤ a) (n : ℕ) : 1 + (n : R) * a ≤ (1 + a) ^ n :=
  one_add_mul_le_pow' (mul_self_nonneg _) (mul_self_nonneg _) (neg_le_iff_add_nonneg'.1 H) _
#align one_add_mul_le_pow one_add_mul_le_pow

/- warning: one_add_mul_sub_le_pow -> one_add_mul_sub_le_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))))) a) -> (forall (n : Nat), LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommGroup.toPartialOrder.{u1} R (StrictOrderedRing.toOrderedAddCommGroup.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))))))) n) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))) a (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))))) a n))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} R] {a : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (Neg.neg.{u1} R (Ring.toNeg.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) a) -> (forall (n : Nat), LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedRing.toPartialOrder.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))))) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1)))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1)))) n) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R (StrictOrderedRing.toRing.{u1} R (LinearOrderedRing.toStrictOrderedRing.{u1} R _inst_1)))) a (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} R (LinearOrderedRing.toLinearOrderedSemiring.{u1} R _inst_1))))))) a n))
Case conversion may be inaccurate. Consider using '#align one_add_mul_sub_le_pow one_add_mul_sub_le_powₓ'. -/
/-- Bernoulli's inequality reformulated to estimate `a^n`. -/
theorem one_add_mul_sub_le_pow (H : -1 ≤ a) (n : ℕ) : 1 + (n : R) * (a - 1) ≤ a ^ n :=
  by
  have : -2 ≤ a - 1 := by rwa [bit0, neg_add, ← sub_eq_add_neg, sub_le_sub_iff_right]
  simpa only [add_sub_cancel'_right] using one_add_mul_le_pow this n
#align one_add_mul_sub_le_pow one_add_mul_sub_le_pow

end LinearOrderedRing

namespace Int

/- warning: int.nat_abs_sq -> Int.natAbs_sq is a dubious translation:
lean 3 declaration is
  forall (x : Int), Eq.{1} Int (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (Int.natAbs x)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) x (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall (x : Int), Eq.{1} Int (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) (Nat.cast.{0} Int instNatCastInt (Int.natAbs x)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) x (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align int.nat_abs_sq Int.natAbs_sqₓ'. -/
theorem natAbs_sq (x : ℤ) : (x.natAbs ^ 2 : ℤ) = x ^ 2 := by rw [sq, Int.natAbs_mul_self', sq]
#align int.nat_abs_sq Int.natAbs_sq

/- warning: int.nat_abs_pow_two -> Int.natAbs_pow_two is a dubious translation:
lean 3 declaration is
  forall (x : Int), Eq.{1} Int (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (Int.natAbs x)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) x (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall (x : Int), Eq.{1} Int (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) (Nat.cast.{0} Int instNatCastInt (Int.natAbs x)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) x (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align int.nat_abs_pow_two Int.natAbs_pow_twoₓ'. -/
alias nat_abs_sq ← nat_abs_pow_two
#align int.nat_abs_pow_two Int.natAbs_pow_two

/- warning: int.abs_le_self_sq -> Int.natAbs_le_self_sq is a dubious translation:
lean 3 declaration is
  forall (a : Int), LE.le.{0} Int Int.hasLe ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) Nat Int (HasLiftT.mk.{1, 1} Nat Int (CoeTCₓ.coe.{1, 1} Nat Int (coeBase.{1, 1} Nat Int Int.hasCoe))) (Int.natAbs a)) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) a (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall (a : Int), LE.le.{0} Int Int.instLEInt (Nat.cast.{0} Int instNatCastInt (Int.natAbs a)) (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) a (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align int.abs_le_self_sq Int.natAbs_le_self_sqₓ'. -/
theorem natAbs_le_self_sq (a : ℤ) : (Int.natAbs a : ℤ) ≤ a ^ 2 :=
  by
  rw [← Int.natAbs_sq a, sq]
  norm_cast
  apply Nat.le_mul_self
#align int.abs_le_self_sq Int.natAbs_le_self_sq

alias abs_le_self_sq ← abs_le_self_pow_two
#align int.abs_le_self_pow_two Int.abs_le_self_pow_two

/- warning: int.le_self_sq -> Int.le_self_sq is a dubious translation:
lean 3 declaration is
  forall (b : Int), LE.le.{0} Int Int.hasLe b (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) b (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall (b : Int), LE.le.{0} Int Int.instLEInt b (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) b (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align int.le_self_sq Int.le_self_sqₓ'. -/
theorem le_self_sq (b : ℤ) : b ≤ b ^ 2 :=
  le_trans le_natAbs (natAbs_le_self_sq _)
#align int.le_self_sq Int.le_self_sq

/- warning: int.le_self_pow_two -> Int.le_self_pow_two is a dubious translation:
lean 3 declaration is
  forall (b : Int), LE.le.{0} Int Int.hasLe b (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) b (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall (b : Int), LE.le.{0} Int Int.instLEInt b (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.instMonoidInt)) b (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align int.le_self_pow_two Int.le_self_pow_twoₓ'. -/
alias le_self_sq ← le_self_pow_two
#align int.le_self_pow_two Int.le_self_pow_two

/- warning: int.pow_right_injective -> Int.pow_right_injective is a dubious translation:
lean 3 declaration is
  forall {x : Int}, (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) (Int.natAbs x)) -> (Function.Injective.{1, 1} Nat Int (HPow.hPow.{0, 0, 0} Int Nat Int (instHPow.{0, 0} Int Nat (Monoid.Pow.{0} Int Int.monoid)) x))
but is expected to have type
  forall {x : Int}, (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) (Int.natAbs x)) -> (Function.Injective.{1, 1} Nat Int ((fun (x._@.Mathlib.Algebra.GroupPower.Lemmas._hyg.8024 : Int) (x._@.Mathlib.Algebra.GroupPower.Lemmas._hyg.8026 : Nat) => HPow.hPow.{0, 0, 0} Int Nat Int Int.instHPowIntNat x._@.Mathlib.Algebra.GroupPower.Lemmas._hyg.8024 x._@.Mathlib.Algebra.GroupPower.Lemmas._hyg.8026) x))
Case conversion may be inaccurate. Consider using '#align int.pow_right_injective Int.pow_right_injectiveₓ'. -/
theorem pow_right_injective {x : ℤ} (h : 1 < x.natAbs) : Function.Injective ((· ^ ·) x : ℕ → ℤ) :=
  by
  suffices Function.Injective (nat_abs ∘ ((· ^ ·) x : ℕ → ℤ)) by
    exact Function.Injective.of_comp this
  convert Nat.pow_right_injective h
  ext n
  rw [Function.comp_apply, nat_abs_pow]
#align int.pow_right_injective Int.pow_right_injective

end Int

variable (M G A)

#print powersHom /-
/-- Monoid homomorphisms from `multiplicative ℕ` are defined by the image
of `multiplicative.of_add 1`. -/
def powersHom [Monoid M] : M ≃ (Multiplicative ℕ →* M)
    where
  toFun x :=
    ⟨fun n => x ^ n.toAdd, by
      convert pow_zero x
      exact toAdd_one, fun m n => pow_add x m n⟩
  invFun f := f (Multiplicative.ofAdd 1)
  left_inv := pow_one
  right_inv f := MonoidHom.ext fun n => by simp [← f.map_pow, ← ofAdd_nsmul]
#align powers_hom powersHom
-/

/- warning: zpowers_hom -> zpowersHom is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Equiv.{succ u1, succ u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : Group.{u1} G], Equiv.{succ u1, succ u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))
Case conversion may be inaccurate. Consider using '#align zpowers_hom zpowersHomₓ'. -/
/-- Monoid homomorphisms from `multiplicative ℤ` are defined by the image
of `multiplicative.of_add 1`. -/
def zpowersHom [Group G] : G ≃ (Multiplicative ℤ →* G)
    where
  toFun x := ⟨fun n => x ^ n.toAdd, zpow_zero x, fun m n => zpow_add x m n⟩
  invFun f := f (Multiplicative.ofAdd 1)
  left_inv := zpow_one
  right_inv f := MonoidHom.ext fun n => by simp [← f.map_zpow, ← ofAdd_zsmul]
#align zpowers_hom zpowersHom

#print multiplesHom /-
/-- Additive homomorphisms from `ℕ` are defined by the image of `1`. -/
def multiplesHom [AddMonoid A] : A ≃ (ℕ →+ A)
    where
  toFun x := ⟨fun n => n • x, zero_nsmul x, fun m n => add_nsmul _ _ _⟩
  invFun f := f 1
  left_inv := one_nsmul
  right_inv f := AddMonoidHom.ext_nat <| one_nsmul (f 1)
#align multiples_hom multiplesHom
-/

/- warning: zmultiples_hom -> zmultiplesHom is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : AddGroup.{u1} A], Equiv.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))))
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : AddGroup.{u1} A], Equiv.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))))
Case conversion may be inaccurate. Consider using '#align zmultiples_hom zmultiplesHomₓ'. -/
/-- Additive homomorphisms from `ℤ` are defined by the image of `1`. -/
def zmultiplesHom [AddGroup A] : A ≃ (ℤ →+ A)
    where
  toFun x := ⟨fun n => n • x, zero_zsmul x, fun m n => add_zsmul _ _ _⟩
  invFun f := f 1
  left_inv := one_zsmul
  right_inv f := AddMonoidHom.ext_int <| one_zsmul (f 1)
#align zmultiples_hom zmultiplesHom

attribute [to_additive multiplesHom] powersHom

attribute [to_additive zmultiplesHom] zpowersHom

variable {M G A}

/- warning: powers_hom_apply -> powersHom_apply is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (x : M) (n : Multiplicative.{0} Nat), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (Multiplicative.{0} Nat) -> M) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1))) => M -> (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1))) (powersHom.{u1} M _inst_1) x) n) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x (coeFn.{1, 1} (Equiv.{1, 1} (Multiplicative.{0} Nat) Nat) (fun (_x : Equiv.{1, 1} (Multiplicative.{0} Nat) Nat) => (Multiplicative.{0} Nat) -> Nat) (Equiv.hasCoeToFun.{1, 1} (Multiplicative.{0} Nat) Nat) (Multiplicative.toAdd.{0} Nat) n))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (x : M) (n : Multiplicative.{0} Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) n) (FunLike.coe.{succ u1, 1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) x) (Multiplicative.{0} Nat) (fun (_x : Multiplicative.{0} Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) _x) (MulHomClass.toFunLike.{u1, 0, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) x) (Multiplicative.{0} Nat) M (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{u1, 0, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) x) (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1))) (powersHom.{u1} M _inst_1) x) n) (HPow.hPow.{u1, 0, u1} M ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Nat) => Nat) n) M (instHPow.{u1, 0} M ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Nat) => Nat) n) (Monoid.Pow.{u1} M _inst_1)) x (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Multiplicative.{0} Nat) Nat) (Multiplicative.{0} Nat) (fun (_x : Multiplicative.{0} Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Nat) => Nat) _x) (Equiv.instFunLikeEquiv.{1, 1} (Multiplicative.{0} Nat) Nat) (Multiplicative.toAdd.{0} Nat) n))
Case conversion may be inaccurate. Consider using '#align powers_hom_apply powersHom_applyₓ'. -/
@[simp]
theorem powersHom_apply [Monoid M] (x : M) (n : Multiplicative ℕ) : powersHom M x n = x ^ n.toAdd :=
  rfl
#align powers_hom_apply powersHom_apply

#print powersHom_symm_apply /-
@[simp]
theorem powersHom_symm_apply [Monoid M] (f : Multiplicative ℕ →* M) :
    (powersHom M).symm f = f (Multiplicative.ofAdd 1) :=
  rfl
#align powers_hom_symm_apply powersHom_symm_apply
-/

/- warning: zpowers_hom_apply -> zpowersHom_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (x : G) (n : Multiplicative.{0} Int), Eq.{succ u1} G (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (Multiplicative.{0} Int) -> G) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (fun (_x : Equiv.{succ u1, succ u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) => G -> (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (Equiv.hasCoeToFun.{succ u1, succ u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (zpowersHom.{u1} G _inst_1) x) n) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) x (coeFn.{1, 1} (Equiv.{1, 1} (Multiplicative.{0} Int) Int) (fun (_x : Equiv.{1, 1} (Multiplicative.{0} Int) Int) => (Multiplicative.{0} Int) -> Int) (Equiv.hasCoeToFun.{1, 1} (Multiplicative.{0} Int) Int) (Multiplicative.toAdd.{0} Int) n))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (x : G) (n : Multiplicative.{0} Int), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => G) n) (FunLike.coe.{succ u1, 1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : G) => MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x) (Multiplicative.{0} Int) (fun (_x : Multiplicative.{0} Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => G) _x) (MulHomClass.toFunLike.{u1, 0, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : G) => MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x) (Multiplicative.{0} Int) G (MulOneClass.toMul.{0} (Multiplicative.{0} Int) (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, 0, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : G) => MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) x) (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) G (fun (_x : G) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : G) => MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))))) (zpowersHom.{u1} G _inst_1) x) n) (HPow.hPow.{u1, 0, u1} G ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Int) => Int) n) G (instHPow.{u1, 0} G ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Int) => Int) n) (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) x (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Multiplicative.{0} Int) Int) (Multiplicative.{0} Int) (fun (_x : Multiplicative.{0} Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Int) => Int) _x) (Equiv.instFunLikeEquiv.{1, 1} (Multiplicative.{0} Int) Int) (Multiplicative.toAdd.{0} Int) n))
Case conversion may be inaccurate. Consider using '#align zpowers_hom_apply zpowersHom_applyₓ'. -/
@[simp]
theorem zpowersHom_apply [Group G] (x : G) (n : Multiplicative ℤ) :
    zpowersHom G x n = x ^ n.toAdd :=
  rfl
#align zpowers_hom_apply zpowersHom_apply

/- warning: zpowers_hom_symm_apply -> zpowersHom_symm_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (f : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))), Eq.{succ u1} G (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G) (fun (_x : Equiv.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G) => (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) -> G) (Equiv.hasCoeToFun.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G) (Equiv.symm.{succ u1, succ u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (zpowersHom.{u1} G _inst_1)) f) (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (Multiplicative.{0} Int) -> G) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) f (coeFn.{1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) (fun (_x : Equiv.{1, 1} Int (Multiplicative.{0} Int)) => Int -> (Multiplicative.{0} Int)) (Equiv.hasCoeToFun.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : Group.{u1} G] (f : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))), Eq.{succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => G) f) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G) (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) => G) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) G) (Equiv.symm.{succ u1, succ u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (zpowersHom.{u1} G _inst_1)) f) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Multiplicative.{0} Int) (fun (_x : Multiplicative.{0} Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => G) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Multiplicative.{0} Int) G (MulOneClass.toMul.{0} (Multiplicative.{0} Int) (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))) (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1))) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_1)))))) f (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) Int (fun (_x : Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Int) => Multiplicative.{0} Int) _x) (Equiv.instFunLikeEquiv.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))))
Case conversion may be inaccurate. Consider using '#align zpowers_hom_symm_apply zpowersHom_symm_applyₓ'. -/
@[simp]
theorem zpowersHom_symm_apply [Group G] (f : Multiplicative ℤ →* G) :
    (zpowersHom G).symm f = f (Multiplicative.ofAdd 1) :=
  rfl
#align zpowers_hom_symm_apply zpowersHom_symm_apply

/- warning: multiples_hom_apply -> multiplesHom_apply is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : AddMonoid.{u1} A] (x : A) (n : Nat), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1)) (fun (_x : AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1)) => Nat -> A) (AddMonoidHom.hasCoeToFun.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1))) (fun (_x : Equiv.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1))) => A -> (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1))) (Equiv.hasCoeToFun.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1))) (multiplesHom.{u1} A _inst_1) x) n) (SMul.smul.{0, u1} Nat A (AddMonoid.SMul.{u1} A _inst_1) n x)
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : AddMonoid.{u1} A] (x : A) (n : Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => A) n) (FunLike.coe.{succ u1, 1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : A) => AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1)) x) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => A) _x) (AddHomClass.toFunLike.{u1, 0, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : A) => AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1)) x) Nat A (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_1)) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : A) => AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1)) x) Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1) (AddMonoidHom.addMonoidHomClass.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1)))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1))) A (fun (_x : A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : A) => AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1)) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A _inst_1))) (multiplesHom.{u1} A _inst_1) x) n) (HSMul.hSMul.{0, u1, u1} Nat A A (instHSMul.{0, u1} Nat A (AddMonoid.SMul.{u1} A _inst_1)) n x)
Case conversion may be inaccurate. Consider using '#align multiples_hom_apply multiplesHom_applyₓ'. -/
@[simp]
theorem multiplesHom_apply [AddMonoid A] (x : A) (n : ℕ) : multiplesHom A x n = n • x :=
  rfl
#align multiples_hom_apply multiplesHom_apply

attribute [to_additive multiplesHom_apply] powersHom_apply

#print multiplesHom_symm_apply /-
@[simp]
theorem multiplesHom_symm_apply [AddMonoid A] (f : ℕ →+ A) : (multiplesHom A).symm f = f 1 :=
  rfl
#align multiples_hom_symm_apply multiplesHom_symm_apply
-/

attribute [to_additive multiplesHom_symm_apply] powersHom_symm_apply

/- warning: zmultiples_hom_apply -> zmultiplesHom_apply is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : AddGroup.{u1} A] (x : A) (n : Int), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) (fun (_x : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) => Int -> A) (AddMonoidHom.hasCoeToFun.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))))) (fun (_x : Equiv.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))))) => A -> (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))))) (Equiv.hasCoeToFun.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))))) (zmultiplesHom.{u1} A _inst_1) x) n) (SMul.smul.{0, u1} Int A (SubNegMonoid.SMulInt.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)) n x)
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : AddGroup.{u1} A] (x : A) (n : Int), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => A) n) (FunLike.coe.{succ u1, 1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : A) => AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) x) Int (fun (_x : Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => A) _x) (AddHomClass.toFunLike.{u1, 0, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : A) => AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) x) Int A (AddZeroClass.toAdd.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : A) => AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) x) Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))) (AddMonoidHom.addMonoidHomClass.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))))) A (fun (_x : A) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : A) => AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))))) (zmultiplesHom.{u1} A _inst_1) x) n) (HSMul.hSMul.{0, u1, u1} Int A A (instHSMul.{0, u1} Int A (SubNegMonoid.SMulInt.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))) n x)
Case conversion may be inaccurate. Consider using '#align zmultiples_hom_apply zmultiplesHom_applyₓ'. -/
@[simp]
theorem zmultiplesHom_apply [AddGroup A] (x : A) (n : ℤ) : zmultiplesHom A x n = n • x :=
  rfl
#align zmultiples_hom_apply zmultiplesHom_apply

attribute [to_additive zmultiplesHom_apply] zpowersHom_apply

/- warning: zmultiples_hom_symm_apply -> zmultiplesHom_symm_apply is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : AddGroup.{u1} A] (f : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) A) (fun (_x : Equiv.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) A) => (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) -> A) (Equiv.hasCoeToFun.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) A) (Equiv.symm.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) (zmultiplesHom.{u1} A _inst_1)) f) (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) (fun (_x : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) => Int -> A) (AddMonoidHom.hasCoeToFun.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) f (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : AddGroup.{u1} A] (f : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))), Eq.{succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) => A) f) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) A) (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) (fun (_x : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) => A) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) A) (Equiv.symm.{succ u1, succ u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) (zmultiplesHom.{u1} A _inst_1)) f) (FunLike.coe.{succ u1, 1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) Int (fun (_x : Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => A) _x) (AddHomClass.toFunLike.{u1, 0, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) Int A (AddZeroClass.toAdd.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))) Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1))) (AddMonoidHom.addMonoidHomClass.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A _inst_1)))))) f (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))
Case conversion may be inaccurate. Consider using '#align zmultiples_hom_symm_apply zmultiplesHom_symm_applyₓ'. -/
@[simp]
theorem zmultiplesHom_symm_apply [AddGroup A] (f : ℤ →+ A) : (zmultiplesHom A).symm f = f 1 :=
  rfl
#align zmultiples_hom_symm_apply zmultiplesHom_symm_apply

attribute [to_additive zmultiplesHom_symm_apply] zpowersHom_symm_apply

/- warning: monoid_hom.apply_mnat -> MonoidHom.apply_mnat is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (f : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (n : Multiplicative.{0} Nat), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (Multiplicative.{0} Nat) -> M) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) f n) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (Multiplicative.{0} Nat) -> M) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) f (coeFn.{1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) (fun (_x : Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) => Nat -> (Multiplicative.{0} Nat)) (Equiv.hasCoeToFun.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (coeFn.{1, 1} (Equiv.{1, 1} (Multiplicative.{0} Nat) Nat) (fun (_x : Equiv.{1, 1} (Multiplicative.{0} Nat) Nat) => (Multiplicative.{0} Nat) -> Nat) (Equiv.hasCoeToFun.{1, 1} (Multiplicative.{0} Nat) Nat) (Multiplicative.toAdd.{0} Nat) n))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (f : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (n : Multiplicative.{0} Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) n) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) (fun (_x : Multiplicative.{0} Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) M (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)))) f n) (HPow.hPow.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (a : Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Nat) => Multiplicative.{0} Nat) a) (Equiv.instFunLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Nat) => Nat) n) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (a : Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Nat) => Multiplicative.{0} Nat) a) (Equiv.instFunLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instHPow.{u1, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (a : Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Nat) => Multiplicative.{0} Nat) a) (Equiv.instFunLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Nat) => Nat) n) (Monoid.Pow.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (a : Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Nat) => Multiplicative.{0} Nat) a) (Equiv.instFunLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) _inst_1)) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) (fun (_x : Multiplicative.{0} Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) M (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)))) f (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Nat) => Multiplicative.{0} Nat) _x) (Equiv.instFunLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Multiplicative.{0} Nat) Nat) (Multiplicative.{0} Nat) (fun (_x : Multiplicative.{0} Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Nat) => Nat) _x) (Equiv.instFunLikeEquiv.{1, 1} (Multiplicative.{0} Nat) Nat) (Multiplicative.toAdd.{0} Nat) n))
Case conversion may be inaccurate. Consider using '#align monoid_hom.apply_mnat MonoidHom.apply_mnatₓ'. -/
-- TODO use to_additive in the rest of this file
theorem MonoidHom.apply_mnat [Monoid M] (f : Multiplicative ℕ →* M) (n : Multiplicative ℕ) :
    f n = f (Multiplicative.ofAdd 1) ^ n.toAdd := by
  rw [← powersHom_symm_apply, ← powersHom_apply, Equiv.apply_symm_apply]
#align monoid_hom.apply_mnat MonoidHom.apply_mnat

/- warning: monoid_hom.ext_mnat -> MonoidHom.ext_mnat is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {{f : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)}} {{g : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)}}, (Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (Multiplicative.{0} Nat) -> M) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) f (coeFn.{1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) (fun (_x : Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) => Nat -> (Multiplicative.{0} Nat)) (Equiv.hasCoeToFun.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) => (Multiplicative.{0} Nat) -> M) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) g (coeFn.{1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) (fun (_x : Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) => Nat -> (Multiplicative.{0} Nat)) (Equiv.hasCoeToFun.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) -> (Eq.{succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) f g)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {{f : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)}} {{g : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)}}, (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (a : Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Nat) => Multiplicative.{0} Nat) a) (Equiv.instFunLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) (fun (_x : Multiplicative.{0} Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) M (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)))) f (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Nat) => Multiplicative.{0} Nat) _x) (Equiv.instFunLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) (fun (_x : Multiplicative.{0} Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) M (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)))) g (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Nat) => Multiplicative.{0} Nat) _x) (Equiv.instFunLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) -> (Eq.{succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M _inst_1)) f g)
Case conversion may be inaccurate. Consider using '#align monoid_hom.ext_mnat MonoidHom.ext_mnatₓ'. -/
@[ext]
theorem MonoidHom.ext_mnat [Monoid M] ⦃f g : Multiplicative ℕ →* M⦄
    (h : f (Multiplicative.ofAdd 1) = g (Multiplicative.ofAdd 1)) : f = g :=
  MonoidHom.ext fun n => by rw [f.apply_mnat, g.apply_mnat, h]
#align monoid_hom.ext_mnat MonoidHom.ext_mnat

/- warning: monoid_hom.apply_mint -> MonoidHom.apply_mint is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Group.{u1} M] (f : MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (n : Multiplicative.{0} Int), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) => (Multiplicative.{0} Int) -> M) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) f n) (HPow.hPow.{u1, 0, u1} M Int M (instHPow.{u1, 0} M Int (DivInvMonoid.Pow.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1))) (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) => (Multiplicative.{0} Int) -> M) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) f (coeFn.{1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) (fun (_x : Equiv.{1, 1} Int (Multiplicative.{0} Int)) => Int -> (Multiplicative.{0} Int)) (Equiv.hasCoeToFun.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))) (coeFn.{1, 1} (Equiv.{1, 1} (Multiplicative.{0} Int) Int) (fun (_x : Equiv.{1, 1} (Multiplicative.{0} Int) Int) => (Multiplicative.{0} Int) -> Int) (Equiv.hasCoeToFun.{1, 1} (Multiplicative.{0} Int) Int) (Multiplicative.toAdd.{0} Int) n))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Group.{u1} M] (f : MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (n : Multiplicative.{0} Int), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => M) n) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (Multiplicative.{0} Int) (fun (_x : Multiplicative.{0} Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => M) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (Multiplicative.{0} Int) M (MulOneClass.toMul.{0} (Multiplicative.{0} Int) (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1))) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))))) f n) (HPow.hPow.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => M) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) Int (fun (a : Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Int) => Multiplicative.{0} Int) a) (Equiv.instFunLikeEquiv.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Int) => Int) n) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => M) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) Int (fun (a : Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Int) => Multiplicative.{0} Int) a) (Equiv.instFunLikeEquiv.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))) (instHPow.{u1, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => M) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) Int (fun (a : Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Int) => Multiplicative.{0} Int) a) (Equiv.instFunLikeEquiv.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Int) => Int) n) (DivInvMonoid.Pow.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => M) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) Int (fun (a : Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Int) => Multiplicative.{0} Int) a) (Equiv.instFunLikeEquiv.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))) (Group.toDivInvMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => M) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) Int (fun (a : Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Int) => Multiplicative.{0} Int) a) (Equiv.instFunLikeEquiv.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))) _inst_1))) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (Multiplicative.{0} Int) (fun (_x : Multiplicative.{0} Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => M) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (Multiplicative.{0} Int) M (MulOneClass.toMul.{0} (Multiplicative.{0} Int) (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))) (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1))) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Int) M (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} M (DivInvMonoid.toMonoid.{u1} M (Group.toDivInvMonoid.{u1} M _inst_1)))))) f (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) Int (fun (_x : Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Int) => Multiplicative.{0} Int) _x) (Equiv.instFunLikeEquiv.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Multiplicative.{0} Int) Int) (Multiplicative.{0} Int) (fun (_x : Multiplicative.{0} Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Int) => Int) _x) (Equiv.instFunLikeEquiv.{1, 1} (Multiplicative.{0} Int) Int) (Multiplicative.toAdd.{0} Int) n))
Case conversion may be inaccurate. Consider using '#align monoid_hom.apply_mint MonoidHom.apply_mintₓ'. -/
theorem MonoidHom.apply_mint [Group M] (f : Multiplicative ℤ →* M) (n : Multiplicative ℤ) :
    f n = f (Multiplicative.ofAdd 1) ^ n.toAdd := by
  rw [← zpowersHom_symm_apply, ← zpowersHom_apply, Equiv.apply_symm_apply]
#align monoid_hom.apply_mint MonoidHom.apply_mint

/-! `monoid_hom.ext_mint` is defined in `data.int.cast` -/


/- warning: add_monoid_hom.apply_nat -> AddMonoidHom.apply_nat is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] (f : AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (n : Nat), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (fun (_x : AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) => Nat -> M) (AddMonoidHom.hasCoeToFun.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) f n) (SMul.smul.{0, u1} Nat M (AddMonoid.SMul.{u1} M _inst_1) n (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (fun (_x : AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) => Nat -> M) (AddMonoidHom.hasCoeToFun.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) f (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] (f : AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (n : Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => M) n) (FunLike.coe.{succ u1, 1, succ u1} (AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => M) _x) (AddHomClass.toFunLike.{u1, 0, u1} (AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) Nat M (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} (AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1) (AddMonoidHom.addMonoidHomClass.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) f n) (HSMul.hSMul.{0, u1, u1} Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => M) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => M) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (instHSMul.{0, u1} Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => M) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (AddMonoid.SMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => M) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) _inst_1)) n (FunLike.coe.{succ u1, 1, succ u1} (AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => M) _x) (AddHomClass.toFunLike.{u1, 0, u1} (AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) Nat M (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} (AddMonoidHom.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)) Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1) (AddMonoidHom.addMonoidHomClass.{0, u1} Nat M (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) f (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.apply_nat AddMonoidHom.apply_natₓ'. -/
theorem AddMonoidHom.apply_nat [AddMonoid M] (f : ℕ →+ M) (n : ℕ) : f n = n • f 1 := by
  rw [← multiplesHom_symm_apply, ← multiplesHom_apply, Equiv.apply_symm_apply]
#align add_monoid_hom.apply_nat AddMonoidHom.apply_nat

/-! `add_monoid_hom.ext_nat` is defined in `data.nat.cast` -/


/- warning: add_monoid_hom.apply_int -> AddMonoidHom.apply_int is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddGroup.{u1} M] (f : AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) (n : Int), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) (fun (_x : AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) => Int -> M) (AddMonoidHom.hasCoeToFun.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) f n) (SMul.smul.{0, u1} Int M (SubNegMonoid.SMulInt.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)) n (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) (fun (_x : AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) => Int -> M) (AddMonoidHom.hasCoeToFun.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) f (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddGroup.{u1} M] (f : AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) (n : Int), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => M) n) (FunLike.coe.{succ u1, 1, succ u1} (AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) Int (fun (_x : Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => M) _x) (AddHomClass.toFunLike.{u1, 0, u1} (AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) Int M (AddZeroClass.toAdd.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} (AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1))) (AddMonoidHom.addMonoidHomClass.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))))) f n) (HSMul.hSMul.{0, u1, u1} Int ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => M) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => M) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (instHSMul.{0, u1} Int ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => M) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (SubNegMonoid.SMulInt.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => M) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => M) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) _inst_1))) n (FunLike.coe.{succ u1, 1, succ u1} (AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) Int (fun (_x : Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => M) _x) (AddHomClass.toFunLike.{u1, 0, u1} (AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) Int M (AddZeroClass.toAdd.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} (AddMonoidHom.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))) Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1))) (AddMonoidHom.addMonoidHomClass.{0, u1} Int M (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} M (SubNegMonoid.toAddMonoid.{u1} M (AddGroup.toSubNegMonoid.{u1} M _inst_1)))))) f (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.apply_int AddMonoidHom.apply_intₓ'. -/
theorem AddMonoidHom.apply_int [AddGroup M] (f : ℤ →+ M) (n : ℤ) : f n = n • f 1 := by
  rw [← zmultiplesHom_symm_apply, ← zmultiplesHom_apply, Equiv.apply_symm_apply]
#align add_monoid_hom.apply_int AddMonoidHom.apply_int

/-! `add_monoid_hom.ext_int` is defined in `data.int.cast` -/


variable (M G A)

/- warning: powers_mul_hom -> powersMulHom is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : CommMonoid.{u1} M], MulEquiv.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1)
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : CommMonoid.{u1} M], MulEquiv.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1)
Case conversion may be inaccurate. Consider using '#align powers_mul_hom powersMulHomₓ'. -/
/-- If `M` is commutative, `powers_hom` is a multiplicative equivalence. -/
def powersMulHom [CommMonoid M] : M ≃* (Multiplicative ℕ →* M) :=
  { powersHom M with map_mul' := fun a b => MonoidHom.ext <| by simp [mul_pow] }
#align powers_mul_hom powersMulHom

/- warning: zpowers_mul_hom -> zpowersMulHom is a dubious translation:
lean 3 declaration is
  forall (G : Type.{u1}) [_inst_1 : CommGroup.{u1} G], MulEquiv.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (CommGroup.toCommMonoid.{u1} G _inst_1))
but is expected to have type
  forall (G : Type.{u1}) [_inst_1 : CommGroup.{u1} G], MulEquiv.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1))
Case conversion may be inaccurate. Consider using '#align zpowers_mul_hom zpowersMulHomₓ'. -/
/-- If `M` is commutative, `zpowers_hom` is a multiplicative equivalence. -/
def zpowersMulHom [CommGroup G] : G ≃* (Multiplicative ℤ →* G) :=
  { zpowersHom G with map_mul' := fun a b => MonoidHom.ext <| by simp [mul_zpow] }
#align zpowers_mul_hom zpowersMulHom

/- warning: multiples_add_hom -> multiplesAddHom is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : AddCommMonoid.{u1} A], AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.hasAdd.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1)
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : AddCommMonoid.{u1} A], AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1)
Case conversion may be inaccurate. Consider using '#align multiples_add_hom multiplesAddHomₓ'. -/
/-- If `M` is commutative, `multiples_hom` is an additive equivalence. -/
def multiplesAddHom [AddCommMonoid A] : A ≃+ (ℕ →+ A) :=
  { multiplesHom A with map_add' := fun a b => AddMonoidHom.ext <| by simp [nsmul_add] }
#align multiples_add_hom multiplesAddHom

/- warning: zmultiples_add_hom -> zmultiplesAddHom is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : AddCommGroup.{u1} A], AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.hasAdd.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1))
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : AddCommGroup.{u1} A], AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1))
Case conversion may be inaccurate. Consider using '#align zmultiples_add_hom zmultiplesAddHomₓ'. -/
/-- If `M` is commutative, `zmultiples_hom` is an additive equivalence. -/
def zmultiplesAddHom [AddCommGroup A] : A ≃+ (ℤ →+ A) :=
  { zmultiplesHom A with map_add' := fun a b => AddMonoidHom.ext <| by simp [zsmul_add] }
#align zmultiples_add_hom zmultiplesAddHom

variable {M G A}

/- warning: powers_mul_hom_apply -> powersMulHom_apply is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : CommMonoid.{u1} M] (x : M) (n : Multiplicative.{0} Nat), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) => (Multiplicative.{0} Nat) -> M) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (coeFn.{succ u1, succ u1} (MulEquiv.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1)) (fun (_x : MulEquiv.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1)) => M -> (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1)))) (MulEquiv.hasCoeToFun.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1)) (powersMulHom.{u1} M _inst_1) x) n) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) x (coeFn.{1, 1} (Equiv.{1, 1} (Multiplicative.{0} Nat) Nat) (fun (_x : Equiv.{1, 1} (Multiplicative.{0} Nat) Nat) => (Multiplicative.{0} Nat) -> Nat) (Equiv.hasCoeToFun.{1, 1} (Multiplicative.{0} Nat) Nat) (Multiplicative.toAdd.{0} Nat) n))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : CommMonoid.{u1} M] (x : M) (n : Multiplicative.{0} Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) n) (FunLike.coe.{succ u1, 1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : M) => MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) x) (Multiplicative.{0} Nat) (fun (_x : Multiplicative.{0} Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) _x) (MulHomClass.toFunLike.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : M) => MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) x) (Multiplicative.{0} Nat) M (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHomClass.toMulHomClass.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : M) => MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) x) (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1)) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))))) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : M) => MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MulEquiv.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1)) M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulEquivClass.instMulHomClass.{u1, u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulEquiv.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1)) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1)))) (powersMulHom.{u1} M _inst_1) x) n) (HPow.hPow.{u1, 0, u1} M ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Nat) => Nat) n) M (instHPow.{u1, 0} M ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Nat) => Nat) n) (Monoid.Pow.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) x (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Multiplicative.{0} Nat) Nat) (Multiplicative.{0} Nat) (fun (_x : Multiplicative.{0} Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Nat) => Nat) _x) (Equiv.instFunLikeEquiv.{1, 1} (Multiplicative.{0} Nat) Nat) (Multiplicative.toAdd.{0} Nat) n))
Case conversion may be inaccurate. Consider using '#align powers_mul_hom_apply powersMulHom_applyₓ'. -/
@[simp]
theorem powersMulHom_apply [CommMonoid M] (x : M) (n : Multiplicative ℕ) :
    powersMulHom M x n = x ^ n.toAdd :=
  rfl
#align powers_mul_hom_apply powersMulHom_apply

/- warning: powers_mul_hom_symm_apply -> powersMulHom_symm_apply is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : CommMonoid.{u1} M] (f : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) M (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1)))) (fun (_x : MulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) M (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1)))) => (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) -> M) (MulEquiv.hasCoeToFun.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) M (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1)))) (MulEquiv.symm.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (powersMulHom.{u1} M _inst_1)) f) (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) => (Multiplicative.{0} Nat) -> M) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) f (coeFn.{1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) (fun (_x : Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) => Nat -> (Multiplicative.{0} Nat)) (Equiv.hasCoeToFun.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : CommMonoid.{u1} M] (f : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) => M) f) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) M (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1)))) (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) => M) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) M (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1)))) (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) M (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulEquivClass.instMulHomClass.{u1, u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) M (MulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) M (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1)))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) M (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1)))))) (MulEquiv.symm.{u1, u1} M (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) _inst_1) (powersMulHom.{u1} M _inst_1)) f) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (Multiplicative.{0} Nat) (fun (_x : Multiplicative.{0} Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Nat) => M) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (Multiplicative.{0} Nat) M (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))) (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1)) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Nat) M (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (Monoid.toMulOneClass.{u1} M (CommMonoid.toMonoid.{u1} M _inst_1))))) f (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Nat) => Multiplicative.{0} Nat) _x) (Equiv.instFunLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))
Case conversion may be inaccurate. Consider using '#align powers_mul_hom_symm_apply powersMulHom_symm_applyₓ'. -/
@[simp]
theorem powersMulHom_symm_apply [CommMonoid M] (f : Multiplicative ℕ →* M) :
    (powersMulHom M).symm f = f (Multiplicative.ofAdd 1) :=
  rfl
#align powers_mul_hom_symm_apply powersMulHom_symm_apply

/- warning: zpowers_mul_hom_apply -> zpowersMulHom_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : CommGroup.{u1} G] (x : G) (n : Multiplicative.{0} Int), Eq.{succ u1} G (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) => (Multiplicative.{0} Int) -> G) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (coeFn.{succ u1, succ u1} (MulEquiv.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (CommGroup.toCommMonoid.{u1} G _inst_1))) (fun (_x : MulEquiv.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (CommGroup.toCommMonoid.{u1} G _inst_1))) => G -> (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))))) (MulEquiv.hasCoeToFun.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (CommGroup.toCommMonoid.{u1} G _inst_1))) (zpowersMulHom.{u1} G _inst_1) x) n) (HPow.hPow.{u1, 0, u1} G Int G (instHPow.{u1, 0} G Int (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))) x (coeFn.{1, 1} (Equiv.{1, 1} (Multiplicative.{0} Int) Int) (fun (_x : Equiv.{1, 1} (Multiplicative.{0} Int) Int) => (Multiplicative.{0} Int) -> Int) (Equiv.hasCoeToFun.{1, 1} (Multiplicative.{0} Int) Int) (Multiplicative.toAdd.{0} Int) n))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : CommGroup.{u1} G] (x : G) (n : Multiplicative.{0} Int), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => G) n) (FunLike.coe.{succ u1, 1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) x) (Multiplicative.{0} Int) (fun (_x : Multiplicative.{0} Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => G) _x) (MulHomClass.toFunLike.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) x) (Multiplicative.{0} Int) G (MulOneClass.toMul.{0} (Multiplicative.{0} Int) (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHomClass.toMulHomClass.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) x) (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : G) => MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MulEquiv.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1))) G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulEquivClass.instMulHomClass.{u1, u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulEquiv.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1))))) (zpowersMulHom.{u1} G _inst_1) x) n) (HPow.hPow.{u1, 0, u1} G ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Int) => Int) n) G (instHPow.{u1, 0} G ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Int) => Int) n) (DivInvMonoid.Pow.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))) x (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} (Multiplicative.{0} Int) Int) (Multiplicative.{0} Int) (fun (_x : Multiplicative.{0} Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Multiplicative.{0} Int) => Int) _x) (Equiv.instFunLikeEquiv.{1, 1} (Multiplicative.{0} Int) Int) (Multiplicative.toAdd.{0} Int) n))
Case conversion may be inaccurate. Consider using '#align zpowers_mul_hom_apply zpowersMulHom_applyₓ'. -/
@[simp]
theorem zpowersMulHom_apply [CommGroup G] (x : G) (n : Multiplicative ℤ) :
    zpowersMulHom G x n = x ^ n.toAdd :=
  rfl
#align zpowers_mul_hom_apply zpowersMulHom_apply

/- warning: zpowers_mul_hom_symm_apply -> zpowersMulHom_symm_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_1 : CommGroup.{u1} G] (f : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))), Eq.{succ u1} G (coeFn.{succ u1, succ u1} (MulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) G (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))))) (fun (_x : MulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) G (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))))) => (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) -> G) (MulEquiv.hasCoeToFun.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) G (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))))) (MulEquiv.symm.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.hasMul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (zpowersMulHom.{u1} G _inst_1)) f) (coeFn.{succ u1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) => (Multiplicative.{0} Int) -> G) (MonoidHom.hasCoeToFun.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) f (coeFn.{1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) (fun (_x : Equiv.{1, 1} Int (Multiplicative.{0} Int)) => Int -> (Multiplicative.{0} Int)) (Equiv.hasCoeToFun.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_1 : CommGroup.{u1} G] (f : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) => G) f) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) G (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))))) (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (fun (_x : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) => G) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) G (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))))) (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) G (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulEquivClass.instMulHomClass.{u1, u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) G (MulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) G (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) G (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))))))) (MulEquiv.symm.{u1, u1} G (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHom.mul.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (CommGroup.toCommMonoid.{u1} G _inst_1)) (zpowersMulHom.{u1} G _inst_1)) f) (FunLike.coe.{succ u1, 1, succ u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (Multiplicative.{0} Int) (fun (_x : Multiplicative.{0} Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{0} Int) => G) _x) (MulHomClass.toFunLike.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (Multiplicative.{0} Int) G (MulOneClass.toMul.{0} (Multiplicative.{0} Int) (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (MonoidHomClass.toMulHomClass.{u1, 0, u1} (MonoidHom.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))) (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1)))) (MonoidHom.monoidHomClass.{0, u1} (Multiplicative.{0} Int) G (Multiplicative.mulOneClass.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G (CommGroup.toGroup.{u1} G _inst_1))))))) f (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Int (Multiplicative.{0} Int)) Int (fun (_x : Int) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Int) => Multiplicative.{0} Int) _x) (Equiv.instFunLikeEquiv.{1, 1} Int (Multiplicative.{0} Int)) (Multiplicative.ofAdd.{0} Int) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))))
Case conversion may be inaccurate. Consider using '#align zpowers_mul_hom_symm_apply zpowersMulHom_symm_applyₓ'. -/
@[simp]
theorem zpowersMulHom_symm_apply [CommGroup G] (f : Multiplicative ℤ →* G) :
    (zpowersMulHom G).symm f = f (Multiplicative.ofAdd 1) :=
  rfl
#align zpowers_mul_hom_symm_apply zpowersMulHom_symm_apply

/- warning: multiples_add_hom_apply -> multiplesAddHom_apply is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} A] (x : A) (n : Nat), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (fun (_x : AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) => Nat -> A) (AddMonoidHom.hasCoeToFun.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (coeFn.{succ u1, succ u1} (AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.hasAdd.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1)) (fun (_x : AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.hasAdd.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1)) => A -> (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)))) (AddEquiv.hasCoeToFun.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.hasAdd.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1)) (multiplesAddHom.{u1} A _inst_1) x) n) (SMul.smul.{0, u1} Nat A (AddMonoid.SMul.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)) n x)
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} A] (x : A) (n : Nat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => A) n) (FunLike.coe.{succ u1, 1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) x) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => A) _x) (AddHomClass.toFunLike.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) x) Nat A (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) x) Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)) (AddMonoidHom.addMonoidHomClass.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1)) A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddEquivClass.instAddHomClass.{u1, u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1)))) (multiplesAddHom.{u1} A _inst_1) x) n) (HSMul.hSMul.{0, u1, u1} Nat A A (instHSMul.{0, u1} Nat A (AddMonoid.SMul.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) n x)
Case conversion may be inaccurate. Consider using '#align multiples_add_hom_apply multiplesAddHom_applyₓ'. -/
@[simp]
theorem multiplesAddHom_apply [AddCommMonoid A] (x : A) (n : ℕ) : multiplesAddHom A x n = n • x :=
  rfl
#align multiples_add_hom_apply multiplesAddHom_apply

/- warning: multiples_add_hom_symm_apply -> multiplesAddHom_symm_apply is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} A] (f : AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (AddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) A (AddMonoidHom.hasAdd.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)))) (fun (_x : AddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) A (AddMonoidHom.hasAdd.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)))) => (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) -> A) (AddEquiv.hasCoeToFun.{u1, u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) A (AddMonoidHom.hasAdd.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)))) (AddEquiv.symm.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.hasAdd.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (multiplesAddHom.{u1} A _inst_1)) f) (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (fun (_x : AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) => Nat -> A) (AddMonoidHom.hasCoeToFun.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) f (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : AddCommMonoid.{u1} A] (f : AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) => A) f) (FunLike.coe.{succ u1, succ u1, succ u1} (AddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) A (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)))) (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (fun (_x : AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) => A) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) A (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)))) (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) A (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddEquivClass.instAddHomClass.{u1, u1, u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) A (AddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) A (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)))) (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) A (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)))))) (AddEquiv.symm.{u1, u1} A (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHom.add.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) _inst_1) (multiplesAddHom.{u1} A _inst_1)) f) (FunLike.coe.{succ u1, 1, succ u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Nat) => A) _x) (AddHomClass.toFunLike.{u1, 0, u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) Nat A (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} (AddMonoidHom.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))) Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1)) (AddMonoidHom.addMonoidHomClass.{0, u1} Nat A (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A _inst_1))))) f (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align multiples_add_hom_symm_apply multiplesAddHom_symm_applyₓ'. -/
@[simp]
theorem multiplesAddHom_symm_apply [AddCommMonoid A] (f : ℕ →+ A) :
    (multiplesAddHom A).symm f = f 1 :=
  rfl
#align multiples_add_hom_symm_apply multiplesAddHom_symm_apply

/- warning: zmultiples_add_hom_apply -> zmultiplesAddHom_apply is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : AddCommGroup.{u1} A] (x : A) (n : Int), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (fun (_x : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) => Int -> A) (AddMonoidHom.hasCoeToFun.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (coeFn.{succ u1, succ u1} (AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.hasAdd.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1))) (fun (_x : AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.hasAdd.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1))) => A -> (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))))) (AddEquiv.hasCoeToFun.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.hasAdd.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1))) (zmultiplesAddHom.{u1} A _inst_1) x) n) (SMul.smul.{0, u1} Int A (SubNegMonoid.SMulInt.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))) n x)
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : AddCommGroup.{u1} A] (x : A) (n : Int), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => A) n) (FunLike.coe.{succ u1, 1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) x) Int (fun (_x : Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => A) _x) (AddHomClass.toFunLike.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) x) Int A (AddZeroClass.toAdd.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) x) Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))) (AddMonoidHom.addMonoidHomClass.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : A) => AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1))) A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddEquivClass.instAddHomClass.{u1, u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1))))) (zmultiplesAddHom.{u1} A _inst_1) x) n) (HSMul.hSMul.{0, u1, u1} Int A A (instHSMul.{0, u1} Int A (SubNegMonoid.SMulInt.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))) n x)
Case conversion may be inaccurate. Consider using '#align zmultiples_add_hom_apply zmultiplesAddHom_applyₓ'. -/
@[simp]
theorem zmultiplesAddHom_apply [AddCommGroup A] (x : A) (n : ℤ) : zmultiplesAddHom A x n = n • x :=
  rfl
#align zmultiples_add_hom_apply zmultiplesAddHom_apply

/- warning: zmultiples_add_hom_symm_apply -> zmultiplesAddHom_symm_apply is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : AddCommGroup.{u1} A] (f : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (AddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) A (AddMonoidHom.hasAdd.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))))) (fun (_x : AddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) A (AddMonoidHom.hasAdd.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))))) => (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) -> A) (AddEquiv.hasCoeToFun.{u1, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) A (AddMonoidHom.hasAdd.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))))) (AddEquiv.symm.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.hasAdd.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (zmultiplesAddHom.{u1} A _inst_1)) f) (coeFn.{succ u1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (fun (_x : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) => Int -> A) (AddMonoidHom.hasCoeToFun.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.addMonoid) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) f (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : AddCommGroup.{u1} A] (f : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) => A) f) (FunLike.coe.{succ u1, succ u1, succ u1} (AddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) A (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))))) (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (fun (_x : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) => A) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) A (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))))) (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) A (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddEquivClass.instAddHomClass.{u1, u1, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) A (AddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) A (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))))) (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) A (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))))))) (AddEquiv.symm.{u1, u1} A (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHom.add.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddCommGroup.toAddCommMonoid.{u1} A _inst_1)) (zmultiplesAddHom.{u1} A _inst_1)) f) (FunLike.coe.{succ u1, 1, succ u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) Int (fun (_x : Int) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Int) => A) _x) (AddHomClass.toFunLike.{u1, 0, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) Int A (AddZeroClass.toAdd.{0} Int (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, 0, u1} (AddMonoidHom.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))) Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1)))) (AddMonoidHom.addMonoidHomClass.{0, u1} Int A (AddMonoid.toAddZeroClass.{0} Int Int.instAddMonoidInt) (AddMonoid.toAddZeroClass.{u1} A (SubNegMonoid.toAddMonoid.{u1} A (AddGroup.toSubNegMonoid.{u1} A (AddCommGroup.toAddGroup.{u1} A _inst_1))))))) f (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))
Case conversion may be inaccurate. Consider using '#align zmultiples_add_hom_symm_apply zmultiplesAddHom_symm_applyₓ'. -/
@[simp]
theorem zmultiplesAddHom_symm_apply [AddCommGroup A] (f : ℤ →+ A) :
    (zmultiplesAddHom A).symm f = f 1 :=
  rfl
#align zmultiples_add_hom_symm_apply zmultiplesAddHom_symm_apply

/-!
### Commutativity (again)

Facts about `semiconj_by` and `commute` that require `zpow` or `zsmul`, or the fact that integer
multiplication equals semiring multiplication.
-/


namespace SemiconjBy

section

variable [Semiring R] {a x y : R}

/- warning: semiconj_by.cast_nat_mul_right -> SemiconjBy.cast_nat_mul_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) a x y) -> (forall (n : Nat), SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) x) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) y))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) a x y) -> (forall (n : Nat), SemiconjBy.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) x) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) y))
Case conversion may be inaccurate. Consider using '#align semiconj_by.cast_nat_mul_right SemiconjBy.cast_nat_mul_rightₓ'. -/
@[simp]
theorem cast_nat_mul_right (h : SemiconjBy a x y) (n : ℕ) : SemiconjBy a ((n : R) * x) (n * y) :=
  SemiconjBy.mul_right (Nat.commute_cast _ _) h
#align semiconj_by.cast_nat_mul_right SemiconjBy.cast_nat_mul_right

/- warning: semiconj_by.cast_nat_mul_left -> SemiconjBy.cast_nat_mul_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) a x y) -> (forall (n : Nat), SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) a) x y)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) a x y) -> (forall (n : Nat), SemiconjBy.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) a) x y)
Case conversion may be inaccurate. Consider using '#align semiconj_by.cast_nat_mul_left SemiconjBy.cast_nat_mul_leftₓ'. -/
@[simp]
theorem cast_nat_mul_left (h : SemiconjBy a x y) (n : ℕ) : SemiconjBy ((n : R) * a) x y :=
  SemiconjBy.mul_left (Nat.cast_commute _ _) h
#align semiconj_by.cast_nat_mul_left SemiconjBy.cast_nat_mul_left

/- warning: semiconj_by.cast_nat_mul_cast_nat_mul -> SemiconjBy.cast_nat_mul_cast_nat_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) a x y) -> (forall (m : Nat) (n : Nat), SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) x) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) y))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) a x y) -> (forall (m : Nat) (n : Nat), SemiconjBy.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) x) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) y))
Case conversion may be inaccurate. Consider using '#align semiconj_by.cast_nat_mul_cast_nat_mul SemiconjBy.cast_nat_mul_cast_nat_mulₓ'. -/
@[simp]
theorem cast_nat_mul_cast_nat_mul (h : SemiconjBy a x y) (m n : ℕ) :
    SemiconjBy ((m : R) * a) (n * x) (n * y) :=
  (h.cast_nat_mul_left m).cast_nat_mul_right n
#align semiconj_by.cast_nat_mul_cast_nat_mul SemiconjBy.cast_nat_mul_cast_nat_mul

end

variable [Monoid M] [Group G] [Ring R]

/- warning: semiconj_by.units_zpow_right -> SemiconjBy.units_zpow_right is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {a : M} {x : Units.{u1} M _inst_1} {y : Units.{u1} M _inst_1}, (SemiconjBy.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) a ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) y)) -> (forall (m : Int), SemiconjBy.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) a ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) (HPow.hPow.{u1, 0, u1} (Units.{u1} M _inst_1) Int (Units.{u1} M _inst_1) (instHPow.{u1, 0} (Units.{u1} M _inst_1) Int (DivInvMonoid.Pow.{u1} (Units.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (Units.{u1} M _inst_1) (Units.group.{u1} M _inst_1)))) x m)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) (HPow.hPow.{u1, 0, u1} (Units.{u1} M _inst_1) Int (Units.{u1} M _inst_1) (instHPow.{u1, 0} (Units.{u1} M _inst_1) Int (DivInvMonoid.Pow.{u1} (Units.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (Units.{u1} M _inst_1) (Units.group.{u1} M _inst_1)))) y m)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {a : M} {x : Units.{u1} M _inst_1} {y : Units.{u1} M _inst_1}, (SemiconjBy.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) a (Units.val.{u1} M _inst_1 x) (Units.val.{u1} M _inst_1 y)) -> (forall (m : Int), SemiconjBy.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) a (Units.val.{u1} M _inst_1 (HPow.hPow.{u1, 0, u1} (Units.{u1} M _inst_1) Int (Units.{u1} M _inst_1) (instHPow.{u1, 0} (Units.{u1} M _inst_1) Int (DivInvMonoid.Pow.{u1} (Units.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (Units.{u1} M _inst_1) (Units.instGroupUnits.{u1} M _inst_1)))) x m)) (Units.val.{u1} M _inst_1 (HPow.hPow.{u1, 0, u1} (Units.{u1} M _inst_1) Int (Units.{u1} M _inst_1) (instHPow.{u1, 0} (Units.{u1} M _inst_1) Int (DivInvMonoid.Pow.{u1} (Units.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (Units.{u1} M _inst_1) (Units.instGroupUnits.{u1} M _inst_1)))) y m)))
Case conversion may be inaccurate. Consider using '#align semiconj_by.units_zpow_right SemiconjBy.units_zpow_rightₓ'. -/
@[simp, to_additive]
theorem units_zpow_right {a : M} {x y : Mˣ} (h : SemiconjBy a x y) :
    ∀ m : ℤ, SemiconjBy a ↑(x ^ m) ↑(y ^ m)
  | (n : ℕ) => by simp only [zpow_ofNat, Units.val_pow_eq_pow_val, h, pow_right]
  | -[n+1] => by simp only [zpow_negSucc, Units.val_pow_eq_pow_val, units_inv_right, h, pow_right]
#align semiconj_by.units_zpow_right SemiconjBy.units_zpow_right
#align add_semiconj_by.add_units_zsmul_right AddSemiconjBy.addUnits_zsmul_right

variable {a b x y x' y' : R}

/- warning: semiconj_by.cast_int_mul_right -> SemiconjBy.cast_int_mul_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) a x y) -> (forall (m : Int), SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) m) x) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) m) y))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) a x y) -> (forall (m : Int), SemiconjBy.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) m) x) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) m) y))
Case conversion may be inaccurate. Consider using '#align semiconj_by.cast_int_mul_right SemiconjBy.cast_int_mul_rightₓ'. -/
@[simp]
theorem cast_int_mul_right (h : SemiconjBy a x y) (m : ℤ) : SemiconjBy a ((m : ℤ) * x) (m * y) :=
  SemiconjBy.mul_right (Int.commute_cast _ _) h
#align semiconj_by.cast_int_mul_right SemiconjBy.cast_int_mul_right

/- warning: semiconj_by.cast_int_mul_left -> SemiconjBy.cast_int_mul_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) a x y) -> (forall (m : Int), SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) m) a) x y)
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) a x y) -> (forall (m : Int), SemiconjBy.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) m) a) x y)
Case conversion may be inaccurate. Consider using '#align semiconj_by.cast_int_mul_left SemiconjBy.cast_int_mul_leftₓ'. -/
@[simp]
theorem cast_int_mul_left (h : SemiconjBy a x y) (m : ℤ) : SemiconjBy ((m : R) * a) x y :=
  SemiconjBy.mul_left (Int.cast_commute _ _) h
#align semiconj_by.cast_int_mul_left SemiconjBy.cast_int_mul_left

/- warning: semiconj_by.cast_int_mul_cast_int_mul -> SemiconjBy.cast_int_mul_cast_int_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) a x y) -> (forall (m : Int) (n : Int), SemiconjBy.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) n) x) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) n) y))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {x : R} {y : R}, (SemiconjBy.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) a x y) -> (forall (m : Int) (n : Int), SemiconjBy.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) n) x) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) n) y))
Case conversion may be inaccurate. Consider using '#align semiconj_by.cast_int_mul_cast_int_mul SemiconjBy.cast_int_mul_cast_int_mulₓ'. -/
@[simp]
theorem cast_int_mul_cast_int_mul (h : SemiconjBy a x y) (m n : ℤ) :
    SemiconjBy ((m : R) * a) (n * x) (n * y) :=
  (h.cast_int_mul_left m).cast_int_mul_right n
#align semiconj_by.cast_int_mul_cast_int_mul SemiconjBy.cast_int_mul_cast_int_mul

end SemiconjBy

namespace Commute

section

variable [Semiring R] {a b : R}

/- warning: commute.cast_nat_mul_right -> Commute.cast_nat_mul_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) a b) -> (forall (n : Nat), Commute.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) b))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) a b) -> (forall (n : Nat), Commute.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) b))
Case conversion may be inaccurate. Consider using '#align commute.cast_nat_mul_right Commute.cast_nat_mul_rightₓ'. -/
@[simp]
theorem cast_nat_mul_right (h : Commute a b) (n : ℕ) : Commute a ((n : R) * b) :=
  h.cast_nat_mul_right n
#align commute.cast_nat_mul_right Commute.cast_nat_mul_right

/- warning: commute.cast_nat_mul_left -> Commute.cast_nat_mul_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) a b) -> (forall (n : Nat), Commute.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) a) b)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) a b) -> (forall (n : Nat), Commute.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) a) b)
Case conversion may be inaccurate. Consider using '#align commute.cast_nat_mul_left Commute.cast_nat_mul_leftₓ'. -/
@[simp]
theorem cast_nat_mul_left (h : Commute a b) (n : ℕ) : Commute ((n : R) * a) b :=
  h.cast_nat_mul_left n
#align commute.cast_nat_mul_left Commute.cast_nat_mul_left

/- warning: commute.cast_nat_mul_cast_nat_mul -> Commute.cast_nat_mul_cast_nat_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) a b) -> (forall (m : Nat) (n : Nat), Commute.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) b))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) a b) -> (forall (m : Nat) (n : Nat), Commute.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) b))
Case conversion may be inaccurate. Consider using '#align commute.cast_nat_mul_cast_nat_mul Commute.cast_nat_mul_cast_nat_mulₓ'. -/
@[simp]
theorem cast_nat_mul_cast_nat_mul (h : Commute a b) (m n : ℕ) : Commute (m * a : R) (n * b : R) :=
  h.cast_nat_mul_cast_nat_mul m n
#align commute.cast_nat_mul_cast_nat_mul Commute.cast_nat_mul_cast_nat_mul

variable (a) (m n : ℕ)

/- warning: commute.self_cast_nat_mul -> Commute.self_cast_nat_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (a : R) (n : Nat), Commute.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) a)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (a : R) (n : Nat), Commute.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) a)
Case conversion may be inaccurate. Consider using '#align commute.self_cast_nat_mul Commute.self_cast_nat_mulₓ'. -/
@[simp]
theorem self_cast_nat_mul : Commute a (n * a : R) :=
  (Commute.refl a).cast_nat_mul_right n
#align commute.self_cast_nat_mul Commute.self_cast_nat_mul

/- warning: commute.cast_nat_mul_self -> Commute.cast_nat_mul_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (a : R) (n : Nat), Commute.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) a) a
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (a : R) (n : Nat), Commute.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) a) a
Case conversion may be inaccurate. Consider using '#align commute.cast_nat_mul_self Commute.cast_nat_mul_selfₓ'. -/
@[simp]
theorem cast_nat_mul_self : Commute ((n : R) * a) a :=
  (Commute.refl a).cast_nat_mul_left n
#align commute.cast_nat_mul_self Commute.cast_nat_mul_self

/- warning: commute.self_cast_nat_mul_cast_nat_mul -> Commute.self_cast_nat_mul_cast_nat_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (a : R) (m : Nat) (n : Nat), Commute.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) n) a)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] (a : R) (m : Nat) (n : Nat), Commute.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Nat.cast.{u1} R (Semiring.toNatCast.{u1} R _inst_1) n) a)
Case conversion may be inaccurate. Consider using '#align commute.self_cast_nat_mul_cast_nat_mul Commute.self_cast_nat_mul_cast_nat_mulₓ'. -/
@[simp]
theorem self_cast_nat_mul_cast_nat_mul : Commute (m * a : R) (n * a : R) :=
  (Commute.refl a).cast_nat_mul_cast_nat_mul m n
#align commute.self_cast_nat_mul_cast_nat_mul Commute.self_cast_nat_mul_cast_nat_mul

end

variable [Monoid M] [Group G] [Ring R]

/- warning: commute.units_zpow_right -> Commute.units_zpow_right is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {a : M} {u : Units.{u1} M _inst_1}, (Commute.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) a ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) u)) -> (forall (m : Int), Commute.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) a ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) (HPow.hPow.{u1, 0, u1} (Units.{u1} M _inst_1) Int (Units.{u1} M _inst_1) (instHPow.{u1, 0} (Units.{u1} M _inst_1) Int (DivInvMonoid.Pow.{u1} (Units.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (Units.{u1} M _inst_1) (Units.group.{u1} M _inst_1)))) u m)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {a : M} {u : Units.{u1} M _inst_1}, (Commute.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) a (Units.val.{u1} M _inst_1 u)) -> (forall (m : Int), Commute.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) a (Units.val.{u1} M _inst_1 (HPow.hPow.{u1, 0, u1} (Units.{u1} M _inst_1) Int (Units.{u1} M _inst_1) (instHPow.{u1, 0} (Units.{u1} M _inst_1) Int (DivInvMonoid.Pow.{u1} (Units.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (Units.{u1} M _inst_1) (Units.instGroupUnits.{u1} M _inst_1)))) u m)))
Case conversion may be inaccurate. Consider using '#align commute.units_zpow_right Commute.units_zpow_rightₓ'. -/
@[simp, to_additive]
theorem units_zpow_right {a : M} {u : Mˣ} (h : Commute a u) (m : ℤ) : Commute a ↑(u ^ m) :=
  h.units_zpow_right m
#align commute.units_zpow_right Commute.units_zpow_right
#align add_commute.add_units_zsmul_right AddCommute.addUnits_zsmul_right

/- warning: commute.units_zpow_left -> Commute.units_zpow_left is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {u : Units.{u1} M _inst_1} {a : M}, (Commute.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) u) a) -> (forall (m : Int), Commute.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) (HPow.hPow.{u1, 0, u1} (Units.{u1} M _inst_1) Int (Units.{u1} M _inst_1) (instHPow.{u1, 0} (Units.{u1} M _inst_1) Int (DivInvMonoid.Pow.{u1} (Units.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (Units.{u1} M _inst_1) (Units.group.{u1} M _inst_1)))) u m)) a)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {u : Units.{u1} M _inst_1} {a : M}, (Commute.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Units.val.{u1} M _inst_1 u) a) -> (forall (m : Int), Commute.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Units.val.{u1} M _inst_1 (HPow.hPow.{u1, 0, u1} (Units.{u1} M _inst_1) Int (Units.{u1} M _inst_1) (instHPow.{u1, 0} (Units.{u1} M _inst_1) Int (DivInvMonoid.Pow.{u1} (Units.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (Units.{u1} M _inst_1) (Units.instGroupUnits.{u1} M _inst_1)))) u m)) a)
Case conversion may be inaccurate. Consider using '#align commute.units_zpow_left Commute.units_zpow_leftₓ'. -/
@[simp, to_additive]
theorem units_zpow_left {u : Mˣ} {a : M} (h : Commute (↑u) a) (m : ℤ) : Commute (↑(u ^ m)) a :=
  (h.symm.units_zpow_right m).symm
#align commute.units_zpow_left Commute.units_zpow_left
#align add_commute.add_units_zsmul_left AddCommute.addUnits_zsmul_left

variable {a b : R}

/- warning: commute.cast_int_mul_right -> Commute.cast_int_mul_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) a b) -> (forall (m : Int), Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) m) b))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) a b) -> (forall (m : Int), Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) m) b))
Case conversion may be inaccurate. Consider using '#align commute.cast_int_mul_right Commute.cast_int_mul_rightₓ'. -/
@[simp]
theorem cast_int_mul_right (h : Commute a b) (m : ℤ) : Commute a (m * b : R) :=
  h.cast_int_mul_right m
#align commute.cast_int_mul_right Commute.cast_int_mul_right

/- warning: commute.cast_int_mul_left -> Commute.cast_int_mul_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) a b) -> (forall (m : Int), Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) m) a) b)
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) a b) -> (forall (m : Int), Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) m) a) b)
Case conversion may be inaccurate. Consider using '#align commute.cast_int_mul_left Commute.cast_int_mul_leftₓ'. -/
@[simp]
theorem cast_int_mul_left (h : Commute a b) (m : ℤ) : Commute ((m : R) * a) b :=
  h.cast_int_mul_left m
#align commute.cast_int_mul_left Commute.cast_int_mul_left

/- warning: commute.cast_int_mul_cast_int_mul -> Commute.cast_int_mul_cast_int_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) a b) -> (forall (m : Int) (n : Int), Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) n) b))
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] {a : R} {b : R}, (Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) a b) -> (forall (m : Int) (n : Int), Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) n) b))
Case conversion may be inaccurate. Consider using '#align commute.cast_int_mul_cast_int_mul Commute.cast_int_mul_cast_int_mulₓ'. -/
theorem cast_int_mul_cast_int_mul (h : Commute a b) (m n : ℤ) : Commute (m * a : R) (n * b : R) :=
  h.cast_int_mul_cast_int_mul m n
#align commute.cast_int_mul_cast_int_mul Commute.cast_int_mul_cast_int_mul

variable (a) (m n : ℤ)

/- warning: commute.cast_int_left -> Commute.cast_int_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] (a : R) (m : Int), Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) m) a
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] (a : R) (m : Int), Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) m) a
Case conversion may be inaccurate. Consider using '#align commute.cast_int_left Commute.cast_int_leftₓ'. -/
@[simp]
theorem cast_int_left : Commute (m : R) a :=
  Int.cast_commute _ _
#align commute.cast_int_left Commute.cast_int_left

/- warning: commute.cast_int_right -> Commute.cast_int_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] (a : R) (m : Int), Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) a ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) m)
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] (a : R) (m : Int), Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) a (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) m)
Case conversion may be inaccurate. Consider using '#align commute.cast_int_right Commute.cast_int_rightₓ'. -/
@[simp]
theorem cast_int_right : Commute a m :=
  Int.commute_cast _ _
#align commute.cast_int_right Commute.cast_int_right

/- warning: commute.self_cast_int_mul -> Commute.self_cast_int_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] (a : R) (n : Int), Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) n) a)
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] (a : R) (n : Int), Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) a (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) n) a)
Case conversion may be inaccurate. Consider using '#align commute.self_cast_int_mul Commute.self_cast_int_mulₓ'. -/
@[simp]
theorem self_cast_int_mul : Commute a (n * a : R) :=
  (Commute.refl a).cast_int_mul_right n
#align commute.self_cast_int_mul Commute.self_cast_int_mul

/- warning: commute.cast_int_mul_self -> Commute.cast_int_mul_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] (a : R) (n : Int), Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) n) a) a
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] (a : R) (n : Int), Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) n) a) a
Case conversion may be inaccurate. Consider using '#align commute.cast_int_mul_self Commute.cast_int_mul_selfₓ'. -/
@[simp]
theorem cast_int_mul_self : Commute ((n : R) * a) a :=
  (Commute.refl a).cast_int_mul_left n
#align commute.cast_int_mul_self Commute.cast_int_mul_self

/- warning: commute.self_cast_int_mul_cast_int_mul -> Commute.self_cast_int_mul_cast_int_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] (a : R) (m : Int) (n : Int), Commute.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_3))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_3)))))) n) a)
but is expected to have type
  forall {R : Type.{u1}} [_inst_3 : Ring.{u1} R] (a : R) (m : Int) (n : Int), Commute.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) m) a) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_3)))) (Int.cast.{u1} R (Ring.toIntCast.{u1} R _inst_3) n) a)
Case conversion may be inaccurate. Consider using '#align commute.self_cast_int_mul_cast_int_mul Commute.self_cast_int_mul_cast_int_mulₓ'. -/
theorem self_cast_int_mul_cast_int_mul : Commute (m * a : R) (n * a : R) :=
  (Commute.refl a).cast_int_mul_cast_int_mul m n
#align commute.self_cast_int_mul_cast_int_mul Commute.self_cast_int_mul_cast_int_mul

end Commute

section Multiplicative

open Multiplicative

#print Nat.toAdd_pow /-
@[simp]
theorem Nat.toAdd_pow (a : Multiplicative ℕ) (b : ℕ) : toAdd (a ^ b) = toAdd a * b :=
  by
  induction' b with b ih
  · erw [pow_zero, toAdd_one, MulZeroClass.mul_zero]
  · simp [*, pow_succ, add_comm, Nat.mul_succ]
#align nat.to_add_pow Nat.toAdd_pow
-/

#print Nat.ofAdd_mul /-
@[simp]
theorem Nat.ofAdd_mul (a b : ℕ) : ofAdd (a * b) = ofAdd a ^ b :=
  (Nat.toAdd_pow _ _).symm
#align nat.of_add_mul Nat.ofAdd_mul
-/

#print Int.toAdd_pow /-
@[simp]
theorem Int.toAdd_pow (a : Multiplicative ℤ) (b : ℕ) : toAdd (a ^ b) = toAdd a * b := by
  induction b <;> simp [*, mul_add, pow_succ, add_comm]
#align int.to_add_pow Int.toAdd_pow
-/

#print Int.toAdd_zpow /-
@[simp]
theorem Int.toAdd_zpow (a : Multiplicative ℤ) (b : ℤ) : toAdd (a ^ b) = toAdd a * b :=
  Int.induction_on b (by simp) (by simp (config := { contextual := true }) [zpow_add, mul_add])
    (by
      simp (config := { contextual := true }) [zpow_add, mul_add, sub_eq_add_neg, -Int.add_neg_one])
#align int.to_add_zpow Int.toAdd_zpow
-/

#print Int.ofAdd_mul /-
@[simp]
theorem Int.ofAdd_mul (a b : ℤ) : ofAdd (a * b) = ofAdd a ^ b :=
  (Int.toAdd_zpow _ _).symm
#align int.of_add_mul Int.ofAdd_mul
-/

end Multiplicative

namespace Units

variable [Monoid M]

/- warning: units.conj_pow -> Units.conj_pow is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (u : Units.{u1} M _inst_1) (x : M) (n : Nat), Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) u) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) (Inv.inv.{u1} (Units.{u1} M _inst_1) (Units.hasInv.{u1} M _inst_1) u))) n) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) u) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) (Inv.inv.{u1} (Units.{u1} M _inst_1) (Units.hasInv.{u1} M _inst_1) u)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (u : Units.{u1} M _inst_1) (x : M) (n : Nat), Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (Units.val.{u1} M _inst_1 u) x) (Units.val.{u1} M _inst_1 (Inv.inv.{u1} (Units.{u1} M _inst_1) (Units.instInv.{u1} M _inst_1) u))) n) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (Units.val.{u1} M _inst_1 u) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n)) (Units.val.{u1} M _inst_1 (Inv.inv.{u1} (Units.{u1} M _inst_1) (Units.instInv.{u1} M _inst_1) u)))
Case conversion may be inaccurate. Consider using '#align units.conj_pow Units.conj_powₓ'. -/
theorem conj_pow (u : Mˣ) (x : M) (n : ℕ) : (↑u * x * ↑u⁻¹) ^ n = u * x ^ n * ↑u⁻¹ :=
  (divp_eq_iff_mul_eq.2 ((u.mk_semiconjBy x).pow_right n).Eq.symm).symm
#align units.conj_pow Units.conj_pow

/- warning: units.conj_pow' -> Units.conj_pow' is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (u : Units.{u1} M _inst_1) (x : M) (n : Nat), Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) (Inv.inv.{u1} (Units.{u1} M _inst_1) (Units.hasInv.{u1} M _inst_1) u)) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) u)) n) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) (Inv.inv.{u1} (Units.{u1} M _inst_1) (Units.hasInv.{u1} M _inst_1) u)) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} M _inst_1) M (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} M _inst_1) M (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} M _inst_1) M (coeBase.{succ u1, succ u1} (Units.{u1} M _inst_1) M (Units.hasCoe.{u1} M _inst_1)))) u))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (u : Units.{u1} M _inst_1) (x : M) (n : Nat), Eq.{succ u1} M (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (Units.val.{u1} M _inst_1 (Inv.inv.{u1} (Units.{u1} M _inst_1) (Units.instInv.{u1} M _inst_1) u)) x) (Units.val.{u1} M _inst_1 u)) n) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (HMul.hMul.{u1, u1, u1} M M M (instHMul.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1))) (Units.val.{u1} M _inst_1 (Inv.inv.{u1} (Units.{u1} M _inst_1) (Units.instInv.{u1} M _inst_1) u)) (HPow.hPow.{u1, 0, u1} M Nat M (instHPow.{u1, 0} M Nat (Monoid.Pow.{u1} M _inst_1)) x n)) (Units.val.{u1} M _inst_1 u))
Case conversion may be inaccurate. Consider using '#align units.conj_pow' Units.conj_pow'ₓ'. -/
theorem conj_pow' (u : Mˣ) (x : M) (n : ℕ) : (↑u⁻¹ * x * u) ^ n = ↑u⁻¹ * x ^ n * u :=
  u⁻¹.conj_pow x n
#align units.conj_pow' Units.conj_pow'

end Units

namespace MulOpposite

#print MulOpposite.op_pow /-
/-- Moving to the opposite monoid commutes with taking powers. -/
@[simp]
theorem op_pow [Monoid M] (x : M) (n : ℕ) : op (x ^ n) = op x ^ n :=
  rfl
#align mul_opposite.op_pow MulOpposite.op_pow
-/

#print MulOpposite.unop_pow /-
@[simp]
theorem unop_pow [Monoid M] (x : Mᵐᵒᵖ) (n : ℕ) : unop (x ^ n) = unop x ^ n :=
  rfl
#align mul_opposite.unop_pow MulOpposite.unop_pow
-/

#print MulOpposite.op_zpow /-
/-- Moving to the opposite group or group_with_zero commutes with taking powers. -/
@[simp]
theorem op_zpow [DivInvMonoid M] (x : M) (z : ℤ) : op (x ^ z) = op x ^ z :=
  rfl
#align mul_opposite.op_zpow MulOpposite.op_zpow
-/

#print MulOpposite.unop_zpow /-
@[simp]
theorem unop_zpow [DivInvMonoid M] (x : Mᵐᵒᵖ) (z : ℤ) : unop (x ^ z) = unop x ^ z :=
  rfl
#align mul_opposite.unop_zpow MulOpposite.unop_zpow
-/

end MulOpposite

