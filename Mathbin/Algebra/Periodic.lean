/-
Copyright (c) 2021 Benjamin Davidson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Benjamin Davidson

! This file was ported from Lean 3 source module algebra.periodic
! leanprover-community/mathlib commit bd9851ca476957ea4549eb19b40e7b5ade9428cc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.BigOperators.Basic
import Mathbin.Algebra.Field.Opposite
import Mathbin.Algebra.Module.Basic
import Mathbin.Algebra.Order.Archimedean
import Mathbin.Data.Int.Parity
import Mathbin.GroupTheory.Coset
import Mathbin.GroupTheory.Subgroup.Zpowers
import Mathbin.GroupTheory.Submonoid.Membership

/-!
# Periodicity

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define and then prove facts about periodic and antiperiodic functions.

## Main definitions

* `function.periodic`: A function `f` is *periodic* if `∀ x, f (x + c) = f x`.
  `f` is referred to as periodic with period `c` or `c`-periodic.

* `function.antiperiodic`: A function `f` is *antiperiodic* if `∀ x, f (x + c) = -f x`.
  `f` is referred to as antiperiodic with antiperiod `c` or `c`-antiperiodic.

Note that any `c`-antiperiodic function will necessarily also be `2*c`-periodic.

## Tags

period, periodic, periodicity, antiperiodic
-/


variable {α β γ : Type _} {f g : α → β} {c c₁ c₂ x : α}

open BigOperators

namespace Function

/-! ### Periodicity -/


#print Function.Periodic /-
/-- A function `f` is said to be `periodic` with period `c` if for all `x`, `f (x + c) = f x`. -/
@[simp]
def Periodic [Add α] (f : α → β) (c : α) : Prop :=
  ∀ x : α, f (x + c) = f x
#align function.periodic Function.Periodic
-/

/- warning: function.periodic.funext -> Function.Periodic.funext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Add.{u1} α], (Function.Periodic.{u1, u2} α β _inst_1 f c) -> (Eq.{max (succ u1) (succ u2)} (α -> β) (fun (x : α) => f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α _inst_1) x c)) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Add.{u2} α], (Function.Periodic.{u2, u1} α β _inst_1 f c) -> (Eq.{max (succ u2) (succ u1)} (α -> β) (fun (x : α) => f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α _inst_1) x c)) f)
Case conversion may be inaccurate. Consider using '#align function.periodic.funext Function.Periodic.funextₓ'. -/
protected theorem Periodic.funext [Add α] (h : Periodic f c) : (fun x => f (x + c)) = f :=
  funext h
#align function.periodic.funext Function.Periodic.funext

/- warning: function.periodic.comp -> Function.Periodic.comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : Add.{u1} α], (Function.Periodic.{u1, u2} α β _inst_1 f c) -> (forall (g : β -> γ), Function.Periodic.{u1, u3} α γ _inst_1 (Function.comp.{succ u1, succ u2, succ u3} α β γ g f) c)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Add.{u3} α], (Function.Periodic.{u3, u2} α β _inst_1 f c) -> (forall (g : β -> γ), Function.Periodic.{u3, u1} α γ _inst_1 (Function.comp.{succ u3, succ u2, succ u1} α β γ g f) c)
Case conversion may be inaccurate. Consider using '#align function.periodic.comp Function.Periodic.compₓ'. -/
protected theorem Periodic.comp [Add α] (h : Periodic f c) (g : β → γ) : Periodic (g ∘ f) c := by
  simp_all
#align function.periodic.comp Function.Periodic.comp

/- warning: function.periodic.comp_add_hom -> Function.Periodic.comp_addHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : Add.{u3} γ], (Function.Periodic.{u1, u2} α β _inst_1 f c) -> (forall (g : AddHom.{u3, u1} γ α _inst_2 _inst_1) (g_inv : α -> γ), (Function.RightInverse.{succ u3, succ u1} γ α g_inv (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (AddHom.{u3, u1} γ α _inst_2 _inst_1) (fun (_x : AddHom.{u3, u1} γ α _inst_2 _inst_1) => γ -> α) (AddHom.hasCoeToFun.{u3, u1} γ α _inst_2 _inst_1) g)) -> (Function.Periodic.{u3, u2} γ β _inst_2 (Function.comp.{succ u3, succ u1, succ u2} γ α β f (coeFn.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (AddHom.{u3, u1} γ α _inst_2 _inst_1) (fun (_x : AddHom.{u3, u1} γ α _inst_2 _inst_1) => γ -> α) (AddHom.hasCoeToFun.{u3, u1} γ α _inst_2 _inst_1) g)) (g_inv c)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {γ : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Add.{u3} α] [_inst_2 : Add.{u2} γ], (Function.Periodic.{u3, u1} α β _inst_1 f c) -> (forall (g : AddHom.{u2, u3} γ α _inst_2 _inst_1) (g_inv : α -> γ), (Function.RightInverse.{succ u2, succ u3} γ α g_inv (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (AddHom.{u2, u3} γ α _inst_2 _inst_1) γ (fun (_x : γ) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : γ) => α) _x) (AddHomClass.toFunLike.{max u3 u2, u2, u3} (AddHom.{u2, u3} γ α _inst_2 _inst_1) γ α _inst_2 _inst_1 (AddHom.addHomClass.{u2, u3} γ α _inst_2 _inst_1)) g)) -> (Function.Periodic.{u2, u1} γ β _inst_2 (Function.comp.{succ u2, succ u3, succ u1} γ α β f (FunLike.coe.{max (succ u3) (succ u2), succ u2, succ u3} (AddHom.{u2, u3} γ α _inst_2 _inst_1) γ (fun (_x : γ) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : γ) => α) _x) (AddHomClass.toFunLike.{max u3 u2, u2, u3} (AddHom.{u2, u3} γ α _inst_2 _inst_1) γ α _inst_2 _inst_1 (AddHom.addHomClass.{u2, u3} γ α _inst_2 _inst_1)) g)) (g_inv c)))
Case conversion may be inaccurate. Consider using '#align function.periodic.comp_add_hom Function.Periodic.comp_addHomₓ'. -/
theorem Periodic.comp_addHom [Add α] [Add γ] (h : Periodic f c) (g : AddHom γ α) (g_inv : α → γ)
    (hg : RightInverse g_inv g) : Periodic (f ∘ g) (g_inv c) := fun x => by
  simp only [hg c, h (g x), AddHom.map_add, comp_app]
#align function.periodic.comp_add_hom Function.Periodic.comp_addHom

/- warning: function.periodic.mul -> Function.Periodic.mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {g : α -> β} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : Mul.{u2} β], (Function.Periodic.{u1, u2} α β _inst_1 f c) -> (Function.Periodic.{u1, u2} α β _inst_1 g c) -> (Function.Periodic.{u1, u2} α β _inst_1 (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHMul.{max u1 u2} (α -> β) (Pi.instMul.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_2))) f g) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {g : α -> β} {c : α} [_inst_1 : Add.{u2} α] [_inst_2 : Mul.{u1} β], (Function.Periodic.{u2, u1} α β _inst_1 f c) -> (Function.Periodic.{u2, u1} α β _inst_1 g c) -> (Function.Periodic.{u2, u1} α β _inst_1 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (α -> β) (α -> β) (α -> β) (instHMul.{max u2 u1} (α -> β) (Pi.instMul.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_2))) f g) c)
Case conversion may be inaccurate. Consider using '#align function.periodic.mul Function.Periodic.mulₓ'. -/
@[to_additive]
protected theorem Periodic.mul [Add α] [Mul β] (hf : Periodic f c) (hg : Periodic g c) :
    Periodic (f * g) c := by simp_all
#align function.periodic.mul Function.Periodic.mul
#align function.periodic.add Function.Periodic.add

/- warning: function.periodic.div -> Function.Periodic.div is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {g : α -> β} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : Div.{u2} β], (Function.Periodic.{u1, u2} α β _inst_1 f c) -> (Function.Periodic.{u1, u2} α β _inst_1 g c) -> (Function.Periodic.{u1, u2} α β _inst_1 (HDiv.hDiv.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHDiv.{max u1 u2} (α -> β) (Pi.instDiv.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_2))) f g) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {g : α -> β} {c : α} [_inst_1 : Add.{u2} α] [_inst_2 : Div.{u1} β], (Function.Periodic.{u2, u1} α β _inst_1 f c) -> (Function.Periodic.{u2, u1} α β _inst_1 g c) -> (Function.Periodic.{u2, u1} α β _inst_1 (HDiv.hDiv.{max u2 u1, max u2 u1, max u2 u1} (α -> β) (α -> β) (α -> β) (instHDiv.{max u2 u1} (α -> β) (Pi.instDiv.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_2))) f g) c)
Case conversion may be inaccurate. Consider using '#align function.periodic.div Function.Periodic.divₓ'. -/
@[to_additive]
protected theorem Periodic.div [Add α] [Div β] (hf : Periodic f c) (hg : Periodic g c) :
    Periodic (f / g) c := by simp_all
#align function.periodic.div Function.Periodic.div
#align function.periodic.sub Function.Periodic.sub

/- warning: list.periodic_prod -> List.periodic_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : Monoid.{u2} β] (l : List.{max u1 u2} (α -> β)), (forall (f : α -> β), (Membership.Mem.{max u1 u2, max u1 u2} (α -> β) (List.{max u1 u2} (α -> β)) (List.hasMem.{max u1 u2} (α -> β)) f l) -> (Function.Periodic.{u1, u2} α β _inst_1 f c)) -> (Function.Periodic.{u1, u2} α β _inst_1 (List.prod.{max u1 u2} (α -> β) (Pi.instMul.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => MulOneClass.toHasMul.{u2} β (Monoid.toMulOneClass.{u2} β _inst_2))) (Pi.instOne.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => MulOneClass.toHasOne.{u2} β (Monoid.toMulOneClass.{u2} β _inst_2))) l) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {c : α} [_inst_1 : Add.{u2} α] [_inst_2 : Monoid.{u1} β] (l : List.{max u2 u1} (α -> β)), (forall (f : α -> β), (Membership.mem.{max u2 u1, max u2 u1} (α -> β) (List.{max u2 u1} (α -> β)) (List.instMembershipList.{max u2 u1} (α -> β)) f l) -> (Function.Periodic.{u2, u1} α β _inst_1 f c)) -> (Function.Periodic.{u2, u1} α β _inst_1 (List.prod.{max u2 u1} (α -> β) (Pi.instMul.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => MulOneClass.toMul.{u1} β (Monoid.toMulOneClass.{u1} β _inst_2))) (Pi.instOne.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => Monoid.toOne.{u1} β _inst_2)) l) c)
Case conversion may be inaccurate. Consider using '#align list.periodic_prod List.periodic_prodₓ'. -/
@[to_additive]
theorem List.periodic_prod [Add α] [Monoid β] (l : List (α → β)) (hl : ∀ f ∈ l, Periodic f c) :
    Periodic l.Prod c := by
  induction' l with g l ih hl
  · simp
  · rw [List.forall_mem_cons] at hl
    simpa only [List.prod_cons] using hl.1.mul (ih hl.2)
#align list.periodic_prod List.periodic_prod
#align list.periodic_sum List.periodic_sum

/- warning: multiset.periodic_prod -> Multiset.periodic_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : CommMonoid.{u2} β] (s : Multiset.{max u1 u2} (α -> β)), (forall (f : α -> β), (Membership.Mem.{max u1 u2, max u1 u2} (α -> β) (Multiset.{max u1 u2} (α -> β)) (Multiset.hasMem.{max u1 u2} (α -> β)) f s) -> (Function.Periodic.{u1, u2} α β _inst_1 f c)) -> (Function.Periodic.{u1, u2} α β _inst_1 (Multiset.prod.{max u1 u2} (α -> β) (Pi.commMonoid.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_2)) s) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {c : α} [_inst_1 : Add.{u2} α] [_inst_2 : CommMonoid.{u1} β] (s : Multiset.{max u2 u1} (α -> β)), (forall (f : α -> β), (Membership.mem.{max u2 u1, max u2 u1} (α -> β) (Multiset.{max u2 u1} (α -> β)) (Multiset.instMembershipMultiset.{max u2 u1} (α -> β)) f s) -> (Function.Periodic.{u2, u1} α β _inst_1 f c)) -> (Function.Periodic.{u2, u1} α β _inst_1 (Multiset.prod.{max u2 u1} (α -> β) (Pi.commMonoid.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_2)) s) c)
Case conversion may be inaccurate. Consider using '#align multiset.periodic_prod Multiset.periodic_prodₓ'. -/
@[to_additive]
theorem Multiset.periodic_prod [Add α] [CommMonoid β] (s : Multiset (α → β))
    (hs : ∀ f ∈ s, Periodic f c) : Periodic s.Prod c :=
  (s.prod_toList ▸ s.toList.periodic_prod) fun f hf => hs f <| Multiset.mem_toList.mp hf
#align multiset.periodic_prod Multiset.periodic_prod
#align multiset.periodic_sum Multiset.periodic_sum

/- warning: finset.periodic_prod -> Finset.periodic_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : CommMonoid.{u2} β] {ι : Type.{u3}} {f : ι -> α -> β} (s : Finset.{u3} ι), (forall (i : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) -> (Function.Periodic.{u1, u2} α β _inst_1 (f i) c)) -> (Function.Periodic.{u1, u2} α β _inst_1 (Finset.prod.{max u1 u2, u3} (α -> β) ι (Pi.commMonoid.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_2)) s (fun (i : ι) => f i)) c)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {c : α} [_inst_1 : Add.{u3} α] [_inst_2 : CommMonoid.{u2} β] {ι : Type.{u1}} {f : ι -> α -> β} (s : Finset.{u1} ι), (forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Function.Periodic.{u3, u2} α β _inst_1 (f i) c)) -> (Function.Periodic.{u3, u2} α β _inst_1 (Finset.prod.{max u2 u3, u1} (α -> β) ι (Pi.commMonoid.{u3, u2} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_2)) s (fun (i : ι) => f i)) c)
Case conversion may be inaccurate. Consider using '#align finset.periodic_prod Finset.periodic_prodₓ'. -/
@[to_additive]
theorem Finset.periodic_prod [Add α] [CommMonoid β] {ι : Type _} {f : ι → α → β} (s : Finset ι)
    (hs : ∀ i ∈ s, Periodic (f i) c) : Periodic (∏ i in s, f i) c :=
  s.prod_toList f ▸ (s.toList.map f).periodic_prod (by simpa [-periodic] )
#align finset.periodic_prod Finset.periodic_prod
#align finset.periodic_sum Finset.periodic_sum

/- warning: function.periodic.smul -> Function.Periodic.smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : SMul.{u3, u2} γ β], (Function.Periodic.{u1, u2} α β _inst_1 f c) -> (forall (a : γ), Function.Periodic.{u1, u2} α β _inst_1 (SMul.smul.{u3, max u1 u2} γ (α -> β) (Function.hasSMul.{u1, u3, u2} α γ β _inst_2) a f) c)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {γ : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Add.{u3} α] [_inst_2 : SMul.{u2, u1} γ β], (Function.Periodic.{u3, u1} α β _inst_1 f c) -> (forall (a : γ), Function.Periodic.{u3, u1} α β _inst_1 (HSMul.hSMul.{u2, max u3 u1, max u3 u1} γ (α -> β) (α -> β) (instHSMul.{u2, max u3 u1} γ (α -> β) (Pi.instSMul.{u3, u1, u2} α γ (fun (a._@.Mathlib.Algebra.Periodic._hyg.562 : α) => β) (fun (i : α) => _inst_2))) a f) c)
Case conversion may be inaccurate. Consider using '#align function.periodic.smul Function.Periodic.smulₓ'. -/
@[to_additive]
protected theorem Periodic.smul [Add α] [SMul γ β] (h : Periodic f c) (a : γ) :
    Periodic (a • f) c := by simp_all
#align function.periodic.smul Function.Periodic.smul
#align function.periodic.vadd Function.Periodic.vadd

/- warning: function.periodic.const_smul -> Function.Periodic.const_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u1} α] [_inst_2 : Group.{u3} γ] [_inst_3 : DistribMulAction.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_2)) _inst_1], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) f c) -> (forall (a : γ), Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) (fun (x : α) => f (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u1} γ α (AddMonoid.toAddZeroClass.{u1} α _inst_1) (DistribMulAction.toDistribSMul.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_2)) _inst_1 _inst_3))) a x)) (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u1} γ α (AddMonoid.toAddZeroClass.{u1} α _inst_1) (DistribMulAction.toDistribSMul.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_2)) _inst_1 _inst_3))) (Inv.inv.{u3} γ (DivInvMonoid.toHasInv.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_2)) a) c))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {γ : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u3} α] [_inst_2 : Group.{u2} γ] [_inst_3 : DistribMulAction.{u2, u3} γ α (DivInvMonoid.toMonoid.{u2} γ (Group.toDivInvMonoid.{u2} γ _inst_2)) _inst_1], (Function.Periodic.{u3, u1} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α _inst_1)) f c) -> (forall (a : γ), Function.Periodic.{u3, u1} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α _inst_1)) (fun (x : α) => f (HSMul.hSMul.{u2, u3, u3} γ α α (instHSMul.{u2, u3} γ α (SMulZeroClass.toSMul.{u2, u3} γ α (AddMonoid.toZero.{u3} α _inst_1) (DistribSMul.toSMulZeroClass.{u2, u3} γ α (AddMonoid.toAddZeroClass.{u3} α _inst_1) (DistribMulAction.toDistribSMul.{u2, u3} γ α (DivInvMonoid.toMonoid.{u2} γ (Group.toDivInvMonoid.{u2} γ _inst_2)) _inst_1 _inst_3)))) a x)) (HSMul.hSMul.{u2, u3, u3} γ α α (instHSMul.{u2, u3} γ α (SMulZeroClass.toSMul.{u2, u3} γ α (AddMonoid.toZero.{u3} α _inst_1) (DistribSMul.toSMulZeroClass.{u2, u3} γ α (AddMonoid.toAddZeroClass.{u3} α _inst_1) (DistribMulAction.toDistribSMul.{u2, u3} γ α (DivInvMonoid.toMonoid.{u2} γ (Group.toDivInvMonoid.{u2} γ _inst_2)) _inst_1 _inst_3)))) (Inv.inv.{u2} γ (InvOneClass.toInv.{u2} γ (DivInvOneMonoid.toInvOneClass.{u2} γ (DivisionMonoid.toDivInvOneMonoid.{u2} γ (Group.toDivisionMonoid.{u2} γ _inst_2)))) a) c))
Case conversion may be inaccurate. Consider using '#align function.periodic.const_smul Function.Periodic.const_smulₓ'. -/
protected theorem Periodic.const_smul [AddMonoid α] [Group γ] [DistribMulAction γ α]
    (h : Periodic f c) (a : γ) : Periodic (fun x => f (a • x)) (a⁻¹ • c) := fun x => by
  simpa only [smul_add, smul_inv_smul] using h (a • x)
#align function.periodic.const_smul Function.Periodic.const_smul

/- warning: function.periodic.const_smul₀ -> Function.Periodic.const_smul₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : AddCommMonoid.{u1} α] [_inst_2 : DivisionRing.{u3} γ] [_inst_3 : Module.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2)) _inst_1], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) f c) -> (forall (a : γ), Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (fun (x : α) => f (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (SMulWithZero.toSmulZeroClass.{u3, u1} γ α (MulZeroClass.toHasZero.{u3} γ (MulZeroOneClass.toMulZeroClass.{u3} γ (MonoidWithZero.toMulZeroOneClass.{u3} γ (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2)))))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (MulActionWithZero.toSMulWithZero.{u3, u1} γ α (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (Module.toMulActionWithZero.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2)) _inst_1 _inst_3)))) a x)) (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (SMulWithZero.toSmulZeroClass.{u3, u1} γ α (MulZeroClass.toHasZero.{u3} γ (MulZeroOneClass.toMulZeroClass.{u3} γ (MonoidWithZero.toMulZeroOneClass.{u3} γ (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2)))))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (MulActionWithZero.toSMulWithZero.{u3, u1} γ α (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (Module.toMulActionWithZero.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2)) _inst_1 _inst_3)))) (Inv.inv.{u3} γ (DivInvMonoid.toHasInv.{u3} γ (DivisionRing.toDivInvMonoid.{u3} γ _inst_2)) a) c))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {γ : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddCommMonoid.{u3} α] [_inst_2 : DivisionSemiring.{u2} γ] [_inst_3 : Module.{u2, u3} γ α (DivisionSemiring.toSemiring.{u2} γ _inst_2) _inst_1], (Function.Periodic.{u3, u1} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1))) f c) -> (forall (a : γ), Function.Periodic.{u3, u1} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1))) (fun (x : α) => f (HSMul.hSMul.{u2, u3, u3} γ α α (instHSMul.{u2, u3} γ α (SMulZeroClass.toSMul.{u2, u3} γ α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (SMulWithZero.toSMulZeroClass.{u2, u3} γ α (MonoidWithZero.toZero.{u2} γ (Semiring.toMonoidWithZero.{u2} γ (DivisionSemiring.toSemiring.{u2} γ _inst_2))) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (MulActionWithZero.toSMulWithZero.{u2, u3} γ α (Semiring.toMonoidWithZero.{u2} γ (DivisionSemiring.toSemiring.{u2} γ _inst_2)) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (Module.toMulActionWithZero.{u2, u3} γ α (DivisionSemiring.toSemiring.{u2} γ _inst_2) _inst_1 _inst_3))))) a x)) (HSMul.hSMul.{u2, u3, u3} γ α α (instHSMul.{u2, u3} γ α (SMulZeroClass.toSMul.{u2, u3} γ α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (SMulWithZero.toSMulZeroClass.{u2, u3} γ α (MonoidWithZero.toZero.{u2} γ (Semiring.toMonoidWithZero.{u2} γ (DivisionSemiring.toSemiring.{u2} γ _inst_2))) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (MulActionWithZero.toSMulWithZero.{u2, u3} γ α (Semiring.toMonoidWithZero.{u2} γ (DivisionSemiring.toSemiring.{u2} γ _inst_2)) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (Module.toMulActionWithZero.{u2, u3} γ α (DivisionSemiring.toSemiring.{u2} γ _inst_2) _inst_1 _inst_3))))) (Inv.inv.{u2} γ (DivisionSemiring.toInv.{u2} γ _inst_2) a) c))
Case conversion may be inaccurate. Consider using '#align function.periodic.const_smul₀ Function.Periodic.const_smul₀ₓ'. -/
theorem Periodic.const_smul₀ [AddCommMonoid α] [DivisionRing γ] [Module γ α] (h : Periodic f c)
    (a : γ) : Periodic (fun x => f (a • x)) (a⁻¹ • c) :=
  by
  intro x
  by_cases ha : a = 0; · simp only [ha, zero_smul]
  simpa only [smul_add, smul_inv_smul₀ ha] using h (a • x)
#align function.periodic.const_smul₀ Function.Periodic.const_smul₀

/- warning: function.periodic.const_mul -> Function.Periodic.const_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) f c) -> (forall (a : α), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) (fun (x : α) => f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) a x)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1)) a) c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) f c) -> (forall (a : α), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) (fun (x : α) => f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) a x)) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) (Inv.inv.{u2} α (DivisionSemiring.toInv.{u2} α _inst_1) a) c))
Case conversion may be inaccurate. Consider using '#align function.periodic.const_mul Function.Periodic.const_mulₓ'. -/
protected theorem Periodic.const_mul [DivisionRing α] (h : Periodic f c) (a : α) :
    Periodic (fun x => f (a * x)) (a⁻¹ * c) :=
  h.const_smul₀ a
#align function.periodic.const_mul Function.Periodic.const_mul

/- warning: function.periodic.const_inv_smul -> Function.Periodic.const_inv_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u1} α] [_inst_2 : Group.{u3} γ] [_inst_3 : DistribMulAction.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_2)) _inst_1], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) f c) -> (forall (a : γ), Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) (fun (x : α) => f (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u1} γ α (AddMonoid.toAddZeroClass.{u1} α _inst_1) (DistribMulAction.toDistribSMul.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_2)) _inst_1 _inst_3))) (Inv.inv.{u3} γ (DivInvMonoid.toHasInv.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_2)) a) x)) (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u1} γ α (AddMonoid.toAddZeroClass.{u1} α _inst_1) (DistribMulAction.toDistribSMul.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_2)) _inst_1 _inst_3))) a c))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {γ : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u3} α] [_inst_2 : Group.{u2} γ] [_inst_3 : DistribMulAction.{u2, u3} γ α (DivInvMonoid.toMonoid.{u2} γ (Group.toDivInvMonoid.{u2} γ _inst_2)) _inst_1], (Function.Periodic.{u3, u1} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α _inst_1)) f c) -> (forall (a : γ), Function.Periodic.{u3, u1} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α _inst_1)) (fun (x : α) => f (HSMul.hSMul.{u2, u3, u3} γ α α (instHSMul.{u2, u3} γ α (SMulZeroClass.toSMul.{u2, u3} γ α (AddMonoid.toZero.{u3} α _inst_1) (DistribSMul.toSMulZeroClass.{u2, u3} γ α (AddMonoid.toAddZeroClass.{u3} α _inst_1) (DistribMulAction.toDistribSMul.{u2, u3} γ α (DivInvMonoid.toMonoid.{u2} γ (Group.toDivInvMonoid.{u2} γ _inst_2)) _inst_1 _inst_3)))) (Inv.inv.{u2} γ (InvOneClass.toInv.{u2} γ (DivInvOneMonoid.toInvOneClass.{u2} γ (DivisionMonoid.toDivInvOneMonoid.{u2} γ (Group.toDivisionMonoid.{u2} γ _inst_2)))) a) x)) (HSMul.hSMul.{u2, u3, u3} γ α α (instHSMul.{u2, u3} γ α (SMulZeroClass.toSMul.{u2, u3} γ α (AddMonoid.toZero.{u3} α _inst_1) (DistribSMul.toSMulZeroClass.{u2, u3} γ α (AddMonoid.toAddZeroClass.{u3} α _inst_1) (DistribMulAction.toDistribSMul.{u2, u3} γ α (DivInvMonoid.toMonoid.{u2} γ (Group.toDivInvMonoid.{u2} γ _inst_2)) _inst_1 _inst_3)))) a c))
Case conversion may be inaccurate. Consider using '#align function.periodic.const_inv_smul Function.Periodic.const_inv_smulₓ'. -/
theorem Periodic.const_inv_smul [AddMonoid α] [Group γ] [DistribMulAction γ α] (h : Periodic f c)
    (a : γ) : Periodic (fun x => f (a⁻¹ • x)) (a • c) := by
  simpa only [inv_inv] using h.const_smul a⁻¹
#align function.periodic.const_inv_smul Function.Periodic.const_inv_smul

/- warning: function.periodic.const_inv_smul₀ -> Function.Periodic.const_inv_smul₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : AddCommMonoid.{u1} α] [_inst_2 : DivisionRing.{u3} γ] [_inst_3 : Module.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2)) _inst_1], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) f c) -> (forall (a : γ), Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (fun (x : α) => f (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (SMulWithZero.toSmulZeroClass.{u3, u1} γ α (MulZeroClass.toHasZero.{u3} γ (MulZeroOneClass.toMulZeroClass.{u3} γ (MonoidWithZero.toMulZeroOneClass.{u3} γ (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2)))))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (MulActionWithZero.toSMulWithZero.{u3, u1} γ α (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (Module.toMulActionWithZero.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2)) _inst_1 _inst_3)))) (Inv.inv.{u3} γ (DivInvMonoid.toHasInv.{u3} γ (DivisionRing.toDivInvMonoid.{u3} γ _inst_2)) a) x)) (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (SMulWithZero.toSmulZeroClass.{u3, u1} γ α (MulZeroClass.toHasZero.{u3} γ (MulZeroOneClass.toMulZeroClass.{u3} γ (MonoidWithZero.toMulZeroOneClass.{u3} γ (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2)))))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (MulActionWithZero.toSMulWithZero.{u3, u1} γ α (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (Module.toMulActionWithZero.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_2)) _inst_1 _inst_3)))) a c))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {γ : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddCommMonoid.{u3} α] [_inst_2 : DivisionSemiring.{u2} γ] [_inst_3 : Module.{u2, u3} γ α (DivisionSemiring.toSemiring.{u2} γ _inst_2) _inst_1], (Function.Periodic.{u3, u1} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1))) f c) -> (forall (a : γ), Function.Periodic.{u3, u1} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1))) (fun (x : α) => f (HSMul.hSMul.{u2, u3, u3} γ α α (instHSMul.{u2, u3} γ α (SMulZeroClass.toSMul.{u2, u3} γ α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (SMulWithZero.toSMulZeroClass.{u2, u3} γ α (MonoidWithZero.toZero.{u2} γ (Semiring.toMonoidWithZero.{u2} γ (DivisionSemiring.toSemiring.{u2} γ _inst_2))) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (MulActionWithZero.toSMulWithZero.{u2, u3} γ α (Semiring.toMonoidWithZero.{u2} γ (DivisionSemiring.toSemiring.{u2} γ _inst_2)) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (Module.toMulActionWithZero.{u2, u3} γ α (DivisionSemiring.toSemiring.{u2} γ _inst_2) _inst_1 _inst_3))))) (Inv.inv.{u2} γ (DivisionSemiring.toInv.{u2} γ _inst_2) a) x)) (HSMul.hSMul.{u2, u3, u3} γ α α (instHSMul.{u2, u3} γ α (SMulZeroClass.toSMul.{u2, u3} γ α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (SMulWithZero.toSMulZeroClass.{u2, u3} γ α (MonoidWithZero.toZero.{u2} γ (Semiring.toMonoidWithZero.{u2} γ (DivisionSemiring.toSemiring.{u2} γ _inst_2))) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (MulActionWithZero.toSMulWithZero.{u2, u3} γ α (Semiring.toMonoidWithZero.{u2} γ (DivisionSemiring.toSemiring.{u2} γ _inst_2)) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (Module.toMulActionWithZero.{u2, u3} γ α (DivisionSemiring.toSemiring.{u2} γ _inst_2) _inst_1 _inst_3))))) a c))
Case conversion may be inaccurate. Consider using '#align function.periodic.const_inv_smul₀ Function.Periodic.const_inv_smul₀ₓ'. -/
theorem Periodic.const_inv_smul₀ [AddCommMonoid α] [DivisionRing γ] [Module γ α] (h : Periodic f c)
    (a : γ) : Periodic (fun x => f (a⁻¹ • x)) (a • c) := by
  simpa only [inv_inv] using h.const_smul₀ a⁻¹
#align function.periodic.const_inv_smul₀ Function.Periodic.const_inv_smul₀

/- warning: function.periodic.const_inv_mul -> Function.Periodic.const_inv_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) f c) -> (forall (a : α), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) (fun (x : α) => f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1)) a) x)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) a c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) f c) -> (forall (a : α), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) (fun (x : α) => f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) (Inv.inv.{u2} α (DivisionSemiring.toInv.{u2} α _inst_1) a) x)) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) a c))
Case conversion may be inaccurate. Consider using '#align function.periodic.const_inv_mul Function.Periodic.const_inv_mulₓ'. -/
theorem Periodic.const_inv_mul [DivisionRing α] (h : Periodic f c) (a : α) :
    Periodic (fun x => f (a⁻¹ * x)) (a * c) :=
  h.const_inv_smul₀ a
#align function.periodic.const_inv_mul Function.Periodic.const_inv_mul

/- warning: function.periodic.mul_const -> Function.Periodic.mul_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) f c) -> (forall (a : α), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) (fun (x : α) => f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) x a)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) c (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1)) a)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) f c) -> (forall (a : α), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) (fun (x : α) => f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) x a)) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) c (Inv.inv.{u2} α (DivisionSemiring.toInv.{u2} α _inst_1) a)))
Case conversion may be inaccurate. Consider using '#align function.periodic.mul_const Function.Periodic.mul_constₓ'. -/
theorem Periodic.mul_const [DivisionRing α] (h : Periodic f c) (a : α) :
    Periodic (fun x => f (x * a)) (c * a⁻¹) :=
  h.const_smul₀ <| MulOpposite.op a
#align function.periodic.mul_const Function.Periodic.mul_const

/- warning: function.periodic.mul_const' -> Function.Periodic.mul_const' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) f c) -> (forall (a : α), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) (fun (x : α) => f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) x a)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1))) c a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) f c) -> (forall (a : α), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) (fun (x : α) => f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) x a)) (HDiv.hDiv.{u2, u2, u2} α α α (instHDiv.{u2} α (DivisionSemiring.toDiv.{u2} α _inst_1)) c a))
Case conversion may be inaccurate. Consider using '#align function.periodic.mul_const' Function.Periodic.mul_const'ₓ'. -/
theorem Periodic.mul_const' [DivisionRing α] (h : Periodic f c) (a : α) :
    Periodic (fun x => f (x * a)) (c / a) := by simpa only [div_eq_mul_inv] using h.mul_const a
#align function.periodic.mul_const' Function.Periodic.mul_const'

/- warning: function.periodic.mul_const_inv -> Function.Periodic.mul_const_inv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) f c) -> (forall (a : α), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) (fun (x : α) => f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) x (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1)) a))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) c a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) f c) -> (forall (a : α), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) (fun (x : α) => f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) x (Inv.inv.{u2} α (DivisionSemiring.toInv.{u2} α _inst_1) a))) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) c a))
Case conversion may be inaccurate. Consider using '#align function.periodic.mul_const_inv Function.Periodic.mul_const_invₓ'. -/
theorem Periodic.mul_const_inv [DivisionRing α] (h : Periodic f c) (a : α) :
    Periodic (fun x => f (x * a⁻¹)) (c * a) :=
  h.const_inv_smul₀ <| MulOpposite.op a
#align function.periodic.mul_const_inv Function.Periodic.mul_const_inv

/- warning: function.periodic.div_const -> Function.Periodic.div_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) f c) -> (forall (a : α), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) (fun (x : α) => f (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1))) x a)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) c a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) f c) -> (forall (a : α), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) (fun (x : α) => f (HDiv.hDiv.{u2, u2, u2} α α α (instHDiv.{u2} α (DivisionSemiring.toDiv.{u2} α _inst_1)) x a)) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) c a))
Case conversion may be inaccurate. Consider using '#align function.periodic.div_const Function.Periodic.div_constₓ'. -/
theorem Periodic.div_const [DivisionRing α] (h : Periodic f c) (a : α) :
    Periodic (fun x => f (x / a)) (c * a) := by simpa only [div_eq_mul_inv] using h.mul_const_inv a
#align function.periodic.div_const Function.Periodic.div_const

/- warning: function.periodic.add_period -> Function.Periodic.add_period is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddSemigroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α _inst_1) f c₁) -> (Function.Periodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α _inst_1) f c₂) -> (Function.Periodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α _inst_1) f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α _inst_1)) c₁ c₂))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddSemigroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α _inst_1) f c₁) -> (Function.Periodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α _inst_1) f c₂) -> (Function.Periodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α _inst_1) f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddSemigroup.toAdd.{u2} α _inst_1)) c₁ c₂))
Case conversion may be inaccurate. Consider using '#align function.periodic.add_period Function.Periodic.add_periodₓ'. -/
theorem Periodic.add_period [AddSemigroup α] (h1 : Periodic f c₁) (h2 : Periodic f c₂) :
    Periodic f (c₁ + c₂) := by simp_all [← add_assoc]
#align function.periodic.add_period Function.Periodic.add_period

/- warning: function.periodic.sub_eq -> Function.Periodic.sub_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) -> (forall (x : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) x c)) (f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c) -> (forall (x : α), Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) x c)) (f x))
Case conversion may be inaccurate. Consider using '#align function.periodic.sub_eq Function.Periodic.sub_eqₓ'. -/
theorem Periodic.sub_eq [AddGroup α] (h : Periodic f c) (x : α) : f (x - c) = f x := by
  simpa only [sub_add_cancel] using (h (x - c)).symm
#align function.periodic.sub_eq Function.Periodic.sub_eq

/- warning: function.periodic.sub_eq' -> Function.Periodic.sub_eq' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddCommGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) f c) -> (Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)))) c x)) (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))) x)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddCommGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) f c) -> (Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)))) c x)) (f (Neg.neg.{u2} α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (SubtractionCommMonoid.toSubtractionMonoid.{u2} α (AddCommGroup.toDivisionAddCommMonoid.{u2} α _inst_1))))) x)))
Case conversion may be inaccurate. Consider using '#align function.periodic.sub_eq' Function.Periodic.sub_eq'ₓ'. -/
theorem Periodic.sub_eq' [AddCommGroup α] (h : Periodic f c) : f (c - x) = f (-x) := by
  simpa only [sub_eq_neg_add] using h (-x)
#align function.periodic.sub_eq' Function.Periodic.sub_eq'

/- warning: function.periodic.neg -> Function.Periodic.neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) -> (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)) c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c) -> (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f (Neg.neg.{u2} α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) c))
Case conversion may be inaccurate. Consider using '#align function.periodic.neg Function.Periodic.negₓ'. -/
protected theorem Periodic.neg [AddGroup α] (h : Periodic f c) : Periodic f (-c) := by
  simpa only [sub_eq_add_neg, periodic] using h.sub_eq
#align function.periodic.neg Function.Periodic.neg

/- warning: function.periodic.sub_period -> Function.Periodic.sub_period is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c₁) -> (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c₂) -> (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) c₁ c₂))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c₁) -> (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c₂) -> (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) c₁ c₂))
Case conversion may be inaccurate. Consider using '#align function.periodic.sub_period Function.Periodic.sub_periodₓ'. -/
theorem Periodic.sub_period [AddGroup α] (h1 : Periodic f c₁) (h2 : Periodic f c₂) :
    Periodic f (c₁ - c₂) := by simpa only [sub_eq_add_neg] using h1.add_period h2.neg
#align function.periodic.sub_period Function.Periodic.sub_period

/- warning: function.periodic.const_add -> Function.Periodic.const_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddSemigroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α _inst_1) f c) -> (forall (a : α), Function.Periodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α _inst_1) (fun (x : α) => f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α _inst_1)) a x)) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddSemigroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α _inst_1) f c) -> (forall (a : α), Function.Periodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α _inst_1) (fun (x : α) => f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddSemigroup.toAdd.{u2} α _inst_1)) a x)) c)
Case conversion may be inaccurate. Consider using '#align function.periodic.const_add Function.Periodic.const_addₓ'. -/
theorem Periodic.const_add [AddSemigroup α] (h : Periodic f c) (a : α) :
    Periodic (fun x => f (a + x)) c := fun x => by simpa [add_assoc] using h (a + x)
#align function.periodic.const_add Function.Periodic.const_add

/- warning: function.periodic.add_const -> Function.Periodic.add_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddCommSemigroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) f c) -> (forall (a : α), Function.Periodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (fun (x : α) => f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x a)) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddCommSemigroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α (AddCommSemigroup.toAddSemigroup.{u2} α _inst_1)) f c) -> (forall (a : α), Function.Periodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α (AddCommSemigroup.toAddSemigroup.{u2} α _inst_1)) (fun (x : α) => f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddSemigroup.toAdd.{u2} α (AddCommSemigroup.toAddSemigroup.{u2} α _inst_1))) x a)) c)
Case conversion may be inaccurate. Consider using '#align function.periodic.add_const Function.Periodic.add_constₓ'. -/
theorem Periodic.add_const [AddCommSemigroup α] (h : Periodic f c) (a : α) :
    Periodic (fun x => f (x + a)) c := by simpa only [add_comm] using h.const_add a
#align function.periodic.add_const Function.Periodic.add_const

/- warning: function.periodic.const_sub -> Function.Periodic.const_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddCommGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) f c) -> (forall (a : α), Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) (fun (x : α) => f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)))) a x)) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddCommGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) f c) -> (forall (a : α), Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) (fun (x : α) => f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)))) a x)) c)
Case conversion may be inaccurate. Consider using '#align function.periodic.const_sub Function.Periodic.const_subₓ'. -/
theorem Periodic.const_sub [AddCommGroup α] (h : Periodic f c) (a : α) :
    Periodic (fun x => f (a - x)) c := fun x => by simp only [← sub_sub, h.sub_eq]
#align function.periodic.const_sub Function.Periodic.const_sub

/- warning: function.periodic.sub_const -> Function.Periodic.sub_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddCommGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) f c) -> (forall (a : α), Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) (fun (x : α) => f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)))) x a)) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddCommGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) f c) -> (forall (a : α), Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) (fun (x : α) => f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)))) x a)) c)
Case conversion may be inaccurate. Consider using '#align function.periodic.sub_const Function.Periodic.sub_constₓ'. -/
theorem Periodic.sub_const [AddCommGroup α] (h : Periodic f c) (a : α) :
    Periodic (fun x => f (x - a)) c := by simpa only [sub_eq_add_neg] using h.add_const (-a)
#align function.periodic.sub_const Function.Periodic.sub_const

/- warning: function.periodic.nsmul -> Function.Periodic.nsmul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) f c) -> (forall (n : Nat), Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α _inst_1) n c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_1)) f c) -> (forall (n : Nat), Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_1)) f (HSMul.hSMul.{0, u2, u2} Nat α α (instHSMul.{0, u2} Nat α (AddMonoid.SMul.{u2} α _inst_1)) n c))
Case conversion may be inaccurate. Consider using '#align function.periodic.nsmul Function.Periodic.nsmulₓ'. -/
theorem Periodic.nsmul [AddMonoid α] (h : Periodic f c) (n : ℕ) : Periodic f (n • c) := by
  induction n <;> simp_all [Nat.succ_eq_add_one, add_nsmul, ← add_assoc, zero_nsmul]
#align function.periodic.nsmul Function.Periodic.nsmul

/- warning: function.periodic.nat_mul -> Function.Periodic.nat_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) f c) -> (forall (n : Nat), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))))) n) c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) f c) -> (forall (n : Nat), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (Nat.cast.{u2} α (Semiring.toNatCast.{u2} α _inst_1) n) c))
Case conversion may be inaccurate. Consider using '#align function.periodic.nat_mul Function.Periodic.nat_mulₓ'. -/
theorem Periodic.nat_mul [Semiring α] (h : Periodic f c) (n : ℕ) : Periodic f (n * c) := by
  simpa only [nsmul_eq_mul] using h.nsmul n
#align function.periodic.nat_mul Function.Periodic.nat_mul

/- warning: function.periodic.neg_nsmul -> Function.Periodic.neg_nsmul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) -> (forall (n : Nat), Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) n c)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c) -> (forall (n : Nat), Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f (Neg.neg.{u2} α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) (HSMul.hSMul.{0, u2, u2} Nat α α (instHSMul.{0, u2} Nat α (AddMonoid.SMul.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) n c)))
Case conversion may be inaccurate. Consider using '#align function.periodic.neg_nsmul Function.Periodic.neg_nsmulₓ'. -/
theorem Periodic.neg_nsmul [AddGroup α] (h : Periodic f c) (n : ℕ) : Periodic f (-(n • c)) :=
  (h.nsmul n).neg
#align function.periodic.neg_nsmul Function.Periodic.neg_nsmul

/- warning: function.periodic.neg_nat_mul -> Function.Periodic.neg_nat_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Ring.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) f c) -> (forall (n : Nat), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))) n) c)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Ring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) f c) -> (forall (n : Nat), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) f (Neg.neg.{u2} α (Ring.toNeg.{u2} α _inst_1) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (Nat.cast.{u2} α (NonAssocRing.toNatCast.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) n) c)))
Case conversion may be inaccurate. Consider using '#align function.periodic.neg_nat_mul Function.Periodic.neg_nat_mulₓ'. -/
theorem Periodic.neg_nat_mul [Ring α] (h : Periodic f c) (n : ℕ) : Periodic f (-(n * c)) :=
  (h.nat_mul n).neg
#align function.periodic.neg_nat_mul Function.Periodic.neg_nat_mul

/- warning: function.periodic.sub_nsmul_eq -> Function.Periodic.sub_nsmul_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) -> (forall (n : Nat), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) x (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) n c))) (f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c) -> (forall (n : Nat), Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) x (HSMul.hSMul.{0, u2, u2} Nat α α (instHSMul.{0, u2} Nat α (AddMonoid.SMul.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) n c))) (f x))
Case conversion may be inaccurate. Consider using '#align function.periodic.sub_nsmul_eq Function.Periodic.sub_nsmul_eqₓ'. -/
theorem Periodic.sub_nsmul_eq [AddGroup α] (h : Periodic f c) (n : ℕ) : f (x - n • c) = f x := by
  simpa only [sub_eq_add_neg] using h.neg_nsmul n x
#align function.periodic.sub_nsmul_eq Function.Periodic.sub_nsmul_eq

/- warning: function.periodic.sub_nat_mul_eq -> Function.Periodic.sub_nat_mul_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} {x : α} [_inst_1 : Ring.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) f c) -> (forall (n : Nat), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) x (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))) n) c))) (f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} {x : α} [_inst_1 : Ring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) f c) -> (forall (n : Nat), Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (Ring.toSub.{u2} α _inst_1)) x (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (Nat.cast.{u2} α (NonAssocRing.toNatCast.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) n) c))) (f x))
Case conversion may be inaccurate. Consider using '#align function.periodic.sub_nat_mul_eq Function.Periodic.sub_nat_mul_eqₓ'. -/
theorem Periodic.sub_nat_mul_eq [Ring α] (h : Periodic f c) (n : ℕ) : f (x - n * c) = f x := by
  simpa only [nsmul_eq_mul] using h.sub_nsmul_eq n
#align function.periodic.sub_nat_mul_eq Function.Periodic.sub_nat_mul_eq

/- warning: function.periodic.nsmul_sub_eq -> Function.Periodic.nsmul_sub_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddCommGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) f c) -> (forall (n : Nat), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)))) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)))) n c) x)) (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))) x)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddCommGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) f c) -> (forall (n : Nat), Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)))) (HSMul.hSMul.{0, u2, u2} Nat α α (instHSMul.{0, u2} Nat α (AddMonoid.SMul.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) n c) x)) (f (Neg.neg.{u2} α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (SubtractionCommMonoid.toSubtractionMonoid.{u2} α (AddCommGroup.toDivisionAddCommMonoid.{u2} α _inst_1))))) x)))
Case conversion may be inaccurate. Consider using '#align function.periodic.nsmul_sub_eq Function.Periodic.nsmul_sub_eqₓ'. -/
theorem Periodic.nsmul_sub_eq [AddCommGroup α] (h : Periodic f c) (n : ℕ) :
    f (n • c - x) = f (-x) :=
  (h.nsmul n).sub_eq'
#align function.periodic.nsmul_sub_eq Function.Periodic.nsmul_sub_eq

/- warning: function.periodic.nat_mul_sub_eq -> Function.Periodic.nat_mul_sub_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} {x : α} [_inst_1 : Ring.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) f c) -> (forall (n : Nat), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))) n) c) x)) (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) x)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} {x : α} [_inst_1 : Ring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) f c) -> (forall (n : Nat), Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (Ring.toSub.{u2} α _inst_1)) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (Nat.cast.{u2} α (NonAssocRing.toNatCast.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) n) c) x)) (f (Neg.neg.{u2} α (Ring.toNeg.{u2} α _inst_1) x)))
Case conversion may be inaccurate. Consider using '#align function.periodic.nat_mul_sub_eq Function.Periodic.nat_mul_sub_eqₓ'. -/
theorem Periodic.nat_mul_sub_eq [Ring α] (h : Periodic f c) (n : ℕ) : f (n * c - x) = f (-x) := by
  simpa only [sub_eq_neg_add] using h.nat_mul n (-x)
#align function.periodic.nat_mul_sub_eq Function.Periodic.nat_mul_sub_eq

/- warning: function.periodic.zsmul -> Function.Periodic.zsmul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) -> (forall (n : Int), Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)) n c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c) -> (forall (n : Int), Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f (HSMul.hSMul.{0, u2, u2} Int α α (instHSMul.{0, u2} Int α (SubNegMonoid.SMulInt.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) n c))
Case conversion may be inaccurate. Consider using '#align function.periodic.zsmul Function.Periodic.zsmulₓ'. -/
protected theorem Periodic.zsmul [AddGroup α] (h : Periodic f c) (n : ℤ) : Periodic f (n • c) :=
  by
  cases n
  · simpa only [Int.ofNat_eq_coe, coe_nat_zsmul] using h.nsmul n
  · simpa only [negSucc_zsmul] using (h.nsmul n.succ).neg
#align function.periodic.zsmul Function.Periodic.zsmul

/- warning: function.periodic.int_mul -> Function.Periodic.int_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Ring.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) f c) -> (forall (n : Int), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) n) c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Ring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) f c) -> (forall (n : Int), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (Int.cast.{u2} α (Ring.toIntCast.{u2} α _inst_1) n) c))
Case conversion may be inaccurate. Consider using '#align function.periodic.int_mul Function.Periodic.int_mulₓ'. -/
protected theorem Periodic.int_mul [Ring α] (h : Periodic f c) (n : ℤ) : Periodic f (n * c) := by
  simpa only [zsmul_eq_mul] using h.zsmul n
#align function.periodic.int_mul Function.Periodic.int_mul

/- warning: function.periodic.sub_zsmul_eq -> Function.Periodic.sub_zsmul_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) -> (forall (n : Int), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) x (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)) n c))) (f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c) -> (forall (n : Int), Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) x (HSMul.hSMul.{0, u2, u2} Int α α (instHSMul.{0, u2} Int α (SubNegMonoid.SMulInt.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) n c))) (f x))
Case conversion may be inaccurate. Consider using '#align function.periodic.sub_zsmul_eq Function.Periodic.sub_zsmul_eqₓ'. -/
theorem Periodic.sub_zsmul_eq [AddGroup α] (h : Periodic f c) (n : ℤ) : f (x - n • c) = f x :=
  (h.zsmul n).sub_eq x
#align function.periodic.sub_zsmul_eq Function.Periodic.sub_zsmul_eq

/- warning: function.periodic.sub_int_mul_eq -> Function.Periodic.sub_int_mul_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} {x : α} [_inst_1 : Ring.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) f c) -> (forall (n : Int), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) x (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) n) c))) (f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} {x : α} [_inst_1 : Ring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) f c) -> (forall (n : Int), Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (Ring.toSub.{u2} α _inst_1)) x (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (Int.cast.{u2} α (Ring.toIntCast.{u2} α _inst_1) n) c))) (f x))
Case conversion may be inaccurate. Consider using '#align function.periodic.sub_int_mul_eq Function.Periodic.sub_int_mul_eqₓ'. -/
theorem Periodic.sub_int_mul_eq [Ring α] (h : Periodic f c) (n : ℤ) : f (x - n * c) = f x :=
  (h.int_mul n).sub_eq x
#align function.periodic.sub_int_mul_eq Function.Periodic.sub_int_mul_eq

/- warning: function.periodic.zsmul_sub_eq -> Function.Periodic.zsmul_sub_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddCommGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) f c) -> (forall (n : Int), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)))) (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))) n c) x)) (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))) x)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddCommGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) f c) -> (forall (n : Int), Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)))) (HSMul.hSMul.{0, u2, u2} Int α α (instHSMul.{0, u2} Int α (SubNegMonoid.SMulInt.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)))) n c) x)) (f (Neg.neg.{u2} α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (SubtractionCommMonoid.toSubtractionMonoid.{u2} α (AddCommGroup.toDivisionAddCommMonoid.{u2} α _inst_1))))) x)))
Case conversion may be inaccurate. Consider using '#align function.periodic.zsmul_sub_eq Function.Periodic.zsmul_sub_eqₓ'. -/
theorem Periodic.zsmul_sub_eq [AddCommGroup α] (h : Periodic f c) (n : ℤ) :
    f (n • c - x) = f (-x) :=
  (h.zsmul _).sub_eq'
#align function.periodic.zsmul_sub_eq Function.Periodic.zsmul_sub_eq

/- warning: function.periodic.int_mul_sub_eq -> Function.Periodic.int_mul_sub_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} {x : α} [_inst_1 : Ring.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) f c) -> (forall (n : Int), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) n) c) x)) (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))) x)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} {x : α} [_inst_1 : Ring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) f c) -> (forall (n : Int), Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (Ring.toSub.{u2} α _inst_1)) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (Int.cast.{u2} α (Ring.toIntCast.{u2} α _inst_1) n) c) x)) (f (Neg.neg.{u2} α (Ring.toNeg.{u2} α _inst_1) x)))
Case conversion may be inaccurate. Consider using '#align function.periodic.int_mul_sub_eq Function.Periodic.int_mul_sub_eqₓ'. -/
theorem Periodic.int_mul_sub_eq [Ring α] (h : Periodic f c) (n : ℤ) : f (n * c - x) = f (-x) :=
  (h.int_mul _).sub_eq'
#align function.periodic.int_mul_sub_eq Function.Periodic.int_mul_sub_eq

/- warning: function.periodic.eq -> Function.Periodic.eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddZeroClass.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α _inst_1) f c) -> (Eq.{succ u2} β (f c) (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α _inst_1))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddZeroClass.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α _inst_1) f c) -> (Eq.{succ u1} β (f c) (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (AddZeroClass.toZero.{u2} α _inst_1)))))
Case conversion may be inaccurate. Consider using '#align function.periodic.eq Function.Periodic.eqₓ'. -/
protected theorem Periodic.eq [AddZeroClass α] (h : Periodic f c) : f c = f 0 := by
  simpa only [zero_add] using h 0
#align function.periodic.eq Function.Periodic.eq

/- warning: function.periodic.neg_eq -> Function.Periodic.neg_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) -> (Eq.{succ u2} β (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)) c)) (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c) -> (Eq.{succ u1} β (f (Neg.neg.{u2} α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) c)) (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align function.periodic.neg_eq Function.Periodic.neg_eqₓ'. -/
protected theorem Periodic.neg_eq [AddGroup α] (h : Periodic f c) : f (-c) = f 0 :=
  h.neg.Eq
#align function.periodic.neg_eq Function.Periodic.neg_eq

/- warning: function.periodic.nsmul_eq -> Function.Periodic.nsmul_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) f c) -> (forall (n : Nat), Eq.{succ u2} β (f (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α _inst_1) n c)) (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α _inst_1)) f c) -> (forall (n : Nat), Eq.{succ u1} β (f (HSMul.hSMul.{0, u2, u2} Nat α α (instHSMul.{0, u2} Nat α (AddMonoid.SMul.{u2} α _inst_1)) n c)) (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (AddMonoid.toZero.{u2} α _inst_1)))))
Case conversion may be inaccurate. Consider using '#align function.periodic.nsmul_eq Function.Periodic.nsmul_eqₓ'. -/
protected theorem Periodic.nsmul_eq [AddMonoid α] (h : Periodic f c) (n : ℕ) : f (n • c) = f 0 :=
  (h.nsmul n).Eq
#align function.periodic.nsmul_eq Function.Periodic.nsmul_eq

/- warning: function.periodic.nat_mul_eq -> Function.Periodic.nat_mul_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) f c) -> (forall (n : Nat), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))))) n) c)) (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) f c) -> (forall (n : Nat), Eq.{succ u1} β (f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (Nat.cast.{u2} α (Semiring.toNatCast.{u2} α _inst_1) n) c)) (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align function.periodic.nat_mul_eq Function.Periodic.nat_mul_eqₓ'. -/
theorem Periodic.nat_mul_eq [Semiring α] (h : Periodic f c) (n : ℕ) : f (n * c) = f 0 :=
  (h.nat_mul n).Eq
#align function.periodic.nat_mul_eq Function.Periodic.nat_mul_eq

/- warning: function.periodic.zsmul_eq -> Function.Periodic.zsmul_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) -> (forall (n : Int), Eq.{succ u2} β (f (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)) n c)) (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c) -> (forall (n : Int), Eq.{succ u1} β (f (HSMul.hSMul.{0, u2, u2} Int α α (instHSMul.{0, u2} Int α (SubNegMonoid.SMulInt.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) n c)) (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align function.periodic.zsmul_eq Function.Periodic.zsmul_eqₓ'. -/
theorem Periodic.zsmul_eq [AddGroup α] (h : Periodic f c) (n : ℤ) : f (n • c) = f 0 :=
  (h.zsmul n).Eq
#align function.periodic.zsmul_eq Function.Periodic.zsmul_eq

/- warning: function.periodic.int_mul_eq -> Function.Periodic.int_mul_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Ring.{u1} α], (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) f c) -> (forall (n : Int), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) n) c)) (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Ring.{u2} α], (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) f c) -> (forall (n : Int), Eq.{succ u1} β (f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (Int.cast.{u2} α (Ring.toIntCast.{u2} α _inst_1) n) c)) (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align function.periodic.int_mul_eq Function.Periodic.int_mul_eqₓ'. -/
theorem Periodic.int_mul_eq [Ring α] (h : Periodic f c) (n : ℤ) : f (n * c) = f 0 :=
  (h.int_mul n).Eq
#align function.periodic.int_mul_eq Function.Periodic.int_mul_eq

/- warning: function.periodic.exists_mem_Ico₀ -> Function.Periodic.exists_mem_Ico₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] [_inst_2 : Archimedean.{u1} α (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} α (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) f c) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) c) -> (forall (x : α), Exists.{succ u1} α (fun (y : α) => Exists.{0} (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) y (Set.Ico.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) c)) (fun (H : Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) y (Set.Ico.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) c)) => Eq.{succ u2} β (f x) (f y))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : LinearOrderedAddCommGroup.{u2} α] [_inst_2 : Archimedean.{u2} α (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} α (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u2} α (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u2} α _inst_1)))], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))))))) f c) -> (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1)))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (SubtractionCommMonoid.toSubtractionMonoid.{u2} α (AddCommGroup.toDivisionAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))))))))) c) -> (forall (x : α), Exists.{succ u2} α (fun (y : α) => And (Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) y (Set.Ico.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (SubtractionCommMonoid.toSubtractionMonoid.{u2} α (AddCommGroup.toDivisionAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))))))))) c)) (Eq.{succ u1} β (f x) (f y))))
Case conversion may be inaccurate. Consider using '#align function.periodic.exists_mem_Ico₀ Function.Periodic.exists_mem_Ico₀ₓ'. -/
/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some
  `y ∈ Ico 0 c` such that `f x = f y`. -/
theorem Periodic.exists_mem_Ico₀ [LinearOrderedAddCommGroup α] [Archimedean α] (h : Periodic f c)
    (hc : 0 < c) (x) : ∃ y ∈ Set.Ico 0 c, f x = f y :=
  let ⟨n, H, _⟩ := existsUnique_zsmul_near_of_pos' hc x
  ⟨x - n • c, H, (h.sub_zsmul_eq n).symm⟩
#align function.periodic.exists_mem_Ico₀ Function.Periodic.exists_mem_Ico₀

/- warning: function.periodic.exists_mem_Ico -> Function.Periodic.exists_mem_Ico is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] [_inst_2 : Archimedean.{u1} α (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} α (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) f c) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) c) -> (forall (x : α) (a : α), Exists.{succ u1} α (fun (y : α) => Exists.{0} (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) y (Set.Ico.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) a c))) (fun (H : Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) y (Set.Ico.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) a c))) => Eq.{succ u2} β (f x) (f y))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : LinearOrderedAddCommGroup.{u2} α] [_inst_2 : Archimedean.{u2} α (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} α (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u2} α (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u2} α _inst_1)))], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))))))) f c) -> (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1)))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (SubtractionCommMonoid.toSubtractionMonoid.{u2} α (AddCommGroup.toDivisionAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))))))))) c) -> (forall (x : α) (a : α), Exists.{succ u2} α (fun (y : α) => And (Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) y (Set.Ico.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))) a (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1)))))))) a c))) (Eq.{succ u1} β (f x) (f y))))
Case conversion may be inaccurate. Consider using '#align function.periodic.exists_mem_Ico Function.Periodic.exists_mem_Icoₓ'. -/
/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some
  `y ∈ Ico a (a + c)` such that `f x = f y`. -/
theorem Periodic.exists_mem_Ico [LinearOrderedAddCommGroup α] [Archimedean α] (h : Periodic f c)
    (hc : 0 < c) (x a) : ∃ y ∈ Set.Ico a (a + c), f x = f y :=
  let ⟨n, H, _⟩ := existsUnique_add_zsmul_mem_Ico hc x a
  ⟨x + n • c, H, (h.zsmul n x).symm⟩
#align function.periodic.exists_mem_Ico Function.Periodic.exists_mem_Ico

/- warning: function.periodic.exists_mem_Ioc -> Function.Periodic.exists_mem_Ioc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] [_inst_2 : Archimedean.{u1} α (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} α (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) f c) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) c) -> (forall (x : α) (a : α), Exists.{succ u1} α (fun (y : α) => Exists.{0} (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) y (Set.Ioc.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) a c))) (fun (H : Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) y (Set.Ioc.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) a c))) => Eq.{succ u2} β (f x) (f y))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : LinearOrderedAddCommGroup.{u2} α] [_inst_2 : Archimedean.{u2} α (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} α (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u2} α (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u2} α _inst_1)))], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))))))) f c) -> (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1)))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (SubtractionCommMonoid.toSubtractionMonoid.{u2} α (AddCommGroup.toDivisionAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))))))))) c) -> (forall (x : α) (a : α), Exists.{succ u2} α (fun (y : α) => And (Membership.mem.{u2, u2} α (Set.{u2} α) (Set.instMembershipSet.{u2} α) y (Set.Ioc.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))) a (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1)))))))) a c))) (Eq.{succ u1} β (f x) (f y))))
Case conversion may be inaccurate. Consider using '#align function.periodic.exists_mem_Ioc Function.Periodic.exists_mem_Iocₓ'. -/
/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some
  `y ∈ Ioc a (a + c)` such that `f x = f y`. -/
theorem Periodic.exists_mem_Ioc [LinearOrderedAddCommGroup α] [Archimedean α] (h : Periodic f c)
    (hc : 0 < c) (x a) : ∃ y ∈ Set.Ioc a (a + c), f x = f y :=
  let ⟨n, H, _⟩ := existsUnique_add_zsmul_mem_Ioc hc x a
  ⟨x + n • c, H, (h.zsmul n x).symm⟩
#align function.periodic.exists_mem_Ioc Function.Periodic.exists_mem_Ioc

/- warning: function.periodic.image_Ioc -> Function.Periodic.image_Ioc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : LinearOrderedAddCommGroup.{u1} α] [_inst_2 : Archimedean.{u1} α (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} α (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))))))) f c) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))))) c) -> (forall (a : α), Eq.{succ u2} (Set.{u2} β) (Set.image.{u1, u2} α β f (Set.Ioc.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1))) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (OrderedAddCommGroup.toAddCommGroup.{u1} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} α _inst_1)))))))) a c))) (Set.range.{u2, succ u1} β α f))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : LinearOrderedAddCommGroup.{u2} α] [_inst_2 : Archimedean.{u2} α (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} α (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u2} α (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u2} α _inst_1)))], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))))))) f c) -> (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1)))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (SubtractionCommMonoid.toSubtractionMonoid.{u2} α (AddCommGroup.toDivisionAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))))))))) c) -> (forall (a : α), Eq.{succ u1} (Set.{u1} β) (Set.image.{u2, u1} α β f (Set.Ioc.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1))) a (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u2} α _inst_1)))))))) a c))) (Set.range.{u1, succ u2} β α f))
Case conversion may be inaccurate. Consider using '#align function.periodic.image_Ioc Function.Periodic.image_Iocₓ'. -/
theorem Periodic.image_Ioc [LinearOrderedAddCommGroup α] [Archimedean α] (h : Periodic f c)
    (hc : 0 < c) (a : α) : f '' Set.Ioc a (a + c) = Set.range f :=
  (Set.image_subset_range _ _).antisymm <|
    Set.range_subset_iff.2 fun x =>
      let ⟨y, hy, hyx⟩ := h.exists_mem_Ioc hc x a
      ⟨y, hy, hyx.symm⟩
#align function.periodic.image_Ioc Function.Periodic.image_Ioc

/- warning: function.periodic_with_period_zero -> Function.periodic_with_period_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : AddZeroClass.{u1} α] (f : α -> β), Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α _inst_1) f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α _inst_1))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : AddZeroClass.{u2} α] (f : α -> β), Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α _inst_1) f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (AddZeroClass.toZero.{u2} α _inst_1)))
Case conversion may be inaccurate. Consider using '#align function.periodic_with_period_zero Function.periodic_with_period_zeroₓ'. -/
theorem periodic_with_period_zero [AddZeroClass α] (f : α → β) : Periodic f 0 := fun x => by
  rw [add_zero]
#align function.periodic_with_period_zero Function.periodic_with_period_zero

/- warning: function.periodic.map_vadd_zmultiples -> Function.Periodic.map_vadd_zmultiples is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddCommGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) f c) -> (forall (a : coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)) α (AddSubgroup.setLike.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))) (AddSubgroup.zmultiples.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1) c)) (x : α), Eq.{succ u2} β (f (VAdd.vadd.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)) α (AddSubgroup.setLike.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))) (AddSubgroup.zmultiples.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1) c)) α (AddAction.toHasVadd.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)) α (AddSubgroup.setLike.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))) (AddSubgroup.zmultiples.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1) c)) α (SubNegMonoid.toAddMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)) α (AddSubgroup.setLike.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))) (AddSubgroup.zmultiples.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1) c)) (AddGroup.toSubNegMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (AddSubgroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubgroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)) α (AddSubgroup.setLike.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))) (AddSubgroup.zmultiples.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1) c)) (AddSubgroup.toAddGroup.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1) (AddSubgroup.zmultiples.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1) c)))) (AddSubgroup.addAction.{u1, u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1) α (AddMonoid.toAddAction.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)))) (AddSubgroup.zmultiples.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1) c))) a x)) (f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddCommGroup.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) f c) -> (forall (a : Subtype.{succ u2} α (fun (x : α) => Membership.mem.{u2, u2} α (AddSubgroup.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)) α (AddSubgroup.instSetLikeAddSubgroup.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))) x (AddSubgroup.zmultiples.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1) c))) (x : α), Eq.{succ u1} β (f (HVAdd.hVAdd.{u2, u2, u2} (Subtype.{succ u2} α (fun (x : α) => Membership.mem.{u2, u2} α (AddSubgroup.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)) α (AddSubgroup.instSetLikeAddSubgroup.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))) x (AddSubgroup.zmultiples.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1) c))) α α (instHVAdd.{u2, u2} (Subtype.{succ u2} α (fun (x : α) => Membership.mem.{u2, u2} α (AddSubgroup.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)) (SetLike.instMembership.{u2, u2} (AddSubgroup.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)) α (AddSubgroup.instSetLikeAddSubgroup.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))) x (AddSubgroup.zmultiples.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1) c))) α (AddSubmonoid.vadd.{u2, u2} α α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)))) (AddAction.toVAdd.{u2, u2} α α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))) (AddMonoid.toAddAction.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) (AddSubgroup.toAddSubmonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1) (AddSubgroup.zmultiples.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1) c)))) a x)) (f x))
Case conversion may be inaccurate. Consider using '#align function.periodic.map_vadd_zmultiples Function.Periodic.map_vadd_zmultiplesₓ'. -/
theorem Periodic.map_vadd_zmultiples [AddCommGroup α] (hf : Periodic f c)
    (a : AddSubgroup.zmultiples c) (x : α) : f (a +ᵥ x) = f x :=
  by
  rcases a with ⟨_, m, rfl⟩
  simp [AddSubgroup.vadd_def, add_comm _ x, hf.zsmul m x]
#align function.periodic.map_vadd_zmultiples Function.Periodic.map_vadd_zmultiples

/- warning: function.periodic.map_vadd_multiples -> Function.Periodic.map_vadd_multiples is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddCommMonoid.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) f c) -> (forall (a : coeSort.{succ u1, succ (succ u1)} (AddSubmonoid.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubmonoid.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) α (AddSubmonoid.setLike.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1)))) (AddSubmonoid.multiples.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1) c)) (x : α), Eq.{succ u2} β (f (VAdd.vadd.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (AddSubmonoid.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (AddSubmonoid.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) α (AddSubmonoid.setLike.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1)))) (AddSubmonoid.multiples.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1) c)) α (AddSubmonoid.hasVadd.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1)) (Add.toVAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1)))) (AddSubmonoid.multiples.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1) c)) a x)) (f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddCommMonoid.{u2} α], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1))) f c) -> (forall (a : Subtype.{succ u2} α (fun (x : α) => Membership.mem.{u2, u2} α (AddSubmonoid.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1))) α (AddSubmonoid.instSetLikeAddSubmonoid.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1)))) x (AddSubmonoid.multiples.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1) c))) (x : α), Eq.{succ u1} β (f (HVAdd.hVAdd.{u2, u2, u2} (Subtype.{succ u2} α (fun (x : α) => Membership.mem.{u2, u2} α (AddSubmonoid.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1))) α (AddSubmonoid.instSetLikeAddSubmonoid.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1)))) x (AddSubmonoid.multiples.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1) c))) α α (instHVAdd.{u2, u2} (Subtype.{succ u2} α (fun (x : α) => Membership.mem.{u2, u2} α (AddSubmonoid.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1))) (SetLike.instMembership.{u2, u2} (AddSubmonoid.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1))) α (AddSubmonoid.instSetLikeAddSubmonoid.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1)))) x (AddSubmonoid.multiples.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1) c))) α (AddSubmonoid.vadd.{u2, u2} α α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1)) (AddAction.toVAdd.{u2, u2} α α (AddCommMonoid.toAddMonoid.{u2} α _inst_1) (AddMonoid.toAddAction.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1))) (AddSubmonoid.multiples.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_1) c))) a x)) (f x))
Case conversion may be inaccurate. Consider using '#align function.periodic.map_vadd_multiples Function.Periodic.map_vadd_multiplesₓ'. -/
theorem Periodic.map_vadd_multiples [AddCommMonoid α] (hf : Periodic f c)
    (a : AddSubmonoid.multiples c) (x : α) : f (a +ᵥ x) = f x :=
  by
  rcases a with ⟨_, m, rfl⟩
  simp [AddSubmonoid.vadd_def, add_comm _ x, hf.nsmul m x]
#align function.periodic.map_vadd_multiples Function.Periodic.map_vadd_multiples

/- warning: function.periodic.lift -> Function.Periodic.lift is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) -> (HasQuotient.Quotient.{u1, u1} α (AddSubgroup.{u1} α _inst_1) (quotientAddGroup.Subgroup.hasQuotient.{u1} α _inst_1) (AddSubgroup.zmultiples.{u1} α _inst_1 c)) -> β
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α], (Function.Periodic.{u1, u2} α β (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) -> (HasQuotient.Quotient.{u1, u1} α (AddSubgroup.{u1} α _inst_1) (QuotientAddGroup.instHasQuotientAddSubgroup.{u1} α _inst_1) (AddSubgroup.zmultiples.{u1} α _inst_1 c)) -> β
Case conversion may be inaccurate. Consider using '#align function.periodic.lift Function.Periodic.liftₓ'. -/
/-- Lift a periodic function to a function from the quotient group. -/
def Periodic.lift [AddGroup α] (h : Periodic f c) (x : α ⧸ AddSubgroup.zmultiples c) : β :=
  Quotient.liftOn' x f fun a b h' =>
    by
    rw [QuotientAddGroup.leftRel_apply] at h'
    obtain ⟨k, hk⟩ := h'
    exact (h.zsmul k _).symm.trans (congr_arg f (add_eq_of_eq_neg_add hk))
#align function.periodic.lift Function.Periodic.lift

/- warning: function.periodic.lift_coe -> Function.Periodic.lift_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α] (h : Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c) (a : α), Eq.{succ u2} β (Function.Periodic.lift.{u1, u2} α β f c _inst_1 h ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) α (HasQuotient.Quotient.{u1, u1} α (AddSubgroup.{u1} α _inst_1) (quotientAddGroup.Subgroup.hasQuotient.{u1} α _inst_1) (AddSubgroup.zmultiples.{u1} α _inst_1 c)) (HasLiftT.mk.{succ u1, succ u1} α (HasQuotient.Quotient.{u1, u1} α (AddSubgroup.{u1} α _inst_1) (quotientAddGroup.Subgroup.hasQuotient.{u1} α _inst_1) (AddSubgroup.zmultiples.{u1} α _inst_1 c)) (CoeTCₓ.coe.{succ u1, succ u1} α (HasQuotient.Quotient.{u1, u1} α (AddSubgroup.{u1} α _inst_1) (quotientAddGroup.Subgroup.hasQuotient.{u1} α _inst_1) (AddSubgroup.zmultiples.{u1} α _inst_1 c)) (quotientAddGroup.HasQuotient.Quotient.hasCoeT.{u1} α _inst_1 (AddSubgroup.zmultiples.{u1} α _inst_1 c)))) a)) (f a)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u2} α] (h : Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c) (a : α), Eq.{succ u1} β (Function.Periodic.lift.{u2, u1} α β f c _inst_1 h (QuotientAddGroup.mk.{u2} α _inst_1 (AddSubgroup.zmultiples.{u2} α _inst_1 c) a)) (f a)
Case conversion may be inaccurate. Consider using '#align function.periodic.lift_coe Function.Periodic.lift_coeₓ'. -/
@[simp]
theorem Periodic.lift_coe [AddGroup α] (h : Periodic f c) (a : α) :
    h.lift (a : α ⧸ AddSubgroup.zmultiples c) = f a :=
  rfl
#align function.periodic.lift_coe Function.Periodic.lift_coe

/-! ### Antiperiodicity -/


#print Function.Antiperiodic /-
/-- A function `f` is said to be `antiperiodic` with antiperiod `c` if for all `x`,
  `f (x + c) = -f x`. -/
@[simp]
def Antiperiodic [Add α] [Neg β] (f : α → β) (c : α) : Prop :=
  ∀ x : α, f (x + c) = -f x
#align function.antiperiodic Function.Antiperiodic
-/

/- warning: function.antiperiodic.funext -> Function.Antiperiodic.funext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β _inst_1 _inst_2 f c) -> (Eq.{max (succ u1) (succ u2)} (α -> β) (fun (x : α) => f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α _inst_1) x c)) (Neg.neg.{max u1 u2} (α -> β) (Pi.instNeg.{u1, u2} α (fun (x : α) => β) (fun (i : α) => _inst_2)) f))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Add.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β _inst_1 _inst_2 f c) -> (Eq.{max (succ u2) (succ u1)} (α -> β) (fun (x : α) => f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α _inst_1) x c)) (Neg.neg.{max u2 u1} (α -> β) (Pi.instNeg.{u2, u1} α (fun (x : α) => β) (fun (i : α) => _inst_2)) f))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.funext Function.Antiperiodic.funextₓ'. -/
protected theorem Antiperiodic.funext [Add α] [Neg β] (h : Antiperiodic f c) :
    (fun x => f (x + c)) = -f :=
  funext h
#align function.antiperiodic.funext Function.Antiperiodic.funext

/- warning: function.antiperiodic.funext' -> Function.Antiperiodic.funext' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β _inst_1 (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c) -> (Eq.{max (succ u1) (succ u2)} (α -> β) (fun (x : α) => Neg.neg.{u2} β (InvolutiveNeg.toHasNeg.{u2} β _inst_2) (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α _inst_1) x c))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Add.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β _inst_1 (InvolutiveNeg.toNeg.{u1} β _inst_2) f c) -> (Eq.{max (succ u2) (succ u1)} (α -> β) (fun (x : α) => Neg.neg.{u1} β (InvolutiveNeg.toNeg.{u1} β _inst_2) (f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α _inst_1) x c))) f)
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.funext' Function.Antiperiodic.funext'ₓ'. -/
protected theorem Antiperiodic.funext' [Add α] [InvolutiveNeg β] (h : Antiperiodic f c) :
    (fun x => -f (x + c)) = f :=
  (eq_neg_iff_eq_neg.mp h.funext).symm
#align function.antiperiodic.funext' Function.Antiperiodic.funext'

/- warning: function.antiperiodic.periodic -> Function.Antiperiodic.periodic is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c) -> (Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))))))) c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c) -> (Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (OfNat.ofNat.{u2} α 2 (instOfNat.{u2} α 2 (Semiring.toNatCast.{u2} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) c))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.periodic Function.Antiperiodic.periodicₓ'. -/
/-- If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period
  `2 * c`. -/
protected theorem Antiperiodic.periodic [Semiring α] [InvolutiveNeg β] (h : Antiperiodic f c) :
    Periodic f (2 * c) := by simp [two_mul, ← add_assoc, h _]
#align function.antiperiodic.periodic Function.Antiperiodic.periodic

/- warning: function.antiperiodic.eq -> Function.Antiperiodic.eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddZeroClass.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α _inst_1) _inst_2 f c) -> (Eq.{succ u2} β (f c) (Neg.neg.{u2} β _inst_2 (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α _inst_1)))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddZeroClass.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α _inst_1) _inst_2 f c) -> (Eq.{succ u1} β (f c) (Neg.neg.{u1} β _inst_2 (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (AddZeroClass.toZero.{u2} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.eq Function.Antiperiodic.eqₓ'. -/
protected theorem Antiperiodic.eq [AddZeroClass α] [Neg β] (h : Antiperiodic f c) : f c = -f 0 := by
  simpa only [zero_add] using h 0
#align function.antiperiodic.eq Function.Antiperiodic.eq

/- warning: function.antiperiodic.nat_even_mul_periodic -> Function.Antiperiodic.nat_even_mul_periodic is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c) -> (forall (n : Nat), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))))) n) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))))))) c)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c) -> (forall (n : Nat), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (Nat.cast.{u2} α (Semiring.toNatCast.{u2} α _inst_1) n) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (OfNat.ofNat.{u2} α 2 (instOfNat.{u2} α 2 (Semiring.toNatCast.{u2} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) c)))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.nat_even_mul_periodic Function.Antiperiodic.nat_even_mul_periodicₓ'. -/
theorem Antiperiodic.nat_even_mul_periodic [Semiring α] [InvolutiveNeg β] (h : Antiperiodic f c)
    (n : ℕ) : Periodic f (n * (2 * c)) :=
  h.Periodic.nat_mul n
#align function.antiperiodic.nat_even_mul_periodic Function.Antiperiodic.nat_even_mul_periodic

/- warning: function.antiperiodic.nat_odd_mul_antiperiodic -> Function.Antiperiodic.nat_odd_mul_antiperiodic is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c) -> (forall (n : Nat), Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))))) n) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))))))) c)) c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c) -> (forall (n : Nat), Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1))))) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (Nat.cast.{u2} α (Semiring.toNatCast.{u2} α _inst_1) n) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (OfNat.ofNat.{u2} α 2 (instOfNat.{u2} α 2 (Semiring.toNatCast.{u2} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) c)) c))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.nat_odd_mul_antiperiodic Function.Antiperiodic.nat_odd_mul_antiperiodicₓ'. -/
theorem Antiperiodic.nat_odd_mul_antiperiodic [Semiring α] [InvolutiveNeg β] (h : Antiperiodic f c)
    (n : ℕ) : Antiperiodic f (n * (2 * c) + c) := fun x => by
  rw [← add_assoc, h, h.periodic.nat_mul]
#align function.antiperiodic.nat_odd_mul_antiperiodic Function.Antiperiodic.nat_odd_mul_antiperiodic

/- warning: function.antiperiodic.int_even_mul_periodic -> Function.Antiperiodic.int_even_mul_periodic is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Ring.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c) -> (forall (n : Int), Function.Periodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) n) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))))) c)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Ring.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c) -> (forall (n : Int), Function.Periodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (Int.cast.{u2} α (Ring.toIntCast.{u2} α _inst_1) n) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (OfNat.ofNat.{u2} α 2 (instOfNat.{u2} α 2 (NonAssocRing.toNatCast.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) c)))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.int_even_mul_periodic Function.Antiperiodic.int_even_mul_periodicₓ'. -/
theorem Antiperiodic.int_even_mul_periodic [Ring α] [InvolutiveNeg β] (h : Antiperiodic f c)
    (n : ℤ) : Periodic f (n * (2 * c)) :=
  h.Periodic.int_mul n
#align function.antiperiodic.int_even_mul_periodic Function.Antiperiodic.int_even_mul_periodic

/- warning: function.antiperiodic.int_odd_mul_antiperiodic -> Function.Antiperiodic.int_odd_mul_antiperiodic is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Ring.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c) -> (forall (n : Int), Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) n) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))))) c)) c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Ring.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c) -> (forall (n : Int), Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))))) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (Int.cast.{u2} α (Ring.toIntCast.{u2} α _inst_1) n) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (OfNat.ofNat.{u2} α 2 (instOfNat.{u2} α 2 (NonAssocRing.toNatCast.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) c)) c))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.int_odd_mul_antiperiodic Function.Antiperiodic.int_odd_mul_antiperiodicₓ'. -/
theorem Antiperiodic.int_odd_mul_antiperiodic [Ring α] [InvolutiveNeg β] (h : Antiperiodic f c)
    (n : ℤ) : Antiperiodic f (n * (2 * c) + c) := fun x => by
  rw [← add_assoc, h, h.periodic.int_mul]
#align function.antiperiodic.int_odd_mul_antiperiodic Function.Antiperiodic.int_odd_mul_antiperiodic

/- warning: function.antiperiodic.sub_eq -> Function.Antiperiodic.sub_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c) -> (forall (x : α), Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) x c)) (Neg.neg.{u2} β (InvolutiveNeg.toHasNeg.{u2} β _inst_2) (f x)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c) -> (forall (x : α), Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) x c)) (Neg.neg.{u1} β (InvolutiveNeg.toNeg.{u1} β _inst_2) (f x)))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.sub_eq Function.Antiperiodic.sub_eqₓ'. -/
theorem Antiperiodic.sub_eq [AddGroup α] [InvolutiveNeg β] (h : Antiperiodic f c) (x : α) :
    f (x - c) = -f x := by simp only [eq_neg_iff_eq_neg.mp (h (x - c)), sub_add_cancel]
#align function.antiperiodic.sub_eq Function.Antiperiodic.sub_eq

/- warning: function.antiperiodic.sub_eq' -> Function.Antiperiodic.sub_eq' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddCommGroup.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) _inst_2 f c) -> (Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)))) c x)) (Neg.neg.{u2} β _inst_2 (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))) x))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} {x : α} [_inst_1 : AddCommGroup.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) _inst_2 f c) -> (Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)))) c x)) (Neg.neg.{u1} β _inst_2 (f (Neg.neg.{u2} α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (SubtractionCommMonoid.toSubtractionMonoid.{u2} α (AddCommGroup.toDivisionAddCommMonoid.{u2} α _inst_1))))) x))))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.sub_eq' Function.Antiperiodic.sub_eq'ₓ'. -/
theorem Antiperiodic.sub_eq' [AddCommGroup α] [Neg β] (h : Antiperiodic f c) :
    f (c - x) = -f (-x) := by simpa only [sub_eq_neg_add] using h (-x)
#align function.antiperiodic.sub_eq' Function.Antiperiodic.sub_eq'

/- warning: function.antiperiodic.neg -> Function.Antiperiodic.neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)) c))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c) -> (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f (Neg.neg.{u2} α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) c))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.neg Function.Antiperiodic.negₓ'. -/
protected theorem Antiperiodic.neg [AddGroup α] [InvolutiveNeg β] (h : Antiperiodic f c) :
    Antiperiodic f (-c) := by simpa only [sub_eq_add_neg, antiperiodic] using h.sub_eq
#align function.antiperiodic.neg Function.Antiperiodic.neg

/- warning: function.antiperiodic.neg_eq -> Function.Antiperiodic.neg_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c) -> (Eq.{succ u2} β (f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)) c)) (Neg.neg.{u2} β (InvolutiveNeg.toHasNeg.{u2} β _inst_2) (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))))))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddGroup.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c) -> (Eq.{succ u1} β (f (Neg.neg.{u2} α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) c)) (Neg.neg.{u1} β (InvolutiveNeg.toNeg.{u1} β _inst_2) (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.neg_eq Function.Antiperiodic.neg_eqₓ'. -/
theorem Antiperiodic.neg_eq [AddGroup α] [InvolutiveNeg β] (h : Antiperiodic f c) : f (-c) = -f 0 :=
  by simpa only [zero_add] using h.neg 0
#align function.antiperiodic.neg_eq Function.Antiperiodic.neg_eq

/- warning: function.antiperiodic.nat_mul_eq_of_eq_zero -> Function.Antiperiodic.nat_mul_eq_of_eq_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Ring.{u1} α] [_inst_2 : NegZeroClass.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) (NegZeroClass.toHasNeg.{u2} β _inst_2) f c) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (NegZeroClass.toHasZero.{u2} β _inst_2))))) -> (forall (n : Nat), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))) n) c)) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (NegZeroClass.toHasZero.{u2} β _inst_2)))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Semiring.{u2} α] [_inst_2 : NegZeroClass.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (NegZeroClass.toNeg.{u1} β _inst_2) f c) -> (Eq.{succ u1} β (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α _inst_1))))) (OfNat.ofNat.{u1} β 0 (Zero.toOfNat0.{u1} β (NegZeroClass.toZero.{u1} β _inst_2)))) -> (forall (n : Nat), Eq.{succ u1} β (f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (Nat.cast.{u2} α (Semiring.toNatCast.{u2} α _inst_1) n) c)) (OfNat.ofNat.{u1} β 0 (Zero.toOfNat0.{u1} β (NegZeroClass.toZero.{u1} β _inst_2))))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.nat_mul_eq_of_eq_zero Function.Antiperiodic.nat_mul_eq_of_eq_zeroₓ'. -/
theorem Antiperiodic.nat_mul_eq_of_eq_zero [Ring α] [NegZeroClass β] (h : Antiperiodic f c)
    (hi : f 0 = 0) : ∀ n : ℕ, f (n * c) = 0
  | 0 => by rwa [Nat.cast_zero, zero_mul]
  | n + 1 => by simp [add_mul, antiperiodic.nat_mul_eq_of_eq_zero n, h _]
#align function.antiperiodic.nat_mul_eq_of_eq_zero Function.Antiperiodic.nat_mul_eq_of_eq_zero

/- warning: function.antiperiodic.int_mul_eq_of_eq_zero -> Function.Antiperiodic.int_mul_eq_of_eq_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Ring.{u1} α] [_inst_2 : SubtractionMonoid.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α _inst_1)) (SubNegMonoid.toHasNeg.{u2} β (SubtractionMonoid.toSubNegMonoid.{u2} β _inst_2)) f c) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (SubtractionMonoid.toSubNegMonoid.{u2} β _inst_2)))))))) -> (forall (n : Int), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α _inst_1))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1)))))) n) c)) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (SubtractionMonoid.toSubNegMonoid.{u2} β _inst_2))))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : Ring.{u2} α] [_inst_2 : SubtractionMonoid.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))))) (NegZeroClass.toNeg.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β _inst_2))) f c) -> (Eq.{succ u1} β (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α _inst_1)))))) (OfNat.ofNat.{u1} β 0 (Zero.toOfNat0.{u1} β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β _inst_2)))))) -> (forall (n : Int), Eq.{succ u1} β (f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (Int.cast.{u2} α (Ring.toIntCast.{u2} α _inst_1) n) c)) (OfNat.ofNat.{u1} β 0 (Zero.toOfNat0.{u1} β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β _inst_2))))))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.int_mul_eq_of_eq_zero Function.Antiperiodic.int_mul_eq_of_eq_zeroₓ'. -/
theorem Antiperiodic.int_mul_eq_of_eq_zero [Ring α] [SubtractionMonoid β] (h : Antiperiodic f c)
    (hi : f 0 = 0) : ∀ n : ℤ, f (n * c) = 0
  | (n : ℕ) => by rwa [Int.cast_ofNat, h.nat_mul_eq_of_eq_zero]
  | -[n+1] => by rw [Int.cast_negSucc, neg_mul, ← mul_neg, h.neg.nat_mul_eq_of_eq_zero hi]
#align function.antiperiodic.int_mul_eq_of_eq_zero Function.Antiperiodic.int_mul_eq_of_eq_zero

/- warning: function.antiperiodic.const_add -> Function.Antiperiodic.const_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddSemigroup.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α _inst_1) _inst_2 f c) -> (forall (a : α), Function.Antiperiodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α _inst_1) _inst_2 (fun (x : α) => f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α _inst_1)) a x)) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddSemigroup.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α _inst_1) _inst_2 f c) -> (forall (a : α), Function.Antiperiodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α _inst_1) _inst_2 (fun (x : α) => f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddSemigroup.toAdd.{u2} α _inst_1)) a x)) c)
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.const_add Function.Antiperiodic.const_addₓ'. -/
theorem Antiperiodic.const_add [AddSemigroup α] [Neg β] (h : Antiperiodic f c) (a : α) :
    Antiperiodic (fun x => f (a + x)) c := fun x => by simpa [add_assoc] using h (a + x)
#align function.antiperiodic.const_add Function.Antiperiodic.const_add

/- warning: function.antiperiodic.add_const -> Function.Antiperiodic.add_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_2 f c) -> (forall (a : α), Function.Antiperiodic.{u1, u2} α β (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_2 (fun (x : α) => f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x a)) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddCommSemigroup.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α (AddCommSemigroup.toAddSemigroup.{u2} α _inst_1)) _inst_2 f c) -> (forall (a : α), Function.Antiperiodic.{u2, u1} α β (AddSemigroup.toAdd.{u2} α (AddCommSemigroup.toAddSemigroup.{u2} α _inst_1)) _inst_2 (fun (x : α) => f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddSemigroup.toAdd.{u2} α (AddCommSemigroup.toAddSemigroup.{u2} α _inst_1))) x a)) c)
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.add_const Function.Antiperiodic.add_constₓ'. -/
theorem Antiperiodic.add_const [AddCommSemigroup α] [Neg β] (h : Antiperiodic f c) (a : α) :
    Antiperiodic (fun x => f (x + a)) c := fun x => by simpa only [add_right_comm] using h (x + a)
#align function.antiperiodic.add_const Function.Antiperiodic.add_const

/- warning: function.antiperiodic.const_sub -> Function.Antiperiodic.const_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddCommGroup.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c) -> (forall (a : α), Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) (fun (x : α) => f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)))) a x)) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddCommGroup.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c) -> (forall (a : α), Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) (InvolutiveNeg.toNeg.{u1} β _inst_2) (fun (x : α) => f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)))) a x)) c)
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.const_sub Function.Antiperiodic.const_subₓ'. -/
theorem Antiperiodic.const_sub [AddCommGroup α] [InvolutiveNeg β] (h : Antiperiodic f c) (a : α) :
    Antiperiodic (fun x => f (a - x)) c := fun x => by simp only [← sub_sub, h.sub_eq]
#align function.antiperiodic.const_sub Function.Antiperiodic.const_sub

/- warning: function.antiperiodic.sub_const -> Function.Antiperiodic.sub_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : AddCommGroup.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) _inst_2 f c) -> (forall (a : α), Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1))))) _inst_2 (fun (x : α) => f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α _inst_1)))) x a)) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddCommGroup.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) _inst_2 f c) -> (forall (a : α), Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1))))) _inst_2 (fun (x : α) => f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α (AddCommGroup.toAddGroup.{u2} α _inst_1)))) x a)) c)
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.sub_const Function.Antiperiodic.sub_constₓ'. -/
theorem Antiperiodic.sub_const [AddCommGroup α] [Neg β] (h : Antiperiodic f c) (a : α) :
    Antiperiodic (fun x => f (x - a)) c := by simpa only [sub_eq_add_neg] using h.add_const (-a)
#align function.antiperiodic.sub_const Function.Antiperiodic.sub_const

/- warning: function.antiperiodic.smul -> Function.Antiperiodic.smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : Monoid.{u3} γ] [_inst_3 : AddGroup.{u2} β] [_inst_4 : DistribMulAction.{u3, u2} γ β _inst_2 (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_3))], (Function.Antiperiodic.{u1, u2} α β _inst_1 (SubNegMonoid.toHasNeg.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_3)) f c) -> (forall (a : γ), Function.Antiperiodic.{u1, u2} α β _inst_1 (SubNegMonoid.toHasNeg.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_3)) (SMul.smul.{u3, max u1 u2} γ (α -> β) (Function.hasSMul.{u1, u3, u2} α γ β (SMulZeroClass.toHasSmul.{u3, u2} γ β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_3)))) (DistribSMul.toSmulZeroClass.{u3, u2} γ β (AddMonoid.toAddZeroClass.{u2} β (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_3))) (DistribMulAction.toDistribSMul.{u3, u2} γ β _inst_2 (SubNegMonoid.toAddMonoid.{u2} β (AddGroup.toSubNegMonoid.{u2} β _inst_3)) _inst_4)))) a f) c)
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {γ : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : Add.{u3} α] [_inst_2 : Monoid.{u2} γ] [_inst_3 : AddGroup.{u1} β] [_inst_4 : DistribMulAction.{u2, u1} γ β _inst_2 (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_3))], (Function.Antiperiodic.{u3, u1} α β _inst_1 (NegZeroClass.toNeg.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (AddGroup.toSubtractionMonoid.{u1} β _inst_3)))) f c) -> (forall (a : γ), Function.Antiperiodic.{u3, u1} α β _inst_1 (NegZeroClass.toNeg.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (AddGroup.toSubtractionMonoid.{u1} β _inst_3)))) (HSMul.hSMul.{u2, max u3 u1, max u3 u1} γ (α -> β) (α -> β) (instHSMul.{u2, max u3 u1} γ (α -> β) (Pi.instSMul.{u3, u1, u2} α γ (fun (a._@.Mathlib.Algebra.Periodic._hyg.4682 : α) => β) (fun (i : α) => SMulZeroClass.toSMul.{u2, u1} γ β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (AddGroup.toSubtractionMonoid.{u1} β _inst_3)))) (DistribSMul.toSMulZeroClass.{u2, u1} γ β (AddMonoid.toAddZeroClass.{u1} β (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_3))) (DistribMulAction.toDistribSMul.{u2, u1} γ β _inst_2 (SubNegMonoid.toAddMonoid.{u1} β (AddGroup.toSubNegMonoid.{u1} β _inst_3)) _inst_4))))) a f) c)
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.smul Function.Antiperiodic.smulₓ'. -/
protected theorem Antiperiodic.smul [Add α] [Monoid γ] [AddGroup β] [DistribMulAction γ β]
    (h : Antiperiodic f c) (a : γ) : Antiperiodic (a • f) c := by simp_all
#align function.antiperiodic.smul Function.Antiperiodic.smul

/- warning: function.antiperiodic.const_smul -> Function.Antiperiodic.const_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u1} α] [_inst_2 : Neg.{u2} β] [_inst_3 : Group.{u3} γ] [_inst_4 : DistribMulAction.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_3)) _inst_1], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) _inst_2 f c) -> (forall (a : γ), Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) _inst_2 (fun (x : α) => f (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u1} γ α (AddMonoid.toAddZeroClass.{u1} α _inst_1) (DistribMulAction.toDistribSMul.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_3)) _inst_1 _inst_4))) a x)) (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u1} γ α (AddMonoid.toAddZeroClass.{u1} α _inst_1) (DistribMulAction.toDistribSMul.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_3)) _inst_1 _inst_4))) (Inv.inv.{u3} γ (DivInvMonoid.toHasInv.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_3)) a) c))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u3} α] [_inst_2 : Neg.{u2} β] [_inst_3 : Group.{u1} γ] [_inst_4 : DistribMulAction.{u1, u3} γ α (DivInvMonoid.toMonoid.{u1} γ (Group.toDivInvMonoid.{u1} γ _inst_3)) _inst_1], (Function.Antiperiodic.{u3, u2} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α _inst_1)) _inst_2 f c) -> (forall (a : γ), Function.Antiperiodic.{u3, u2} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α _inst_1)) _inst_2 (fun (x : α) => f (HSMul.hSMul.{u1, u3, u3} γ α α (instHSMul.{u1, u3} γ α (SMulZeroClass.toSMul.{u1, u3} γ α (AddMonoid.toZero.{u3} α _inst_1) (DistribSMul.toSMulZeroClass.{u1, u3} γ α (AddMonoid.toAddZeroClass.{u3} α _inst_1) (DistribMulAction.toDistribSMul.{u1, u3} γ α (DivInvMonoid.toMonoid.{u1} γ (Group.toDivInvMonoid.{u1} γ _inst_3)) _inst_1 _inst_4)))) a x)) (HSMul.hSMul.{u1, u3, u3} γ α α (instHSMul.{u1, u3} γ α (SMulZeroClass.toSMul.{u1, u3} γ α (AddMonoid.toZero.{u3} α _inst_1) (DistribSMul.toSMulZeroClass.{u1, u3} γ α (AddMonoid.toAddZeroClass.{u3} α _inst_1) (DistribMulAction.toDistribSMul.{u1, u3} γ α (DivInvMonoid.toMonoid.{u1} γ (Group.toDivInvMonoid.{u1} γ _inst_3)) _inst_1 _inst_4)))) (Inv.inv.{u1} γ (InvOneClass.toInv.{u1} γ (DivInvOneMonoid.toInvOneClass.{u1} γ (DivisionMonoid.toDivInvOneMonoid.{u1} γ (Group.toDivisionMonoid.{u1} γ _inst_3)))) a) c))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.const_smul Function.Antiperiodic.const_smulₓ'. -/
theorem Antiperiodic.const_smul [AddMonoid α] [Neg β] [Group γ] [DistribMulAction γ α]
    (h : Antiperiodic f c) (a : γ) : Antiperiodic (fun x => f (a • x)) (a⁻¹ • c) := fun x => by
  simpa only [smul_add, smul_inv_smul] using h (a • x)
#align function.antiperiodic.const_smul Function.Antiperiodic.const_smul

/- warning: function.antiperiodic.const_smul₀ -> Function.Antiperiodic.const_smul₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : AddCommMonoid.{u1} α] [_inst_2 : Neg.{u2} β] [_inst_3 : DivisionRing.{u3} γ] [_inst_4 : Module.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)) _inst_1], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) _inst_2 f c) -> (forall {a : γ}, (Ne.{succ u3} γ a (OfNat.ofNat.{u3} γ 0 (OfNat.mk.{u3} γ 0 (Zero.zero.{u3} γ (MulZeroClass.toHasZero.{u3} γ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} γ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} γ (NonAssocRing.toNonUnitalNonAssocRing.{u3} γ (Ring.toNonAssocRing.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)))))))))) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) _inst_2 (fun (x : α) => f (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (SMulWithZero.toSmulZeroClass.{u3, u1} γ α (MulZeroClass.toHasZero.{u3} γ (MulZeroOneClass.toMulZeroClass.{u3} γ (MonoidWithZero.toMulZeroOneClass.{u3} γ (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)))))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (MulActionWithZero.toSMulWithZero.{u3, u1} γ α (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (Module.toMulActionWithZero.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)) _inst_1 _inst_4)))) a x)) (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (SMulWithZero.toSmulZeroClass.{u3, u1} γ α (MulZeroClass.toHasZero.{u3} γ (MulZeroOneClass.toMulZeroClass.{u3} γ (MonoidWithZero.toMulZeroOneClass.{u3} γ (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)))))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (MulActionWithZero.toSMulWithZero.{u3, u1} γ α (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (Module.toMulActionWithZero.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)) _inst_1 _inst_4)))) (Inv.inv.{u3} γ (DivInvMonoid.toHasInv.{u3} γ (DivisionRing.toDivInvMonoid.{u3} γ _inst_3)) a) c)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddCommMonoid.{u3} α] [_inst_2 : Neg.{u2} β] [_inst_3 : DivisionSemiring.{u1} γ] [_inst_4 : Module.{u1, u3} γ α (DivisionSemiring.toSemiring.{u1} γ _inst_3) _inst_1], (Function.Antiperiodic.{u3, u2} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1))) _inst_2 f c) -> (forall {a : γ}, (Ne.{succ u1} γ a (OfNat.ofNat.{u1} γ 0 (Zero.toOfNat0.{u1} γ (MonoidWithZero.toZero.{u1} γ (Semiring.toMonoidWithZero.{u1} γ (DivisionSemiring.toSemiring.{u1} γ _inst_3)))))) -> (Function.Antiperiodic.{u3, u2} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1))) _inst_2 (fun (x : α) => f (HSMul.hSMul.{u1, u3, u3} γ α α (instHSMul.{u1, u3} γ α (SMulZeroClass.toSMul.{u1, u3} γ α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (SMulWithZero.toSMulZeroClass.{u1, u3} γ α (MonoidWithZero.toZero.{u1} γ (Semiring.toMonoidWithZero.{u1} γ (DivisionSemiring.toSemiring.{u1} γ _inst_3))) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (MulActionWithZero.toSMulWithZero.{u1, u3} γ α (Semiring.toMonoidWithZero.{u1} γ (DivisionSemiring.toSemiring.{u1} γ _inst_3)) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (Module.toMulActionWithZero.{u1, u3} γ α (DivisionSemiring.toSemiring.{u1} γ _inst_3) _inst_1 _inst_4))))) a x)) (HSMul.hSMul.{u1, u3, u3} γ α α (instHSMul.{u1, u3} γ α (SMulZeroClass.toSMul.{u1, u3} γ α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (SMulWithZero.toSMulZeroClass.{u1, u3} γ α (MonoidWithZero.toZero.{u1} γ (Semiring.toMonoidWithZero.{u1} γ (DivisionSemiring.toSemiring.{u1} γ _inst_3))) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (MulActionWithZero.toSMulWithZero.{u1, u3} γ α (Semiring.toMonoidWithZero.{u1} γ (DivisionSemiring.toSemiring.{u1} γ _inst_3)) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (Module.toMulActionWithZero.{u1, u3} γ α (DivisionSemiring.toSemiring.{u1} γ _inst_3) _inst_1 _inst_4))))) (Inv.inv.{u1} γ (DivisionSemiring.toInv.{u1} γ _inst_3) a) c)))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.const_smul₀ Function.Antiperiodic.const_smul₀ₓ'. -/
theorem Antiperiodic.const_smul₀ [AddCommMonoid α] [Neg β] [DivisionRing γ] [Module γ α]
    (h : Antiperiodic f c) {a : γ} (ha : a ≠ 0) : Antiperiodic (fun x => f (a • x)) (a⁻¹ • c) :=
  fun x => by simpa only [smul_add, smul_inv_smul₀ ha] using h (a • x)
#align function.antiperiodic.const_smul₀ Function.Antiperiodic.const_smul₀

/- warning: function.antiperiodic.const_mul -> Function.Antiperiodic.const_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))))))))) -> (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 (fun (x : α) => f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) a x)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1)) a) c)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1)))))) -> (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 (fun (x : α) => f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) a x)) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) (Inv.inv.{u2} α (DivisionSemiring.toInv.{u2} α _inst_1) a) c)))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.const_mul Function.Antiperiodic.const_mulₓ'. -/
theorem Antiperiodic.const_mul [DivisionRing α] [Neg β] (h : Antiperiodic f c) {a : α}
    (ha : a ≠ 0) : Antiperiodic (fun x => f (a * x)) (a⁻¹ * c) :=
  h.const_smul₀ ha
#align function.antiperiodic.const_mul Function.Antiperiodic.const_mul

/- warning: function.antiperiodic.const_inv_smul -> Function.Antiperiodic.const_inv_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u1} α] [_inst_2 : Neg.{u2} β] [_inst_3 : Group.{u3} γ] [_inst_4 : DistribMulAction.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_3)) _inst_1], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) _inst_2 f c) -> (forall (a : γ), Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) _inst_2 (fun (x : α) => f (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u1} γ α (AddMonoid.toAddZeroClass.{u1} α _inst_1) (DistribMulAction.toDistribSMul.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_3)) _inst_1 _inst_4))) (Inv.inv.{u3} γ (DivInvMonoid.toHasInv.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_3)) a) x)) (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_1)) (DistribSMul.toSmulZeroClass.{u3, u1} γ α (AddMonoid.toAddZeroClass.{u1} α _inst_1) (DistribMulAction.toDistribSMul.{u3, u1} γ α (DivInvMonoid.toMonoid.{u3} γ (Group.toDivInvMonoid.{u3} γ _inst_3)) _inst_1 _inst_4))) a c))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddMonoid.{u3} α] [_inst_2 : Neg.{u2} β] [_inst_3 : Group.{u1} γ] [_inst_4 : DistribMulAction.{u1, u3} γ α (DivInvMonoid.toMonoid.{u1} γ (Group.toDivInvMonoid.{u1} γ _inst_3)) _inst_1], (Function.Antiperiodic.{u3, u2} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α _inst_1)) _inst_2 f c) -> (forall (a : γ), Function.Antiperiodic.{u3, u2} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α _inst_1)) _inst_2 (fun (x : α) => f (HSMul.hSMul.{u1, u3, u3} γ α α (instHSMul.{u1, u3} γ α (SMulZeroClass.toSMul.{u1, u3} γ α (AddMonoid.toZero.{u3} α _inst_1) (DistribSMul.toSMulZeroClass.{u1, u3} γ α (AddMonoid.toAddZeroClass.{u3} α _inst_1) (DistribMulAction.toDistribSMul.{u1, u3} γ α (DivInvMonoid.toMonoid.{u1} γ (Group.toDivInvMonoid.{u1} γ _inst_3)) _inst_1 _inst_4)))) (Inv.inv.{u1} γ (InvOneClass.toInv.{u1} γ (DivInvOneMonoid.toInvOneClass.{u1} γ (DivisionMonoid.toDivInvOneMonoid.{u1} γ (Group.toDivisionMonoid.{u1} γ _inst_3)))) a) x)) (HSMul.hSMul.{u1, u3, u3} γ α α (instHSMul.{u1, u3} γ α (SMulZeroClass.toSMul.{u1, u3} γ α (AddMonoid.toZero.{u3} α _inst_1) (DistribSMul.toSMulZeroClass.{u1, u3} γ α (AddMonoid.toAddZeroClass.{u3} α _inst_1) (DistribMulAction.toDistribSMul.{u1, u3} γ α (DivInvMonoid.toMonoid.{u1} γ (Group.toDivInvMonoid.{u1} γ _inst_3)) _inst_1 _inst_4)))) a c))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.const_inv_smul Function.Antiperiodic.const_inv_smulₓ'. -/
theorem Antiperiodic.const_inv_smul [AddMonoid α] [Neg β] [Group γ] [DistribMulAction γ α]
    (h : Antiperiodic f c) (a : γ) : Antiperiodic (fun x => f (a⁻¹ • x)) (a • c) := by
  simpa only [inv_inv] using h.const_smul a⁻¹
#align function.antiperiodic.const_inv_smul Function.Antiperiodic.const_inv_smul

/- warning: function.antiperiodic.const_inv_smul₀ -> Function.Antiperiodic.const_inv_smul₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {f : α -> β} {c : α} [_inst_1 : AddCommMonoid.{u1} α] [_inst_2 : Neg.{u2} β] [_inst_3 : DivisionRing.{u3} γ] [_inst_4 : Module.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)) _inst_1], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) _inst_2 f c) -> (forall {a : γ}, (Ne.{succ u3} γ a (OfNat.ofNat.{u3} γ 0 (OfNat.mk.{u3} γ 0 (Zero.zero.{u3} γ (MulZeroClass.toHasZero.{u3} γ (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} γ (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} γ (NonAssocRing.toNonUnitalNonAssocRing.{u3} γ (Ring.toNonAssocRing.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)))))))))) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) _inst_2 (fun (x : α) => f (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (SMulWithZero.toSmulZeroClass.{u3, u1} γ α (MulZeroClass.toHasZero.{u3} γ (MulZeroOneClass.toMulZeroClass.{u3} γ (MonoidWithZero.toMulZeroOneClass.{u3} γ (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)))))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (MulActionWithZero.toSMulWithZero.{u3, u1} γ α (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (Module.toMulActionWithZero.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)) _inst_1 _inst_4)))) (Inv.inv.{u3} γ (DivInvMonoid.toHasInv.{u3} γ (DivisionRing.toDivInvMonoid.{u3} γ _inst_3)) a) x)) (SMul.smul.{u3, u1} γ α (SMulZeroClass.toHasSmul.{u3, u1} γ α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (SMulWithZero.toSmulZeroClass.{u3, u1} γ α (MulZeroClass.toHasZero.{u3} γ (MulZeroOneClass.toMulZeroClass.{u3} γ (MonoidWithZero.toMulZeroOneClass.{u3} γ (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)))))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (MulActionWithZero.toSMulWithZero.{u3, u1} γ α (Semiring.toMonoidWithZero.{u3} γ (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3))) (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_1))) (Module.toMulActionWithZero.{u3, u1} γ α (Ring.toSemiring.{u3} γ (DivisionRing.toRing.{u3} γ _inst_3)) _inst_1 _inst_4)))) a c)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : AddCommMonoid.{u3} α] [_inst_2 : Neg.{u2} β] [_inst_3 : DivisionSemiring.{u1} γ] [_inst_4 : Module.{u1, u3} γ α (DivisionSemiring.toSemiring.{u1} γ _inst_3) _inst_1], (Function.Antiperiodic.{u3, u2} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1))) _inst_2 f c) -> (forall {a : γ}, (Ne.{succ u1} γ a (OfNat.ofNat.{u1} γ 0 (Zero.toOfNat0.{u1} γ (MonoidWithZero.toZero.{u1} γ (Semiring.toMonoidWithZero.{u1} γ (DivisionSemiring.toSemiring.{u1} γ _inst_3)))))) -> (Function.Antiperiodic.{u3, u2} α β (AddZeroClass.toAdd.{u3} α (AddMonoid.toAddZeroClass.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1))) _inst_2 (fun (x : α) => f (HSMul.hSMul.{u1, u3, u3} γ α α (instHSMul.{u1, u3} γ α (SMulZeroClass.toSMul.{u1, u3} γ α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (SMulWithZero.toSMulZeroClass.{u1, u3} γ α (MonoidWithZero.toZero.{u1} γ (Semiring.toMonoidWithZero.{u1} γ (DivisionSemiring.toSemiring.{u1} γ _inst_3))) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (MulActionWithZero.toSMulWithZero.{u1, u3} γ α (Semiring.toMonoidWithZero.{u1} γ (DivisionSemiring.toSemiring.{u1} γ _inst_3)) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (Module.toMulActionWithZero.{u1, u3} γ α (DivisionSemiring.toSemiring.{u1} γ _inst_3) _inst_1 _inst_4))))) (Inv.inv.{u1} γ (DivisionSemiring.toInv.{u1} γ _inst_3) a) x)) (HSMul.hSMul.{u1, u3, u3} γ α α (instHSMul.{u1, u3} γ α (SMulZeroClass.toSMul.{u1, u3} γ α (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (SMulWithZero.toSMulZeroClass.{u1, u3} γ α (MonoidWithZero.toZero.{u1} γ (Semiring.toMonoidWithZero.{u1} γ (DivisionSemiring.toSemiring.{u1} γ _inst_3))) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (MulActionWithZero.toSMulWithZero.{u1, u3} γ α (Semiring.toMonoidWithZero.{u1} γ (DivisionSemiring.toSemiring.{u1} γ _inst_3)) (AddMonoid.toZero.{u3} α (AddCommMonoid.toAddMonoid.{u3} α _inst_1)) (Module.toMulActionWithZero.{u1, u3} γ α (DivisionSemiring.toSemiring.{u1} γ _inst_3) _inst_1 _inst_4))))) a c)))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.const_inv_smul₀ Function.Antiperiodic.const_inv_smul₀ₓ'. -/
theorem Antiperiodic.const_inv_smul₀ [AddCommMonoid α] [Neg β] [DivisionRing γ] [Module γ α]
    (h : Antiperiodic f c) {a : γ} (ha : a ≠ 0) : Antiperiodic (fun x => f (a⁻¹ • x)) (a • c) := by
  simpa only [inv_inv] using h.const_smul₀ (inv_ne_zero ha)
#align function.antiperiodic.const_inv_smul₀ Function.Antiperiodic.const_inv_smul₀

/- warning: function.antiperiodic.const_inv_mul -> Function.Antiperiodic.const_inv_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))))))))) -> (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 (fun (x : α) => f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1)) a) x)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) a c)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1)))))) -> (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 (fun (x : α) => f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) (Inv.inv.{u2} α (DivisionSemiring.toInv.{u2} α _inst_1) a) x)) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) a c)))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.const_inv_mul Function.Antiperiodic.const_inv_mulₓ'. -/
theorem Antiperiodic.const_inv_mul [DivisionRing α] [Neg β] (h : Antiperiodic f c) {a : α}
    (ha : a ≠ 0) : Antiperiodic (fun x => f (a⁻¹ * x)) (a * c) :=
  h.const_inv_smul₀ ha
#align function.antiperiodic.const_inv_mul Function.Antiperiodic.const_inv_mul

/- warning: function.antiperiodic.mul_const -> Function.Antiperiodic.mul_const is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))))))))) -> (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 (fun (x : α) => f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) x a)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) c (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1)) a))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1)))))) -> (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 (fun (x : α) => f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) x a)) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) c (Inv.inv.{u2} α (DivisionSemiring.toInv.{u2} α _inst_1) a))))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.mul_const Function.Antiperiodic.mul_constₓ'. -/
theorem Antiperiodic.mul_const [DivisionRing α] [Neg β] (h : Antiperiodic f c) {a : α}
    (ha : a ≠ 0) : Antiperiodic (fun x => f (x * a)) (c * a⁻¹) :=
  h.const_smul₀ <| (MulOpposite.op_ne_zero_iff a).mpr ha
#align function.antiperiodic.mul_const Function.Antiperiodic.mul_const

/- warning: function.antiperiodic.mul_const' -> Function.Antiperiodic.mul_const' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))))))))) -> (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 (fun (x : α) => f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) x a)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1))) c a)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1)))))) -> (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 (fun (x : α) => f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) x a)) (HDiv.hDiv.{u2, u2, u2} α α α (instHDiv.{u2} α (DivisionSemiring.toDiv.{u2} α _inst_1)) c a)))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.mul_const' Function.Antiperiodic.mul_const'ₓ'. -/
theorem Antiperiodic.mul_const' [DivisionRing α] [Neg β] (h : Antiperiodic f c) {a : α}
    (ha : a ≠ 0) : Antiperiodic (fun x => f (x * a)) (c / a) := by
  simpa only [div_eq_mul_inv] using h.mul_const ha
#align function.antiperiodic.mul_const' Function.Antiperiodic.mul_const'

/- warning: function.antiperiodic.mul_const_inv -> Function.Antiperiodic.mul_const_inv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))))))))) -> (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 (fun (x : α) => f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) x (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1)) a))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) c a)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1)))))) -> (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 (fun (x : α) => f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) x (Inv.inv.{u2} α (DivisionSemiring.toInv.{u2} α _inst_1) a))) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) c a)))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.mul_const_inv Function.Antiperiodic.mul_const_invₓ'. -/
theorem Antiperiodic.mul_const_inv [DivisionRing α] [Neg β] (h : Antiperiodic f c) {a : α}
    (ha : a ≠ 0) : Antiperiodic (fun x => f (x * a⁻¹)) (c * a) :=
  h.const_inv_smul₀ <| (MulOpposite.op_ne_zero_iff a).mpr ha
#align function.antiperiodic.mul_const_inv Function.Antiperiodic.mul_const_inv

/- warning: function.antiperiodic.div_inv -> Function.Antiperiodic.div_inv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c : α} [_inst_1 : DivisionRing.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))))))))) -> (Function.Antiperiodic.{u1, u2} α β (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) _inst_2 (fun (x : α) => f (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (DivisionRing.toDivInvMonoid.{u1} α _inst_1))) x a)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α _inst_1)))) c a)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c : α} [_inst_1 : DivisionSemiring.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 f c) -> (forall {a : α}, (Ne.{succ u2} α a (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1)))))) -> (Function.Antiperiodic.{u2, u1} α β (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) _inst_2 (fun (x : α) => f (HDiv.hDiv.{u2, u2, u2} α α α (instHDiv.{u2} α (DivisionSemiring.toDiv.{u2} α _inst_1)) x a)) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (DivisionSemiring.toSemiring.{u2} α _inst_1))))) c a)))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.div_inv Function.Antiperiodic.div_invₓ'. -/
protected theorem Antiperiodic.div_inv [DivisionRing α] [Neg β] (h : Antiperiodic f c) {a : α}
    (ha : a ≠ 0) : Antiperiodic (fun x => f (x / a)) (c * a) := by
  simpa only [div_eq_mul_inv] using h.mul_const_inv ha
#align function.antiperiodic.div_inv Function.Antiperiodic.div_inv

/- warning: function.antiperiodic.add -> Function.Antiperiodic.add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c₁) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c₂) -> (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))))) c₁ c₂))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c₁) -> (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c₂) -> (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))))) c₁ c₂))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.add Function.Antiperiodic.addₓ'. -/
protected theorem Antiperiodic.add [AddGroup α] [InvolutiveNeg β] (h1 : Antiperiodic f c₁)
    (h2 : Antiperiodic f c₂) : Periodic f (c₁ + c₂) := by simp_all [← add_assoc]
#align function.antiperiodic.add Function.Antiperiodic.add

/- warning: function.antiperiodic.sub -> Function.Antiperiodic.sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c₁) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c₂) -> (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) c₁ c₂))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c₁) -> (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c₂) -> (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) c₁ c₂))
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.sub Function.Antiperiodic.subₓ'. -/
protected theorem Antiperiodic.sub [AddGroup α] [InvolutiveNeg β] (h1 : Antiperiodic f c₁)
    (h2 : Antiperiodic f c₂) : Periodic f (c₁ - c₂) := by
  simpa only [sub_eq_add_neg] using h1.add h2.neg
#align function.antiperiodic.sub Function.Antiperiodic.sub

/- warning: function.periodic.add_antiperiod -> Function.Periodic.add_antiperiod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c₁) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) _inst_2 f c₂) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) _inst_2 f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))))) c₁ c₂))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c₁) -> (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) _inst_2 f c₂) -> (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) _inst_2 f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))))) c₁ c₂))
Case conversion may be inaccurate. Consider using '#align function.periodic.add_antiperiod Function.Periodic.add_antiperiodₓ'. -/
theorem Periodic.add_antiperiod [AddGroup α] [Neg β] (h1 : Periodic f c₁) (h2 : Antiperiodic f c₂) :
    Antiperiodic f (c₁ + c₂) := by simp_all [← add_assoc]
#align function.periodic.add_antiperiod Function.Periodic.add_antiperiod

/- warning: function.periodic.sub_antiperiod -> Function.Periodic.sub_antiperiod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c₁) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c₂) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) c₁ c₂))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c₁) -> (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c₂) -> (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) c₁ c₂))
Case conversion may be inaccurate. Consider using '#align function.periodic.sub_antiperiod Function.Periodic.sub_antiperiodₓ'. -/
theorem Periodic.sub_antiperiod [AddGroup α] [InvolutiveNeg β] (h1 : Periodic f c₁)
    (h2 : Antiperiodic f c₂) : Antiperiodic f (c₁ - c₂) := by
  simpa only [sub_eq_add_neg] using h1.add_antiperiod h2.neg
#align function.periodic.sub_antiperiod Function.Periodic.sub_antiperiod

/- warning: function.periodic.add_antiperiod_eq -> Function.Periodic.add_antiperiod_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u1} α] [_inst_2 : Neg.{u2} β], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c₁) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) _inst_2 f c₂) -> (Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))))) c₁ c₂)) (Neg.neg.{u2} β _inst_2 (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))))))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u2} α] [_inst_2 : Neg.{u1} β], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c₁) -> (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) _inst_2 f c₂) -> (Eq.{succ u1} β (f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))))) c₁ c₂)) (Neg.neg.{u1} β _inst_2 (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align function.periodic.add_antiperiod_eq Function.Periodic.add_antiperiod_eqₓ'. -/
theorem Periodic.add_antiperiod_eq [AddGroup α] [Neg β] (h1 : Periodic f c₁)
    (h2 : Antiperiodic f c₂) : f (c₁ + c₂) = -f 0 :=
  (h1.add_antiperiod h2).Eq
#align function.periodic.add_antiperiod_eq Function.Periodic.add_antiperiod_eq

/- warning: function.periodic.sub_antiperiod_eq -> Function.Periodic.sub_antiperiod_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u1} α] [_inst_2 : InvolutiveNeg.{u2} β], (Function.Periodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) f c₁) -> (Function.Antiperiodic.{u1, u2} α β (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (InvolutiveNeg.toHasNeg.{u2} β _inst_2) f c₂) -> (Eq.{succ u2} β (f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) c₁ c₂)) (Neg.neg.{u2} β (InvolutiveNeg.toHasNeg.{u2} β _inst_2) (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))))))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {c₁ : α} {c₂ : α} [_inst_1 : AddGroup.{u2} α] [_inst_2 : InvolutiveNeg.{u1} β], (Function.Periodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) f c₁) -> (Function.Antiperiodic.{u2, u1} α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (SubNegMonoid.toAddMonoid.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) (InvolutiveNeg.toNeg.{u1} β _inst_2) f c₂) -> (Eq.{succ u1} β (f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1))) c₁ c₂)) (Neg.neg.{u1} β (InvolutiveNeg.toNeg.{u1} β _inst_2) (f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align function.periodic.sub_antiperiod_eq Function.Periodic.sub_antiperiod_eqₓ'. -/
theorem Periodic.sub_antiperiod_eq [AddGroup α] [InvolutiveNeg β] (h1 : Periodic f c₁)
    (h2 : Antiperiodic f c₂) : f (c₁ - c₂) = -f 0 :=
  (h1.sub_antiperiod h2).Eq
#align function.periodic.sub_antiperiod_eq Function.Periodic.sub_antiperiod_eq

/- warning: function.antiperiodic.mul -> Function.Antiperiodic.mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {g : α -> β} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : Mul.{u2} β] [_inst_3 : HasDistribNeg.{u2} β _inst_2], (Function.Antiperiodic.{u1, u2} α β _inst_1 (InvolutiveNeg.toHasNeg.{u2} β (HasDistribNeg.toHasInvolutiveNeg.{u2} β _inst_2 _inst_3)) f c) -> (Function.Antiperiodic.{u1, u2} α β _inst_1 (InvolutiveNeg.toHasNeg.{u2} β (HasDistribNeg.toHasInvolutiveNeg.{u2} β _inst_2 _inst_3)) g c) -> (Function.Periodic.{u1, u2} α β _inst_1 (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHMul.{max u1 u2} (α -> β) (Pi.instMul.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_2))) f g) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {g : α -> β} {c : α} [_inst_1 : Add.{u2} α] [_inst_2 : Mul.{u1} β] [_inst_3 : HasDistribNeg.{u1} β _inst_2], (Function.Antiperiodic.{u2, u1} α β _inst_1 (InvolutiveNeg.toNeg.{u1} β (HasDistribNeg.toInvolutiveNeg.{u1} β _inst_2 _inst_3)) f c) -> (Function.Antiperiodic.{u2, u1} α β _inst_1 (InvolutiveNeg.toNeg.{u1} β (HasDistribNeg.toInvolutiveNeg.{u1} β _inst_2 _inst_3)) g c) -> (Function.Periodic.{u2, u1} α β _inst_1 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (α -> β) (α -> β) (α -> β) (instHMul.{max u2 u1} (α -> β) (Pi.instMul.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => _inst_2))) f g) c)
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.mul Function.Antiperiodic.mulₓ'. -/
protected theorem Antiperiodic.mul [Add α] [Mul β] [HasDistribNeg β] (hf : Antiperiodic f c)
    (hg : Antiperiodic g c) : Periodic (f * g) c := by simp_all
#align function.antiperiodic.mul Function.Antiperiodic.mul

/- warning: function.antiperiodic.div -> Function.Antiperiodic.div is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {f : α -> β} {g : α -> β} {c : α} [_inst_1 : Add.{u1} α] [_inst_2 : DivisionMonoid.{u2} β] [_inst_3 : HasDistribNeg.{u2} β (MulOneClass.toHasMul.{u2} β (Monoid.toMulOneClass.{u2} β (DivInvMonoid.toMonoid.{u2} β (DivisionMonoid.toDivInvMonoid.{u2} β _inst_2))))], (Function.Antiperiodic.{u1, u2} α β _inst_1 (InvolutiveNeg.toHasNeg.{u2} β (HasDistribNeg.toHasInvolutiveNeg.{u2} β (MulOneClass.toHasMul.{u2} β (Monoid.toMulOneClass.{u2} β (DivInvMonoid.toMonoid.{u2} β (DivisionMonoid.toDivInvMonoid.{u2} β _inst_2)))) _inst_3)) f c) -> (Function.Antiperiodic.{u1, u2} α β _inst_1 (InvolutiveNeg.toHasNeg.{u2} β (HasDistribNeg.toHasInvolutiveNeg.{u2} β (MulOneClass.toHasMul.{u2} β (Monoid.toMulOneClass.{u2} β (DivInvMonoid.toMonoid.{u2} β (DivisionMonoid.toDivInvMonoid.{u2} β _inst_2)))) _inst_3)) g c) -> (Function.Periodic.{u1, u2} α β _inst_1 (HDiv.hDiv.{max u1 u2, max u1 u2, max u1 u2} (α -> β) (α -> β) (α -> β) (instHDiv.{max u1 u2} (α -> β) (Pi.instDiv.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => DivInvMonoid.toHasDiv.{u2} β (DivisionMonoid.toDivInvMonoid.{u2} β _inst_2)))) f g) c)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {f : α -> β} {g : α -> β} {c : α} [_inst_1 : Add.{u2} α] [_inst_2 : DivisionMonoid.{u1} β] [_inst_3 : HasDistribNeg.{u1} β (MulOneClass.toMul.{u1} β (Monoid.toMulOneClass.{u1} β (DivInvMonoid.toMonoid.{u1} β (DivisionMonoid.toDivInvMonoid.{u1} β _inst_2))))], (Function.Antiperiodic.{u2, u1} α β _inst_1 (InvolutiveNeg.toNeg.{u1} β (HasDistribNeg.toInvolutiveNeg.{u1} β (MulOneClass.toMul.{u1} β (Monoid.toMulOneClass.{u1} β (DivInvMonoid.toMonoid.{u1} β (DivisionMonoid.toDivInvMonoid.{u1} β _inst_2)))) _inst_3)) f c) -> (Function.Antiperiodic.{u2, u1} α β _inst_1 (InvolutiveNeg.toNeg.{u1} β (HasDistribNeg.toInvolutiveNeg.{u1} β (MulOneClass.toMul.{u1} β (Monoid.toMulOneClass.{u1} β (DivInvMonoid.toMonoid.{u1} β (DivisionMonoid.toDivInvMonoid.{u1} β _inst_2)))) _inst_3)) g c) -> (Function.Periodic.{u2, u1} α β _inst_1 (HDiv.hDiv.{max u2 u1, max u2 u1, max u2 u1} (α -> β) (α -> β) (α -> β) (instHDiv.{max u2 u1} (α -> β) (Pi.instDiv.{u2, u1} α (fun (ᾰ : α) => β) (fun (i : α) => DivInvMonoid.toDiv.{u1} β (DivisionMonoid.toDivInvMonoid.{u1} β _inst_2)))) f g) c)
Case conversion may be inaccurate. Consider using '#align function.antiperiodic.div Function.Antiperiodic.divₓ'. -/
protected theorem Antiperiodic.div [Add α] [DivisionMonoid β] [HasDistribNeg β]
    (hf : Antiperiodic f c) (hg : Antiperiodic g c) : Periodic (f / g) c := by
  simp_all [neg_div_neg_eq]
#align function.antiperiodic.div Function.Antiperiodic.div

end Function

/- warning: int.fract_periodic -> Int.fract_periodic is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : LinearOrderedRing.{u1} α] [_inst_2 : FloorRing.{u1} α _inst_1], Function.Periodic.{u1, u1} α α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Int.fract.{u1} α _inst_1 _inst_2) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))))))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : LinearOrderedRing.{u1} α] [_inst_2 : FloorRing.{u1} α _inst_1], Function.Periodic.{u1, u1} α α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))))) (Int.fract.{u1} α _inst_1 _inst_2) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align int.fract_periodic Int.fract_periodicₓ'. -/
theorem Int.fract_periodic (α) [LinearOrderedRing α] [FloorRing α] :
    Function.Periodic Int.fract (1 : α) := by exact_mod_cast fun a => Int.fract_add_int a 1
#align int.fract_periodic Int.fract_periodic

