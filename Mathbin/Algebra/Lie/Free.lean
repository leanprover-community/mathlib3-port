import Mathbin.Algebra.Lie.OfAssociative 
import Mathbin.Algebra.Lie.NonUnitalNonAssocAlgebra 
import Mathbin.Algebra.Lie.UniversalEnveloping 
import Mathbin.Algebra.FreeNonUnitalNonAssocAlgebra

/-!
# Free Lie algebras

Given a commutative ring `R` and a type `X` we construct the free Lie algebra on `X` with
coefficients in `R` together with its universal property.

## Main definitions

  * `free_lie_algebra`
  * `free_lie_algebra.lift`
  * `free_lie_algebra.of`
  * `free_lie_algebra.universal_enveloping_equiv_free_algebra`

## Implementation details

### Quotient of free non-unital, non-associative algebra

We follow [N. Bourbaki, *Lie Groups and Lie Algebras, Chapters 1--3*](bourbaki1975) and construct
the free Lie algebra as a quotient of the free non-unital, non-associative algebra. Since we do not
currently have definitions of ideals, lattices of ideals, and quotients for
`non_unital_non_assoc_semiring`, we construct our quotient using the low-level `quot` function on
an inductively-defined relation.

### Alternative construction (needs PBW)

An alternative construction of the free Lie algebra on `X` is to start with the free unital
associative algebra on `X`, regard it as a Lie algebra via the ring commutator, and take its
smallest Lie subalgebra containing `X`. I.e.:
`lie_subalgebra.lie_span R (free_algebra R X) (set.range (free_algebra.ι R))`.

However with this definition there does not seem to be an easy proof that the required universal
property holds, and I don't know of a proof that avoids invoking the Poincaré–Birkhoff–Witt theorem.
A related MathOverflow question is [this one](https://mathoverflow.net/questions/396680/).

## Tags

lie algebra, free algebra, non-unital, non-associative, universal property, forgetful functor,
adjoint functor
-/


universe u v w

noncomputable theory

variable (R : Type u) (X : Type v) [CommRingₓ R]

local notation "lib" => FreeNonUnitalNonAssocAlgebra

local notation "lib.lift" => FreeNonUnitalNonAssocAlgebra.lift

local notation "lib.of" => FreeNonUnitalNonAssocAlgebra.of

local notation "lib.lift_of_apply" => FreeNonUnitalNonAssocAlgebra.lift_of_apply

local notation "lib.lift_comp_of" => FreeNonUnitalNonAssocAlgebra.lift_comp_of

namespace FreeLieAlgebra

/-- The quotient of `lib R X` by the equivalence relation generated by this relation will give us
the free Lie algebra. -/
inductive rel : lib R X → lib R X → Prop
  | lie_self (a : lib R X) : rel (a*a) 0
  | leibniz_lie (a b c : lib R X) : rel (a*b*c) (((a*b)*c)+b*a*c)
  | smul (t : R) (a b : lib R X) : rel a b → rel (t • a) (t • b)
  | add_right (a b c : lib R X) : rel a b → rel (a+c) (b+c)
  | mul_left (a b c : lib R X) : rel b c → rel (a*b) (a*c)
  | mul_right (a b c : lib R X) : rel a b → rel (a*c) (b*c)

variable {R X}

theorem rel.add_left (a b c : lib R X) (h : rel R X b c) : rel R X (a+b) (a+c) :=
  by 
    rw [add_commₓ _ b, add_commₓ _ c]
    exact rel.add_right _ _ _ h

theorem rel.neg (a b : lib R X) (h : rel R X a b) : rel R X (-a) (-b) :=
  h.smul (-1) _ _

end FreeLieAlgebra

-- error in Algebra.Lie.Free: ././Mathport/Syntax/Translate/Basic.lean:704:9: unsupported derive handler inhabited
/-- The free Lie algebra on the type `X` with coefficients in the commutative ring `R`. -/
@[derive #[expr inhabited]]
def free_lie_algebra :=
quot (free_lie_algebra.rel R X)

namespace FreeLieAlgebra

instance : AddCommGroupₓ (FreeLieAlgebra R X) :=
  { add := Quot.map₂ (·+·) rel.add_left rel.add_right,
    add_comm :=
      by 
        rintro ⟨a⟩ ⟨b⟩
        change Quot.mk _ _ = Quot.mk _ _ 
        rw [add_commₓ],
    add_assoc :=
      by 
        rintro ⟨a⟩ ⟨b⟩ ⟨c⟩
        change Quot.mk _ _ = Quot.mk _ _ 
        rw [add_assocₓ],
    zero := Quot.mk _ 0,
    zero_add :=
      by 
        rintro ⟨a⟩
        change Quot.mk _ _ = _ 
        rw [zero_addₓ],
    add_zero :=
      by 
        rintro ⟨a⟩
        change Quot.mk _ _ = _ 
        rw [add_zeroₓ],
    neg := Quot.map Neg.neg rel.neg,
    add_left_neg :=
      by 
        rintro ⟨a⟩
        change Quot.mk _ _ = Quot.mk _ _ 
        rw [add_left_negₓ] }

instance : Module R (FreeLieAlgebra R X) :=
  { smul := fun t => Quot.map ((· • ·) t) (rel.smul t),
    one_smul :=
      by 
        rintro ⟨a⟩
        change Quot.mk _ _ = Quot.mk _ _ 
        rw [one_smul],
    mul_smul :=
      by 
        rintro t₁ t₂ ⟨a⟩
        change Quot.mk _ _ = Quot.mk _ _ 
        rw [mul_smul],
    add_smul :=
      by 
        rintro t₁ t₂ ⟨a⟩
        change Quot.mk _ _ = Quot.mk _ _ 
        rw [add_smul],
    smul_add :=
      by 
        rintro t ⟨a⟩ ⟨b⟩
        change Quot.mk _ _ = Quot.mk _ _ 
        rw [smul_add],
    zero_smul :=
      by 
        rintro ⟨a⟩
        change Quot.mk _ _ = Quot.mk _ _ 
        rw [zero_smul],
    smul_zero :=
      fun t =>
        by 
          change Quot.mk _ _ = Quot.mk _ _ 
          rw [smul_zero] }

/-- Note that here we turn the `has_mul` coming from the `non_unital_non_assoc_semiring` structure
on `lib R X` into a `has_bracket` on `free_lie_algebra`. -/
instance : LieRing (FreeLieAlgebra R X) :=
  { bracket := Quot.map₂ (·*·) rel.mul_left rel.mul_right,
    add_lie :=
      by 
        rintro ⟨a⟩ ⟨b⟩ ⟨c⟩
        change Quot.mk _ _ = Quot.mk _ _ 
        rw [add_mulₓ],
    lie_add :=
      by 
        rintro ⟨a⟩ ⟨b⟩ ⟨c⟩
        change Quot.mk _ _ = Quot.mk _ _ 
        rw [mul_addₓ],
    lie_self :=
      by 
        rintro ⟨a⟩
        exact Quot.sound (rel.lie_self a),
    leibniz_lie :=
      by 
        rintro ⟨a⟩ ⟨b⟩ ⟨c⟩
        exact Quot.sound (rel.leibniz_lie a b c) }

instance : LieAlgebra R (FreeLieAlgebra R X) :=
  { lie_smul :=
      by 
        rintro t ⟨a⟩ ⟨c⟩
        change Quot.mk _ (a • t • c) = Quot.mk _ (t • a • c)
        rw [←smul_comm] }

variable {X}

/-- The embedding of `X` into the free Lie algebra of `X` with coefficients in the commutative ring
`R`. -/
def of : X → FreeLieAlgebra R X :=
  fun x => Quot.mk _ (lib.of R x)

variable {L : Type w} [LieRing L] [LieAlgebra R L]

attribute [local instance] LieRing.toNonUnitalNonAssocSemiring

/-- An auxiliary definition used to construct the equivalence `lift` below. -/
def lift_aux (f : X → L) :=
  lib.lift R f

theorem lift_aux_map_smul (f : X → L) (t : R) (a : lib R X) : lift_aux R f (t • a) = t • lift_aux R f a :=
  NonUnitalAlgHom.map_smul _ t a

theorem lift_aux_map_add (f : X → L) (a b : lib R X) : lift_aux R f (a+b) = lift_aux R f a+lift_aux R f b :=
  NonUnitalAlgHom.map_add _ a b

theorem lift_aux_map_mul (f : X → L) (a b : lib R X) : lift_aux R f (a*b) = ⁅lift_aux R f a,lift_aux R f b⁆ :=
  NonUnitalAlgHom.map_mul _ a b

theorem lift_aux_spec (f : X → L) (a b : lib R X) (h : FreeLieAlgebra.Rel R X a b) : lift_aux R f a = lift_aux R f b :=
  by 
    induction h 
    case rel.lie_self a' => 
      simp only [lift_aux_map_mul, NonUnitalAlgHom.map_zero, lie_self]
    case rel.leibniz_lie a' b' c' => 
      simp only [lift_aux_map_mul, lift_aux_map_add, sub_add_cancel, lie_lie]
    case rel.smul t a' b' h₁ h₂ => 
      simp only [lift_aux_map_smul, h₂]
    case rel.add_right a' b' c' h₁ h₂ => 
      simp only [lift_aux_map_add, h₂]
    case rel.mul_left a' b' c' h₁ h₂ => 
      simp only [lift_aux_map_mul, h₂]
    case rel.mul_right a' b' c' h₁ h₂ => 
      simp only [lift_aux_map_mul, h₂]

/-- The quotient map as a `non_unital_alg_hom`. -/
def mk : NonUnitalAlgHom R (lib R X) (FreeLieAlgebra R X) :=
  { toFun := Quot.mk (rel R X), map_smul' := fun t a => rfl, map_zero' := rfl, map_add' := fun a b => rfl,
    map_mul' := fun a b => rfl }

/-- The functor `X ↦ free_lie_algebra R X` from the category of types to the category of Lie
algebras over `R` is adjoint to the forgetful functor in the other direction. -/
def lift : (X → L) ≃ (FreeLieAlgebra R X →ₗ⁅R⁆ L) :=
  { toFun :=
      fun f =>
        { toFun := fun c => Quot.liftOn c (lift_aux R f) (lift_aux_spec R f),
          map_add' :=
            by 
              rintro ⟨a⟩ ⟨b⟩
              rw [←lift_aux_map_add]
              rfl,
          map_smul' :=
            by 
              rintro t ⟨a⟩
              rw [←lift_aux_map_smul]
              rfl,
          map_lie' :=
            by 
              rintro ⟨a⟩ ⟨b⟩
              rw [←lift_aux_map_mul]
              rfl },
    invFun := fun F => F ∘ of R,
    left_inv :=
      fun f =>
        by 
          ext x 
          simp only [lift_aux, of, Quot.lift_on_mk, LieHom.coe_mk, Function.comp_app, lib.lift_of_apply],
    right_inv :=
      fun F =>
        by 
          ext ⟨a⟩
          let F' := F.to_non_unital_alg_hom.comp (mk R)
          exact NonUnitalAlgHom.congr_fun (lib.lift_comp_of R F') a }

@[simp]
theorem lift_symm_apply (F : FreeLieAlgebra R X →ₗ⁅R⁆ L) : (lift R).symm F = F ∘ of R :=
  rfl

variable {R}

@[simp]
theorem of_comp_lift (f : X → L) : lift R f ∘ of R = f :=
  (lift R).left_inv f

@[simp]
theorem lift_unique (f : X → L) (g : FreeLieAlgebra R X →ₗ⁅R⁆ L) : g ∘ of R = f ↔ g = lift R f :=
  (lift R).symm_apply_eq

@[simp]
theorem lift_of_apply (f : X → L) x : lift R f (of R x) = f x :=
  by 
    rw [←Function.comp_app (lift R f) (of R) x, of_comp_lift]

@[simp]
theorem lift_comp_of (F : FreeLieAlgebra R X →ₗ⁅R⁆ L) : lift R (F ∘ of R) = F :=
  by 
    rw [←lift_symm_apply]
    exact (lift R).apply_symm_apply F

@[ext]
theorem hom_ext {F₁ F₂ : FreeLieAlgebra R X →ₗ⁅R⁆ L} (h : ∀ x, F₁ (of R x) = F₂ (of R x)) : F₁ = F₂ :=
  have h' : (lift R).symm F₁ = (lift R).symm F₂ :=
    by 
      ext 
      simp [h]
  (lift R).symm.Injective h'

variable (R X)

/-- The universal enveloping algebra of the free Lie algebra is just the free unital associative
algebra. -/
@[simps]
def universal_enveloping_equiv_free_algebra : UniversalEnvelopingAlgebra R (FreeLieAlgebra R X) ≃ₐ[R] FreeAlgebra R X :=
  AlgEquiv.ofAlgHom (UniversalEnvelopingAlgebra.lift R$ FreeLieAlgebra.lift R$ FreeAlgebra.ι R)
    (FreeAlgebra.lift R$ UniversalEnvelopingAlgebra.ι R ∘ FreeLieAlgebra.of R)
    (by 
      ext 
      simp )
    (by 
      ext 
      simp )

end FreeLieAlgebra

