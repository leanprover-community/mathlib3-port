/-
Copyright (c) 2020 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash

! This file was ported from Lean 3 source module algebra.lie.universal_enveloping
! leanprover-community/mathlib commit 18a5306c091183ac90884daa9373fa3b178e8607
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Lie.OfAssociative
import Mathbin.Algebra.RingQuot
import Mathbin.LinearAlgebra.TensorAlgebra.Basic

/-!
# Universal enveloping algebra

Given a commutative ring `R` and a Lie algebra `L` over `R`, we construct the universal
enveloping algebra of `L`, together with its universal property.

## Main definitions

  * `universal_enveloping_algebra`: the universal enveloping algebra, endowed with an
    `R`-algebra structure.
  * `universal_enveloping_algebra.ι`: the Lie algebra morphism from `L` to its universal
    enveloping algebra.
  * `universal_enveloping_algebra.lift`: given an associative algebra `A`, together with a Lie
    algebra morphism `f : L →ₗ⁅R⁆ A`, `lift R L f : universal_enveloping_algebra R L →ₐ[R] A` is the
    unique morphism of algebras through which `f` factors.
  * `universal_enveloping_algebra.ι_comp_lift`: states that the lift of a morphism is indeed part
    of a factorisation.
  * `universal_enveloping_algebra.lift_unique`: states that lifts of morphisms are indeed unique.
  * `universal_enveloping_algebra.hom_ext`: a restatement of `lift_unique` as an extensionality
    lemma.

## Tags

lie algebra, universal enveloping algebra, tensor algebra
-/


universe u₁ u₂ u₃

variable (R : Type u₁) (L : Type u₂)

variable [CommRing R] [LieRing L] [LieAlgebra R L]

-- mathport name: exprιₜ
local notation "ιₜ" => TensorAlgebra.ι R

namespace UniversalEnvelopingAlgebra

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The quotient by the ideal generated by this relation is the universal enveloping algebra.\n\nNote that we have avoided using the more natural expression:\n| lie_compat (x y : L) : rel (ιₜ ⁅x, y⁆) ⁅ιₜ x, ιₜ y⁆\nso that our construction needs only the semiring structure of the tensor algebra. -/")]
      []
      []
      []
      []
      [])
     (Command.inductive
      "inductive"
      (Command.declId `Rel [])
      (Command.optDeclSig
       []
       [(Term.typeSpec
         ":"
         (Term.arrow
          (Term.app `TensorAlgebra [`R `L])
          "→"
          (Term.arrow (Term.app `TensorAlgebra [`R `L]) "→" (Term.prop "Prop"))))])
      []
      [(Command.ctor
        []
        "|"
        (Command.declModifiers [] [] [] [] [] [])
        `lie_compat
        (Command.optDeclSig
         [(Term.explicitBinder "(" [`x `y] [":" `L] [] ")")]
         [(Term.typeSpec
           ":"
           (Term.app
            `Rel
            [(«term_+_»
              (Term.app
               (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")
               [(Data.Bracket.«term⁅_,_⁆» "⁅" `x ", " `y "⁆")])
              "+"
              («term_*_»
               (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y])
               "*"
               (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])))
             («term_*_»
              (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
              "*"
              (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))]))]))]
      []
      (Command.optDeriving [])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.inductive', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.inductive', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.inductive', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.inductive', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.inductive', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.inductive', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.inductive', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      (Term.app
       `Rel
       [(«term_+_»
         (Term.app
          (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")
          [(Data.Bracket.«term⁅_,_⁆» "⁅" `x ", " `y "⁆")])
         "+"
         («term_*_»
          (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y])
          "*"
          (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])))
        («term_*_»
         (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
         "*"
         (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
       "*"
       (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.Lie.UniversalEnveloping.termιₜ', expected 'Algebra.Lie.UniversalEnveloping.termιₜ._@.Algebra.Lie.UniversalEnveloping._hyg.5'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.inductive', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.inductive', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    The quotient by the ideal generated by this relation is the universal enveloping algebra.
    
    Note that we have avoided using the more natural expression:
    | lie_compat (x y : L) : rel (ιₜ ⁅x, y⁆) ⁅ιₜ x, ιₜ y⁆
    so that our construction needs only the semiring structure of the tensor algebra. -/
  inductive
    Rel
    : TensorAlgebra R L → TensorAlgebra R L → Prop
    | lie_compat ( x y : L ) : Rel ιₜ ⁅ x , y ⁆ + ιₜ y * ιₜ x ιₜ x * ιₜ y
#align universal_enveloping_algebra.rel UniversalEnvelopingAlgebra.Rel

end UniversalEnvelopingAlgebra

/- ./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler algebra[algebra] R -/
/-- The universal enveloping algebra of a Lie algebra. -/
def UniversalEnvelopingAlgebra :=
  RingQuot (UniversalEnvelopingAlgebra.Rel R L)deriving Inhabited, Ring,
  «./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler algebra[algebra] R»
#align universal_enveloping_algebra UniversalEnvelopingAlgebra

namespace UniversalEnvelopingAlgebra

/-- The quotient map from the tensor algebra to the universal enveloping algebra as a morphism of
associative algebras. -/
def mkAlgHom : TensorAlgebra R L →ₐ[R] UniversalEnvelopingAlgebra R L :=
  RingQuot.mkAlgHom R (Rel R L)
#align universal_enveloping_algebra.mk_alg_hom UniversalEnvelopingAlgebra.mkAlgHom

variable {L}

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
     (Command.declModifiers
      [(Command.docComment
        "/--"
        "The natural Lie algebra morphism from a Lie algebra to its universal enveloping algebra. -/")]
      []
      []
      []
      []
      [])
     (Command.def
      "def"
      (Command.declId `ι [])
      (Command.optDeclSig
       []
       [(Term.typeSpec
         ":"
         (Algebra.Lie.Basic.«term_→ₗ⁅_⁆_»
          `L
          " →ₗ⁅"
          `R
          "⁆ "
          (Term.app `UniversalEnvelopingAlgebra [`R `L])))])
      (Command.declValSimple
       ":="
       (Term.structInst
        "{"
        [[(Term.app
           (Term.proj (Term.proj (Term.app `mkAlgHom [`R `L]) "." `toLinearMap) "." `comp)
           [(Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")])]
         "with"]
        [(Term.structInstField
          (Term.structInstLVal `map_lie' [])
          ":="
          (Term.fun
           "fun"
           (Term.basicFun
            [`x `y]
            []
            "=>"
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.tacticSuffices_
                 "suffices"
                 (Term.sufficesDecl
                  []
                  («term_=_»
                   (Term.app
                    `mk_alg_hom
                    [`R
                     `L
                     («term_+_»
                      (Term.app
                       (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")
                       [(Data.Bracket.«term⁅_,_⁆» "⁅" `x ", " `y "⁆")])
                      "+"
                      («term_*_»
                       (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y])
                       "*"
                       (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])))])
                   "="
                   (Term.app
                    `mk_alg_hom
                    [`R
                     `L
                     («term_*_»
                      (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
                      "*"
                      (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))]))
                  (Term.byTactic'
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(Tactic.rwSeq
                       "rw"
                       []
                       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `AlgHom.map_mul)] "]")
                       [(Tactic.location "at" (Tactic.locationHyp [`this] []))])
                      []
                      (Tactic.simp
                       "simp"
                       []
                       []
                       []
                       ["["
                        [(Tactic.simpLemma [] [] `LieRing.of_associative_ring_bracket)
                         ","
                         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `this)]
                        "]"]
                       [])])))))
                []
                (Tactic.exact
                 "exact"
                 (Term.app
                  `RingQuot.mk_alg_hom_rel
                  [(Term.hole "_") (Term.app `rel.lie_compat [`x `y])]))]))))))]
        (Term.optEllipsis [])
        []
        "}")
       [])
      []
      []
      []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.structInst
       "{"
       [[(Term.app
          (Term.proj (Term.proj (Term.app `mkAlgHom [`R `L]) "." `toLinearMap) "." `comp)
          [(Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")])]
        "with"]
       [(Term.structInstField
         (Term.structInstLVal `map_lie' [])
         ":="
         (Term.fun
          "fun"
          (Term.basicFun
           [`x `y]
           []
           "=>"
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(Tactic.tacticSuffices_
                "suffices"
                (Term.sufficesDecl
                 []
                 («term_=_»
                  (Term.app
                   `mk_alg_hom
                   [`R
                    `L
                    («term_+_»
                     (Term.app
                      (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")
                      [(Data.Bracket.«term⁅_,_⁆» "⁅" `x ", " `y "⁆")])
                     "+"
                     («term_*_»
                      (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y])
                      "*"
                      (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])))])
                  "="
                  (Term.app
                   `mk_alg_hom
                   [`R
                    `L
                    («term_*_»
                     (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
                     "*"
                     (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))]))
                 (Term.byTactic'
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(Tactic.rwSeq
                      "rw"
                      []
                      (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `AlgHom.map_mul)] "]")
                      [(Tactic.location "at" (Tactic.locationHyp [`this] []))])
                     []
                     (Tactic.simp
                      "simp"
                      []
                      []
                      []
                      ["["
                       [(Tactic.simpLemma [] [] `LieRing.of_associative_ring_bracket)
                        ","
                        (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `this)]
                       "]"]
                      [])])))))
               []
               (Tactic.exact
                "exact"
                (Term.app
                 `RingQuot.mk_alg_hom_rel
                 [(Term.hole "_") (Term.app `rel.lie_compat [`x `y])]))]))))))]
       (Term.optEllipsis [])
       []
       "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.fun
       "fun"
       (Term.basicFun
        [`x `y]
        []
        "=>"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.tacticSuffices_
             "suffices"
             (Term.sufficesDecl
              []
              («term_=_»
               (Term.app
                `mk_alg_hom
                [`R
                 `L
                 («term_+_»
                  (Term.app
                   (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")
                   [(Data.Bracket.«term⁅_,_⁆» "⁅" `x ", " `y "⁆")])
                  "+"
                  («term_*_»
                   (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y])
                   "*"
                   (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])))])
               "="
               (Term.app
                `mk_alg_hom
                [`R
                 `L
                 («term_*_»
                  (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
                  "*"
                  (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))]))
              (Term.byTactic'
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `AlgHom.map_mul)] "]")
                   [(Tactic.location "at" (Tactic.locationHyp [`this] []))])
                  []
                  (Tactic.simp
                   "simp"
                   []
                   []
                   []
                   ["["
                    [(Tactic.simpLemma [] [] `LieRing.of_associative_ring_bracket)
                     ","
                     (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `this)]
                    "]"]
                   [])])))))
            []
            (Tactic.exact
             "exact"
             (Term.app
              `RingQuot.mk_alg_hom_rel
              [(Term.hole "_") (Term.app `rel.lie_compat [`x `y])]))])))))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(Tactic.tacticSuffices_
           "suffices"
           (Term.sufficesDecl
            []
            («term_=_»
             (Term.app
              `mk_alg_hom
              [`R
               `L
               («term_+_»
                (Term.app
                 (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")
                 [(Data.Bracket.«term⁅_,_⁆» "⁅" `x ", " `y "⁆")])
                "+"
                («term_*_»
                 (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y])
                 "*"
                 (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])))])
             "="
             (Term.app
              `mk_alg_hom
              [`R
               `L
               («term_*_»
                (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
                "*"
                (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))]))
            (Term.byTactic'
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(Tactic.rwSeq
                 "rw"
                 []
                 (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `AlgHom.map_mul)] "]")
                 [(Tactic.location "at" (Tactic.locationHyp [`this] []))])
                []
                (Tactic.simp
                 "simp"
                 []
                 []
                 []
                 ["["
                  [(Tactic.simpLemma [] [] `LieRing.of_associative_ring_bracket)
                   ","
                   (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `this)]
                  "]"]
                 [])])))))
          []
          (Tactic.exact
           "exact"
           (Term.app
            `RingQuot.mk_alg_hom_rel
            [(Term.hole "_") (Term.app `rel.lie_compat [`x `y])]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.exact
       "exact"
       (Term.app `RingQuot.mk_alg_hom_rel [(Term.hole "_") (Term.app `rel.lie_compat [`x `y])]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `RingQuot.mk_alg_hom_rel [(Term.hole "_") (Term.app `rel.lie_compat [`x `y])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app `rel.lie_compat [`x `y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      `x
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `rel.lie_compat
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023,
     term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" (Term.app `rel.lie_compat [`x `y]) ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
      (Term.hole "_")
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      `RingQuot.mk_alg_hom_rel
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.tacticSuffices_
       "suffices"
       (Term.sufficesDecl
        []
        («term_=_»
         (Term.app
          `mk_alg_hom
          [`R
           `L
           («term_+_»
            (Term.app
             (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")
             [(Data.Bracket.«term⁅_,_⁆» "⁅" `x ", " `y "⁆")])
            "+"
            («term_*_»
             (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y])
             "*"
             (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])))])
         "="
         (Term.app
          `mk_alg_hom
          [`R
           `L
           («term_*_»
            (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
            "*"
            (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))]))
        (Term.byTactic'
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `AlgHom.map_mul)] "]")
             [(Tactic.location "at" (Tactic.locationHyp [`this] []))])
            []
            (Tactic.simp
             "simp"
             []
             []
             []
             ["["
              [(Tactic.simpLemma [] [] `LieRing.of_associative_ring_bracket)
               ","
               (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `this)]
              "]"]
             [])])))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic'', expected 'Lean.Parser.Term.fromTerm'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.simp
       "simp"
       []
       []
       []
       ["["
        [(Tactic.simpLemma [] [] `LieRing.of_associative_ring_bracket)
         ","
         (Tactic.simpLemma [] [(patternIgnore (token.«← » "←"))] `this)]
        "]"]
       [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `this
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `LieRing.of_associative_ring_bracket
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Tactic.rwSeq
       "rw"
       []
       (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `AlgHom.map_mul)] "]")
       [(Tactic.location "at" (Tactic.locationHyp [`this] []))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `this
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `AlgHom.map_mul
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
      («term_=_»
       (Term.app
        `mk_alg_hom
        [`R
         `L
         («term_+_»
          (Term.app
           (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")
           [(Data.Bracket.«term⁅_,_⁆» "⁅" `x ", " `y "⁆")])
          "+"
          («term_*_»
           (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y])
           "*"
           (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])))])
       "="
       (Term.app
        `mk_alg_hom
        [`R
         `L
         («term_*_»
          (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
          "*"
          (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app
       `mk_alg_hom
       [`R
        `L
        («term_*_»
         (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
         "*"
         (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_*_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      («term_*_»
       (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`x])
       "*"
       (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y]))
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      (Term.app (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ") [`y])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
      `y
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none,
     [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
      (Algebra.Lie.UniversalEnveloping.termιₜ "ιₜ")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.Lie.UniversalEnveloping.termιₜ', expected 'Algebra.Lie.UniversalEnveloping.termιₜ._@.Algebra.Lie.UniversalEnveloping._hyg.5'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.opaque'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- The natural Lie algebra morphism from a Lie algebra to its universal enveloping algebra. -/
  def
    ι
    : L →ₗ⁅ R ⁆ UniversalEnvelopingAlgebra R L
    :=
      {
        mkAlgHom R L . toLinearMap . comp ιₜ with
        map_lie'
          :=
          fun
            x y
              =>
              by
                suffices
                    mk_alg_hom R L ιₜ ⁅ x , y ⁆ + ιₜ y * ιₜ x = mk_alg_hom R L ιₜ x * ιₜ y
                      by
                        rw [ AlgHom.map_mul ] at this
                          simp [ LieRing.of_associative_ring_bracket , ← this ]
                  exact RingQuot.mk_alg_hom_rel _ rel.lie_compat x y
        }
#align universal_enveloping_algebra.ι UniversalEnvelopingAlgebra.ι

variable {A : Type u₃} [Ring A] [Algebra R A] (f : L →ₗ⁅R⁆ A)

/-- The universal property of the universal enveloping algebra: Lie algebra morphisms into
associative algebras lift to associative algebra morphisms from the universal enveloping algebra. -/
def lift : (L →ₗ⁅R⁆ A) ≃ (UniversalEnvelopingAlgebra R L →ₐ[R] A)
    where
  toFun f :=
    RingQuot.liftAlgHom R
      ⟨TensorAlgebra.lift R (f : L →ₗ[R] A), by
        intro a b h; induction' h with x y
        simp only [LieRing.of_associative_ring_bracket, map_add, TensorAlgebra.lift_ι_apply,
          LieHom.coe_to_linear_map, LieHom.map_lie, map_mul, sub_add_cancel]⟩
  invFun F := (F : UniversalEnvelopingAlgebra R L →ₗ⁅R⁆ A).comp (ι R)
  left_inv f := by
    ext
    simp only [ι, mk_alg_hom, TensorAlgebra.lift_ι_apply, LieHom.coe_to_linear_map,
      LinearMap.to_fun_eq_coe, LinearMap.coe_comp, LieHom.coe_comp, AlgHom.coe_to_lie_hom,
      LieHom.coe_mk, Function.comp_apply, AlgHom.to_linear_map_apply,
      RingQuot.lift_alg_hom_mk_alg_hom_apply]
  right_inv F := by
    ext
    simp only [ι, mk_alg_hom, TensorAlgebra.lift_ι_apply, LieHom.coe_to_linear_map,
      LinearMap.to_fun_eq_coe, LinearMap.coe_comp, LieHom.coe_linear_map_comp,
      AlgHom.comp_to_linear_map, Function.comp_apply, AlgHom.to_linear_map_apply,
      RingQuot.lift_alg_hom_mk_alg_hom_apply, AlgHom.coe_to_lie_hom, LieHom.coe_mk]
#align universal_enveloping_algebra.lift UniversalEnvelopingAlgebra.lift

@[simp]
theorem lift_symm_apply (F : UniversalEnvelopingAlgebra R L →ₐ[R] A) :
    (lift R).symm F = (F : UniversalEnvelopingAlgebra R L →ₗ⁅R⁆ A).comp (ι R) :=
  rfl
#align universal_enveloping_algebra.lift_symm_apply UniversalEnvelopingAlgebra.lift_symm_apply

@[simp]
theorem ι_comp_lift : lift R f ∘ ι R = f :=
  funext <| LieHom.ext_iff.mp <| (lift R).symm_apply_apply f
#align universal_enveloping_algebra.ι_comp_lift UniversalEnvelopingAlgebra.ι_comp_lift

@[simp]
theorem lift_ι_apply (x : L) : lift R f (ι R x) = f x := by
  rw [← Function.comp_apply (lift R f) (ι R) x, ι_comp_lift]
#align universal_enveloping_algebra.lift_ι_apply UniversalEnvelopingAlgebra.lift_ι_apply

theorem lift_unique (g : UniversalEnvelopingAlgebra R L →ₐ[R] A) : g ∘ ι R = f ↔ g = lift R f :=
  by
  refine' Iff.trans _ (lift R).symm_apply_eq
  constructor <;>
    · intro h
      ext
      simp [← h]
#align universal_enveloping_algebra.lift_unique UniversalEnvelopingAlgebra.lift_unique

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem hom_ext {g₁ g₂ : UniversalEnvelopingAlgebra R L →ₐ[R] A}
    (h :
      (g₁ : UniversalEnvelopingAlgebra R L →ₗ⁅R⁆ A).comp (ι R) =
        (g₂ : UniversalEnvelopingAlgebra R L →ₗ⁅R⁆ A).comp (ι R)) :
    g₁ = g₂ :=
  have h' : (lift R).symm g₁ = (lift R).symm g₂ := by ext; simp [h]
  (lift R).symm.Injective h'
#align universal_enveloping_algebra.hom_ext UniversalEnvelopingAlgebra.hom_ext

end UniversalEnvelopingAlgebra

