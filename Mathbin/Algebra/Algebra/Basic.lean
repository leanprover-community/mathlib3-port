/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Yury Kudryashov

! This file was ported from Lean 3 source module algebra.algebra.basic
! leanprover-community/mathlib commit 23aa88e32dcc9d2a24cca7bc23268567ed4cd7d6
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Module.Basic
import Mathbin.Algebra.Module.Ulift
import Mathbin.Algebra.NeZero
import Mathbin.Algebra.PunitInstances
import Mathbin.Algebra.Ring.Aut
import Mathbin.Algebra.Ring.Ulift
import Mathbin.Algebra.CharZero.Lemmas
import Mathbin.LinearAlgebra.Basic
import Mathbin.RingTheory.Subring.Basic
import Mathbin.Tactic.Abel

/-!
# Algebras over commutative semirings

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define associative unital `algebra`s over commutative (semi)rings, algebra
homomorphisms `alg_hom`, and algebra equivalences `alg_equiv`.

`subalgebra`s are defined in `algebra.algebra.subalgebra`.

For the category of `R`-algebras, denoted `Algebra R`, see the file
`algebra/category/Algebra/basic.lean`.

See the implementation notes for remarks about non-associative and non-unital algebras.

## Main definitions:

* `algebra R A`: the algebra typeclass.
* `algebra_map R A : R →+* A`: the canonical map from `R` to `A`, as a `ring_hom`. This is the
  preferred spelling of this map, it is also available as:
  * `algebra.linear_map R A : R →ₗ[R] A`, a `linear_map`.
  * `algebra.of_id R A : R →ₐ[R] A`, an `alg_hom` (defined in a later file).
* Instances of `algebra` in this file:
  * `algebra.id`
  * `algebra_nat`
  * `algebra_int`
  * `algebra_rat`
  * `mul_opposite.algebra`
  * `module.End.algebra`

## Implementation notes

Given a commutative (semi)ring `R`, there are two ways to define an `R`-algebra structure on a
(possibly noncommutative) (semi)ring `A`:
* By endowing `A` with a morphism of rings `R →+* A` denoted `algebra_map R A` which lands in the
  center of `A`.
* By requiring `A` be an `R`-module such that the action associates and commutes with multiplication
  as `r • (a₁ * a₂) = (r • a₁) * a₂ = a₁ * (r • a₂)`.

We define `algebra R A` in a way that subsumes both definitions, by extending `has_smul R A` and
requiring that this scalar action `r • x` must agree with left multiplication by the image of the
structure morphism `algebra_map R A r * x`.

As a result, there are two ways to talk about an `R`-algebra `A` when `A` is a semiring:
1. ```lean
   variables [comm_semiring R] [semiring A]
   variables [algebra R A]
   ```
2. ```lean
   variables [comm_semiring R] [semiring A]
   variables [module R A] [smul_comm_class R A A] [is_scalar_tower R A A]
   ```

The first approach implies the second via typeclass search; so any lemma stated with the second set
of arguments will automatically apply to the first set. Typeclass search does not know that the
second approach implies the first, but this can be shown with:
```lean
example {R A : Type*} [comm_semiring R] [semiring A]
  [module R A] [smul_comm_class R A A] [is_scalar_tower R A A] : algebra R A :=
algebra.of_module smul_mul_assoc mul_smul_comm
```

The advantage of the first approach is that `algebra_map R A` is available, and `alg_hom R A B` and
`subalgebra R A` can be used. For concrete `R` and `A`, `algebra_map R A` is often definitionally
convenient.

The advantage of the second approach is that `comm_semiring R`, `semiring A`, and `module R A` can
all be relaxed independently; for instance, this allows us to:
* Replace `semiring A` with `non_unital_non_assoc_semiring A` in order to describe non-unital and/or
  non-associative algebras.
* Replace `comm_semiring R` and `module R A` with `comm_group R'` and `distrib_mul_action R' A`,
  which when `R' = Rˣ` lets us talk about the "algebra-like" action of `Rˣ` on an
  `R`-algebra `A`.

While `alg_hom R A B` cannot be used in the second approach, `non_unital_alg_hom R A B` still can.

You should always use the first approach when working with associative unital algebras, and mimic
the second approach only when you need to weaken a condition on either `R` or `A`.

-/


universe u v w u₁ v₁

open BigOperators

section Prio

/- ./././Mathport/Syntax/Translate/Basic.lean:334:40: warning: unsupported option extends_priority -/
-- We set this priority to 0 later in this file
set_option extends_priority 200

#print Algebra /-
/- control priority of
`instance [algebra R A] : has_smul R A` -/
/-- An associative unital `R`-algebra is a semiring `A` equipped with a map into its center `R → A`.

See the implementation notes in this file for discussion of the details of this definition.
-/
@[nolint has_nonempty_instance]
class Algebra (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] extends SMul R A,
  R →+* A where
  commutes' : ∀ r x, to_fun r * x = x * to_fun r
  smul_def' : ∀ r x, r • x = to_fun r * x
#align algebra Algebra
-/

end Prio

#print algebraMap /-
/-- Embedding `R →+* A` given by `algebra` structure. -/
def algebraMap (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R →+* A :=
  Algebra.toRingHom
#align algebra_map algebraMap
-/

namespace algebraMap

/- warning: algebra_map.has_lift_t -> algebraMap.coeHTCT is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2], HasLiftT.{succ u1, succ u2} R A
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2], CoeHTCT.{succ u1, succ u2} R A
Case conversion may be inaccurate. Consider using '#align algebra_map.has_lift_t algebraMap.coeHTCTₓ'. -/
def coeHTCT (R A : Type _) [CommSemiring R] [Semiring A] [Algebra R A] : HasLiftT R A :=
  ⟨fun r => algebraMap R A r⟩
#align algebra_map.has_lift_t algebraMap.coeHTCT

attribute [instance] algebraMap.coeHTCT

section CommSemiringSemiring

variable {R A : Type _} [CommSemiring R] [Semiring A] [Algebra R A]

#print algebraMap.coe_zero /-
@[simp, norm_cast]
theorem coe_zero : (↑(0 : R) : A) = 0 :=
  map_zero (algebraMap R A)
#align algebra_map.coe_zero algebraMap.coe_zero
-/

#print algebraMap.coe_one /-
@[simp, norm_cast]
theorem coe_one : (↑(1 : R) : A) = 1 :=
  map_one (algebraMap R A)
#align algebra_map.coe_one algebraMap.coe_one
-/

#print algebraMap.coe_add /-
@[norm_cast]
theorem coe_add (a b : R) : (↑(a + b : R) : A) = ↑a + ↑b :=
  map_add (algebraMap R A) a b
#align algebra_map.coe_add algebraMap.coe_add
-/

#print algebraMap.coe_mul /-
@[norm_cast]
theorem coe_mul (a b : R) : (↑(a * b : R) : A) = ↑a * ↑b :=
  map_mul (algebraMap R A) a b
#align algebra_map.coe_mul algebraMap.coe_mul
-/

#print algebraMap.coe_pow /-
@[norm_cast]
theorem coe_pow (a : R) (n : ℕ) : (↑(a ^ n : R) : A) = ↑a ^ n :=
  map_pow (algebraMap R A) _ _
#align algebra_map.coe_pow algebraMap.coe_pow
-/

end CommSemiringSemiring

section CommRingRing

variable {R A : Type _} [CommRing R] [Ring A] [Algebra R A]

#print algebraMap.coe_neg /-
@[norm_cast]
theorem coe_neg (x : R) : (↑(-x : R) : A) = -↑x :=
  map_neg (algebraMap R A) x
#align algebra_map.coe_neg algebraMap.coe_neg
-/

end CommRingRing

section CommSemiringCommSemiring

variable {R A : Type _} [CommSemiring R] [CommSemiring A] [Algebra R A]

open BigOperators

#print algebraMap.coe_prod /-
-- direct to_additive fails because of some mix-up with polynomials
@[norm_cast]
theorem coe_prod {ι : Type _} {s : Finset ι} (a : ι → R) :
    (↑(∏ i : ι in s, a i : R) : A) = ∏ i : ι in s, (↑(a i) : A) :=
  map_prod (algebraMap R A) a s
#align algebra_map.coe_prod algebraMap.coe_prod
-/

#print algebraMap.coe_sum /-
-- to_additive fails for some reason
@[norm_cast]
theorem coe_sum {ι : Type _} {s : Finset ι} (a : ι → R) :
    ↑(∑ i : ι in s, a i) = ∑ i : ι in s, (↑(a i) : A) :=
  map_sum (algebraMap R A) a s
#align algebra_map.coe_sum algebraMap.coe_sum
-/

attribute [to_additive] coe_prod

end CommSemiringCommSemiring

section FieldNontrivial

variable {R A : Type _} [Field R] [CommSemiring A] [Nontrivial A] [Algebra R A]

#print algebraMap.coe_inj /-
@[norm_cast, simp]
theorem coe_inj {a b : R} : (↑a : A) = ↑b ↔ a = b :=
  (algebraMap R A).Injective.eq_iff
#align algebra_map.coe_inj algebraMap.coe_inj
-/

#print algebraMap.lift_map_eq_zero_iff /-
@[norm_cast, simp]
theorem lift_map_eq_zero_iff (a : R) : (↑a : A) = 0 ↔ a = 0 :=
  map_eq_zero_iff _ (algebraMap R A).Injective
#align algebra_map.lift_map_eq_zero_iff algebraMap.lift_map_eq_zero_iff
-/

end FieldNontrivial

section SemifieldSemidivisionRing

variable {R : Type _} (A : Type _) [Semifield R] [DivisionSemiring A] [Algebra R A]

#print algebraMap.coe_inv /-
@[norm_cast]
theorem coe_inv (r : R) : ↑r⁻¹ = ((↑r)⁻¹ : A) :=
  map_inv₀ (algebraMap R A) r
#align algebra_map.coe_inv algebraMap.coe_inv
-/

#print algebraMap.coe_div /-
@[norm_cast]
theorem coe_div (r s : R) : ↑(r / s) = (↑r / ↑s : A) :=
  map_div₀ (algebraMap R A) r s
#align algebra_map.coe_div algebraMap.coe_div
-/

#print algebraMap.coe_zpow /-
@[norm_cast]
theorem coe_zpow (r : R) (z : ℤ) : ↑(r ^ z) = (↑r ^ z : A) :=
  map_zpow₀ (algebraMap R A) r z
#align algebra_map.coe_zpow algebraMap.coe_zpow
-/

end SemifieldSemidivisionRing

section FieldDivisionRing

variable (R A : Type _) [Field R] [DivisionRing A] [Algebra R A]

#print algebraMap.coe_ratCast /-
@[norm_cast]
theorem coe_ratCast (q : ℚ) : ↑(q : R) = (q : A) :=
  map_ratCast (algebraMap R A) q
#align algebra_map.coe_rat_cast algebraMap.coe_ratCast
-/

end FieldDivisionRing

end algebraMap

/- warning: ring_hom.to_algebra' -> RingHom.toAlgebra' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} S] (i : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)), (forall (c : R) (x : S), Eq.{succ u2} S (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) i c) x) (HMul.hMul.{u2, u2, u2} S S S (instHMul.{u2} S (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) i c))) -> (Algebra.{u1, u2} R S _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} S] (i : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)), (forall (c : R) (x : (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) (NonUnitalNonAssocSemiring.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) _inst_2)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) i c) x) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) (NonUnitalNonAssocSemiring.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) c) _inst_2)))) x (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_2))))) i c))) -> (Algebra.{u1, u2} R S _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align ring_hom.to_algebra' RingHom.toAlgebra'ₓ'. -/
/-- Creating an algebra from a morphism to the center of a semiring. -/
def RingHom.toAlgebra' {R S} [CommSemiring R] [Semiring S] (i : R →+* S)
    (h : ∀ c x, i c * x = x * i c) : Algebra R S
    where
  smul c x := i c * x
  commutes' := h
  smul_def' c x := rfl
  toRingHom := i
#align ring_hom.to_algebra' RingHom.toAlgebra'

#print RingHom.toAlgebra /-
/-- Creating an algebra from a morphism to a commutative semiring. -/
def RingHom.toAlgebra {R S} [CommSemiring R] [CommSemiring S] (i : R →+* S) : Algebra R S :=
  i.toAlgebra' fun _ => mul_comm _
#align ring_hom.to_algebra RingHom.toAlgebra
-/

/- warning: ring_hom.algebra_map_to_algebra -> RingHom.algebraMap_toAlgebra is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : CommSemiring.{u2} S] (i : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))), Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_2))) (algebraMap.{u1, u2} R S _inst_1 (CommSemiring.toSemiring.{u2} S _inst_2) (RingHom.toAlgebra.{u1, u2} R S _inst_1 _inst_2 i)) i
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : CommSemiring.{u1} S] (i : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))), Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S _inst_2))) (algebraMap.{u2, u1} R S _inst_1 (CommSemiring.toSemiring.{u1} S _inst_2) (RingHom.toAlgebra.{u2, u1} R S _inst_1 _inst_2 i)) i
Case conversion may be inaccurate. Consider using '#align ring_hom.algebra_map_to_algebra RingHom.algebraMap_toAlgebraₓ'. -/
theorem RingHom.algebraMap_toAlgebra {R S} [CommSemiring R] [CommSemiring S] (i : R →+* S) :
    @algebraMap R S _ _ i.toAlgebra = i :=
  rfl
#align ring_hom.algebra_map_to_algebra RingHom.algebraMap_toAlgebra

namespace Algebra

variable {R : Type u} {S : Type v} {A : Type w} {B : Type _}

/- warning: algebra.of_module' -> Algebra.ofModule' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Module.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))], (forall (r : R) (x : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3)))) r (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))))) x) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3)))) r x)) -> (forall (r : R) (x : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) x (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3)))) r (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))))))) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3)))) r x)) -> (Algebra.{u1, u2} R A _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Module.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))], (forall (r : R) (x : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (SMulZeroClass.toSMul.{u1, u2} R A (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3))))) r (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A _inst_2)))) x) (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (SMulZeroClass.toSMul.{u1, u2} R A (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3))))) r x)) -> (forall (r : R) (x : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) x (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (SMulZeroClass.toSMul.{u1, u2} R A (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3))))) r (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A _inst_2))))) (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (SMulZeroClass.toSMul.{u1, u2} R A (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3))))) r x)) -> (Algebra.{u1, u2} R A _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align algebra.of_module' Algebra.ofModule'ₓ'. -/
/-- Let `R` be a commutative semiring, let `A` be a semiring with a `module R` structure.
If `(r • 1) * x = x * (r • 1) = r • x` for all `r : R` and `x : A`, then `A` is an `algebra`
over `R`.

See note [reducible non-instances]. -/
@[reducible]
def ofModule' [CommSemiring R] [Semiring A] [Module R A] (h₁ : ∀ (r : R) (x : A), r • 1 * x = r • x)
    (h₂ : ∀ (r : R) (x : A), x * r • 1 = r • x) : Algebra R A
    where
  toFun r := r • 1
  map_one' := one_smul _ _
  map_mul' r₁ r₂ := by rw [h₁, mul_smul]
  map_zero' := zero_smul _ _
  map_add' r₁ r₂ := add_smul r₁ r₂ 1
  commutes' r x := by simp only [h₁, h₂]
  smul_def' r x := by simp only [h₁]
#align algebra.of_module' Algebra.ofModule'

/- warning: algebra.of_module -> Algebra.ofModule is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Module.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))], (forall (r : R) (x : A) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3)))) r x) y) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3)))) r (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) x y))) -> (forall (r : R) (x : A) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) x (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3)))) r y)) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3)))) r (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) x y))) -> (Algebra.{u1, u2} R A _inst_1 _inst_2)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Module.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))], (forall (r : R) (x : A) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (SMulZeroClass.toSMul.{u1, u2} R A (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3))))) r x) y) (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (SMulZeroClass.toSMul.{u1, u2} R A (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3))))) r (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) x y))) -> (forall (r : R) (x : A) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) x (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (SMulZeroClass.toSMul.{u1, u2} R A (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3))))) r y)) (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (SMulZeroClass.toSMul.{u1, u2} R A (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) _inst_3))))) r (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) x y))) -> (Algebra.{u1, u2} R A _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align algebra.of_module Algebra.ofModuleₓ'. -/
/-- Let `R` be a commutative semiring, let `A` be a semiring with a `module R` structure.
If `(r • x) * y = x * (r • y) = r • (x * y)` for all `r : R` and `x y : A`, then `A`
is an `algebra` over `R`.

See note [reducible non-instances]. -/
@[reducible]
def ofModule [CommSemiring R] [Semiring A] [Module R A]
    (h₁ : ∀ (r : R) (x y : A), r • x * y = r • (x * y))
    (h₂ : ∀ (r : R) (x y : A), x * r • y = r • (x * y)) : Algebra R A :=
  ofModule' (fun r x => by rw [h₁, one_mul]) fun r x => by rw [h₂, mul_one]
#align algebra.of_module Algebra.ofModule

section Semiring

variable [CommSemiring R] [CommSemiring S]

variable [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]

/-- We keep this lemma private because it picks up the `algebra.to_has_smul` instance
which we set to priority 0 shortly. See `smul_def` below for the public version. -/
private theorem smul_def'' (r : R) (x : A) : r • x = algebraMap R A r * x :=
  Algebra.smul_def' r x
#align algebra.smul_def'' algebra.smul_def''

/- warning: algebra.algebra_ext -> Algebra.algebra_ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_7 : CommSemiring.{u1} R] {A : Type.{u2}} [_inst_8 : Semiring.{u2} A] (P : Algebra.{u1, u2} R A _inst_7 _inst_8) (Q : Algebra.{u1, u2} R A _inst_7 _inst_8), (forall (r : R), Eq.{succ u2} A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_7)) (Semiring.toNonAssocSemiring.{u2} A _inst_8)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_7)) (Semiring.toNonAssocSemiring.{u2} A _inst_8)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_7)) (Semiring.toNonAssocSemiring.{u2} A _inst_8)) (algebraMap.{u1, u2} R A _inst_7 _inst_8 P) r) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_7)) (Semiring.toNonAssocSemiring.{u2} A _inst_8)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_7)) (Semiring.toNonAssocSemiring.{u2} A _inst_8)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_7)) (Semiring.toNonAssocSemiring.{u2} A _inst_8)) (algebraMap.{u1, u2} R A _inst_7 _inst_8 Q) r)) -> (Eq.{max (succ u1) (succ u2)} (Algebra.{u1, u2} R A _inst_7 _inst_8) P Q)
but is expected to have type
  forall {R : Type.{u2}} [_inst_7 : CommSemiring.{u2} R] {A : Type.{u1}} [_inst_8 : Semiring.{u1} A] (P : Algebra.{u2, u1} R A _inst_7 _inst_8) (Q : Algebra.{u2, u1} R A _inst_7 _inst_8), (forall (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8)) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_8))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_8)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8)) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8))))) (algebraMap.{u2, u1} R A _inst_7 _inst_8 P) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8)) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_8))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_8)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8)) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_7)) (Semiring.toNonAssocSemiring.{u1} A _inst_8))))) (algebraMap.{u2, u1} R A _inst_7 _inst_8 Q) r)) -> (Eq.{max (succ u2) (succ u1)} (Algebra.{u2, u1} R A _inst_7 _inst_8) P Q)
Case conversion may be inaccurate. Consider using '#align algebra.algebra_ext Algebra.algebra_extₓ'. -/
-- We'll later use this to show `algebra ℤ M` is a subsingleton.
/-- To prove two algebra structures on a fixed `[comm_semiring R] [semiring A]` agree,
it suffices to check the `algebra_map`s agree.
-/
@[ext]
theorem algebra_ext {R : Type _} [CommSemiring R] {A : Type _} [Semiring A] (P Q : Algebra R A)
    (w :
      ∀ r : R,
        (haveI := P
          algebraMap R A r) =
          haveI := Q
          algebraMap R A r) :
    P = Q := by
  rcases P with @⟨⟨P⟩⟩
  rcases Q with @⟨⟨Q⟩⟩
  congr
  · funext r a
    replace w := congr_arg (fun s => s * a) (w r)
    simp only [← smul_def''] at w
    apply w
  · ext r
    exact w r
  · apply proof_irrel_heq
  · apply proof_irrel_heq
#align algebra.algebra_ext Algebra.algebra_ext

#print Algebra.toModule /-
-- see Note [lower instance priority]
instance (priority := 200) toModule : Module R A
    where
  one_smul := by simp [smul_def'']
  mul_smul := by simp [smul_def'', mul_assoc]
  smul_add := by simp [smul_def'', mul_add]
  smul_zero := by simp [smul_def'']
  add_smul := by simp [smul_def'', add_mul]
  zero_smul := by simp [smul_def'']
#align algebra.to_module Algebra.toModule
-/

-- From now on, we don't want to use the following instance anymore.
-- Unfortunately, leaving it in place causes deterministic timeouts later in mathlib.
attribute [instance] Algebra.toHasSmul

/- warning: algebra.smul_def -> Algebra.smul_def is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R) (x : A), Eq.{succ u2} A (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r x) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) x)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R) (x : A), Eq.{succ u2} A (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_3 _inst_4)) r x) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonUnitalNonAssocSemiring.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_3)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) x)
Case conversion may be inaccurate. Consider using '#align algebra.smul_def Algebra.smul_defₓ'. -/
theorem smul_def (r : R) (x : A) : r • x = algebraMap R A r * x :=
  Algebra.smul_def' r x
#align algebra.smul_def Algebra.smul_def

/- warning: algebra.algebra_map_eq_smul_one -> Algebra.algebraMap_eq_smul_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R), Eq.{succ u2} A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_3 _inst_4)) r (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A _inst_3))))
Case conversion may be inaccurate. Consider using '#align algebra.algebra_map_eq_smul_one Algebra.algebraMap_eq_smul_oneₓ'. -/
theorem algebraMap_eq_smul_one (r : R) : algebraMap R A r = r • 1 :=
  calc
    algebraMap R A r = algebraMap R A r * 1 := (mul_one _).symm
    _ = r • 1 := (Algebra.smul_def r 1).symm
    
#align algebra.algebra_map_eq_smul_one Algebra.algebraMap_eq_smul_one

/- warning: algebra.algebra_map_eq_smul_one' -> Algebra.algebraMap_eq_smul_one' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3], Eq.{max (succ u1) (succ u2)} (R -> A) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4)) (fun (r : R) => SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3], Eq.{max (succ u1) (succ u2)} (forall (ᾰ : R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4)) (fun (r : R) => HSMul.hSMul.{u1, u2, u2} R A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (instHSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_3 _inst_4)) r (OfNat.ofNat.{u2} A 1 (One.toOfNat1.{u2} A (Semiring.toOne.{u2} A _inst_3))))
Case conversion may be inaccurate. Consider using '#align algebra.algebra_map_eq_smul_one' Algebra.algebraMap_eq_smul_one'ₓ'. -/
theorem algebraMap_eq_smul_one' : ⇑(algebraMap R A) = fun r => r • (1 : A) :=
  funext algebraMap_eq_smul_one
#align algebra.algebra_map_eq_smul_one' Algebra.algebraMap_eq_smul_one'

/- warning: algebra.commutes -> Algebra.commutes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R) (x : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) x) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R) (x : A), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonUnitalNonAssocSemiring.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_3)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) x) (HMul.hMul.{u2, u2, u2} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) x (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r))
Case conversion may be inaccurate. Consider using '#align algebra.commutes Algebra.commutesₓ'. -/
/-- `mul_comm` for `algebra`s when one element is from the base ring. -/
theorem commutes (r : R) (x : A) : algebraMap R A r * x = x * algebraMap R A r :=
  Algebra.commutes' r x
#align algebra.commutes Algebra.commutes

/- warning: algebra.left_comm -> Algebra.left_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (x : A) (r : R) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) x (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) y)) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) x y))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (x : A) (r : R) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) x (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonUnitalNonAssocSemiring.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_3)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) y)) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonUnitalNonAssocSemiring.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_3)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) x y))
Case conversion may be inaccurate. Consider using '#align algebra.left_comm Algebra.left_commₓ'. -/
/-- `mul_left_comm` for `algebra`s when one element is from the base ring. -/
theorem left_comm (x : A) (r : R) (y : A) :
    x * (algebraMap R A r * y) = algebraMap R A r * (x * y) := by
  rw [← mul_assoc, ← commutes, mul_assoc]
#align algebra.left_comm Algebra.left_comm

/- warning: algebra.right_comm -> Algebra.right_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (x : A) (r : R) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r)) y) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) x y) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (x : A) (r : R) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (HMul.hMul.{u2, u2, u2} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) x (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r)) y) (HMul.hMul.{u2, u2, u2} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) x y) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r))
Case conversion may be inaccurate. Consider using '#align algebra.right_comm Algebra.right_commₓ'. -/
/-- `mul_right_comm` for `algebra`s when one element is from the base ring. -/
theorem right_comm (x : A) (r : R) (y : A) : x * algebraMap R A r * y = x * y * algebraMap R A r :=
  by rw [mul_assoc, commutes, ← mul_assoc]
#align algebra.right_comm Algebra.right_comm

/- warning: is_scalar_tower.right -> IsScalarTower.right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3], IsScalarTower.{u1, u2, u2} R A A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) (Mul.toSMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4)))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3], IsScalarTower.{u1, u2, u2} R A A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_3 _inst_4) (SMulZeroClass.toSMul.{u2, u2} A A (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u2} A A (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_3)) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_3)) (MulZeroClass.toSMulWithZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align is_scalar_tower.right IsScalarTower.rightₓ'. -/
instance IsScalarTower.right : IsScalarTower R A A :=
  ⟨fun x y z => by rw [smul_eq_mul, smul_eq_mul, smul_def, smul_def, mul_assoc]⟩
#align is_scalar_tower.right IsScalarTower.right

/- warning: algebra.mul_smul_comm -> Algebra.mul_smul_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (s : R) (x : A) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) x (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) s y)) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) s (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) x y))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (s : R) (x : A) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) x (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_3 _inst_4)) s y)) (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_3 _inst_4)) s (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) x y))
Case conversion may be inaccurate. Consider using '#align algebra.mul_smul_comm Algebra.mul_smul_commₓ'. -/
/-- This is just a special case of the global `mul_smul_comm` lemma that requires less typeclass
search (and was here first). -/
@[simp]
protected theorem mul_smul_comm (s : R) (x y : A) : x * s • y = s • (x * y) :=
  by-- TODO: set up `is_scalar_tower.smul_comm_class` earlier so that we can actually prove this using
  -- `mul_smul_comm s x y`.
  rw [smul_def, smul_def, left_comm]
#align algebra.mul_smul_comm Algebra.mul_smul_comm

/- warning: algebra.smul_mul_assoc -> Algebra.smul_mul_assoc is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R) (x : A) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r x) y) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) x y))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R) (x : A) (y : A), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_3 _inst_4)) r x) y) (HSMul.hSMul.{u1, u2, u2} R A A (instHSMul.{u1, u2} R A (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_3 _inst_4)) r (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) x y))
Case conversion may be inaccurate. Consider using '#align algebra.smul_mul_assoc Algebra.smul_mul_assocₓ'. -/
/-- This is just a special case of the global `smul_mul_assoc` lemma that requires less typeclass
search (and was here first). -/
@[simp]
protected theorem smul_mul_assoc (r : R) (x y : A) : r • x * y = r • (x * y) :=
  smul_mul_assoc r x y
#align algebra.smul_mul_assoc Algebra.smul_mul_assoc

/- warning: smul_algebra_map -> smul_algebraMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] {α : Type.{u3}} [_inst_7 : Monoid.{u3} α] [_inst_8 : MulDistribMulAction.{u3, u2} α A _inst_7 (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_3))] [_inst_9 : SMulCommClass.{u3, u1, u2} α R A (MulAction.toHasSmul.{u3, u2} α A _inst_7 (MulDistribMulAction.toMulAction.{u3, u2} α A _inst_7 (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_3)) _inst_8)) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4)))))] (a : α) (r : R), Eq.{succ u2} A (SMul.smul.{u3, u2} α A (MulAction.toHasSmul.{u3, u2} α A _inst_7 (MulDistribMulAction.toMulAction.{u3, u2} α A _inst_7 (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_3)) _inst_8)) a (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r)
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Semiring.{u3} A] [_inst_4 : Algebra.{u2, u3} R A _inst_1 _inst_3] {α : Type.{u1}} [_inst_7 : Monoid.{u1} α] [_inst_8 : MulDistribMulAction.{u1, u3} α A _inst_7 (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_3))] [_inst_9 : SMulCommClass.{u1, u2, u3} α R A (MulAction.toSMul.{u1, u3} α A _inst_7 (MulDistribMulAction.toMulAction.{u1, u3} α A _inst_7 (MonoidWithZero.toMonoid.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_3)) _inst_8)) (Algebra.toSMul.{u2, u3} R A _inst_1 _inst_3 _inst_4)] (a : α) (r : R), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (HSMul.hSMul.{u1, u3, u3} α ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (instHSMul.{u1, u3} α ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (MulAction.toSMul.{u1, u3} α ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_7 (MulDistribMulAction.toMulAction.{u1, u3} α ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_7 (MonoidWithZero.toMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_3)) _inst_8))) a (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3) (RingHom.instRingHomClassRingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3))))) (algebraMap.{u2, u3} R A _inst_1 _inst_3 _inst_4) r)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3) (RingHom.instRingHomClassRingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3))))) (algebraMap.{u2, u3} R A _inst_1 _inst_3 _inst_4) r)
Case conversion may be inaccurate. Consider using '#align smul_algebra_map smul_algebraMapₓ'. -/
@[simp]
theorem smul_algebraMap {α : Type _} [Monoid α] [MulDistribMulAction α A] [SMulCommClass α R A]
    (a : α) (r : R) : a • algebraMap R A r = algebraMap R A r := by
  rw [algebra_map_eq_smul_one, smul_comm a r (1 : A), smul_one]
#align smul_algebra_map smul_algebraMap

section

variable {r : R} {a : A}

/- warning: algebra.bit0_smul_one clashes with [anonymous] -> [anonymous]
warning: algebra.bit0_smul_one -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] {r : R}, Eq.{succ u2} A (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))))) (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}}, (Nat -> R -> A) -> Nat -> (List.{u1} R) -> (List.{u2} A)
Case conversion may be inaccurate. Consider using '#align algebra.bit0_smul_one [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : bit0 r • (1 : A) = bit0 (r • (1 : A)) := by simp [bit0, add_smul]
#align algebra.bit0_smul_one [anonymous]

/- warning: algebra.bit0_smul_one' clashes with [anonymous] -> [anonymous]
warning: algebra.bit0_smul_one' -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] {r : R}, Eq.{succ u2} A (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))))) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (OfNat.ofNat.{u2} A 2 (OfNat.mk.{u2} A 2 (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}}, (Nat -> R -> A) -> Nat -> (List.{u1} R) -> (List.{u2} A)
Case conversion may be inaccurate. Consider using '#align algebra.bit0_smul_one' [anonymous]ₓ'. -/
theorem [anonymous] : bit0 r • (1 : A) = r • 2 := by simp [bit0, add_smul, smul_add]
#align algebra.bit0_smul_one' [anonymous]

/- warning: algebra.bit0_smul_bit0 clashes with [anonymous] -> [anonymous]
warning: algebra.bit0_smul_bit0 -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] {r : R} {a : A}, Eq.{succ u2} A (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r) (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) a)) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) a)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}}, (Nat -> R -> A) -> Nat -> (List.{u1} R) -> (List.{u2} A)
Case conversion may be inaccurate. Consider using '#align algebra.bit0_smul_bit0 [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : bit0 r • bit0 a = r • bit0 (bit0 a) := by simp [bit0, add_smul, smul_add]
#align algebra.bit0_smul_bit0 [anonymous]

/- warning: algebra.bit0_smul_bit1 clashes with [anonymous] -> [anonymous]
warning: algebra.bit0_smul_bit1 -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] {r : R} {a : A}, Eq.{succ u2} A (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) (bit0.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r) (bit1.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) a)) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (bit1.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) a)))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}}, (Nat -> R -> A) -> Nat -> (List.{u1} R) -> (List.{u2} A)
Case conversion may be inaccurate. Consider using '#align algebra.bit0_smul_bit1 [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : bit0 r • bit1 a = r • bit0 (bit1 a) := by simp [bit0, add_smul, smul_add]
#align algebra.bit0_smul_bit1 [anonymous]

/- warning: algebra.bit1_smul_one clashes with [anonymous] -> [anonymous]
warning: algebra.bit1_smul_one -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] {r : R}, Eq.{succ u2} A (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) (bit1.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))))) (bit1.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}}, (Nat -> R -> A) -> Nat -> (List.{u1} R) -> (List.{u2} A)
Case conversion may be inaccurate. Consider using '#align algebra.bit1_smul_one [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : bit1 r • (1 : A) = bit1 (r • (1 : A)) := by simp [bit1, add_smul]
#align algebra.bit1_smul_one [anonymous]

/- warning: algebra.bit1_smul_one' clashes with [anonymous] -> [anonymous]
warning: algebra.bit1_smul_one' -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] {r : R}, Eq.{succ u2} A (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) (bit1.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))))) (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (OfNat.ofNat.{u2} A 2 (OfNat.mk.{u2} A 2 (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))))))) (OfNat.ofNat.{u2} A 1 (OfNat.mk.{u2} A 1 (One.one.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}}, (Nat -> R -> A) -> Nat -> (List.{u1} R) -> (List.{u2} A)
Case conversion may be inaccurate. Consider using '#align algebra.bit1_smul_one' [anonymous]ₓ'. -/
theorem [anonymous] : bit1 r • (1 : A) = r • 2 + 1 := by simp [bit1, bit0, add_smul, smul_add]
#align algebra.bit1_smul_one' [anonymous]

/- warning: algebra.bit1_smul_bit0 clashes with [anonymous] -> [anonymous]
warning: algebra.bit1_smul_bit0 -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] {r : R} {a : A}, Eq.{succ u2} A (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) (bit1.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r) (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) a)) (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) a))) (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) a))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}}, (Nat -> R -> A) -> Nat -> (List.{u1} R) -> (List.{u2} A)
Case conversion may be inaccurate. Consider using '#align algebra.bit1_smul_bit0 [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : bit1 r • bit0 a = r • bit0 (bit0 a) + bit0 a := by
  simp [bit1, add_smul, smul_add]
#align algebra.bit1_smul_bit0 [anonymous]

/- warning: algebra.bit1_smul_bit1 clashes with [anonymous] -> [anonymous]
warning: algebra.bit1_smul_bit1 -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] {r : R} {a : A}, Eq.{succ u2} A (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) (bit1.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) r) (bit1.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) a)) (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (SMul.smul.{u1, u2} R A (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4))))) r (bit0.{u2} A (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (bit1.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) a))) (bit1.{u2} A (AddMonoidWithOne.toOne.{u2} A (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} A (NonAssocSemiring.toAddCommMonoidWithOne.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) (Distrib.toHasAdd.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)))) a))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}}, (Nat -> R -> A) -> Nat -> (List.{u1} R) -> (List.{u2} A)
Case conversion may be inaccurate. Consider using '#align algebra.bit1_smul_bit1 [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] : bit1 r • bit1 a = r • bit0 (bit1 a) + bit1 a :=
  by
  simp only [bit0, bit1, add_smul, smul_add, one_smul]
  abel
#align algebra.bit1_smul_bit1 [anonymous]

end

variable (R A)

#print Algebra.linearMap /-
/-- The canonical ring homomorphism `algebra_map R A : R →* A` for any `R`-algebra `A`,
packaged as an `R`-linear map.
-/
protected def linearMap : R →ₗ[R] A :=
  { algebraMap R A with map_smul' := fun x y => by simp [Algebra.smul_def] }
#align algebra.linear_map Algebra.linearMap
-/

/- warning: algebra.linear_map_apply -> Algebra.linearMap_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R), Eq.{succ u2} A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4)) (fun (_x : LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4)) => R -> A) (LinearMap.hasCoeToFun.{u1, u1, u1, u2} R R R A (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Algebra.linearMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r)
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => A) r) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => A) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u2} R R R A (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Algebra.linearMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r)
Case conversion may be inaccurate. Consider using '#align algebra.linear_map_apply Algebra.linearMap_applyₓ'. -/
@[simp]
theorem linearMap_apply (r : R) : Algebra.linearMap R A r = algebraMap R A r :=
  rfl
#align algebra.linear_map_apply Algebra.linearMap_apply

/- warning: algebra.coe_linear_map -> Algebra.coe_linearMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3], Eq.{max (succ u1) (succ u2)} (R -> A) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4)) (fun (_x : LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4)) => R -> A) (LinearMap.hasCoeToFun.{u1, u1, u1, u2} R R R A (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Algebra.linearMap.{u1, u2} R A _inst_1 _inst_3 _inst_4)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3], Eq.{max (succ u1) (succ u2)} (forall (ᾰ : R), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => A) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (LinearMap.{u1, u1, u1, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => A) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, u2} R R R A (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (Semiring.toModule.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Algebra.linearMap.{u1, u2} R A _inst_1 _inst_3 _inst_4)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3))))) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align algebra.coe_linear_map Algebra.coe_linearMapₓ'. -/
theorem coe_linearMap : ⇑(Algebra.linearMap R A) = algebraMap R A :=
  rfl
#align algebra.coe_linear_map Algebra.coe_linearMap

#print Algebra.id /-
instance id : Algebra R R :=
  (RingHom.id R).toAlgebra
#align algebra.id Algebra.id
-/

variable {R A}

namespace id

#print Algebra.id.map_eq_id /-
@[simp]
theorem map_eq_id : algebraMap R R = RingHom.id _ :=
  rfl
#align algebra.id.map_eq_id Algebra.id.map_eq_id
-/

/- warning: algebra.id.map_eq_self -> Algebra.id.map_eq_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (x : R), Eq.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => R -> R) (RingHom.hasCoeToFun.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (algebraMap.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)) x) x
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) x) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} R R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (algebraMap.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)) x) x
Case conversion may be inaccurate. Consider using '#align algebra.id.map_eq_self Algebra.id.map_eq_selfₓ'. -/
theorem map_eq_self (x : R) : algebraMap R R x = x :=
  rfl
#align algebra.id.map_eq_self Algebra.id.map_eq_self

/- warning: algebra.id.smul_eq_mul -> Algebra.id.smul_eq_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (x : R) (y : R), Eq.{succ u1} R (SMul.smul.{u1, u1} R R (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x y) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x y)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (x : R) (y : R), Eq.{succ u1} R (HSMul.hSMul.{u1, u1, u1} R R R (instHSMul.{u1, u1} R R (Algebra.toSMul.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1))) x y) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) x y)
Case conversion may be inaccurate. Consider using '#align algebra.id.smul_eq_mul Algebra.id.smul_eq_mulₓ'. -/
@[simp]
theorem smul_eq_mul (x y : R) : x • y = x * y :=
  rfl
#align algebra.id.smul_eq_mul Algebra.id.smul_eq_mul

end id

section PUnit

#print PUnit.algebra /-
instance PUnit.algebra : Algebra R PUnit
    where
  toFun x := PUnit.unit
  map_one' := rfl
  map_mul' _ _ := rfl
  map_zero' := rfl
  map_add' _ _ := rfl
  commutes' _ _ := rfl
  smul_def' _ _ := rfl
#align punit.algebra PUnit.algebra
-/

/- warning: algebra.algebra_map_punit -> Algebra.algebraMap_pUnit is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (r : R), Eq.{succ u2} PUnit.{succ u2} (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R PUnit.{succ u2} (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} PUnit.{succ u2} (Ring.toSemiring.{u2} PUnit.{succ u2} (CommRing.toRing.{u2} PUnit.{succ u2} PUnit.commRing.{u2})))) (fun (_x : RingHom.{u1, u2} R PUnit.{succ u2} (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} PUnit.{succ u2} (Ring.toSemiring.{u2} PUnit.{succ u2} (CommRing.toRing.{u2} PUnit.{succ u2} PUnit.commRing.{u2})))) => R -> PUnit.{succ u2}) (RingHom.hasCoeToFun.{u1, u2} R PUnit.{succ u2} (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} PUnit.{succ u2} (Ring.toSemiring.{u2} PUnit.{succ u2} (CommRing.toRing.{u2} PUnit.{succ u2} PUnit.commRing.{u2})))) (algebraMap.{u1, u2} R PUnit.{succ u2} _inst_1 (Ring.toSemiring.{u2} PUnit.{succ u2} (CommRing.toRing.{u2} PUnit.{succ u2} PUnit.commRing.{u2})) (PUnit.algebra.{u1, u2} R _inst_1)) r) PUnit.unit.{succ u2}
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => PUnit.{succ u1}) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R PUnit.{succ u1} (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} PUnit.{succ u1} (Ring.toSemiring.{u1} PUnit.{succ u1} (CommRing.toRing.{u1} PUnit.{succ u1} PUnit.commRing.{u1})))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => PUnit.{succ u1}) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R PUnit.{succ u1} (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} PUnit.{succ u1} (Ring.toSemiring.{u1} PUnit.{succ u1} (CommRing.toRing.{u1} PUnit.{succ u1} PUnit.commRing.{u1})))) R PUnit.{succ u1} (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} PUnit.{succ u1} (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} PUnit.{succ u1} (Semiring.toNonAssocSemiring.{u1} PUnit.{succ u1} (Ring.toSemiring.{u1} PUnit.{succ u1} (CommRing.toRing.{u1} PUnit.{succ u1} PUnit.commRing.{u1}))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R PUnit.{succ u1} (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} PUnit.{succ u1} (Ring.toSemiring.{u1} PUnit.{succ u1} (CommRing.toRing.{u1} PUnit.{succ u1} PUnit.commRing.{u1})))) R PUnit.{succ u1} (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} PUnit.{succ u1} (Semiring.toNonAssocSemiring.{u1} PUnit.{succ u1} (Ring.toSemiring.{u1} PUnit.{succ u1} (CommRing.toRing.{u1} PUnit.{succ u1} PUnit.commRing.{u1})))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R PUnit.{succ u1} (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} PUnit.{succ u1} (Ring.toSemiring.{u1} PUnit.{succ u1} (CommRing.toRing.{u1} PUnit.{succ u1} PUnit.commRing.{u1})))) R PUnit.{succ u1} (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} PUnit.{succ u1} (Ring.toSemiring.{u1} PUnit.{succ u1} (CommRing.toRing.{u1} PUnit.{succ u1} PUnit.commRing.{u1}))) (RingHom.instRingHomClassRingHom.{u2, u1} R PUnit.{succ u1} (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} PUnit.{succ u1} (Ring.toSemiring.{u1} PUnit.{succ u1} (CommRing.toRing.{u1} PUnit.{succ u1} PUnit.commRing.{u1}))))))) (algebraMap.{u2, u1} R PUnit.{succ u1} _inst_1 (Ring.toSemiring.{u1} PUnit.{succ u1} (CommRing.toRing.{u1} PUnit.{succ u1} PUnit.commRing.{u1})) (PUnit.algebra.{u2, u1} R _inst_1)) r) PUnit.unit.{succ u1}
Case conversion may be inaccurate. Consider using '#align algebra.algebra_map_punit Algebra.algebraMap_pUnitₓ'. -/
@[simp]
theorem algebraMap_pUnit (r : R) : algebraMap R PUnit r = PUnit.unit :=
  rfl
#align algebra.algebra_map_punit Algebra.algebraMap_pUnit

end PUnit

section ULift

#print ULift.algebra /-
instance ULift.algebra : Algebra R (ULift A) :=
  { ULift.module',
    (ULift.ringEquiv : ULift A ≃+* A).symm.toRingHom.comp
      (algebraMap R A) with
    toFun := fun r => ULift.up (algebraMap R A r)
    commutes' := fun r x => ULift.down_injective <| Algebra.commutes r x.down
    smul_def' := fun r x => ULift.down_injective <| Algebra.smul_def' r x.down }
#align ulift.algebra ULift.algebra
-/

/- warning: ulift.algebra_map_eq -> ULift.algebraMap_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R), Eq.{succ (max u2 u3)} (ULift.{u3, u2} A) (coeFn.{max (succ u1) (succ (max u2 u3)), max (succ u1) (succ (max u2 u3))} (RingHom.{u1, max u2 u3} R (ULift.{u3, u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (ULift.{u3, u2} A) (ULift.semiring.{u2, u3} A _inst_3))) (fun (_x : RingHom.{u1, max u2 u3} R (ULift.{u3, u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (ULift.{u3, u2} A) (ULift.semiring.{u2, u3} A _inst_3))) => R -> (ULift.{u3, u2} A)) (RingHom.hasCoeToFun.{u1, max u2 u3} R (ULift.{u3, u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (ULift.{u3, u2} A) (ULift.semiring.{u2, u3} A _inst_3))) (algebraMap.{u1, max u2 u3} R (ULift.{u3, u2} A) _inst_1 (ULift.semiring.{u2, u3} A _inst_3) (ULift.algebra.{u1, u2, u3} R A _inst_1 _inst_3 _inst_4)) r) (ULift.up.{u3, u2} A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Semiring.{u3} A] [_inst_4 : Algebra.{u2, u3} R A _inst_1 _inst_3] (r : R), Eq.{max (succ u3) (succ u1)} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => ULift.{u1, u3} A) r) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u2, max (succ u3) (succ u1)} (RingHom.{u2, max u3 u1} R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => ULift.{u1, u3} A) _x) (MulHomClass.toFunLike.{max (max u2 u3) u1, u2, max u3 u1} (RingHom.{u2, max u3 u1} R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3))) R (ULift.{u1, u3} A) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u3 u1} (ULift.{u1, u3} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max (max u2 u3) u1, u2, max u3 u1} (RingHom.{u2, max u3 u1} R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3))) R (ULift.{u1, u3} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max (max u2 u3) u1, u2, max u3 u1} (RingHom.{u2, max u3 u1} R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3))) R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3)) (RingHom.instRingHomClassRingHom.{u2, max u3 u1} R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3)))))) (algebraMap.{u2, max u3 u1} R (ULift.{u1, u3} A) _inst_1 (ULift.semiring.{u3, u1} A _inst_3) (ULift.algebra.{u2, u3, u1} R A _inst_1 _inst_3 _inst_4)) r) (ULift.up.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3) (RingHom.instRingHomClassRingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3))))) (algebraMap.{u2, u3} R A _inst_1 _inst_3 _inst_4) r))
Case conversion may be inaccurate. Consider using '#align ulift.algebra_map_eq ULift.algebraMap_eqₓ'. -/
theorem ULift.algebraMap_eq (r : R) : algebraMap R (ULift A) r = ULift.up (algebraMap R A r) :=
  rfl
#align ulift.algebra_map_eq ULift.algebraMap_eq

/- warning: ulift.down_algebra_map -> ULift.down_algebraMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (r : R), Eq.{succ u2} A (ULift.down.{u3, u2} A (coeFn.{max (succ u1) (succ (max u2 u3)), max (succ u1) (succ (max u2 u3))} (RingHom.{u1, max u2 u3} R (ULift.{u3, u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (ULift.{u3, u2} A) (ULift.semiring.{u2, u3} A _inst_3))) (fun (_x : RingHom.{u1, max u2 u3} R (ULift.{u3, u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (ULift.{u3, u2} A) (ULift.semiring.{u2, u3} A _inst_3))) => R -> (ULift.{u3, u2} A)) (RingHom.hasCoeToFun.{u1, max u2 u3} R (ULift.{u3, u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{max u2 u3} (ULift.{u3, u2} A) (ULift.semiring.{u2, u3} A _inst_3))) (algebraMap.{u1, max u2 u3} R (ULift.{u3, u2} A) _inst_1 (ULift.semiring.{u2, u3} A _inst_3) (ULift.algebra.{u1, u2, u3} R A _inst_1 _inst_3 _inst_4)) r)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_3)) (algebraMap.{u1, u2} R A _inst_1 _inst_3 _inst_4) r)
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u3}} [_inst_1 : CommSemiring.{u2} R] [_inst_3 : Semiring.{u3} A] [_inst_4 : Algebra.{u2, u3} R A _inst_1 _inst_3] (r : R), Eq.{succ u3} A (ULift.down.{u1, u3} A (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u2, max (succ u3) (succ u1)} (RingHom.{u2, max u3 u1} R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => ULift.{u1, u3} A) _x) (MulHomClass.toFunLike.{max (max u2 u3) u1, u2, max u3 u1} (RingHom.{u2, max u3 u1} R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3))) R (ULift.{u1, u3} A) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{max u3 u1} (ULift.{u1, u3} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max (max u2 u3) u1, u2, max u3 u1} (RingHom.{u2, max u3 u1} R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3))) R (ULift.{u1, u3} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max (max u2 u3) u1, u2, max u3 u1} (RingHom.{u2, max u3 u1} R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3))) R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3)) (RingHom.instRingHomClassRingHom.{u2, max u3 u1} R (ULift.{u1, u3} A) (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{max u3 u1} (ULift.{u1, u3} A) (ULift.semiring.{u3, u1} A _inst_3)))))) (algebraMap.{u2, max u3 u1} R (ULift.{u1, u3} A) _inst_1 (ULift.semiring.{u3, u1} A _inst_3) (ULift.algebra.{u2, u3, u1} R A _inst_1 _inst_3 _inst_4)) r)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3)) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3) (RingHom.instRingHomClassRingHom.{u2, u3} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} A _inst_3))))) (algebraMap.{u2, u3} R A _inst_1 _inst_3 _inst_4) r)
Case conversion may be inaccurate. Consider using '#align ulift.down_algebra_map ULift.down_algebraMapₓ'. -/
@[simp]
theorem ULift.down_algebraMap (r : R) : (algebraMap R (ULift A) r).down = algebraMap R A r :=
  rfl
#align ulift.down_algebra_map ULift.down_algebraMap

end ULift

/- warning: algebra.of_subsemiring -> Algebra.ofSubsemiring is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (S : Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))), Algebra.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) A (Subsemiring.toCommSemiring.{u1} R _inst_1 S) _inst_3
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_3 : Semiring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_3] (S : Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))), Algebra.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) A (Subsemiring.toCommSemiring.{u1} R _inst_1 S) _inst_3
Case conversion may be inaccurate. Consider using '#align algebra.of_subsemiring Algebra.ofSubsemiringₓ'. -/
/-- Algebra over a subsemiring. This builds upon `subsemiring.module`. -/
instance ofSubsemiring (S : Subsemiring R) : Algebra S A :=
  { (algebraMap R A).comp S.Subtype with
    smul := (· • ·)
    commutes' := fun r x => Algebra.commutes r x
    smul_def' := fun r x => Algebra.smul_def r x }
#align algebra.of_subsemiring Algebra.ofSubsemiring

/- warning: algebra.algebra_map_of_subsemiring -> Algebra.algebraMap_ofSubsemiring is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (S : Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))), Eq.{succ u1} (RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (algebraMap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Subsemiring.toCommSemiring.{u1} R _inst_1 S) (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.ofSubsemiring.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1) S)) (Subsemiring.subtype.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) S)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (S : Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))), Eq.{succ u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (algebraMap.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Subsemiring.toCommSemiring.{u1} R _inst_1 S) (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.ofSubsemiring.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1) S)) (Subsemiring.subtype.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) S)
Case conversion may be inaccurate. Consider using '#align algebra.algebra_map_of_subsemiring Algebra.algebraMap_ofSubsemiringₓ'. -/
theorem algebraMap_ofSubsemiring (S : Subsemiring R) :
    (algebraMap S R : S →+* R) = Subsemiring.subtype S :=
  rfl
#align algebra.algebra_map_of_subsemiring Algebra.algebraMap_ofSubsemiring

/- warning: algebra.coe_algebra_map_of_subsemiring -> Algebra.coe_algebraMap_ofSubsemiring is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (S : Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))), Eq.{succ u1} ((fun (_x : RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) -> R) (algebraMap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Subsemiring.toCommSemiring.{u1} R _inst_1 S) (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.ofSubsemiring.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1) S))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) -> R) (RingHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (algebraMap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Subsemiring.toCommSemiring.{u1} R _inst_1 S) (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.ofSubsemiring.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1) S))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (S : Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))), Eq.{succ u1} (forall (a : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) => R) a) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (fun (_x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (algebraMap.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Subsemiring.toCommSemiring.{u1} R _inst_1 S) (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.ofSubsemiring.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1) S))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S))
Case conversion may be inaccurate. Consider using '#align algebra.coe_algebra_map_of_subsemiring Algebra.coe_algebraMap_ofSubsemiringₓ'. -/
theorem coe_algebraMap_ofSubsemiring (S : Subsemiring R) : (algebraMap S R : S → R) = Subtype.val :=
  rfl
#align algebra.coe_algebra_map_of_subsemiring Algebra.coe_algebraMap_ofSubsemiring

/- warning: algebra.algebra_map_of_subsemiring_apply -> Algebra.algebraMap_ofSubsemiring_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (S : Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (x : coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S), Eq.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) => (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) -> R) (RingHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (algebraMap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (Subsemiring.toCommSemiring.{u1} R _inst_1 S) (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.ofSubsemiring.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1) S)) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.setLike.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S))))) x)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (S : Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) => R) x) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (fun (_x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) (Subsemiring.toCommSemiring.{u1} R _inst_1 S))) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) (algebraMap.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.instMembership.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) x S)) R (Subsemiring.toCommSemiring.{u1} R _inst_1 S) (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.ofSubsemiring.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1) S)) x) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Subsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) R (Subsemiring.instSetLikeSubsemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) S)) x)
Case conversion may be inaccurate. Consider using '#align algebra.algebra_map_of_subsemiring_apply Algebra.algebraMap_ofSubsemiring_applyₓ'. -/
theorem algebraMap_ofSubsemiring_apply (S : Subsemiring R) (x : S) : algebraMap S R x = x :=
  rfl
#align algebra.algebra_map_of_subsemiring_apply Algebra.algebraMap_ofSubsemiring_apply

/- warning: algebra.of_subring -> Algebra.ofSubring is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_7 : CommRing.{u1} R] [_inst_8 : Ring.{u2} A] [_inst_9 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_7) (Ring.toSemiring.{u2} A _inst_8)] (S : Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)), Algebra.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) A (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Algebra.ofSubring._proof_1.{u1} R _inst_7)) (Ring.toSemiring.{u2} A _inst_8)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_7 : CommRing.{u1} R] [_inst_8 : Ring.{u2} A] [_inst_9 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_7) (Ring.toSemiring.{u2} A _inst_8)] (S : Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)), Algebra.{u1, u2} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) A (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)) (Ring.toSemiring.{u2} A _inst_8)
Case conversion may be inaccurate. Consider using '#align algebra.of_subring Algebra.ofSubringₓ'. -/
/-- Algebra over a subring. This builds upon `subring.module`. -/
instance ofSubring {R A : Type _} [CommRing R] [Ring A] [Algebra R A] (S : Subring R) :
    Algebra S A :=
  { Algebra.ofSubsemiring S.toSubsemiring, (algebraMap R A).comp S.Subtype with smul := (· • ·) }
#align algebra.of_subring Algebra.ofSubring

/- warning: algebra.algebra_map_of_subring -> Algebra.algebraMap_ofSubring is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_7 : CommRing.{u1} R] (S : Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)), Eq.{succ u1} (RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (algebraMap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Algebra.ofSubring.{u1, u1} R R _inst_7 (CommRing.toRing.{u1} R _inst_7) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_7)) S)) (Subring.subtype.{u1} R (CommRing.toRing.{u1} R _inst_7) S)
but is expected to have type
  forall {R : Type.{u1}} [_inst_7 : CommRing.{u1} R] (S : Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)), Eq.{succ u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (algebraMap.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Algebra.ofSubring.{u1, u1} R R _inst_7 (CommRing.toRing.{u1} R _inst_7) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_7)) S)) (Subring.subtype.{u1} R (CommRing.toRing.{u1} R _inst_7) S)
Case conversion may be inaccurate. Consider using '#align algebra.algebra_map_of_subring Algebra.algebraMap_ofSubringₓ'. -/
theorem algebraMap_ofSubring {R : Type _} [CommRing R] (S : Subring R) :
    (algebraMap S R : S →+* R) = Subring.subtype S :=
  rfl
#align algebra.algebra_map_of_subring Algebra.algebraMap_ofSubring

/- warning: algebra.coe_algebra_map_of_subring -> Algebra.coe_algebraMap_ofSubring is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_7 : CommRing.{u1} R] (S : Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)), Eq.{succ u1} ((fun (_x : RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) => (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) -> R) (algebraMap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Algebra.ofSubring.{u1, u1} R R _inst_7 (CommRing.toRing.{u1} R _inst_7) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_7)) S))) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (fun (_x : RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) => (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) -> R) (RingHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (algebraMap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Algebra.ofSubring.{u1, u1} R R _inst_7 (CommRing.toRing.{u1} R _inst_7) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_7)) S))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.hasMem.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S))
but is expected to have type
  forall {R : Type.{u1}} [_inst_7 : CommRing.{u1} R] (S : Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)), Eq.{succ u1} (forall (a : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) => R) a) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (fun (_x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7))) (RingHom.instRingHomClassRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7))))))) (algebraMap.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Algebra.ofSubring.{u1, u1} R R _inst_7 (CommRing.toRing.{u1} R _inst_7) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_7)) S))) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S))
Case conversion may be inaccurate. Consider using '#align algebra.coe_algebra_map_of_subring Algebra.coe_algebraMap_ofSubringₓ'. -/
theorem coe_algebraMap_ofSubring {R : Type _} [CommRing R] (S : Subring R) :
    (algebraMap S R : S → R) = Subtype.val :=
  rfl
#align algebra.coe_algebra_map_of_subring Algebra.coe_algebraMap_ofSubring

/- warning: algebra.algebra_map_of_subring_apply -> Algebra.algebraMap_ofSubring_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_7 : CommRing.{u1} R] (S : Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (x : coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S), Eq.{succ u1} R (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (fun (_x : RingHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) => (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) -> R) (RingHom.hasCoeToFun.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (Semiring.toNonAssocSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (CommSemiring.toSemiring.{u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (algebraMap.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (SubsemiringClass.toCommSemiring.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S R (CommRing.toCommSemiring.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SubringClass.to_subsemiringClass.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (CommRing.toRing.{u1} R _inst_7) (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Subring.subringClass.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Algebra.ofSubring.{u1, u1} R R _inst_7 (CommRing.toRing.{u1} R _inst_7) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_7)) S)) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) S) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.hasMem.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.setLike.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S))))) x)
but is expected to have type
  forall {R : Type.{u1}} [_inst_7 : CommRing.{u1} R] (S : Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) => R) x) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (fun (_x : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) => R) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (NonUnitalNonAssocSemiring.toMul.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))))) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7))))) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)))) (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7))) (RingHom.instRingHomClassRingHom.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (Semiring.toNonAssocSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommSemiring.toSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)))) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7))))))) (algebraMap.{u1, u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) R (CommRing.toCommSemiring.{u1} (Subtype.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (SetLike.instMembership.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7))) x S)) (Subring.toCommRing.{u1} R _inst_7 S)) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_7)) (Algebra.ofSubring.{u1, u1} R R _inst_7 (CommRing.toRing.{u1} R _inst_7) (Algebra.id.{u1} R (CommRing.toCommSemiring.{u1} R _inst_7)) S)) x) (Subtype.val.{succ u1} R (fun (x : R) => Membership.mem.{u1, u1} R (Set.{u1} R) (Set.instMembershipSet.{u1} R) x (SetLike.coe.{u1, u1} (Subring.{u1} R (CommRing.toRing.{u1} R _inst_7)) R (Subring.instSetLikeSubring.{u1} R (CommRing.toRing.{u1} R _inst_7)) S)) x)
Case conversion may be inaccurate. Consider using '#align algebra.algebra_map_of_subring_apply Algebra.algebraMap_ofSubring_applyₓ'. -/
theorem algebraMap_ofSubring_apply {R : Type _} [CommRing R] (S : Subring R) (x : S) :
    algebraMap S R x = x :=
  rfl
#align algebra.algebra_map_of_subring_apply Algebra.algebraMap_ofSubring_apply

#print Algebra.algebraMapSubmonoid /-
/-- Explicit characterization of the submonoid map in the case of an algebra.
`S` is made explicit to help with type inference -/
def algebraMapSubmonoid (S : Type _) [Semiring S] [Algebra R S] (M : Submonoid R) : Submonoid S :=
  M.map (algebraMap R S)
#align algebra.algebra_map_submonoid Algebra.algebraMapSubmonoid
-/

/- warning: algebra.mem_algebra_map_submonoid_of_mem -> Algebra.mem_algebraMapSubmonoid_of_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {S : Type.{u2}} [_inst_7 : Semiring.{u2} S] [_inst_8 : Algebra.{u1, u2} R S _inst_1 _inst_7] {M : Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))} (x : coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) M), Membership.Mem.{u2, u2} S (Submonoid.{u2} S (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_7)))) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} S (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_7)))) S (Submonoid.setLike.{u2} S (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_7))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) (fun (_x : RingHom.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} S _inst_7)) (algebraMap.{u1, u2} R S _inst_1 _inst_7 _inst_8) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) M) R (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) M) R (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) M) R (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) M) R (coeSubtype.{succ u1} R (fun (x : R) => Membership.Mem.{u1, u1} R (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (SetLike.hasMem.{u1, u1} (Submonoid.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) R (Submonoid.setLike.{u1} R (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))))) x M))))) x)) (Algebra.algebraMapSubmonoid.{u1, u2} R _inst_1 S _inst_7 _inst_8 M)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] {S : Type.{u1}} [_inst_7 : Semiring.{u1} S] [_inst_8 : Algebra.{u2, u1} R S _inst_1 _inst_7] {M : Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))} (x : Subtype.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))) x M)), Membership.mem.{u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) M)) x)) (Submonoid.{u1} S (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_7)))) (SetLike.instMembership.{u1, u1} (Submonoid.{u1} S (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_7)))) S (Submonoid.instSetLikeSubmonoid.{u1} S (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_7))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S _inst_7)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S _inst_7)) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_7))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S _inst_7)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_7)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S _inst_7)) R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S _inst_7) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} S _inst_7))))) (algebraMap.{u2, u1} R S _inst_1 _inst_7 _inst_8) (Subtype.val.{succ u2} R (fun (x : R) => Membership.mem.{u2, u2} R (Set.{u2} R) (Set.instMembershipSet.{u2} R) x (SetLike.coe.{u2, u2} (Submonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) R (Submonoid.instSetLikeSubmonoid.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) M)) x)) (Algebra.algebraMapSubmonoid.{u2, u1} R _inst_1 S _inst_7 _inst_8 M)
Case conversion may be inaccurate. Consider using '#align algebra.mem_algebra_map_submonoid_of_mem Algebra.mem_algebraMapSubmonoid_of_memₓ'. -/
theorem mem_algebraMapSubmonoid_of_mem {S : Type _} [Semiring S] [Algebra R S] {M : Submonoid R}
    (x : M) : algebraMap R S x ∈ algebraMapSubmonoid S M :=
  Set.mem_image_of_mem (algebraMap R S) x.2
#align algebra.mem_algebra_map_submonoid_of_mem Algebra.mem_algebraMapSubmonoid_of_mem

end Semiring

section CommSemiring

variable [CommSemiring R]

/- warning: algebra.mul_sub_algebra_map_commutes -> Algebra.mul_sub_algebraMap_commutes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2)] (x : A) (r : R), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A _inst_2))) x (HSub.hSub.{u2, u2, u2} A A A (instHSub.{u2} A (SubNegMonoid.toHasSub.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddGroupWithOne.toAddGroup.{u2} A (NonAssocRing.toAddGroupWithOne.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2)))))) x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (algebraMap.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2) _inst_3) r))) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A _inst_2))) (HSub.hSub.{u2, u2, u2} A A A (instHSub.{u2} A (SubNegMonoid.toHasSub.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddGroupWithOne.toAddGroup.{u2} A (NonAssocRing.toAddGroupWithOne.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2)))))) x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (algebraMap.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2) _inst_3) r)) x)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2)] (x : A) (r : R), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2)))) x (HSub.hSub.{u2, u2, u2} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A (instHSub.{u2} A (Ring.toSub.{u2} A _inst_2)) x (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)))))) (algebraMap.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2) _inst_3) r))) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2)))) (HSub.hSub.{u2, u2, u2} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A (instHSub.{u2} A (Ring.toSub.{u2} A _inst_2)) x (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)))))) (algebraMap.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2) _inst_3) r)) x)
Case conversion may be inaccurate. Consider using '#align algebra.mul_sub_algebra_map_commutes Algebra.mul_sub_algebraMap_commutesₓ'. -/
theorem mul_sub_algebraMap_commutes [Ring A] [Algebra R A] (x : A) (r : R) :
    x * (x - algebraMap R A r) = (x - algebraMap R A r) * x := by rw [mul_sub, ← commutes, sub_mul]
#align algebra.mul_sub_algebra_map_commutes Algebra.mul_sub_algebraMap_commutes

/- warning: algebra.mul_sub_algebra_map_pow_commutes -> Algebra.mul_sub_algebraMap_pow_commutes is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2)] (x : A) (r : R) (n : Nat), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A _inst_2))) x (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (Ring.toMonoid.{u2} A _inst_2))) (HSub.hSub.{u2, u2, u2} A A A (instHSub.{u2} A (SubNegMonoid.toHasSub.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddGroupWithOne.toAddGroup.{u2} A (NonAssocRing.toAddGroupWithOne.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2)))))) x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (algebraMap.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2) _inst_3) r)) n)) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (Ring.toDistrib.{u2} A _inst_2))) (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (Ring.toMonoid.{u2} A _inst_2))) (HSub.hSub.{u2, u2, u2} A A A (instHSub.{u2} A (SubNegMonoid.toHasSub.{u2} A (AddGroup.toSubNegMonoid.{u2} A (AddGroupWithOne.toAddGroup.{u2} A (NonAssocRing.toAddGroupWithOne.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2)))))) x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (algebraMap.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2) _inst_3) r)) n) x)
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2)] (x : A) (r : R) (n : Nat), Eq.{succ u2} A (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2)))) x (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_2))))) (HSub.hSub.{u2, u2, u2} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A (instHSub.{u2} A (Ring.toSub.{u2} A _inst_2)) x (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)))))) (algebraMap.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2) _inst_3) r)) n)) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocRing.toMul.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2)))) (HPow.hPow.{u2, 0, u2} A Nat A (instHPow.{u2, 0} A Nat (Monoid.Pow.{u2} A (MonoidWithZero.toMonoid.{u2} A (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_2))))) (HSub.hSub.{u2, u2, u2} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A (instHSub.{u2} A (Ring.toSub.{u2} A _inst_2)) x (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)))))) (algebraMap.{u1, u2} R A _inst_1 (Ring.toSemiring.{u2} A _inst_2) _inst_3) r)) n) x)
Case conversion may be inaccurate. Consider using '#align algebra.mul_sub_algebra_map_pow_commutes Algebra.mul_sub_algebraMap_pow_commutesₓ'. -/
theorem mul_sub_algebraMap_pow_commutes [Ring A] [Algebra R A] (x : A) (r : R) (n : ℕ) :
    x * (x - algebraMap R A r) ^ n = (x - algebraMap R A r) ^ n * x :=
  by
  induction' n with n ih
  · simp
  · rw [pow_succ, ← mul_assoc, mul_sub_algebra_map_commutes, mul_assoc, ih, ← mul_assoc]
#align algebra.mul_sub_algebra_map_pow_commutes Algebra.mul_sub_algebraMap_pow_commutes

end CommSemiring

section Ring

variable [CommRing R]

variable (R)

#print Algebra.semiringToRing /-
/-- A `semiring` that is an `algebra` over a commutative ring carries a natural `ring` structure.
See note [reducible non-instances]. -/
@[reducible]
def semiringToRing [Semiring A] [Algebra R A] : Ring A :=
  { Module.addCommMonoidToAddCommGroup R, (inferInstance : Semiring A) with }
#align algebra.semiring_to_ring Algebra.semiringToRing
-/

end Ring

end Algebra

namespace MulOpposite

variable {R A : Type _} [CommSemiring R] [Semiring A] [Algebra R A]

instance : Algebra R Aᵐᵒᵖ :=
  {
    MulOpposite.hasSmul A
      R with
    toRingHom := (algebraMap R A).toOpposite fun x y => Algebra.commutes _ _
    smul_def' := fun c x =>
      unop_injective <| by
        dsimp
        simp only [op_mul, Algebra.smul_def, Algebra.commutes, op_unop]
    commutes' := fun r =>
      MulOpposite.rec' fun x => by dsimp <;> simp only [← op_mul, Algebra.commutes] }

/- warning: mul_opposite.algebra_map_apply -> MulOpposite.algebraMap_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] (c : R), Eq.{succ u2} (MulOpposite.{u2} A) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2))) (fun (_x : RingHom.{u1, u2} R (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2))) => R -> (MulOpposite.{u2} A)) (RingHom.hasCoeToFun.{u1, u2} R (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2))) (algebraMap.{u1, u2} R (MulOpposite.{u2} A) _inst_1 (MulOpposite.semiring.{u2} A _inst_2) (MulOpposite.algebra.{u1, u2} R A _inst_1 _inst_2 _inst_3)) c) (MulOpposite.op.{u2} A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_3) c))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] (c : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MulOpposite.{u2} A) c) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => MulOpposite.{u2} A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2))) R (MulOpposite.{u2} A) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} (MulOpposite.{u2} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2))) R (MulOpposite.{u2} A) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2))) R (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2)) (RingHom.instRingHomClassRingHom.{u1, u2} R (MulOpposite.{u2} A) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (MulOpposite.{u2} A) (MulOpposite.semiring.{u2} A _inst_2)))))) (algebraMap.{u1, u2} R (MulOpposite.{u2} A) _inst_1 (MulOpposite.semiring.{u2} A _inst_2) (MulOpposite.instAlgebraMulOppositeSemiring.{u1, u2} R A _inst_1 _inst_2 _inst_3)) c) (MulOpposite.op.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) c) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_3) c))
Case conversion may be inaccurate. Consider using '#align mul_opposite.algebra_map_apply MulOpposite.algebraMap_applyₓ'. -/
@[simp]
theorem algebraMap_apply (c : R) : algebraMap R Aᵐᵒᵖ c = op (algebraMap R A c) :=
  rfl
#align mul_opposite.algebra_map_apply MulOpposite.algebraMap_apply

end MulOpposite

namespace Module

variable (R : Type u) (M : Type v) [CommSemiring R] [AddCommMonoid M] [Module R M]

instance : Algebra R (Module.End R M) :=
  Algebra.ofModule smul_mul_assoc fun r f g => (smul_comm r f g).symm

/- warning: module.algebra_map_End_eq_smul_id -> Module.algebraMap_end_eq_smul_id is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R), Eq.{succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (fun (_x : RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) => R -> (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.hasCoeToFun.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.algebra.{u1, u2} R M _inst_1 _inst_2 _inst_3)) a) (SMul.smul.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (LinearMap.hasSmul.{u1, u1, u1, u2, u2} R R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Module.toDistribMulAction.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (smulCommClass_self.{u1, u2} R M (CommSemiring.toCommMonoid.{u1} R _inst_1) (MulActionWithZero.toMulAction.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) a (LinearMap.id.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.instRingHomClassRingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.instAlgebraEndToSemiringSemiring.{u1, u2} R M _inst_1 _inst_2 _inst_3)) a) (HSMul.hSMul.{u1, u2, u2} R (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) a) (instHSMul.{u1, u2} R (LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) (LinearMap.instSMulLinearMap.{u1, u1, u1, u2, u2} R R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Module.toDistribMulAction.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (smulCommClass_self.{u1, u2} R M (CommSemiring.toCommMonoid.{u1} R _inst_1) (MulActionWithZero.toMulAction.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) a (LinearMap.id.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align module.algebra_map_End_eq_smul_id Module.algebraMap_end_eq_smul_idₓ'. -/
theorem algebraMap_end_eq_smul_id (a : R) : (algebraMap R (End R M)) a = a • LinearMap.id :=
  rfl
#align module.algebra_map_End_eq_smul_id Module.algebraMap_end_eq_smul_id

/- warning: module.algebra_map_End_apply -> Module.algebraMap_end_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R) (m : M), Eq.{succ u2} M (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (fun (_x : RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) => R -> (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.hasCoeToFun.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.algebra.{u1, u2} R M _inst_1 _inst_2 _inst_3)) a) m) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) a m)
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (a : R) (m : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) m) (FunLike.coe.{succ u2, succ u2, succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) a) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.instRingHomClassRingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.instAlgebraEndToSemiringSemiring.{u1, u2} R M _inst_1 _inst_2 _inst_3)) a) m) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) a m)
Case conversion may be inaccurate. Consider using '#align module.algebra_map_End_apply Module.algebraMap_end_applyₓ'. -/
@[simp]
theorem algebraMap_end_apply (a : R) (m : M) : (algebraMap R (End R M)) a m = a • m :=
  rfl
#align module.algebra_map_End_apply Module.algebraMap_end_apply

/- warning: module.ker_algebra_map_End -> Module.ker_algebraMap_end is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_4 : Field.{u1} K] [_inst_5 : AddCommGroup.{u2} V] [_inst_6 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5)] (a : K), (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))))))))))) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (LinearMap.ker.{u1, u1, u2, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6 _inst_6 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))))) (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6 _inst_6 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} K (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6))) (fun (_x : RingHom.{u1, u2} K (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6))) => K -> (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6)) (RingHom.hasCoeToFun.{u1, u2} K (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6))) (algebraMap.{u1, u2} K (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)) (Module.End.semiring.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.algebra.{u1, u2} K V (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6)) a)) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6)))
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_4 : Field.{u1} K] [_inst_5 : AddCommGroup.{u2} V] [_inst_6 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5)] (a : K), (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommGroupWithZero.toCommMonoidWithZero.{u1} K (Semifield.toCommGroupWithZero.{u1} K (Field.toSemifield.{u1} K _inst_4))))))) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (LinearMap.ker.{u1, u1, u2, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6 _inst_6 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))))) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) a) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6 _inst_6 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} K (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6))) K (fun (_x : K) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : K) => Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} K (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6))) K (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (NonUnitalNonAssocSemiring.toMul.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))))) (NonUnitalNonAssocSemiring.toMul.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} K (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6))) K (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} K (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6))) K (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6)) (RingHom.instRingHomClassRingHom.{u1, u2} K (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semiring.toNonAssocSemiring.{u1} K (CommSemiring.toSemiring.{u1} K (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)))) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.End.semiring.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6)))))) (algebraMap.{u1, u2} K (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)) (Module.End.semiring.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Module.instAlgebraEndToSemiringSemiring.{u1, u2} K V (Semifield.toCommSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6)) a)) (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_4))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_5) _inst_6)))
Case conversion may be inaccurate. Consider using '#align module.ker_algebra_map_End Module.ker_algebraMap_endₓ'. -/
@[simp]
theorem ker_algebraMap_end (K : Type u) (V : Type v) [Field K] [AddCommGroup V] [Module K V] (a : K)
    (ha : a ≠ 0) : ((algebraMap K (End K V)) a).ker = ⊥ :=
  LinearMap.ker_smul _ _ ha
#align module.ker_algebra_map_End Module.ker_algebraMap_end

section

variable {R M}

/- warning: module.End_is_unit_apply_inv_apply_of_is_unit -> Module.End_isUnit_apply_inv_apply_of_isUnit is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {f : Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} (h : IsUnit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f) (x : M), Eq.{succ u2} M (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Units.inv.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (IsUnit.unit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f h)) x)) x
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {f : Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} (h : IsUnit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f) (x : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (fun (a : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Units.inv.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (IsUnit.unit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f h)) x)) (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Units.inv.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (IsUnit.unit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f h)) x)) x
Case conversion may be inaccurate. Consider using '#align module.End_is_unit_apply_inv_apply_of_is_unit Module.End_isUnit_apply_inv_apply_of_isUnitₓ'. -/
theorem End_isUnit_apply_inv_apply_of_isUnit {f : Module.End R M} (h : IsUnit f) (x : M) :
    f (h.Unit.inv x) = x :=
  show (f * h.Unit.inv) x = x by simp
#align module.End_is_unit_apply_inv_apply_of_is_unit Module.End_isUnit_apply_inv_apply_of_isUnit

/- warning: module.End_is_unit_inv_apply_apply_of_is_unit -> Module.End_isUnit_inv_apply_apply_of_isUnit is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {f : Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} (h : IsUnit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f) (x : M), Eq.{succ u2} M (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Units.inv.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (IsUnit.unit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f h)) (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f x)) x
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {f : Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3} (h : IsUnit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f) (x : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (fun (a : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f x)) (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Units.inv.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (IsUnit.unit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f h)) (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f x)) x
Case conversion may be inaccurate. Consider using '#align module.End_is_unit_inv_apply_apply_of_is_unit Module.End_isUnit_inv_apply_apply_of_isUnitₓ'. -/
theorem End_isUnit_inv_apply_apply_of_isUnit {f : Module.End R M} (h : IsUnit f) (x : M) :
    h.Unit.inv (f x) = x :=
  (by simp : (h.Unit.inv * f) x = x)
#align module.End_is_unit_inv_apply_apply_of_is_unit Module.End_isUnit_inv_apply_apply_of_isUnit

/- warning: module.End_is_unit_iff -> Module.End_isUnit_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (f : Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3), Iff (IsUnit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f) (Function.Bijective.{succ u2, succ u2} M M (coeFn.{succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] (f : Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3), Iff (IsUnit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) f) (Function.Bijective.{succ u2, succ u2} M M (FunLike.coe.{succ u2, succ u2, succ u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f))
Case conversion may be inaccurate. Consider using '#align module.End_is_unit_iff Module.End_isUnit_iffₓ'. -/
theorem End_isUnit_iff (f : Module.End R M) : IsUnit f ↔ Function.Bijective f :=
  ⟨fun h =>
    Function.bijective_iff_has_inverse.mpr <|
      ⟨h.Unit.inv,
        ⟨End_isUnit_inv_apply_apply_of_isUnit h, End_isUnit_apply_inv_apply_of_isUnit h⟩⟩,
    fun H =>
    let e : M ≃ₗ[R] M := { f, Equiv.ofBijective f H with }
    ⟨⟨_, e.symm, LinearMap.ext e.right_inv, LinearMap.ext e.left_inv⟩, rfl⟩⟩
#align module.End_is_unit_iff Module.End_isUnit_iff

/- warning: module.End_algebra_map_is_unit_inv_apply_eq_iff -> Module.End_algebraMap_isUnit_inv_apply_eq_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {x : R} (h : IsUnit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (fun (_x : RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) => R -> (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.hasCoeToFun.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.algebra.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x)) (m : M) (m' : M), Iff (Eq.{succ u2} M (coeFn.{succ u2, succ u2} (Units.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (fun (x : Units.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) => M -> M) (coeFnTrans.{succ u2, succ u2, succ u2} (Units.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (coeBaseAux.{succ u2, succ u2} (Units.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Units.hasCoe.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (Inv.inv.{u2} (Units.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Units.hasInv.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (IsUnit.unit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (fun (_x : RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) => R -> (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.hasCoeToFun.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.algebra.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x) h)) m) m') (Eq.{succ u2} M m (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) x m'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {x : R} (h : IsUnit.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.instRingHomClassRingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.instAlgebraEndToSemiringSemiring.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x)) (m : M) (m' : M), Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) m) (FunLike.coe.{succ u2, succ u2, succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) M (fun (x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Units.val.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Inv.inv.{u2} (Units.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Units.instInvUnits.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (IsUnit.unit.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) a) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.instRingHomClassRingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.instAlgebraEndToSemiringSemiring.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x) h))) m) m') (Eq.{succ u2} M m (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) x m'))
Case conversion may be inaccurate. Consider using '#align module.End_algebra_map_is_unit_inv_apply_eq_iff Module.End_algebraMap_isUnit_inv_apply_eq_iffₓ'. -/
theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}
    (h : IsUnit (algebraMap R (Module.End R M) x)) (m m' : M) : h.Unit⁻¹ m = m' ↔ m = x • m' :=
  { mp := fun H => ((congr_arg h.Unit H).symm.trans (End_isUnit_apply_inv_apply_of_isUnit h _)).symm
    mpr := fun H =>
      H.symm ▸ by
        apply_fun h.unit using ((Module.End_isUnit_iff _).mp h).Injective
        erw [End_is_unit_apply_inv_apply_of_is_unit]
        rfl }
#align module.End_algebra_map_is_unit_inv_apply_eq_iff Module.End_algebraMap_isUnit_inv_apply_eq_iff

/- warning: module.End_algebra_map_is_unit_inv_apply_eq_iff' -> Module.End_algebraMap_isUnit_inv_apply_eq_iff' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {x : R} (h : IsUnit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (fun (_x : RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) => R -> (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.hasCoeToFun.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.algebra.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x)) (m : M) (m' : M), Iff (Eq.{succ u2} M m' (coeFn.{succ u2, succ u2} (Units.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (fun (x : Units.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) => M -> M) (coeFnTrans.{succ u2, succ u2, succ u2} (Units.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M M _inst_2 _inst_2 _inst_3 _inst_3) => M -> M) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (coeBaseAux.{succ u2, succ u2} (Units.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Units.hasCoe.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (Inv.inv.{u2} (Units.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Units.hasInv.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (IsUnit.unit.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (fun (_x : RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) => R -> (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.hasCoeToFun.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.algebra.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x) h)) m)) (Eq.{succ u2} M m (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) x m'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] {x : R} (h : IsUnit.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.instRingHomClassRingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.instAlgebraEndToSemiringSemiring.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x)) (m : M) (m' : M), Iff (Eq.{succ u2} M m' (FunLike.coe.{succ u2, succ u2, succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) M (fun (x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => M) x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} R R M M (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_2 _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (Units.val.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Inv.inv.{u2} (Units.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (Units.instInvUnits.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (IsUnit.unit.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) x) (Module.End.monoid.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) a) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))) R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)) (RingHom.instRingHomClassRingHom.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3)))))) (algebraMap.{u1, u2} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3) (Module.instAlgebraEndToSemiringSemiring.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x) h))) m)) (Eq.{succ u2} M m (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3))))) x m'))
Case conversion may be inaccurate. Consider using '#align module.End_algebra_map_is_unit_inv_apply_eq_iff' Module.End_algebraMap_isUnit_inv_apply_eq_iff'ₓ'. -/
theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R}
    (h : IsUnit (algebraMap R (Module.End R M) x)) (m m' : M) : m' = h.Unit⁻¹ m ↔ m = x • m' :=
  { mp := fun H => ((congr_arg h.Unit H).trans (End_isUnit_apply_inv_apply_of_isUnit h _)).symm
    mpr := fun H =>
      H.symm ▸ by
        apply_fun h.unit using ((Module.End_isUnit_iff _).mp h).Injective
        erw [End_is_unit_apply_inv_apply_of_is_unit]
        rfl }
#align module.End_algebra_map_is_unit_inv_apply_eq_iff' Module.End_algebraMap_isUnit_inv_apply_eq_iff'

end

end Module

namespace LinearMap

variable {R : Type _} {A : Type _} {B : Type _} [CommSemiring R] [Semiring A] [Semiring B]
  [Algebra R A] [Algebra R B]

/- warning: linear_map.map_algebra_map_mul -> LinearMap.map_algebraMap_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Semiring.{u3} B] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_5 : Algebra.{u1, u3} R B _inst_1 _inst_3] (f : LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5)) (a : A) (r : R), Eq.{succ u3} B (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5)) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5)) => A -> B) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R A B (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_4) r) a)) (HMul.hMul.{u3, u3, u3} B B B (instHMul.{u3} B (Distrib.toHasMul.{u3} B (NonUnitalNonAssocSemiring.toDistrib.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} B _inst_3)) (fun (_x : RingHom.{u1, u3} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} B _inst_3)) => R -> B) (RingHom.hasCoeToFun.{u1, u3} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} B _inst_3)) (algebraMap.{u1, u3} R B _inst_1 _inst_3 _inst_5) r) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5)) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5)) => A -> B) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R A B (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f a))
but is expected to have type
  forall {R : Type.{u3}} {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommSemiring.{u3} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Semiring.{u1} B] [_inst_4 : Algebra.{u3, u2} R A _inst_1 _inst_2] [_inst_5 : Algebra.{u3, u1} R B _inst_1 _inst_3] (f : LinearMap.{u3, u3, u2, u1} R R (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (Algebra.toModule.{u3, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u3, u1} R B _inst_1 _inst_3 _inst_5)) (a : A) (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonUnitalNonAssocSemiring.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_2)))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (algebraMap.{u3, u2} R A _inst_1 _inst_2 _inst_4) r) a)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (Algebra.toModule.{u3, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u3, u1} R B _inst_1 _inst_3 _inst_5)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R A B (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (Algebra.toModule.{u3, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u3, u1} R B _inst_1 _inst_3 _inst_5) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) f (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonUnitalNonAssocSemiring.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_2)))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (algebraMap.{u3, u2} R A _inst_1 _inst_2 _inst_4) r) a)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => B) r) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => B) r) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => B) r) (NonUnitalNonAssocSemiring.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => B) r) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => B) r) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => B) r) _inst_3)))) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (RingHom.{u3, u1} R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => B) _x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (RingHom.{u3, u1} R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3)) R B (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3)) R B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3)) R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3))))) (algebraMap.{u3, u1} R B _inst_1 _inst_3 _inst_5) r) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (Algebra.toModule.{u3, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u3, u1} R B _inst_1 _inst_3 _inst_5)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R A B (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (Algebra.toModule.{u3, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u3, u1} R B _inst_1 _inst_3 _inst_5) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) f a))
Case conversion may be inaccurate. Consider using '#align linear_map.map_algebra_map_mul LinearMap.map_algebraMap_mulₓ'. -/
/-- An alternate statement of `linear_map.map_smul` for when `algebra_map` is more convenient to
work with than `•`. -/
theorem map_algebraMap_mul (f : A →ₗ[R] B) (a : A) (r : R) :
    f (algebraMap R A r * a) = algebraMap R B r * f a := by
  rw [← Algebra.smul_def, ← Algebra.smul_def, map_smul]
#align linear_map.map_algebra_map_mul LinearMap.map_algebraMap_mul

/- warning: linear_map.map_mul_algebra_map -> LinearMap.map_mul_algebraMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} {B : Type.{u3}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Semiring.{u3} B] [_inst_4 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_5 : Algebra.{u1, u3} R B _inst_1 _inst_3] (f : LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5)) (a : A) (r : R), Eq.{succ u3} B (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5)) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5)) => A -> B) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R A B (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) a (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_4) r))) (HMul.hMul.{u3, u3, u3} B B B (instHMul.{u3} B (Distrib.toHasMul.{u3} B (NonUnitalNonAssocSemiring.toDistrib.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5)) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5)) => A -> B) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R A B (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} B (Semiring.toNonAssocSemiring.{u3} B _inst_3))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u1, u3} R B _inst_1 _inst_3 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) f a) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} B _inst_3)) (fun (_x : RingHom.{u1, u3} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} B _inst_3)) => R -> B) (RingHom.hasCoeToFun.{u1, u3} R B (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u3} B _inst_3)) (algebraMap.{u1, u3} R B _inst_1 _inst_3 _inst_5) r))
but is expected to have type
  forall {R : Type.{u3}} {A : Type.{u2}} {B : Type.{u1}} [_inst_1 : CommSemiring.{u3} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Semiring.{u1} B] [_inst_4 : Algebra.{u3, u2} R A _inst_1 _inst_2] [_inst_5 : Algebra.{u3, u1} R B _inst_1 _inst_3] (f : LinearMap.{u3, u3, u2, u1} R R (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (Algebra.toModule.{u3, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u3, u1} R B _inst_1 _inst_3 _inst_5)) (a : A) (r : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) (HMul.hMul.{u2, u2, u2} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) a (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (algebraMap.{u3, u2} R A _inst_1 _inst_2 _inst_4) r))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (Algebra.toModule.{u3, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u3, u1} R B _inst_1 _inst_3 _inst_5)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R A B (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (Algebra.toModule.{u3, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u3, u1} R B _inst_1 _inst_3 _inst_5) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) f (HMul.hMul.{u2, u2, u2} A ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) a (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2) (RingHom.instRingHomClassRingHom.{u3, u2} R A (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (algebraMap.{u3, u2} R A _inst_1 _inst_2 _inst_4) r))) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => B) r) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) a) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) a) (NonUnitalNonAssocSemiring.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) a) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) a) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) a) _inst_3)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (Algebra.toModule.{u3, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u3, u1} R B _inst_1 _inst_3 _inst_5)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => B) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R A B (CommSemiring.toSemiring.{u3} R _inst_1) (CommSemiring.toSemiring.{u3} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (Algebra.toModule.{u3, u2} R A _inst_1 _inst_2 _inst_4) (Algebra.toModule.{u3, u1} R B _inst_1 _inst_3 _inst_5) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) f a) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (RingHom.{u3, u1} R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => B) _x) (MulHomClass.toFunLike.{max u3 u1, u3, u1} (RingHom.{u3, u1} R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3)) R B (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3)) R B (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} B (Semiring.toNonAssocSemiring.{u1} B _inst_3)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u1, u3, u1} (RingHom.{u3, u1} R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3)) R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3) (RingHom.instRingHomClassRingHom.{u3, u1} R B (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} B _inst_3))))) (algebraMap.{u3, u1} R B _inst_1 _inst_3 _inst_5) r))
Case conversion may be inaccurate. Consider using '#align linear_map.map_mul_algebra_map LinearMap.map_mul_algebraMapₓ'. -/
theorem map_mul_algebraMap (f : A →ₗ[R] B) (a : A) (r : R) :
    f (a * algebraMap R A r) = f a * algebraMap R B r := by
  rw [← Algebra.commutes, ← Algebra.commutes, map_algebra_map_mul]
#align linear_map.map_mul_algebra_map LinearMap.map_mul_algebraMap

end LinearMap

/- warning: rat.smul_one_eq_coe -> Rat.smul_one_eq_coe is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_1 : DivisionRing.{u1} A] [_inst_2 : Algebra.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A (DivisionRing.toRing.{u1} A _inst_1))] (m : Rat), Eq.{succ u1} A (SMul.smul.{0, u1} Rat A (Algebra.toHasSmul.{0, u1} Rat A Rat.commSemiring (Ring.toSemiring.{u1} A (DivisionRing.toRing.{u1} A _inst_1)) _inst_2) m (OfNat.ofNat.{u1} A 1 (OfNat.mk.{u1} A 1 (One.one.{u1} A (AddMonoidWithOne.toOne.{u1} A (AddGroupWithOne.toAddMonoidWithOne.{u1} A (NonAssocRing.toAddGroupWithOne.{u1} A (Ring.toNonAssocRing.{u1} A (DivisionRing.toRing.{u1} A _inst_1))))))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Rat A (HasLiftT.mk.{1, succ u1} Rat A (CoeTCₓ.coe.{1, succ u1} Rat A (Rat.castCoe.{u1} A (DivisionRing.toHasRatCast.{u1} A _inst_1)))) m)
but is expected to have type
  forall {A : Type.{u1}} [_inst_1 : DivisionRing.{u1} A] [_inst_2 : Algebra.{0, u1} Rat A Rat.commSemiring (DivisionSemiring.toSemiring.{u1} A (DivisionRing.toDivisionSemiring.{u1} A _inst_1))] (m : Rat), Eq.{succ u1} A (SMul.smul.{0, u1} Rat A (Algebra.toSMul.{0, u1} Rat A Rat.commSemiring (DivisionSemiring.toSemiring.{u1} A (DivisionRing.toDivisionSemiring.{u1} A _inst_1)) _inst_2) m (OfNat.ofNat.{u1} A 1 (One.toOfNat1.{u1} A (NonAssocRing.toOne.{u1} A (Ring.toNonAssocRing.{u1} A (DivisionRing.toRing.{u1} A _inst_1)))))) (Rat.cast.{u1} A (DivisionRing.toRatCast.{u1} A _inst_1) m)
Case conversion may be inaccurate. Consider using '#align rat.smul_one_eq_coe Rat.smul_one_eq_coeₓ'. -/
@[simp]
theorem Rat.smul_one_eq_coe {A : Type _} [DivisionRing A] [Algebra ℚ A] (m : ℚ) :
    @SMul.smul Algebra.toHasSmul m (1 : A) = ↑m := by rw [Algebra.smul_def, mul_one, eq_ratCast]
#align rat.smul_one_eq_coe Rat.smul_one_eq_coe

section Nat

variable {R : Type _} [Semiring R]

#print algebraNat /-
-- Lower the priority so that `algebra.id` is picked most of the time when working with
-- `ℕ`-algebras. This is only an issue since `algebra.id` and `algebra_nat` are not yet defeq.
-- TODO: fix this by adding an `of_nat` field to semirings.
/-- Semiring ⥤ ℕ-Alg -/
instance (priority := 99) algebraNat : Algebra ℕ R
    where
  commutes' := Nat.cast_commute
  smul_def' _ _ := nsmul_eq_mul _ _
  toRingHom := Nat.castRingHom R
#align algebra_nat algebraNat
-/

#print nat_algebra_subsingleton /-
instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R) :=
  ⟨fun P Q => by
    ext
    simp⟩
#align nat_algebra_subsingleton nat_algebra_subsingleton
-/

end Nat

namespace RingHom

variable {R S : Type _}

/- warning: ring_hom.map_rat_algebra_map -> RingHom.map_rat_algebraMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Ring.{u2} S] [_inst_3 : Algebra.{0, u1} Rat R Rat.commSemiring (Ring.toSemiring.{u1} R _inst_1)] [_inst_4 : Algebra.{0, u2} Rat S Rat.commSemiring (Ring.toSemiring.{u2} S _inst_2)] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (r : Rat), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S _inst_2))) f (coeFn.{succ u1, succ u1} (RingHom.{0, u1} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (fun (_x : RingHom.{0, u1} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) => Rat -> R) (RingHom.hasCoeToFun.{0, u1} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (algebraMap.{0, u1} Rat R Rat.commSemiring (Ring.toSemiring.{u1} R _inst_1) _inst_3) r)) (coeFn.{succ u2, succ u2} (RingHom.{0, u2} Rat S (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (fun (_x : RingHom.{0, u2} Rat S (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) => Rat -> S) (RingHom.hasCoeToFun.{0, u2} Rat S (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S _inst_2))) (algebraMap.{0, u2} Rat S Rat.commSemiring (Ring.toSemiring.{u2} S _inst_2) _inst_4) r)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : Algebra.{0, u2} Rat R Rat.commSemiring _inst_1] [_inst_4 : Algebra.{0, u1} Rat S Rat.commSemiring _inst_2] (f : RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (r : Rat), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (FunLike.coe.{succ u2, 1, succ u2} (RingHom.{0, u2} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Rat (fun (a : Rat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Rat) => R) a) (MulHomClass.toFunLike.{u2, 0, u2} (RingHom.{0, u2} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Rat R (NonUnitalNonAssocSemiring.toMul.{0} Rat (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)))) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{u2, 0, u2} (RingHom.{0, u2} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Rat R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u2, 0, u2} (RingHom.{0, u2} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1) (RingHom.instRingHomClassRingHom.{0, u2} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (algebraMap.{0, u2} Rat R Rat.commSemiring _inst_1 _inst_3) r)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_1) (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) f (FunLike.coe.{succ u2, 1, succ u2} (RingHom.{0, u2} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Rat (fun (_x : Rat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Rat) => R) _x) (MulHomClass.toFunLike.{u2, 0, u2} (RingHom.{0, u2} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Rat R (NonUnitalNonAssocSemiring.toMul.{0} Rat (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)))) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalRingHomClass.toMulHomClass.{u2, 0, u2} (RingHom.{0, u2} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Rat R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomClass.toNonUnitalRingHomClass.{u2, 0, u2} (RingHom.{0, u2} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1)) Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1) (RingHom.instRingHomClassRingHom.{0, u2} Rat R (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (algebraMap.{0, u2} Rat R Rat.commSemiring _inst_1 _inst_3) r)) (FunLike.coe.{succ u1, 1, succ u1} (RingHom.{0, u1} Rat S (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) Rat (fun (_x : Rat) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Rat) => S) _x) (MulHomClass.toFunLike.{u1, 0, u1} (RingHom.{0, u1} Rat S (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) Rat S (NonUnitalNonAssocSemiring.toMul.{0} Rat (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{u1, 0, u1} (RingHom.{0, u1} Rat S (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) Rat S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{0} Rat (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{u1, 0, u1} (RingHom.{0, u1} Rat S (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} S _inst_2)) Rat S (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} S _inst_2) (RingHom.instRingHomClassRingHom.{0, u1} Rat S (Semiring.toNonAssocSemiring.{0} Rat (CommSemiring.toSemiring.{0} Rat Rat.commSemiring)) (Semiring.toNonAssocSemiring.{u1} S _inst_2))))) (algebraMap.{0, u1} Rat S Rat.commSemiring _inst_2 _inst_4) r)
Case conversion may be inaccurate. Consider using '#align ring_hom.map_rat_algebra_map RingHom.map_rat_algebraMapₓ'. -/
-- note that `R`, `S` could be `semiring`s but this is useless mathematically speaking -
-- a ℚ-algebra is a ring. furthermore, this change probably slows down elaboration.
@[simp]
theorem map_rat_algebraMap [Ring R] [Ring S] [Algebra ℚ R] [Algebra ℚ S] (f : R →+* S) (r : ℚ) :
    f (algebraMap ℚ R r) = algebraMap ℚ S r :=
  RingHom.ext_iff.1 (Subsingleton.elim (f.comp (algebraMap ℚ R)) (algebraMap ℚ S)) r
#align ring_hom.map_rat_algebra_map RingHom.map_rat_algebraMap

end RingHom

section Rat

#print algebraRat /-
instance algebraRat {α} [DivisionRing α] [CharZero α] : Algebra ℚ α
    where
  smul := (· • ·)
  smul_def' := DivisionRing.qsmul_eq_mul'
  toRingHom := Rat.castHom α
  commutes' := Rat.cast_commute
#align algebra_rat algebraRat
-/

/-- The two `algebra ℚ ℚ` instances should coincide. -/
example : algebraRat = Algebra.id ℚ :=
  rfl

#print algebraMap_rat_rat /-
@[simp]
theorem algebraMap_rat_rat : algebraMap ℚ ℚ = RingHom.id ℚ :=
  Subsingleton.elim _ _
#align algebra_map_rat_rat algebraMap_rat_rat
-/

#print algebra_rat_subsingleton /-
instance algebra_rat_subsingleton {α} [Semiring α] : Subsingleton (Algebra ℚ α) :=
  ⟨fun x y => Algebra.algebra_ext x y <| RingHom.congr_fun <| Subsingleton.elim _ _⟩
#align algebra_rat_subsingleton algebra_rat_subsingleton
-/

end Rat

section Int

variable (R : Type _) [Ring R]

/- warning: algebra_int -> algebraInt is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R], Algebra.{0, u1} Int R Int.commSemiring (Ring.toSemiring.{u1} R _inst_1)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R], Algebra.{0, u1} Int R Int.instCommSemiringInt (Ring.toSemiring.{u1} R _inst_1)
Case conversion may be inaccurate. Consider using '#align algebra_int algebraIntₓ'. -/
-- Lower the priority so that `algebra.id` is picked most of the time when working with
-- `ℤ`-algebras. This is only an issue since `algebra.id ℤ` and `algebra_int ℤ` are not yet defeq.
-- TODO: fix this by adding an `of_int` field to rings.
/-- Ring ⥤ ℤ-Alg -/
instance (priority := 99) algebraInt : Algebra ℤ R
    where
  commutes' := Int.cast_commute
  smul_def' _ _ := zsmul_eq_mul _ _
  toRingHom := Int.castRingHom R
#align algebra_int algebraInt

/- warning: algebra_map_int_eq -> algebraMap_int_eq is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R], Eq.{succ u1} (RingHom.{0, u1} Int R (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.commSemiring)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (algebraMap.{0, u1} Int R Int.commSemiring (Ring.toSemiring.{u1} R _inst_1) (algebraInt.{u1} R _inst_1)) (Int.castRingHom.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Ring.{u1} R], Eq.{succ u1} (RingHom.{0, u1} Int R (Semiring.toNonAssocSemiring.{0} Int (CommSemiring.toSemiring.{0} Int Int.instCommSemiringInt)) (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (algebraMap.{0, u1} Int R Int.instCommSemiringInt (Ring.toSemiring.{u1} R _inst_1) (algebraInt.{u1} R _inst_1)) (Int.castRingHom.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align algebra_map_int_eq algebraMap_int_eqₓ'. -/
/-- A special case of `eq_int_cast'` that happens to be true definitionally -/
@[simp]
theorem algebraMap_int_eq : algebraMap ℤ R = Int.castRingHom R :=
  rfl
#align algebra_map_int_eq algebraMap_int_eq

variable {R}

/- warning: int_algebra_subsingleton -> int_algebra_subsingleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R], Subsingleton.{succ u1} (Algebra.{0, u1} Int R Int.commSemiring (Ring.toSemiring.{u1} R _inst_1))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R], Subsingleton.{succ u1} (Algebra.{0, u1} Int R Int.instCommSemiringInt (Ring.toSemiring.{u1} R _inst_1))
Case conversion may be inaccurate. Consider using '#align int_algebra_subsingleton int_algebra_subsingletonₓ'. -/
instance int_algebra_subsingleton : Subsingleton (Algebra ℤ R) :=
  ⟨fun P Q => by
    ext
    simp⟩
#align int_algebra_subsingleton int_algebra_subsingleton

end Int

namespace NoZeroSMulDivisors

variable {R A : Type _}

open Algebra

/- warning: no_zero_smul_divisors.of_algebra_map_injective -> NoZeroSMulDivisors.of_algebraMap_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] [_inst_4 : NoZeroDivisors.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))], (Function.Injective.{succ u1, succ u2} R A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_3))) -> (NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Semiring.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 _inst_2] [_inst_4 : NoZeroDivisors.{u1} A (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (MonoidWithZero.toZero.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_2))], (Function.Injective.{succ u2, succ u1} R A (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2))))) (algebraMap.{u2, u1} R A _inst_1 _inst_2 _inst_3))) -> (NoZeroSMulDivisors.{u2, u1} R A (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) (MonoidWithZero.toZero.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_2)) (Algebra.toSMul.{u2, u1} R A _inst_1 _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align no_zero_smul_divisors.of_algebra_map_injective NoZeroSMulDivisors.of_algebraMap_injectiveₓ'. -/
/-- If `algebra_map R A` is injective and `A` has no zero divisors,
`R`-multiples in `A` are zero only if one of the factors is zero.

Cannot be an instance because there is no `injective (algebra_map R A)` typeclass.
-/
theorem of_algebraMap_injective [CommSemiring R] [Semiring A] [Algebra R A] [NoZeroDivisors A]
    (h : Function.Injective (algebraMap R A)) : NoZeroSMulDivisors R A :=
  ⟨fun c x hcx =>
    (mul_eq_zero.mp ((smul_def c x).symm.trans hcx)).imp_left
      (map_eq_zero_iff (algebraMap R A) h).mp⟩
#align no_zero_smul_divisors.of_algebra_map_injective NoZeroSMulDivisors.of_algebraMap_injective

variable (R A)

/- warning: no_zero_smul_divisors.algebra_map_injective -> NoZeroSMulDivisors.algebraMap_injective is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : Ring.{u2} A] [_inst_3 : Nontrivial.{u2} A] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_2)] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_2) _inst_4)))))], Function.Injective.{succ u1, succ u2} R A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (algebraMap.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_2) _inst_4))
but is expected to have type
  forall (R : Type.{u2}) (A : Type.{u1}) [_inst_1 : CommRing.{u2} R] [_inst_2 : Ring.{u1} A] [_inst_3 : Nontrivial.{u1} A] [_inst_4 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_2)] [_inst_5 : NoZeroSMulDivisors.{u2, u1} R A (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (MonoidWithZero.toZero.{u1} A (Semiring.toMonoidWithZero.{u1} A (Ring.toSemiring.{u1} A _inst_2))) (Algebra.toSMul.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_2) _inst_4)], Function.Injective.{succ u2, succ u1} R A (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2))) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2))) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2)))))) (algebraMap.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_2) _inst_4))
Case conversion may be inaccurate. Consider using '#align no_zero_smul_divisors.algebra_map_injective NoZeroSMulDivisors.algebraMap_injectiveₓ'. -/
theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]
    [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A) :=
  suffices Function.Injective fun c : R => c • (1 : A)
    by
    convert this
    ext
    rw [Algebra.smul_def, mul_one]
  smul_left_injective R one_ne_zero
#align no_zero_smul_divisors.algebra_map_injective NoZeroSMulDivisors.algebraMap_injective

/- warning: ne_zero.of_no_zero_smul_divisors -> NeZero.of_noZeroSMulDivisors is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) (n : Nat) [_inst_1 : CommRing.{u1} R] [_inst_2 : NeZero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat R (HasLiftT.mk.{1, succ u1} Nat R (CoeTCₓ.coe.{1, succ u1} Nat R (Nat.castCoe.{u1} R (AddMonoidWithOne.toNatCast.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) n)] [_inst_3 : Ring.{u2} A] [_inst_4 : Nontrivial.{u2} A] [_inst_5 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_3)] [_inst_6 : NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_3))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_3))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_3))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_3))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_3)))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_3) _inst_5)))))], NeZero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_3))))) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat A (HasLiftT.mk.{1, succ u2} Nat A (CoeTCₓ.coe.{1, succ u2} Nat A (Nat.castCoe.{u2} A (AddMonoidWithOne.toNatCast.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (NonAssocRing.toAddGroupWithOne.{u2} A (Ring.toNonAssocRing.{u2} A _inst_3))))))) n)
but is expected to have type
  forall (R : Type.{u2}) (A : Type.{u1}) (n : Nat) [_inst_1 : CommRing.{u2} R] [_inst_2 : NeZero.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Nat.cast.{u2} R (NonAssocRing.toNatCast.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))) n)] [_inst_3 : Ring.{u1} A] [_inst_4 : Nontrivial.{u1} A] [_inst_5 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3)] [_inst_6 : NoZeroSMulDivisors.{u2, u1} R A (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (MonoidWithZero.toZero.{u1} A (Semiring.toMonoidWithZero.{u1} A (Ring.toSemiring.{u1} A _inst_3))) (Algebra.toSMul.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3) _inst_5)], NeZero.{u1} A (MonoidWithZero.toZero.{u1} A (Semiring.toMonoidWithZero.{u1} A (Ring.toSemiring.{u1} A _inst_3))) (Nat.cast.{u1} A (NonAssocRing.toNatCast.{u1} A (Ring.toNonAssocRing.{u1} A _inst_3)) n)
Case conversion may be inaccurate. Consider using '#align ne_zero.of_no_zero_smul_divisors NeZero.of_noZeroSMulDivisorsₓ'. -/
theorem NeZero.of_noZeroSMulDivisors (n : ℕ) [CommRing R] [NeZero (n : R)] [Ring A] [Nontrivial A]
    [Algebra R A] [NoZeroSMulDivisors R A] : NeZero (n : A) :=
  NeZero.nat_of_injective <| NoZeroSMulDivisors.algebraMap_injective R A
#align ne_zero.of_no_zero_smul_divisors NeZero.of_noZeroSMulDivisors

variable {R A}

/- warning: no_zero_smul_divisors.iff_algebra_map_injective -> NoZeroSMulDivisors.iff_algebraMap_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommRing.{u1} R] [_inst_2 : Ring.{u2} A] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A _inst_2)] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_2)], Iff (NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2)))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_2) _inst_4)))))) (Function.Injective.{succ u1, succ u2} R A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_2))) (algebraMap.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_2) _inst_4)))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommRing.{u2} R] [_inst_2 : Ring.{u1} A] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A _inst_2)] [_inst_4 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_2)], Iff (NoZeroSMulDivisors.{u2, u1} R A (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (MonoidWithZero.toZero.{u1} A (Semiring.toMonoidWithZero.{u1} A (Ring.toSemiring.{u1} A _inst_2))) (Algebra.toSMul.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_2) _inst_4)) (Function.Injective.{succ u2, succ u1} R A (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2))) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2))) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2))) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2)) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A _inst_2)))))) (algebraMap.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_2) _inst_4)))
Case conversion may be inaccurate. Consider using '#align no_zero_smul_divisors.iff_algebra_map_injective NoZeroSMulDivisors.iff_algebraMap_injectiveₓ'. -/
theorem iff_algebraMap_injective [CommRing R] [Ring A] [IsDomain A] [Algebra R A] :
    NoZeroSMulDivisors R A ↔ Function.Injective (algebraMap R A) :=
  ⟨@NoZeroSMulDivisors.algebraMap_injective R A _ _ _ _, NoZeroSMulDivisors.of_algebraMap_injective⟩
#align no_zero_smul_divisors.iff_algebra_map_injective NoZeroSMulDivisors.iff_algebraMap_injective

/- warning: no_zero_smul_divisors.char_zero.no_zero_smul_divisors_nat -> NoZeroSMulDivisors.CharZero.noZeroSMulDivisors_nat is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))] [_inst_3 : CharZero.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))], NoZeroSMulDivisors.{0, u1} Nat R Nat.hasZero (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (AddMonoid.SMul.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))] [_inst_3 : CharZero.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))], NoZeroSMulDivisors.{0, u1} Nat R (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.SMul.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align no_zero_smul_divisors.char_zero.no_zero_smul_divisors_nat NoZeroSMulDivisors.CharZero.noZeroSMulDivisors_natₓ'. -/
-- see note [lower instance priority]
instance (priority := 100) CharZero.noZeroSMulDivisors_nat [Semiring R] [NoZeroDivisors R]
    [CharZero R] : NoZeroSMulDivisors ℕ R :=
  NoZeroSMulDivisors.of_algebraMap_injective <| (algebraMap ℕ R).injective_nat
#align no_zero_smul_divisors.char_zero.no_zero_smul_divisors_nat NoZeroSMulDivisors.CharZero.noZeroSMulDivisors_nat

/- warning: no_zero_smul_divisors.char_zero.no_zero_smul_divisors_int -> NoZeroSMulDivisors.CharZero.noZeroSMulDivisors_int is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))] [_inst_3 : CharZero.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))], NoZeroSMulDivisors.{0, u1} Int R Int.hasZero (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] [_inst_2 : NoZeroDivisors.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)))] [_inst_3 : CharZero.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_1))], NoZeroSMulDivisors.{0, u1} Int R (CommMonoidWithZero.toZero.{0} Int (CancelCommMonoidWithZero.toCommMonoidWithZero.{0} Int (IsDomain.toCancelCommMonoidWithZero.{0} Int Int.instCommSemiringInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing))))) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (Ring.toAddGroupWithOne.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align no_zero_smul_divisors.char_zero.no_zero_smul_divisors_int NoZeroSMulDivisors.CharZero.noZeroSMulDivisors_intₓ'. -/
-- see note [lower instance priority]
instance (priority := 100) CharZero.noZeroSMulDivisors_int [Ring R] [NoZeroDivisors R]
    [CharZero R] : NoZeroSMulDivisors ℤ R :=
  NoZeroSMulDivisors.of_algebraMap_injective <| (algebraMap ℤ R).injective_int
#align no_zero_smul_divisors.char_zero.no_zero_smul_divisors_int NoZeroSMulDivisors.CharZero.noZeroSMulDivisors_int

section Field

variable [Field R] [Semiring A] [Algebra R A]

/- warning: no_zero_smul_divisors.algebra.no_zero_smul_divisors -> NoZeroSMulDivisors.Algebra.noZeroSMulDivisors is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : Field.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A (Semifield.toCommSemiring.{u1} R (Field.toSemifield.{u1} R _inst_1)) _inst_2] [_inst_4 : Nontrivial.{u2} A] [_inst_5 : NoZeroDivisors.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))], NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (DivisionRing.toRing.{u1} R (Field.toDivisionRing.{u1} R _inst_1))))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (Semifield.toCommSemiring.{u1} R (Field.toSemifield.{u1} R _inst_1))))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (Semifield.toCommSemiring.{u1} R (Field.toSemifield.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (Semifield.toCommSemiring.{u1} R (Field.toSemifield.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A (Semifield.toCommSemiring.{u1} R (Field.toSemifield.{u1} R _inst_1)) _inst_2 _inst_3)))))
but is expected to have type
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : Field.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A (Semifield.toCommSemiring.{u1} R (Field.toSemifield.{u1} R _inst_1)) _inst_2] [_inst_4 : Nontrivial.{u2} A] [_inst_5 : NoZeroDivisors.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2))], NoZeroSMulDivisors.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommGroupWithZero.toCommMonoidWithZero.{u1} R (Semifield.toCommGroupWithZero.{u1} R (Field.toSemifield.{u1} R _inst_1)))) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (Algebra.toSMul.{u1, u2} R A (Semifield.toCommSemiring.{u1} R (Field.toSemifield.{u1} R _inst_1)) _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align no_zero_smul_divisors.algebra.no_zero_smul_divisors NoZeroSMulDivisors.Algebra.noZeroSMulDivisorsₓ'. -/
-- see note [lower instance priority]
instance (priority := 100) Algebra.noZeroSMulDivisors [Nontrivial A] [NoZeroDivisors A] :
    NoZeroSMulDivisors R A :=
  NoZeroSMulDivisors.of_algebraMap_injective (algebraMap R A).Injective
#align no_zero_smul_divisors.algebra.no_zero_smul_divisors NoZeroSMulDivisors.Algebra.noZeroSMulDivisors

end Field

end NoZeroSMulDivisors

section IsScalarTower

variable {R : Type _} [CommSemiring R]

variable (A : Type _) [Semiring A] [Algebra R A]

variable {M : Type _} [AddCommMonoid M] [Module A M] [Module R M] [IsScalarTower R A M]

variable {N : Type _} [AddCommMonoid N] [Module A N] [Module R N] [IsScalarTower R A N]

/- warning: algebra_compatible_smul -> algebra_compatible_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (A : Type.{u2}) [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] {M : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} A M _inst_2 _inst_4] [_inst_6 : Module.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4] [_inst_7 : IsScalarTower.{u1, u2, u3} R A M (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u3} A M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u2, u3} A M (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u2, u3} A M (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u2, u3} A M _inst_2 _inst_4 _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6))))] (r : R) (m : M), Eq.{succ u3} M (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6)))) r m) (SMul.smul.{u2, u3} A M (SMulZeroClass.toHasSmul.{u2, u3} A M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u2, u3} A M (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u2, u3} A M (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u2, u3} A M _inst_2 _inst_4 _inst_5)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_3) r) m)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : CommSemiring.{u2} R] (A : Type.{u1}) [_inst_2 : Semiring.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 _inst_2] {M : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u1, u3} A M _inst_2 _inst_4] [_inst_6 : Module.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_4] [_inst_7 : IsScalarTower.{u2, u1, u3} R A M (Algebra.toSMul.{u2, u1} R A _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u1, u3} A M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u1, u3} A M (MonoidWithZero.toZero.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u1, u3} A M (Semiring.toMonoidWithZero.{u1} A _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u1, u3} A M _inst_2 _inst_4 _inst_5)))) (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_4 _inst_6))))] (r : R) (m : M), Eq.{succ u3} M (HSMul.hSMul.{u2, u3, u3} R M M (instHSMul.{u2, u3} R M (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u2, u3} R M (CommSemiring.toSemiring.{u2} R _inst_1) _inst_4 _inst_6))))) r m) (HSMul.hSMul.{u1, u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M M (instHSMul.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M (SMulZeroClass.toSMul.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M _inst_2 _inst_4 _inst_5))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} R A (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} A _inst_2))))) (algebraMap.{u2, u1} R A _inst_1 _inst_2 _inst_3) r) m)
Case conversion may be inaccurate. Consider using '#align algebra_compatible_smul algebra_compatible_smulₓ'. -/
theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m := by
  rw [← one_smul A m, ← smul_assoc, Algebra.smul_def, mul_one, one_smul]
#align algebra_compatible_smul algebra_compatible_smul

/- warning: algebra_map_smul -> algebraMap_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (A : Type.{u2}) [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] {M : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} A M _inst_2 _inst_4] [_inst_6 : Module.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4] [_inst_7 : IsScalarTower.{u1, u2, u3} R A M (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u3} A M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u2, u3} A M (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u2, u3} A M (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u2, u3} A M _inst_2 _inst_4 _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6))))] (r : R) (m : M), Eq.{succ u3} M (SMul.smul.{u2, u3} A M (SMulZeroClass.toHasSmul.{u2, u3} A M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u2, u3} A M (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u2, u3} A M (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u2, u3} A M _inst_2 _inst_4 _inst_5)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (fun (_x : RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) => R -> A) (RingHom.hasCoeToFun.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_3) r) m) (SMul.smul.{u1, u3} R M (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6)))) r m)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] (A : Type.{u2}) [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] {M : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} A M _inst_2 _inst_4] [_inst_6 : Module.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4] [_inst_7 : IsScalarTower.{u1, u2, u3} R A M (Algebra.toSMul.{u1, u2} R A _inst_1 _inst_2 _inst_3) (SMulZeroClass.toSMul.{u2, u3} A M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u2, u3} A M (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u2, u3} A M (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u2, u3} A M _inst_2 _inst_4 _inst_5)))) (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6))))] (r : R) (m : M), Eq.{succ u3} M (HSMul.hSMul.{u2, u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M M (instHSMul.{u2, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M (SMulZeroClass.toSMul.{u2, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u2, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u2, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u2, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) r) M _inst_2 _inst_4 _inst_5))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => A) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2)) R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2) (RingHom.instRingHomClassRingHom.{u1, u2} R A (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} A _inst_2))))) (algebraMap.{u1, u2} R A _inst_1 _inst_2 _inst_3) r) m) (HSMul.hSMul.{u1, u3, u3} R M M (instHSMul.{u1, u3} R M (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6))))) r m)
Case conversion may be inaccurate. Consider using '#align algebra_map_smul algebraMap_smulₓ'. -/
@[simp]
theorem algebraMap_smul (r : R) (m : M) : (algebraMap R A) r • m = r • m :=
  (algebra_compatible_smul A r m).symm
#align algebra_map_smul algebraMap_smul

/- warning: int_cast_smul -> intCast_smul is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} [_inst_12 : CommRing.{u1} k] [_inst_13 : AddCommGroup.{u2} V] [_inst_14 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_12)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_13)] (r : Int) (x : V), Eq.{succ u2} V (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_13)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_12)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_13)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_12))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_13)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_12)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_13) _inst_14)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int k (HasLiftT.mk.{1, succ u1} Int k (CoeTCₓ.coe.{1, succ u1} Int k (Int.castCoe.{u1} k (AddGroupWithOne.toHasIntCast.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_12))))))) r) x) (SMul.smul.{0, u2} Int V (SubNegMonoid.SMulInt.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_13))) r x)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} [_inst_12 : CommRing.{u2} k] [_inst_13 : AddCommGroup.{u1} V] [_inst_14 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_12)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_13)] (r : Int) (x : V), Eq.{succ u1} V (HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_13))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (CommMonoidWithZero.toZero.{u2} k (CommSemiring.toCommMonoidWithZero.{u2} k (CommRing.toCommSemiring.{u2} k _inst_12))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_13))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_12))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_13))))) (Module.toMulActionWithZero.{u2, u1} k V (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_12)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_13) _inst_14))))) (Int.cast.{u2} k (Ring.toIntCast.{u2} k (CommRing.toRing.{u2} k _inst_12)) r) x) (HSMul.hSMul.{0, u1, u1} Int V V (instHSMul.{0, u1} Int V (SubNegMonoid.SMulInt.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_13)))) r x)
Case conversion may be inaccurate. Consider using '#align int_cast_smul intCast_smulₓ'. -/
theorem intCast_smul {k V : Type _} [CommRing k] [AddCommGroup V] [Module k V] (r : ℤ) (x : V) :
    (r : k) • x = r • x :=
  algebraMap_smul k r x
#align int_cast_smul intCast_smul

/- warning: no_zero_smul_divisors.trans -> NoZeroSMulDivisors.trans is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) (M : Type.{u3}) [_inst_12 : CommRing.{u1} R] [_inst_13 : Ring.{u2} A] [_inst_14 : IsDomain.{u2} A (Ring.toSemiring.{u2} A _inst_13)] [_inst_15 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_12) (Ring.toSemiring.{u2} A _inst_13)] [_inst_16 : AddCommGroup.{u3} M] [_inst_17 : Module.{u1, u3} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_12)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)] [_inst_18 : Module.{u2, u3} A M (Ring.toSemiring.{u2} A _inst_13) (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)] [_inst_19 : IsScalarTower.{u1, u2, u3} R A M (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_13))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_12)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_13))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_12))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_13))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_12)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_13)))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_12) (Ring.toSemiring.{u2} A _inst_13) _inst_15))))) (SMulZeroClass.toHasSmul.{u2, u3} A M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (SMulWithZero.toSmulZeroClass.{u2, u3} A M (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_13))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (MulActionWithZero.toSMulWithZero.{u2, u3} A M (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_13)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (Module.toMulActionWithZero.{u2, u3} A M (Ring.toSemiring.{u2} A _inst_13) (AddCommGroup.toAddCommMonoid.{u3} M _inst_16) _inst_18)))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_12)))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_12))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (Module.toMulActionWithZero.{u1, u3} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_12)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_16) _inst_17))))] [_inst_20 : NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_12)))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_13))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_13))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_12)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_13))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_12))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_13))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_12)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A _inst_13)))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_12) (Ring.toSemiring.{u2} A _inst_13) _inst_15)))))] [_inst_21 : NoZeroSMulDivisors.{u2, u3} A M (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A _inst_13))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_16))))) (SMulZeroClass.toHasSmul.{u2, u3} A M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (SMulWithZero.toSmulZeroClass.{u2, u3} A M (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_13))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (MulActionWithZero.toSMulWithZero.{u2, u3} A M (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_13)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (Module.toMulActionWithZero.{u2, u3} A M (Ring.toSemiring.{u2} A _inst_13) (AddCommGroup.toAddCommMonoid.{u3} M _inst_16) _inst_18))))], NoZeroSMulDivisors.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_12)))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (SubNegMonoid.toAddMonoid.{u3} M (AddGroup.toSubNegMonoid.{u3} M (AddCommGroup.toAddGroup.{u3} M _inst_16))))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_12)))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_12))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (AddCommGroup.toAddCommMonoid.{u3} M _inst_16)))) (Module.toMulActionWithZero.{u1, u3} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_12)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_16) _inst_17))))
but is expected to have type
  forall (R : Type.{u3}) (A : Type.{u2}) (M : Type.{u1}) [_inst_12 : CommRing.{u3} R] [_inst_13 : Ring.{u2} A] [_inst_14 : IsDomain.{u2} A (Ring.toSemiring.{u2} A _inst_13)] [_inst_15 : Algebra.{u3, u2} R A (CommRing.toCommSemiring.{u3} R _inst_12) (Ring.toSemiring.{u2} A _inst_13)] [_inst_16 : AddCommGroup.{u1} M] [_inst_17 : Module.{u3, u1} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_12)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_16)] [_inst_18 : Module.{u2, u1} A M (Ring.toSemiring.{u2} A _inst_13) (AddCommGroup.toAddCommMonoid.{u1} M _inst_16)] [_inst_19 : IsScalarTower.{u3, u2, u1} R A M (Algebra.toSMul.{u3, u2} R A (CommRing.toCommSemiring.{u3} R _inst_12) (Ring.toSemiring.{u2} A _inst_13) _inst_15) (SMulZeroClass.toSMul.{u2, u1} A M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (SMulWithZero.toSMulZeroClass.{u2, u1} A M (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_13))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (MulActionWithZero.toSMulWithZero.{u2, u1} A M (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_13)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (Module.toMulActionWithZero.{u2, u1} A M (Ring.toSemiring.{u2} A _inst_13) (AddCommGroup.toAddCommMonoid.{u1} M _inst_16) _inst_18)))) (SMulZeroClass.toSMul.{u3, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (SMulWithZero.toSMulZeroClass.{u3, u1} R M (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_12))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (MulActionWithZero.toSMulWithZero.{u3, u1} R M (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_12))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (Module.toMulActionWithZero.{u3, u1} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_12)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_16) _inst_17))))] [_inst_20 : NoZeroSMulDivisors.{u3, u2} R A (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_12))) (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_13))) (Algebra.toSMul.{u3, u2} R A (CommRing.toCommSemiring.{u3} R _inst_12) (Ring.toSemiring.{u2} A _inst_13) _inst_15)] [_inst_21 : NoZeroSMulDivisors.{u2, u1} A M (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_13))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (SMulZeroClass.toSMul.{u2, u1} A M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (SMulWithZero.toSMulZeroClass.{u2, u1} A M (MonoidWithZero.toZero.{u2} A (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_13))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (MulActionWithZero.toSMulWithZero.{u2, u1} A M (Semiring.toMonoidWithZero.{u2} A (Ring.toSemiring.{u2} A _inst_13)) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (Module.toMulActionWithZero.{u2, u1} A M (Ring.toSemiring.{u2} A _inst_13) (AddCommGroup.toAddCommMonoid.{u1} M _inst_16) _inst_18))))], NoZeroSMulDivisors.{u3, u1} R M (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_12))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (SMulZeroClass.toSMul.{u3, u1} R M (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (SMulWithZero.toSMulZeroClass.{u3, u1} R M (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_12))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (MulActionWithZero.toSMulWithZero.{u3, u1} R M (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_12))) (NegZeroClass.toZero.{u1} M (SubNegZeroMonoid.toNegZeroClass.{u1} M (SubtractionMonoid.toSubNegZeroMonoid.{u1} M (SubtractionCommMonoid.toSubtractionMonoid.{u1} M (AddCommGroup.toDivisionAddCommMonoid.{u1} M _inst_16))))) (Module.toMulActionWithZero.{u3, u1} R M (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_12)) (AddCommGroup.toAddCommMonoid.{u1} M _inst_16) _inst_17))))
Case conversion may be inaccurate. Consider using '#align no_zero_smul_divisors.trans NoZeroSMulDivisors.transₓ'. -/
theorem NoZeroSMulDivisors.trans (R A M : Type _) [CommRing R] [Ring A] [IsDomain A] [Algebra R A]
    [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M] [NoZeroSMulDivisors R A]
    [NoZeroSMulDivisors A M] : NoZeroSMulDivisors R M :=
  by
  refine' ⟨fun r m h => _⟩
  rw [algebra_compatible_smul A r m] at h
  cases' smul_eq_zero.1 h with H H
  · have : Function.Injective (algebraMap R A) :=
      NoZeroSMulDivisors.iff_algebraMap_injective.1 inferInstance
    left
    exact (injective_iff_map_eq_zero _).1 this _ H
  · right
    exact H
#align no_zero_smul_divisors.trans NoZeroSMulDivisors.trans

variable {A}

#print IsScalarTower.to_smulCommClass /-
-- see Note [lower instance priority]
instance (priority := 100) IsScalarTower.to_smulCommClass : SMulCommClass R A M :=
  ⟨fun r a m => by
    rw [algebra_compatible_smul A r (a • m), smul_smul, Algebra.commutes, mul_smul, ←
      algebra_compatible_smul]⟩
#align is_scalar_tower.to_smul_comm_class IsScalarTower.to_smulCommClass
-/

#print IsScalarTower.to_smulCommClass' /-
-- see Note [lower instance priority]
instance (priority := 100) IsScalarTower.to_smulCommClass' : SMulCommClass A R M :=
  SMulCommClass.symm _ _ _
#align is_scalar_tower.to_smul_comm_class' IsScalarTower.to_smulCommClass'
-/

#print smul_algebra_smul_comm /-
theorem smul_algebra_smul_comm (r : R) (a : A) (m : M) : a • r • m = r • a • m :=
  smul_comm _ _ _
#align smul_algebra_smul_comm smul_algebra_smul_comm
-/

namespace LinearMap

/- warning: linear_map.coe_is_scalar_tower -> LinearMap.coeIsScalarTower is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : CommSemiring.{u1} R] {A : Type.{u2}} [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] {M : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} A M _inst_2 _inst_4] [_inst_6 : Module.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4] [_inst_7 : IsScalarTower.{u1, u2, u3} R A M (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u3} A M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u2, u3} A M (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u2, u3} A M (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u2, u3} A M _inst_2 _inst_4 _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6))))] {N : Type.{u4}} [_inst_8 : AddCommMonoid.{u4} N] [_inst_9 : Module.{u2, u4} A N _inst_2 _inst_8] [_inst_10 : Module.{u1, u4} R N (CommSemiring.toSemiring.{u1} R _inst_1) _inst_8] [_inst_11 : IsScalarTower.{u1, u2, u4} R A N (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u4} A N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u2, u4} A N (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u2, u4} A N (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u2, u4} A N _inst_2 _inst_8 _inst_9)))) (SMulZeroClass.toHasSmul.{u1, u4} R N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u1, u4} R N (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u1, u4} R N (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u1, u4} R N (CommSemiring.toSemiring.{u1} R _inst_1) _inst_8 _inst_10))))], Coe.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10)
but is expected to have type
  forall (R : Type.{u1}) {_inst_1 : Type.{u2}} {A : Type.{u3}} {_inst_2 : Type.{u4}} [_inst_3 : Semiring.{u1} R] [M : Semiring.{u2} _inst_1] [_inst_4 : AddCommMonoid.{u3} A] [_inst_5 : AddCommMonoid.{u4} _inst_2] [_inst_6 : Module.{u1, u3} R A _inst_3 _inst_4] [_inst_7 : Module.{u1, u4} R _inst_2 _inst_3 _inst_5] [N : Module.{u2, u3} _inst_1 A M _inst_4] [_inst_8 : Module.{u2, u4} _inst_1 _inst_2 M _inst_5] [_inst_9 : LinearMap.CompatibleSMul.{u3, u4, u1, u2} A _inst_2 _inst_4 _inst_5 R _inst_1 M (SMulZeroClass.toSMul.{u1, u3} R A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_4)) (SMulWithZero.toSMulZeroClass.{u1, u3} R A (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_3)) (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_4)) (MulActionWithZero.toSMulWithZero.{u1, u3} R A (Semiring.toMonoidWithZero.{u1} R _inst_3) (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_4)) (Module.toMulActionWithZero.{u1, u3} R A _inst_3 _inst_4 _inst_6)))) N (SMulZeroClass.toSMul.{u1, u4} R _inst_2 (AddMonoid.toZero.{u4} _inst_2 (AddCommMonoid.toAddMonoid.{u4} _inst_2 _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u4} R _inst_2 (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_3)) (AddMonoid.toZero.{u4} _inst_2 (AddCommMonoid.toAddMonoid.{u4} _inst_2 _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u4} R _inst_2 (Semiring.toMonoidWithZero.{u1} R _inst_3) (AddMonoid.toZero.{u4} _inst_2 (AddCommMonoid.toAddMonoid.{u4} _inst_2 _inst_5)) (Module.toMulActionWithZero.{u1, u4} R _inst_2 _inst_3 _inst_5 _inst_7)))) _inst_8], CoeHTCT.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (LinearMap.{u2, u2, u3, u4} _inst_1 _inst_1 M M (RingHom.id.{u2} _inst_1 (Semiring.toNonAssocSemiring.{u2} _inst_1 M)) A _inst_2 _inst_4 _inst_5 N _inst_8) (LinearMap.{u1, u1, u3, u4} R R _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)) A _inst_2 _inst_4 _inst_5 _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align linear_map.coe_is_scalar_tower LinearMap.coeIsScalarTowerₓ'. -/
instance coeIsScalarTower : Coe (M →ₗ[A] N) (M →ₗ[R] N) :=
  ⟨restrictScalars R⟩
#align linear_map.coe_is_scalar_tower LinearMap.coeIsScalarTower

variable (R) {A M N}

/- warning: linear_map.coe_restrict_scalars_eq_coe clashes with linear_map.coe_restrict_scalars -> LinearMap.coe_restrictScalars
warning: linear_map.coe_restrict_scalars_eq_coe -> LinearMap.coe_restrictScalars is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] {A : Type.{u2}} [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] {M : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} A M _inst_2 _inst_4] [_inst_6 : Module.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4] [_inst_7 : IsScalarTower.{u1, u2, u3} R A M (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u3} A M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u2, u3} A M (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u2, u3} A M (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u2, u3} A M _inst_2 _inst_4 _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6))))] {N : Type.{u4}} [_inst_8 : AddCommMonoid.{u4} N] [_inst_9 : Module.{u2, u4} A N _inst_2 _inst_8] [_inst_10 : Module.{u1, u4} R N (CommSemiring.toSemiring.{u1} R _inst_1) _inst_8] [_inst_11 : IsScalarTower.{u1, u2, u4} R A N (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u4} A N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u2, u4} A N (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u2, u4} A N (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u2, u4} A N _inst_2 _inst_8 _inst_9)))) (SMulZeroClass.toHasSmul.{u1, u4} R N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u1, u4} R N (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u1, u4} R N (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u1, u4} R N (CommSemiring.toSemiring.{u1} R _inst_1) _inst_8 _inst_10))))] (f : LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9), Eq.{max (succ u3) (succ u4)} ((fun (_x : LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) => M -> N) (LinearMap.restrictScalars.{u1, u2, u3, u4} R A M N (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4 _inst_8 _inst_6 _inst_10 _inst_5 _inst_9 (LinearMap.IsScalarTower.compatibleSMul.{u3, u4, u1, u2} M N _inst_4 _inst_8 R A _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6)))) _inst_5 _inst_7 (SMulZeroClass.toHasSmul.{u1, u4} R N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u1, u4} R N (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u1, u4} R N (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u1, u4} R N (CommSemiring.toSemiring.{u1} R _inst_1) _inst_8 _inst_10)))) _inst_9 _inst_11) f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) (fun (_x : LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) => M -> N) (LinearMap.hasCoeToFun.{u1, u1, u3, u4} R R M N (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_8 _inst_6 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) (LinearMap.restrictScalars.{u1, u2, u3, u4} R A M N (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4 _inst_8 _inst_6 _inst_10 _inst_5 _inst_9 (LinearMap.IsScalarTower.compatibleSMul.{u3, u4, u1, u2} M N _inst_4 _inst_8 R A _inst_2 (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6)))) _inst_5 _inst_7 (SMulZeroClass.toHasSmul.{u1, u4} R N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u1, u4} R N (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u1, u4} R N (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u1, u4} R N (CommSemiring.toSemiring.{u1} R _inst_1) _inst_8 _inst_10)))) _inst_9 _inst_11) f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (fun (_x : LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) => M -> N) (LinearMap.hasCoeToFun.{u2, u2, u3, u4} A A M N _inst_2 _inst_2 _inst_4 _inst_8 _inst_5 _inst_9 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) f)
but is expected to have type
  forall (R : Type.{u1}) {_inst_1 : Type.{u4}} {A : Type.{u3}} {_inst_2 : Type.{u2}} [_inst_3 : Semiring.{u1} R] [M : Semiring.{u4} _inst_1] [_inst_4 : AddCommMonoid.{u3} A] [_inst_5 : AddCommMonoid.{u2} _inst_2] [_inst_6 : Module.{u1, u3} R A _inst_3 _inst_4] [_inst_7 : Module.{u1, u2} R _inst_2 _inst_3 _inst_5] [N : Module.{u4, u3} _inst_1 A M _inst_4] [_inst_8 : Module.{u4, u2} _inst_1 _inst_2 M _inst_5] [_inst_9 : LinearMap.CompatibleSMul.{u3, u2, u1, u4} A _inst_2 _inst_4 _inst_5 R _inst_1 M (SMulZeroClass.toSMul.{u1, u3} R A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_4)) (SMulWithZero.toSMulZeroClass.{u1, u3} R A (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_3)) (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_4)) (MulActionWithZero.toSMulWithZero.{u1, u3} R A (Semiring.toMonoidWithZero.{u1} R _inst_3) (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_4)) (Module.toMulActionWithZero.{u1, u3} R A _inst_3 _inst_4 _inst_6)))) N (SMulZeroClass.toSMul.{u1, u2} R _inst_2 (AddMonoid.toZero.{u2} _inst_2 (AddCommMonoid.toAddMonoid.{u2} _inst_2 _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u2} R _inst_2 (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_3)) (AddMonoid.toZero.{u2} _inst_2 (AddCommMonoid.toAddMonoid.{u2} _inst_2 _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u2} R _inst_2 (Semiring.toMonoidWithZero.{u1} R _inst_3) (AddMonoid.toZero.{u2} _inst_2 (AddCommMonoid.toAddMonoid.{u2} _inst_2 _inst_5)) (Module.toMulActionWithZero.{u1, u2} R _inst_2 _inst_3 _inst_5 _inst_7)))) _inst_8] (_inst_10 : LinearMap.{u4, u4, u3, u2} _inst_1 _inst_1 M M (RingHom.id.{u4} _inst_1 (Semiring.toNonAssocSemiring.{u4} _inst_1 M)) A _inst_2 _inst_4 _inst_5 N _inst_8), Eq.{max (succ u3) (succ u2)} (forall (a : A), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => _inst_2) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u1, u1, u3, u2} R R _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)) A _inst_2 _inst_4 _inst_5 _inst_6 _inst_7) A (fun (a : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => _inst_2) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, u2} R R A _inst_2 _inst_3 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))) (LinearMap.restrictScalars.{u1, u4, u3, u2} R _inst_1 A _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 _inst_7 N _inst_8 _inst_9 _inst_10)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u4, u4, u3, u2} _inst_1 _inst_1 M M (RingHom.id.{u4} _inst_1 (Semiring.toNonAssocSemiring.{u4} _inst_1 M)) A _inst_2 _inst_4 _inst_5 N _inst_8) A (fun (a : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => _inst_2) a) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, u2} _inst_1 _inst_1 A _inst_2 M M _inst_4 _inst_5 N _inst_8 (RingHom.id.{u4} _inst_1 (Semiring.toNonAssocSemiring.{u4} _inst_1 M))) _inst_10)
Case conversion may be inaccurate. Consider using '#align linear_map.coe_restrict_scalars_eq_coe LinearMap.coe_restrictScalarsₓ'. -/
@[simp, norm_cast squash]
theorem coe_restrictScalars (f : M →ₗ[A] N) : (f.restrictScalars R : M → N) = f :=
  rfl
#align linear_map.coe_restrict_scalars_eq_coe LinearMap.coe_restrictScalars

/- warning: linear_map.coe_coe_is_scalar_tower clashes with linear_map.coe_restrict_scalars -> LinearMap.coe_restrictScalars
warning: linear_map.coe_coe_is_scalar_tower -> LinearMap.coe_restrictScalars is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : CommSemiring.{u1} R] {A : Type.{u2}} [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] {M : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u2, u3} A M _inst_2 _inst_4] [_inst_6 : Module.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4] [_inst_7 : IsScalarTower.{u1, u2, u3} R A M (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u3} A M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u2, u3} A M (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u2, u3} A M (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u2, u3} A M _inst_2 _inst_4 _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_6))))] {N : Type.{u4}} [_inst_8 : AddCommMonoid.{u4} N] [_inst_9 : Module.{u2, u4} A N _inst_2 _inst_8] [_inst_10 : Module.{u1, u4} R N (CommSemiring.toSemiring.{u1} R _inst_1) _inst_8] [_inst_11 : IsScalarTower.{u1, u2, u4} R A N (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) (Algebra.toModule.{u1, u2} R A _inst_1 _inst_2 _inst_3))))) (SMulZeroClass.toHasSmul.{u2, u4} A N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u2, u4} A N (MulZeroClass.toHasZero.{u2} A (MulZeroOneClass.toMulZeroClass.{u2} A (MonoidWithZero.toMulZeroOneClass.{u2} A (Semiring.toMonoidWithZero.{u2} A _inst_2)))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u2, u4} A N (Semiring.toMonoidWithZero.{u2} A _inst_2) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u2, u4} A N _inst_2 _inst_8 _inst_9)))) (SMulZeroClass.toHasSmul.{u1, u4} R N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u1, u4} R N (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u1, u4} R N (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u1, u4} R N (CommSemiring.toSemiring.{u1} R _inst_1) _inst_8 _inst_10))))] (f : LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9), Eq.{max (succ u3) (succ u4)} ((fun (_x : LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) => M -> N) ((fun (a : Sort.{max (succ u3) (succ u4)}) (b : Sort.{max (succ u3) (succ u4)}) [self : HasLiftT.{max (succ u3) (succ u4), max (succ u3) (succ u4)} a b] => self.0) (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) (HasLiftT.mk.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) (CoeTCₓ.coe.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) (coeBase.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) (LinearMap.coeIsScalarTower.{u1, u2, u3, u4} R _inst_1 A _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 _inst_7 N _inst_8 _inst_9 _inst_10 _inst_11)))) f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) (fun (_x : LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) => M -> N) (LinearMap.hasCoeToFun.{u1, u1, u3, u4} R R M N (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) _inst_4 _inst_8 _inst_6 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)))) ((fun (a : Sort.{max (succ u3) (succ u4)}) (b : Sort.{max (succ u3) (succ u4)}) [self : HasLiftT.{max (succ u3) (succ u4), max (succ u3) (succ u4)} a b] => self.0) (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) (HasLiftT.mk.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) (CoeTCₓ.coe.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) (coeBase.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.{u1, u1, u3, u4} R R (CommSemiring.toSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) M N _inst_4 _inst_8 _inst_6 _inst_10) (LinearMap.coeIsScalarTower.{u1, u2, u3, u4} R _inst_1 A _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 _inst_7 N _inst_8 _inst_9 _inst_10 _inst_11)))) f)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) (fun (_x : LinearMap.{u2, u2, u3, u4} A A _inst_2 _inst_2 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2)) M N _inst_4 _inst_8 _inst_5 _inst_9) => M -> N) (LinearMap.hasCoeToFun.{u2, u2, u3, u4} A A M N _inst_2 _inst_2 _inst_4 _inst_8 _inst_5 _inst_9 (RingHom.id.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))) f)
but is expected to have type
  forall (R : Type.{u1}) {_inst_1 : Type.{u4}} {A : Type.{u3}} {_inst_2 : Type.{u2}} [_inst_3 : Semiring.{u1} R] [M : Semiring.{u4} _inst_1] [_inst_4 : AddCommMonoid.{u3} A] [_inst_5 : AddCommMonoid.{u2} _inst_2] [_inst_6 : Module.{u1, u3} R A _inst_3 _inst_4] [_inst_7 : Module.{u1, u2} R _inst_2 _inst_3 _inst_5] [N : Module.{u4, u3} _inst_1 A M _inst_4] [_inst_8 : Module.{u4, u2} _inst_1 _inst_2 M _inst_5] [_inst_9 : LinearMap.CompatibleSMul.{u3, u2, u1, u4} A _inst_2 _inst_4 _inst_5 R _inst_1 M (SMulZeroClass.toSMul.{u1, u3} R A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_4)) (SMulWithZero.toSMulZeroClass.{u1, u3} R A (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_3)) (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_4)) (MulActionWithZero.toSMulWithZero.{u1, u3} R A (Semiring.toMonoidWithZero.{u1} R _inst_3) (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_4)) (Module.toMulActionWithZero.{u1, u3} R A _inst_3 _inst_4 _inst_6)))) N (SMulZeroClass.toSMul.{u1, u2} R _inst_2 (AddMonoid.toZero.{u2} _inst_2 (AddCommMonoid.toAddMonoid.{u2} _inst_2 _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u2} R _inst_2 (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_3)) (AddMonoid.toZero.{u2} _inst_2 (AddCommMonoid.toAddMonoid.{u2} _inst_2 _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u2} R _inst_2 (Semiring.toMonoidWithZero.{u1} R _inst_3) (AddMonoid.toZero.{u2} _inst_2 (AddCommMonoid.toAddMonoid.{u2} _inst_2 _inst_5)) (Module.toMulActionWithZero.{u1, u2} R _inst_2 _inst_3 _inst_5 _inst_7)))) _inst_8] (_inst_10 : LinearMap.{u4, u4, u3, u2} _inst_1 _inst_1 M M (RingHom.id.{u4} _inst_1 (Semiring.toNonAssocSemiring.{u4} _inst_1 M)) A _inst_2 _inst_4 _inst_5 N _inst_8), Eq.{max (succ u3) (succ u2)} (forall (a : A), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => _inst_2) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u1, u1, u3, u2} R R _inst_3 _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3)) A _inst_2 _inst_4 _inst_5 _inst_6 _inst_7) A (fun (a : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => _inst_2) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, u2} R R A _inst_2 _inst_3 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_3))) (LinearMap.restrictScalars.{u1, u4, u3, u2} R _inst_1 A _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 _inst_7 N _inst_8 _inst_9 _inst_10)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u4, u4, u3, u2} _inst_1 _inst_1 M M (RingHom.id.{u4} _inst_1 (Semiring.toNonAssocSemiring.{u4} _inst_1 M)) A _inst_2 _inst_4 _inst_5 N _inst_8) A (fun (a : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : A) => _inst_2) a) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, u2} _inst_1 _inst_1 A _inst_2 M M _inst_4 _inst_5 N _inst_8 (RingHom.id.{u4} _inst_1 (Semiring.toNonAssocSemiring.{u4} _inst_1 M))) _inst_10)
Case conversion may be inaccurate. Consider using '#align linear_map.coe_coe_is_scalar_tower LinearMap.coe_restrictScalarsₓ'. -/
@[simp, norm_cast squash]
theorem coe_restrictScalars (f : M →ₗ[A] N) : ((f : M →ₗ[R] N) : M → N) = f :=
  rfl
#align linear_map.coe_coe_is_scalar_tower LinearMap.coe_restrictScalars

/- warning: linear_map.lto_fun -> LinearMap.ltoFun is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (A : Type.{u3}) [_inst_12 : CommSemiring.{u1} R] [_inst_13 : AddCommMonoid.{u2} M] [_inst_14 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_12) _inst_13] [_inst_15 : CommRing.{u3} A] [_inst_16 : Algebra.{u1, u3} R A _inst_12 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15))], LinearMap.{u3, u3, max u2 u3, max u2 u3} A A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15)) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15)) (RingHom.id.{u3} A (Semiring.toNonAssocSemiring.{u3} A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15)))) (LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_12) (CommSemiring.toSemiring.{u1} R _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_12))) M A _inst_13 (AddCommGroup.toAddCommMonoid.{u3} A (NonUnitalNonAssocRing.toAddCommGroup.{u3} A (NonAssocRing.toNonUnitalNonAssocRing.{u3} A (Ring.toNonAssocRing.{u3} A (CommRing.toRing.{u3} A _inst_15))))) _inst_14 (Algebra.toModule.{u1, u3} R A _inst_12 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15)) _inst_16)) (M -> A) (LinearMap.addCommMonoid.{u1, u1, u2, u3} R R M A (CommSemiring.toSemiring.{u1} R _inst_12) (CommSemiring.toSemiring.{u1} R _inst_12) _inst_13 (AddCommGroup.toAddCommMonoid.{u3} A (NonUnitalNonAssocRing.toAddCommGroup.{u3} A (NonAssocRing.toNonUnitalNonAssocRing.{u3} A (Ring.toNonAssocRing.{u3} A (CommRing.toRing.{u3} A _inst_15))))) _inst_14 (Algebra.toModule.{u1, u3} R A _inst_12 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15)) _inst_16) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_12)))) (Pi.addCommMonoid.{u2, u3} M (fun (ᾰ : M) => A) (fun (i : M) => AddCommGroup.toAddCommMonoid.{u3} A (NonUnitalNonAssocRing.toAddCommGroup.{u3} A (NonAssocRing.toNonUnitalNonAssocRing.{u3} A (Ring.toNonAssocRing.{u3} A (CommRing.toRing.{u3} A _inst_15)))))) (LinearMap.module.{u1, u1, u3, u2, u3} R R A M A (CommSemiring.toSemiring.{u1} R _inst_12) (CommSemiring.toSemiring.{u1} R _inst_12) _inst_13 (AddCommGroup.toAddCommMonoid.{u3} A (NonUnitalNonAssocRing.toAddCommGroup.{u3} A (NonAssocRing.toNonUnitalNonAssocRing.{u3} A (Ring.toNonAssocRing.{u3} A (CommRing.toRing.{u3} A _inst_15))))) _inst_14 (Algebra.toModule.{u1, u3} R A _inst_12 (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15)) _inst_16) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_12))) (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15)) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15))) (LinearMap.ltoFun._proof_1.{u1, u3} R A _inst_12 _inst_15 _inst_16)) (Pi.Function.module.{u2, u3, u3} M A A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15)) (AddCommGroup.toAddCommMonoid.{u3} A (NonUnitalNonAssocRing.toAddCommGroup.{u3} A (NonAssocRing.toNonUnitalNonAssocRing.{u3} A (Ring.toNonAssocRing.{u3} A (CommRing.toRing.{u3} A _inst_15))))) (Semiring.toModule.{u3} A (Ring.toSemiring.{u3} A (CommRing.toRing.{u3} A _inst_15))))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (A : Type.{u3}) [_inst_12 : CommSemiring.{u1} R] [_inst_13 : AddCommMonoid.{u2} M] [_inst_14 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_12) _inst_13] [_inst_15 : CommSemiring.{u3} A] [_inst_16 : Algebra.{u1, u3} R A _inst_12 (CommSemiring.toSemiring.{u3} A _inst_15)], LinearMap.{u3, u3, max u3 u2, max u2 u3} A A (CommSemiring.toSemiring.{u3} A _inst_15) (CommSemiring.toSemiring.{u3} A _inst_15) (RingHom.id.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_15))) (LinearMap.{u1, u1, u2, u3} R R (CommSemiring.toSemiring.{u1} R _inst_12) (CommSemiring.toSemiring.{u1} R _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_12))) M A _inst_13 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_15)))) _inst_14 (Algebra.toModule.{u1, u3} R A _inst_12 (CommSemiring.toSemiring.{u3} A _inst_15) _inst_16)) (M -> A) (LinearMap.addCommMonoid.{u1, u1, u2, u3} R R M A (CommSemiring.toSemiring.{u1} R _inst_12) (CommSemiring.toSemiring.{u1} R _inst_12) _inst_13 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_15)))) _inst_14 (Algebra.toModule.{u1, u3} R A _inst_12 (CommSemiring.toSemiring.{u3} A _inst_15) _inst_16) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_12)))) (Pi.addCommMonoid.{u2, u3} M (fun (ᾰ : M) => A) (fun (i : M) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_15))))) (LinearMap.instModuleLinearMapAddCommMonoid.{u1, u1, u3, u2, u3} R R A M A (CommSemiring.toSemiring.{u1} R _inst_12) (CommSemiring.toSemiring.{u1} R _inst_12) _inst_13 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_15)))) _inst_14 (Algebra.toModule.{u1, u3} R A _inst_12 (CommSemiring.toSemiring.{u3} A _inst_15) _inst_16) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_12))) (CommSemiring.toSemiring.{u3} A _inst_15) (Semiring.toModule.{u3} A (CommSemiring.toSemiring.{u3} A _inst_15)) (IsScalarTower.to_smulCommClass.{u1, u3, u3} R _inst_12 A (CommSemiring.toSemiring.{u3} A _inst_15) _inst_16 A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_15)))) (Semiring.toModule.{u3} A (CommSemiring.toSemiring.{u3} A _inst_15)) (Algebra.toModule.{u1, u3} R A _inst_12 (CommSemiring.toSemiring.{u3} A _inst_15) _inst_16) (IsScalarTower.right.{u1, u3} R A _inst_12 (CommSemiring.toSemiring.{u3} A _inst_15) _inst_16))) (Pi.module.{u2, u3, u3} M (fun (a._@.Mathlib.Algebra.Algebra.Basic._hyg.6632 : M) => A) A (CommSemiring.toSemiring.{u3} A _inst_15) (fun (i : M) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} A (Semiring.toNonAssocSemiring.{u3} A (CommSemiring.toSemiring.{u3} A _inst_15)))) (fun (i : M) => Semiring.toModule.{u3} A (CommSemiring.toSemiring.{u3} A _inst_15)))
Case conversion may be inaccurate. Consider using '#align linear_map.lto_fun LinearMap.ltoFunₓ'. -/
/-- `A`-linearly coerce a `R`-linear map from `M` to `A` to a function, given an algebra `A` over
a commutative semiring `R` and `M` a module over `R`. -/
def ltoFun (R : Type u) (M : Type v) (A : Type w) [CommSemiring R] [AddCommMonoid M] [Module R M]
    [CommRing A] [Algebra R A] : (M →ₗ[R] A) →ₗ[A] M → A
    where
  toFun := LinearMap.toFun
  map_add' f g := rfl
  map_smul' c f := rfl
#align linear_map.lto_fun LinearMap.ltoFun

end LinearMap

end IsScalarTower

/-! TODO: The following lemmas no longer involve `algebra` at all, and could be moved closer
to `algebra/module/submodule.lean`. Currently this is tricky because `ker`, `range`, `⊤`, and `⊥`
are all defined in `linear_algebra/basic.lean`. -/


section Module

open Module

variable (R S M N : Type _) [Semiring R] [Semiring S] [SMul R S]

variable [AddCommMonoid M] [Module R M] [Module S M] [IsScalarTower R S M]

variable [AddCommMonoid N] [Module R N] [Module S N] [IsScalarTower R S N]

variable {S M N}

/- warning: linear_map.ker_restrict_scalars -> LinearMap.ker_restrictScalars is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {S : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u2} S] [_inst_3 : SMul.{u1, u2} R S] [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u1, u3} R M _inst_1 _inst_4] [_inst_6 : Module.{u2, u3} S M _inst_2 _inst_4] [_inst_7 : IsScalarTower.{u1, u2, u3} R S M _inst_3 (SMulZeroClass.toHasSmul.{u2, u3} S M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u2, u3} S M (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u2, u3} S M (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u2, u3} S M _inst_2 _inst_4 _inst_6)))) (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_4 _inst_5))))] [_inst_8 : AddCommMonoid.{u4} N] [_inst_9 : Module.{u1, u4} R N _inst_1 _inst_8] [_inst_10 : Module.{u2, u4} S N _inst_2 _inst_8] [_inst_11 : IsScalarTower.{u1, u2, u4} R S N _inst_3 (SMulZeroClass.toHasSmul.{u2, u4} S N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u2, u4} S N (MulZeroClass.toHasZero.{u2} S (MulZeroOneClass.toMulZeroClass.{u2} S (MonoidWithZero.toMulZeroOneClass.{u2} S (Semiring.toMonoidWithZero.{u2} S _inst_2)))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u2, u4} S N (Semiring.toMonoidWithZero.{u2} S _inst_2) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u2, u4} S N _inst_2 _inst_8 _inst_10)))) (SMulZeroClass.toHasSmul.{u1, u4} R N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u1, u4} R N (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u1, u4} R N (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u1, u4} R N _inst_1 _inst_8 _inst_9))))] (f : LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M N _inst_4 _inst_8 _inst_6 _inst_10), Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_4 _inst_5) (LinearMap.ker.{u1, u1, u3, u4, max u3 u4} R R M N _inst_1 _inst_1 _inst_4 _inst_8 _inst_5 _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.semilinearMapClass.{u1, u1, u3, u4} R R M N _inst_1 _inst_1 _inst_4 _inst_8 _inst_5 _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.restrictScalars.{u1, u2, u3, u4} R S M N _inst_1 _inst_2 _inst_4 _inst_8 _inst_5 _inst_9 _inst_6 _inst_10 (LinearMap.IsScalarTower.compatibleSMul.{u3, u4, u1, u2} M N _inst_4 _inst_8 R S _inst_2 _inst_3 (SMulZeroClass.toHasSmul.{u1, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_4 _inst_5)))) _inst_6 _inst_7 (SMulZeroClass.toHasSmul.{u1, u4} R N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (SMulWithZero.toSmulZeroClass.{u1, u4} R N (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (MulActionWithZero.toSMulWithZero.{u1, u4} R N (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_8))) (Module.toMulActionWithZero.{u1, u4} R N _inst_1 _inst_8 _inst_9)))) _inst_10 _inst_11) f)) (Submodule.restrictScalars.{u1, u2, u3} R S M _inst_2 _inst_4 _inst_1 _inst_5 _inst_6 _inst_3 _inst_7 (LinearMap.ker.{u2, u2, u3, u4, max u3 u4} S S M N _inst_2 _inst_2 _inst_4 _inst_8 _inst_6 _inst_10 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) (LinearMap.{u2, u2, u3, u4} S S _inst_2 _inst_2 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2)) M N _inst_4 _inst_8 _inst_6 _inst_10) (LinearMap.semilinearMapClass.{u2, u2, u3, u4} S S M N _inst_2 _inst_2 _inst_4 _inst_8 _inst_6 _inst_10 (RingHom.id.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_2))) f))
but is expected to have type
  forall (R : Type.{u1}) {S : Type.{u4}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u4} S] [_inst_3 : SMul.{u1, u4} R S] [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : Module.{u1, u3} R M _inst_1 _inst_4] [_inst_6 : Module.{u4, u3} S M _inst_2 _inst_4] [_inst_7 : IsScalarTower.{u1, u4, u3} R S M _inst_3 (SMulZeroClass.toSMul.{u4, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u4, u3} S M (MonoidWithZero.toZero.{u4} S (Semiring.toMonoidWithZero.{u4} S _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u4, u3} S M (Semiring.toMonoidWithZero.{u4} S _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u4, u3} S M _inst_2 _inst_4 _inst_6)))) (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_4 _inst_5))))] [_inst_8 : AddCommMonoid.{u2} N] [_inst_9 : Module.{u1, u2} R N _inst_1 _inst_8] [_inst_10 : Module.{u4, u2} S N _inst_2 _inst_8] [_inst_11 : IsScalarTower.{u1, u4, u2} R S N _inst_3 (SMulZeroClass.toSMul.{u4, u2} S N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)) (SMulWithZero.toSMulZeroClass.{u4, u2} S N (MonoidWithZero.toZero.{u4} S (Semiring.toMonoidWithZero.{u4} S _inst_2)) (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)) (MulActionWithZero.toSMulWithZero.{u4, u2} S N (Semiring.toMonoidWithZero.{u4} S _inst_2) (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)) (Module.toMulActionWithZero.{u4, u2} S N _inst_2 _inst_8 _inst_10)))) (SMulZeroClass.toSMul.{u1, u2} R N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)) (SMulWithZero.toSMulZeroClass.{u1, u2} R N (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)) (MulActionWithZero.toSMulWithZero.{u1, u2} R N (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)) (Module.toMulActionWithZero.{u1, u2} R N _inst_1 _inst_8 _inst_9))))] (f : LinearMap.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) M N _inst_4 _inst_8 _inst_6 _inst_10), Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_4 _inst_5) (LinearMap.ker.{u1, u1, u3, u2, max u3 u2} R R M N _inst_1 _inst_1 _inst_4 _inst_8 _inst_5 _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M N _inst_4 _inst_8 _inst_5 _inst_9) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, u2} R R M N _inst_1 _inst_1 _inst_4 _inst_8 _inst_5 _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.restrictScalars.{u1, u4, u3, u2} R S M N _inst_1 _inst_2 _inst_4 _inst_8 _inst_5 _inst_9 _inst_6 _inst_10 (LinearMap.IsScalarTower.compatibleSMul.{u3, u2, u1, u4} M N _inst_4 _inst_8 R S _inst_2 _inst_3 (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_4 _inst_5)))) _inst_6 _inst_7 (SMulZeroClass.toSMul.{u1, u2} R N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)) (SMulWithZero.toSMulZeroClass.{u1, u2} R N (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)) (MulActionWithZero.toSMulWithZero.{u1, u2} R N (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)) (Module.toMulActionWithZero.{u1, u2} R N _inst_1 _inst_8 _inst_9)))) _inst_10 _inst_11) f)) (Submodule.restrictScalars.{u1, u4, u3} R S M _inst_2 _inst_4 _inst_1 _inst_5 _inst_6 _inst_3 _inst_7 (LinearMap.ker.{u4, u4, u3, u2, max u3 u2} S S M N _inst_2 _inst_2 _inst_4 _inst_8 _inst_6 _inst_10 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) (LinearMap.{u4, u4, u3, u2} S S _inst_2 _inst_2 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2)) M N _inst_4 _inst_8 _inst_6 _inst_10) (LinearMap.instSemilinearMapClassLinearMap.{u4, u4, u3, u2} S S M N _inst_2 _inst_2 _inst_4 _inst_8 _inst_6 _inst_10 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_2))) f))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_restrict_scalars LinearMap.ker_restrictScalarsₓ'. -/
@[simp]
theorem LinearMap.ker_restrictScalars (f : M →ₗ[S] N) :
    (f.restrictScalars R).ker = f.ker.restrictScalars R :=
  rfl
#align linear_map.ker_restrict_scalars LinearMap.ker_restrictScalars

end Module

example {R A} [CommSemiring R] [Semiring A] [Module R A] [SMulCommClass R A A]
    [IsScalarTower R A A] : Algebra R A :=
  Algebra.ofModule smul_mul_assoc mul_smul_comm

