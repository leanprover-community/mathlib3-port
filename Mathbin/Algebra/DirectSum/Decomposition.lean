/-
Copyright (c) 2022 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser, Jujian Zhang

! This file was ported from Lean 3 source module algebra.direct_sum.decomposition
! leanprover-community/mathlib commit 4e861f25ba5ceef42ba0712d8ffeb32f38ad6441
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.DirectSum.Module
import Mathbin.Algebra.Module.Submodule.Basic

/-!
# Decompositions of additive monoids, groups, and modules into direct sums

## Main definitions

* `direct_sum.decomposition ℳ`: A typeclass to provide a constructive decomposition from
  an additive monoid `M` into a family of additive submonoids `ℳ`
* `direct_sum.decompose ℳ`: The canonical equivalence provided by the above typeclass


## Main statements

* `direct_sum.decomposition.is_internal`: The link to `direct_sum.is_internal`.

## Implementation details

As we want to talk about different types of decomposition (additive monoids, modules, rings, ...),
we choose to avoid heavily bundling `direct_sum.decompose`, instead making copies for the
`add_equiv`, `linear_equiv`, etc. This means we have to repeat statements that follow from these
bundled homs, but means we don't have to repeat statements for different types of decomposition.
-/


variable {ι R M σ : Type _}

open DirectSum BigOperators

namespace DirectSum

section AddCommMonoid

variable [DecidableEq ι] [AddCommMonoid M]

variable [SetLike σ M] [AddSubmonoidClass σ M] (ℳ : ι → σ)

#print DirectSum.Decomposition /-
/-- A decomposition is an equivalence between an additive monoid `M` and a direct sum of additive
submonoids `ℳ i` of that `M`, such that the "recomposition" is canonical. This definition also
works for additive groups and modules.

This is a version of `direct_sum.is_internal` which comes with a constructive inverse to the
canonical "recomposition" rather than just a proof that the "recomposition" is bijective. -/
class Decomposition where
  decompose' : M → ⨁ i, ℳ i
  left_inv : Function.LeftInverse (DirectSum.coeAddMonoidHom ℳ) decompose'
  right_inv : Function.RightInverse (DirectSum.coeAddMonoidHom ℳ) decompose'
#align direct_sum.decomposition DirectSum.Decomposition
-/

include M

/-- `direct_sum.decomposition` instances, while carrying data, are always equal. -/
instance : Subsingleton (Decomposition ℳ) :=
  ⟨fun x y => by
    cases' x with x xl xr
    cases' y with y yl yr
    congr
    exact Function.LeftInverse.eq_rightInverse xr yl⟩

variable [Decomposition ℳ]

/- warning: direct_sum.decomposition.is_internal -> DirectSum.Decomposition.isInternal is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ], DirectSum.IsInternal.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubmonoidClass.{u1, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ], DirectSum.IsInternal.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ
Case conversion may be inaccurate. Consider using '#align direct_sum.decomposition.is_internal DirectSum.Decomposition.isInternalₓ'. -/
protected theorem Decomposition.isInternal : DirectSum.IsInternal ℳ :=
  ⟨Decomposition.right_inv.Injective, Decomposition.left_inv.Surjective⟩
#align direct_sum.decomposition.is_internal DirectSum.Decomposition.isInternal

#print DirectSum.decompose /-
/-- If `M` is graded by `ι` with degree `i` component `ℳ i`, then it is isomorphic as
to a direct sum of components. This is the canonical spelling of the `decompose'` field. -/
def decompose : M ≃ ⨁ i, ℳ i where
  toFun := Decomposition.decompose'
  invFun := DirectSum.coeAddMonoidHom ℳ
  left_inv := Decomposition.left_inv
  right_inv := Decomposition.right_inv
#align direct_sum.decompose DirectSum.decompose
-/

/- warning: direct_sum.decomposition.induction_on -> DirectSum.Decomposition.inductionOn is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {p : M -> Prop}, (p (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) -> (forall {i : ι} (m : coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)), p ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u3} M σ (SetLike.hasMem.{u3, u2} σ M _inst_3) x (ℳ i)))))) m)) -> (forall (m : M) (m' : M), (p m) -> (p m') -> (p (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) m m'))) -> (forall (m : M), p m)
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubmonoidClass.{u1, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {p : M -> Prop}, (p (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) -> (forall {i : ι} (m : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))), p (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u1, u2} σ M _inst_3 (ℳ i))) m)) -> (forall (m : M) (m' : M), (p m) -> (p m') -> (p (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) m m'))) -> (forall (m : M), p m)
Case conversion may be inaccurate. Consider using '#align direct_sum.decomposition.induction_on DirectSum.Decomposition.inductionOnₓ'. -/
protected theorem Decomposition.inductionOn {p : M → Prop} (h_zero : p 0)
    (h_homogeneous : ∀ {i} (m : ℳ i), p (m : M)) (h_add : ∀ m m' : M, p m → p m' → p (m + m')) :
    ∀ m, p m :=
  by
  let ℳ' : ι → AddSubmonoid M := fun i =>
    (⟨ℳ i, fun _ _ => AddMemClass.add_mem, ZeroMemClass.zero_mem _⟩ : AddSubmonoid M)
  haveI t : DirectSum.Decomposition ℳ' :=
    { decompose' := DirectSum.decompose ℳ
      left_inv := fun _ => (decompose ℳ).left_inv _
      right_inv := fun _ => (decompose ℳ).right_inv _ }
  have mem : ∀ m, m ∈ iSup ℳ' := fun m =>
    (DirectSum.IsInternal.addSubmonoid_iSup_eq_top ℳ' (decomposition.is_internal ℳ')).symm ▸ trivial
  exact fun m =>
    AddSubmonoid.iSup_induction ℳ' (mem m) (fun i m h => h_homogeneous ⟨m, h⟩) h_zero h_add
#align direct_sum.decomposition.induction_on DirectSum.Decomposition.inductionOn

/- warning: direct_sum.decomposition.decompose'_eq -> DirectSum.Decomposition.decompose'_eq is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ], Eq.{max (succ u2) (succ (max u1 u2))} (M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.Decomposition.decompose'.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i) _inst_5) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubmonoidClass.{u1, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ], Eq.{max (succ u3) (succ u2)} (M -> (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.Decomposition.decompose'.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i) _inst_5) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5))
Case conversion may be inaccurate. Consider using '#align direct_sum.decomposition.decompose'_eq DirectSum.Decomposition.decompose'_eqₓ'. -/
@[simp]
theorem Decomposition.decompose'_eq : Decomposition.decompose' = decompose ℳ :=
  rfl
#align direct_sum.decomposition.decompose'_eq DirectSum.Decomposition.decompose'_eq

/- warning: direct_sum.decompose_symm_of -> DirectSum.decompose_symm_of is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {i : ι} (x : coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)), Eq.{succ u2} M (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (AddMonoidHom.{u2, max u1 u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddCommMonoid.toAddMonoid.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (fun (_x : AddMonoidHom.{u2, max u1 u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddCommMonoid.toAddMonoid.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) => (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoidHom.hasCoeToFun.{u2, max u1 u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddCommMonoid.toAddMonoid.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun {i : ι} => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i) x)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u3} M σ (SetLike.hasMem.{u3, u2} σ M _inst_3) x (ℳ i)))))) x)
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u3}} {σ : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : SetLike.{u2, u3} σ M] [_inst_4 : AddSubmonoidClass.{u2, u3} σ M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {i : ι} (x : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))), Eq.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (a : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) a) (AddHomClass.toFunLike.{max u1 u3, u3, max u1 u3} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toAdd.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))) (AddZeroClass.toAdd.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u3, max u1 u3} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))) (AddMonoidHom.addMonoidHomClass.{u3, max u1 u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))))) (DirectSum.of.{u1, u3} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i) x)) (FunLike.coe.{max (succ u1) (succ u3), max (succ u1) (succ u3), succ u3} (Equiv.{max (succ u1) (succ u3), succ u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (fun (_x : DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u3), succ u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u3, max (succ u1) (succ u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (_x : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (AddHomClass.toFunLike.{max u1 u3, u3, max u1 u3} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toAdd.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))) (AddZeroClass.toAdd.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u3, max u1 u3} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))) (AddMonoidHom.addMonoidHomClass.{u3, max u1 u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))))) (DirectSum.of.{u1, u3} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i) x)) (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u2, u3} σ M _inst_3 (ℳ i))) x)
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_symm_of DirectSum.decompose_symm_ofₓ'. -/
@[simp]
theorem decompose_symm_of {i : ι} (x : ℳ i) : (decompose ℳ).symm (DirectSum.of _ i x) = x :=
  DirectSum.coeAddMonoidHom_of ℳ _ _
#align direct_sum.decompose_symm_of DirectSum.decompose_symm_of

/- warning: direct_sum.decompose_coe -> DirectSum.decompose_coe is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {i : ι} (x : coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)), Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u3} M σ (SetLike.hasMem.{u3, u2} σ M _inst_3) x (ℳ i)))))) x)) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (AddMonoidHom.{u2, max u1 u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddCommMonoid.toAddMonoid.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (fun (_x : AddMonoidHom.{u2, max u1 u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddCommMonoid.toAddMonoid.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) => (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoidHom.hasCoeToFun.{u2, max u1 u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddCommMonoid.toAddMonoid.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun {i : ι} => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i) x)
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u3}} {σ : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : SetLike.{u2, u3} σ M] [_inst_4 : AddSubmonoidClass.{u2, u3} σ M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {i : ι} (x : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))), Eq.{max (succ u1) (succ u3)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u2, u3} σ M _inst_3 (ℳ i))) x)) (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (Equiv.{succ u3, max (succ u3) (succ u1)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u3, max (succ u1) (succ u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u2, u3} σ M _inst_3 (ℳ i))) x)) (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (_x : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (AddHomClass.toFunLike.{max u1 u3, u3, max u1 u3} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toAdd.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))) (AddZeroClass.toAdd.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u3, max u1 u3} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))) (AddMonoidHom.addMonoidHomClass.{u3, max u1 u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))))) (DirectSum.of.{u1, u3} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i) x)
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_coe DirectSum.decompose_coeₓ'. -/
@[simp]
theorem decompose_coe {i : ι} (x : ℳ i) : decompose ℳ (x : M) = DirectSum.of _ i x := by
  rw [← decompose_symm_of, Equiv.apply_symm_apply]
#align direct_sum.decompose_coe DirectSum.decompose_coe

/- warning: direct_sum.decompose_of_mem -> DirectSum.decompose_of_mem is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {x : M} {i : ι} (hx : Membership.Mem.{u2, u3} M σ (SetLike.hasMem.{u3, u2} σ M _inst_3) x (ℳ i)), Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) x) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (AddMonoidHom.{u2, max u1 u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (DirectSum.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))))) (fun (_x : AddMonoidHom.{u2, max u1 u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (DirectSum.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))))) => (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) -> (DirectSum.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) (AddMonoidHom.hasCoeToFun.{u2, max u1 u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (DirectSum.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i)) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (i : ι) => (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i) (Subtype.mk.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u3} M σ (SetLike.hasMem.{u3, u2} σ M _inst_3) x (ℳ i)) x hx))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u3}} {σ : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : SetLike.{u2, u3} σ M] [_inst_4 : AddSubmonoidClass.{u2, u3} σ M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {x : M} {i : ι} (hx : Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i)), Eq.{max (succ u1) (succ u3)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) x) (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (Equiv.{succ u3, max (succ u3) (succ u1)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u3, max (succ u1) (succ u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) x) (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (_x : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (AddHomClass.toFunLike.{max u1 u3, u3, max u1 u3} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toAdd.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))) (AddZeroClass.toAdd.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u3, max u1 u3} (AddMonoidHom.{u3, max u3 u1} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))) (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))) (AddMonoidHom.addMonoidHomClass.{u3, max u1 u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddCommMonoid.toAddMonoid.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))))) (DirectSum.of.{u1, u3} ι (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i) (Subtype.mk.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i)) x hx))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_of_mem DirectSum.decompose_of_memₓ'. -/
theorem decompose_of_mem {x : M} {i : ι} (hx : x ∈ ℳ i) :
    decompose ℳ x = DirectSum.of (fun i => ℳ i) i ⟨x, hx⟩ :=
  decompose_coe _ ⟨x, hx⟩
#align direct_sum.decompose_of_mem DirectSum.decompose_of_mem

/- warning: direct_sum.decompose_of_mem_same -> DirectSum.decompose_of_mem_same is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {x : M} {i : ι}, (Membership.Mem.{u2, u3} M σ (SetLike.hasMem.{u3, u2} σ M _inst_3) x (ℳ i)) -> (Eq.{succ u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u3} M σ (SetLike.hasMem.{u3, u2} σ M _inst_3) x (ℳ i)))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => forall (i : ι), coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) x) i)) x)
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u3}} {σ : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : SetLike.{u2, u3} σ M] [_inst_4 : AddSubmonoidClass.{u2, u3} σ M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {x : M} {i : ι}, (Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i)) -> (Eq.{succ u3} M (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u2, u3} σ M _inst_3 (ℳ i))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Dfinsupp.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) _x) (Dfinsupp.funLike.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) i)) (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (Equiv.{succ u3, max (succ u3) (succ u1)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u3, max (succ u1) (succ u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) x) i)) x)
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_of_mem_same DirectSum.decompose_of_mem_sameₓ'. -/
theorem decompose_of_mem_same {x : M} {i : ι} (hx : x ∈ ℳ i) : (decompose ℳ x i : M) = x := by
  rw [decompose_of_mem _ hx, DirectSum.of_eq_same, Subtype.coe_mk]
#align direct_sum.decompose_of_mem_same DirectSum.decompose_of_mem_same

/- warning: direct_sum.decompose_of_mem_ne -> DirectSum.decompose_of_mem_ne is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {x : M} {i : ι} {j : ι}, (Membership.Mem.{u2, u3} M σ (SetLike.hasMem.{u3, u2} σ M _inst_3) x (ℳ i)) -> (Ne.{succ u1} ι i j) -> (Eq.{succ u2} M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ j)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ j)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ j)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ j)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u3} M σ (SetLike.hasMem.{u3, u2} σ M _inst_3) x (ℳ j)))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => forall (i : ι), coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) x) j)) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))))))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u3}} {σ : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : SetLike.{u2, u3} σ M] [_inst_4 : AddSubmonoidClass.{u2, u3} σ M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {x : M} {i : ι} {j : ι}, (Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i)) -> (Ne.{succ u1} ι i j) -> (Eq.{succ u3} M (Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u2, u3} σ M _inst_3 (ℳ j))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Dfinsupp.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) _x) (Dfinsupp.funLike.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) i)) (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (Equiv.{succ u3, max (succ u3) (succ u1)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u3, max (succ u1) (succ u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) x) j)) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)))))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_of_mem_ne DirectSum.decompose_of_mem_neₓ'. -/
theorem decompose_of_mem_ne {x : M} {i j : ι} (hx : x ∈ ℳ i) (hij : i ≠ j) :
    (decompose ℳ x j : M) = 0 := by
  rw [decompose_of_mem _ hx, DirectSum.of_eq_of_ne _ _ _ _ hij, ZeroMemClass.coe_zero]
#align direct_sum.decompose_of_mem_ne DirectSum.decompose_of_mem_ne

/- warning: direct_sum.decompose_add_equiv -> DirectSum.decomposeAddEquiv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ], AddEquiv.{u2, max u1 u2} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ], AddEquiv.{u2, max u2 u1} M (DirectSum.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u3} M σ (SetLike.instMembership.{u3, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u3} M σ (SetLike.instMembership.{u3, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u3} M σ (SetLike.instMembership.{u3, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u3} M σ (SetLike.instMembership.{u3, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u3} M σ (SetLike.instMembership.{u3, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_add_equiv DirectSum.decomposeAddEquivₓ'. -/
/-- If `M` is graded by `ι` with degree `i` component `ℳ i`, then it is isomorphic as
an additive monoid to a direct sum of components. -/
@[simps (config := { fullyApplied := false })]
def decomposeAddEquiv : M ≃+ ⨁ i, ℳ i :=
  AddEquiv.symm { (decompose ℳ).symm with map_add' := map_add (DirectSum.coeAddMonoidHom ℳ) }
#align direct_sum.decompose_add_equiv DirectSum.decomposeAddEquiv

/- warning: direct_sum.decompose_zero -> DirectSum.decompose_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ], Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))) (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) 0 (OfNat.mk.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) 0 (Zero.zero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toHasZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))))))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubmonoidClass.{u1, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ], Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) (OfNat.ofNat.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) 0 (Zero.toOfNat0.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) (AddMonoid.toZero.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) (AddCommMonoid.toAddMonoid.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))) (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_zero DirectSum.decompose_zeroₓ'. -/
@[simp]
theorem decompose_zero : decompose ℳ (0 : M) = 0 :=
  map_zero (decomposeAddEquiv ℳ)
#align direct_sum.decompose_zero DirectSum.decompose_zero

/- warning: direct_sum.decompose_symm_zero -> DirectSum.decompose_symm_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ], Eq.{succ u2} M (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) 0 (OfNat.mk.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) 0 (Zero.zero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toHasZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))))))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))))))
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u3}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u2} ι] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : SetLike.{u1, u3} σ M] [_inst_4 : AddSubmonoidClass.{u1, u3} σ M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u2, u3, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ], Eq.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) (OfNat.ofNat.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) 0 (Zero.toOfNat0.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))))) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (Equiv.{max (succ u2) (succ u3), succ u3} (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), succ u3} (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u3, max (succ u2) (succ u3)} M (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u2, u3, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) (OfNat.ofNat.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) 0 (Zero.toOfNat0.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u1} M σ (SetLike.instMembership.{u1, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))))))) (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2))))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_symm_zero DirectSum.decompose_symm_zeroₓ'. -/
@[simp]
theorem decompose_symm_zero : (decompose ℳ).symm 0 = (0 : M) :=
  map_zero (decomposeAddEquiv ℳ).symm
#align direct_sum.decompose_symm_zero DirectSum.decompose_symm_zero

/- warning: direct_sum.decompose_add -> DirectSum.decompose_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] (x : M) (y : M), Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instHAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) x) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) y))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubmonoidClass.{u1, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] (x : M) (y : M), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y)) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) x y)) (HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) x) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) y) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) x) (instHAdd.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) x) (AddZeroClass.toAdd.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) x) (AddMonoid.toAddZeroClass.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) x) (AddCommMonoid.toAddMonoid.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) x) (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) x) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) y))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_add DirectSum.decompose_addₓ'. -/
@[simp]
theorem decompose_add (x y : M) : decompose ℳ (x + y) = decompose ℳ x + decompose ℳ y :=
  map_add (decomposeAddEquiv ℳ) x y
#align direct_sum.decompose_add DirectSum.decompose_add

/- warning: direct_sum.decompose_symm_add -> DirectSum.decompose_symm_add is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] (x : DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (y : DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))), Eq.{succ u2} M (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instHAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))))) x y)) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)))) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) x) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) y))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubmonoidClass.{u1, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] (x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (y : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))), Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) (HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instHAdd.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toAdd.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))))) x y)) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (Equiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (fun (_x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) (HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instHAdd.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddZeroClass.toAdd.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddMonoid.toAddZeroClass.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (AddCommMonoid.toAddMonoid.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))))))) x y)) (HAdd.hAdd.{u2, u2, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) x) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) y) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) x) (instHAdd.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) x) (AddZeroClass.toAdd.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) x) (AddMonoid.toAddZeroClass.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) x) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) x) _inst_2)))) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (Equiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (fun (_x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) x) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (Equiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (fun (_x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) y))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_symm_add DirectSum.decompose_symm_addₓ'. -/
@[simp]
theorem decompose_symm_add (x y : ⨁ i, ℳ i) :
    (decompose ℳ).symm (x + y) = (decompose ℳ).symm x + (decompose ℳ).symm y :=
  map_add (decomposeAddEquiv ℳ).symm x y
#align direct_sum.decompose_symm_add DirectSum.decompose_symm_add

/- warning: direct_sum.decompose_sum -> DirectSum.decompose_sum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {ι' : Type.{u4}} (s : Finset.{u4} ι') (f : ι' -> M), Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) (Finset.sum.{u2, u4} M ι' _inst_2 s (fun (i : ι') => f i))) (Finset.sum.{max u1 u2, u4} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) ι' (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) s (fun (i : ι') => coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) (f i)))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubmonoidClass.{u1, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {ι' : Type.{u4}} (s : Finset.{u4} ι') (f : ι' -> M), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (Finset.sum.{u2, u4} M ι' _inst_2 s (fun (i : ι') => f i))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) (Finset.sum.{u2, u4} M ι' _inst_2 s (fun (i : ι') => f i))) (Finset.sum.{max u3 u2, u4} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) ι' (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) s (fun (i : ι') => FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) (f i)))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_sum DirectSum.decompose_sumₓ'. -/
@[simp]
theorem decompose_sum {ι'} (s : Finset ι') (f : ι' → M) :
    decompose ℳ (∑ i in s, f i) = ∑ i in s, decompose ℳ (f i) :=
  map_sum (decomposeAddEquiv ℳ) f s
#align direct_sum.decompose_sum DirectSum.decompose_sum

/- warning: direct_sum.decompose_symm_sum -> DirectSum.decompose_symm_sum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {ι' : Type.{u4}} (s : Finset.{u4} ι') (f : ι' -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))), Eq.{succ u2} M (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) (Finset.sum.{max u1 u2, u4} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) ι' (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) s (fun (i : ι') => f i))) (Finset.sum.{u2, u4} M ι' _inst_2 s (fun (i : ι') => coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) (f i)))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubmonoidClass.{u1, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] {ι' : Type.{u4}} (s : Finset.{u4} ι') (f : ι' -> (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))), Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) (Finset.sum.{max u3 u2, u4} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) ι' (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) s (fun (i : ι') => f i))) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (Equiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (fun (_x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) (Finset.sum.{max u3 u2, u4} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) ι' (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) s (fun (i : ι') => f i))) (Finset.sum.{u2, u4} M ι' _inst_2 s (fun (i : ι') => FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (Equiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (fun (_x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) M) (Equiv.symm.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5)) (f i)))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_symm_sum DirectSum.decompose_symm_sumₓ'. -/
@[simp]
theorem decompose_symm_sum {ι'} (s : Finset ι') (f : ι' → ⨁ i, ℳ i) :
    (decompose ℳ).symm (∑ i in s, f i) = ∑ i in s, (decompose ℳ).symm (f i) :=
  map_sum (decomposeAddEquiv ℳ).symm f s
#align direct_sum.decompose_symm_sum DirectSum.decompose_symm_sum

/- warning: direct_sum.sum_support_decompose -> DirectSum.sum_support_decompose is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubmonoidClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] [_inst_6 : forall (i : ι) (x : coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)), Decidable (Ne.{succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) x (OfNat.ofNat.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) 0 (OfNat.mk.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) 0 (Zero.zero.{u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (ZeroMemClass.zero.{u3, u2} σ M _inst_3 (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (AddSubmonoidClass.to_zeroMemClass.{u3, u2} σ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))))))] (r : M), Eq.{succ u2} M (Finset.sum.{u2, u1} M ι _inst_2 (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i)))) (fun (i : ι) (x : coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) => _inst_6 i x) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) r)) (fun (i : ι) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u3} M σ (SetLike.hasMem.{u3, u2} σ M _inst_3) x (ℳ i)))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) => forall (i : ι), coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) r) i))) r
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u3}} {σ : Type.{u2}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : SetLike.{u2, u3} σ M] [_inst_4 : AddSubmonoidClass.{u2, u3} σ M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ] [_inst_6 : forall (i : ι) (x : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))), Decidable (Ne.{succ u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) x (OfNat.ofNat.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) 0 (Zero.toOfNat0.{u3} (Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (ZeroMemClass.zero.{u2, u3} σ M _inst_3 (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) (AddSubmonoidClass.toZeroMemClass.{u2, u3} σ M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_2)) _inst_3 _inst_4) (ℳ i)))))] (r : M), Eq.{succ u3} M (Finset.sum.{u3, u1} M ι _inst_2 (Dfinsupp.support.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) (fun (a : ι) (b : ι) => _inst_1 a b) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) (fun (i : ι) (x : Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) => _inst_6 i x) (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (Equiv.{succ u3, max (succ u3) (succ u1)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u3, max (succ u1) (succ u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) r)) (fun (i : ι) => Subtype.val.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Set.{u3} M) (Set.instMembershipSet.{u3} M) x (SetLike.coe.{u2, u3} σ M _inst_3 (ℳ i))) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Dfinsupp.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) _x) (Dfinsupp.funLike.{u1, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) i) i) ((fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)) i))) i)) (FunLike.coe.{max (succ u1) (succ u3), succ u3, max (succ u1) (succ u3)} (Equiv.{succ u3, max (succ u3) (succ u1)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u3, max (succ u1) (succ u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u2} M σ (SetLike.instMembership.{u2, u3} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u2} M _inst_2 σ _inst_3 _inst_4 (ℳ i)))) (DirectSum.decompose.{u1, u3, u2} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) _inst_2 _inst_3 _inst_4 ℳ _inst_5) r) i))) r
Case conversion may be inaccurate. Consider using '#align direct_sum.sum_support_decompose DirectSum.sum_support_decomposeₓ'. -/
theorem sum_support_decompose [∀ (i) (x : ℳ i), Decidable (x ≠ 0)] (r : M) :
    (∑ i in (decompose ℳ r).support, (decompose ℳ r i : M)) = r :=
  by
  conv_rhs =>
    rw [← (decompose ℳ).symm_apply_apply r, ← sum_support_of (fun i => ℳ i) (decompose ℳ r)]
  rw [decompose_symm_sum]
  simp_rw [decompose_symm_of]
#align direct_sum.sum_support_decompose DirectSum.sum_support_decompose

end AddCommMonoid

#print DirectSum.addCommGroupSetLike /-
/-- The `-` in the statements below doesn't resolve without this line.

This seems to a be a problem of synthesized vs inferred typeclasses disagreeing. If we replace
the statement of `decompose_neg` with `@eq (⨁ i, ℳ i) (decompose ℳ (-x)) (-decompose ℳ x)`
instead of `decompose ℳ (-x) = -decompose ℳ x`, which forces the typeclasses needed by `⨁ i, ℳ i` to
be found by unification rather than synthesis, then everything works fine without this instance. -/
instance addCommGroupSetLike [AddCommGroup M] [SetLike σ M] [AddSubgroupClass σ M] (ℳ : ι → σ) :
    AddCommGroup (⨁ i, ℳ i) := by infer_instance
#align direct_sum.add_comm_group_set_like DirectSum.addCommGroupSetLike
-/

section AddCommGroup

variable [DecidableEq ι] [AddCommGroup M]

variable [SetLike σ M] [AddSubgroupClass σ M] (ℳ : ι → σ)

variable [Decomposition ℳ]

include M

/- warning: direct_sum.decompose_neg -> DirectSum.decompose_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubgroupClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ] (x : M), Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5) (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) x)) (Neg.neg.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (SubNegMonoid.toHasNeg.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (AddGroup.toSubNegMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (AddCommGroup.toAddGroup.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.addCommGroupSetLike.{u1, u2, u3} ι M σ _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i))))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5) x))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubgroupClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ] (x : M), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (Neg.neg.{u2} M (NegZeroClass.toNeg.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) x)) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5) (Neg.neg.{u2} M (NegZeroClass.toNeg.{u2} M (SubNegZeroMonoid.toNegZeroClass.{u2} M (SubtractionMonoid.toSubNegZeroMonoid.{u2} M (SubtractionCommMonoid.toSubtractionMonoid.{u2} M (AddCommGroup.toDivisionAddCommMonoid.{u2} M _inst_2))))) x)) (Neg.neg.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (NegZeroClass.toNeg.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (SubNegZeroMonoid.toNegZeroClass.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (SubtractionMonoid.toSubNegZeroMonoid.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (SubtractionCommMonoid.toSubtractionMonoid.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (AddCommGroup.toDivisionAddCommMonoid.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (DirectSum.addCommGroupSetLike.{u3, u2, u1} ι M σ _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i))))))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5) x))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_neg DirectSum.decompose_negₓ'. -/
@[simp]
theorem decompose_neg (x : M) : decompose ℳ (-x) = -decompose ℳ x :=
  map_neg (decomposeAddEquiv ℳ) x
#align direct_sum.decompose_neg DirectSum.decompose_neg

/- warning: direct_sum.decompose_symm_neg -> DirectSum.decompose_symm_neg is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubgroupClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ] (x : DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (AddSubgroupClass.toAddCommGroup.{u3, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))), Eq.{succ u2} M (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5)) (Neg.neg.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (SubNegMonoid.toHasNeg.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (AddGroup.toSubNegMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (AddCommGroup.toAddGroup.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.addCommGroupSetLike.{u1, u2, u3} ι M σ _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i))))) x)) (Neg.neg.{u2} M (SubNegMonoid.toHasNeg.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2))) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5)) x))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubgroupClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ] (x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))), Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) (Neg.neg.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (NegZeroClass.toNeg.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (SubNegZeroMonoid.toNegZeroClass.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (SubtractionMonoid.toSubNegZeroMonoid.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (SubtractionCommMonoid.toSubtractionMonoid.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (AddCommGroup.toDivisionAddCommMonoid.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (DirectSum.addCommGroupSetLike.{u3, u2, u1} ι M σ _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i))))))) x)) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (Equiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (fun (_x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (Equiv.symm.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5)) (Neg.neg.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (NegZeroClass.toNeg.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (SubNegZeroMonoid.toNegZeroClass.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (SubtractionMonoid.toSubNegZeroMonoid.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (SubtractionCommMonoid.toSubtractionMonoid.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (AddCommGroup.toDivisionAddCommMonoid.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (DirectSum.addCommGroupSetLike.{u3, u2, u1} ι M σ _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i))))))) x)) (Neg.neg.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) (NegZeroClass.toNeg.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) (SubtractionCommMonoid.toSubtractionMonoid.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) (AddCommGroup.toDivisionAddCommMonoid.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) _inst_2))))) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (Equiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (fun (_x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (Equiv.symm.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5)) x))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_symm_neg DirectSum.decompose_symm_negₓ'. -/
@[simp]
theorem decompose_symm_neg (x : ⨁ i, ℳ i) : (decompose ℳ).symm (-x) = -(decompose ℳ).symm x :=
  map_neg (decomposeAddEquiv ℳ).symm x
#align direct_sum.decompose_symm_neg DirectSum.decompose_symm_neg

/- warning: direct_sum.decompose_sub -> DirectSum.decompose_sub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubgroupClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ] (x : M) (y : M), Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toHasSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) x y)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (instHSub.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (SubNegMonoid.toHasSub.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (AddGroup.toSubNegMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (AddCommGroup.toAddGroup.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.addCommGroupSetLike.{u1, u2, u3} ι M σ _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i)))))) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5) x) (coeFn.{max 1 (max (succ u2) (succ (max u1 u2))) (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (fun (_x : Equiv.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) => M -> (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (Equiv.hasCoeToFun.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5) y))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubgroupClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ] (x : M) (y : M), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) x y)) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) x y)) (HSub.hSub.{max u3 u2, max u3 u2, max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) y) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (instHSub.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (SubNegMonoid.toSub.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (AddGroup.toSubNegMonoid.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (AddCommGroup.toAddGroup.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) x) (DirectSum.addCommGroupSetLike.{u3, u2, u1} ι M σ _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i)))))) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5) x) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5) y))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_sub DirectSum.decompose_subₓ'. -/
@[simp]
theorem decompose_sub (x y : M) : decompose ℳ (x - y) = decompose ℳ x - decompose ℳ y :=
  map_sub (decomposeAddEquiv ℳ) x y
#align direct_sum.decompose_sub DirectSum.decompose_sub

/- warning: direct_sum.decompose_symm_sub -> DirectSum.decompose_symm_sub is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {σ : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : SetLike.{u3, u2} σ M] [_inst_4 : AddSubgroupClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ] (x : DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (AddSubgroupClass.toAddCommGroup.{u3, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (y : DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) i) (AddSubgroupClass.toAddCommGroup.{u3, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))), Eq.{succ u2} M (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (instHSub.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (SubNegMonoid.toHasSub.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (AddGroup.toSubNegMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (AddCommGroup.toAddGroup.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.addCommGroupSetLike.{u1, u2, u3} ι M σ _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i)))))) x y)) (HSub.hSub.{u2, u2, u2} M M M (instHSub.{u2} M (SubNegMonoid.toHasSub.{u2} M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)))) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5)) x) (coeFn.{max 1 (max (succ (max u1 u2)) (succ u2)) (succ u2) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u2)} (Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (fun (_x : Equiv.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) => (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) -> M) (Equiv.hasCoeToFun.{succ (max u1 u2), succ u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (Equiv.symm.{succ u2, succ (max u1 u2)} M (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} σ Type.{u2} (SetLike.hasCoeToSort.{u3, u2} σ M _inst_3) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.decompose.{u1, u2, u3} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.to_addSubmonoidClass.{u3, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5)) y))
but is expected to have type
  forall {ι : Type.{u3}} {M : Type.{u2}} {σ : Type.{u1}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : SetLike.{u1, u2} σ M] [_inst_4 : AddSubgroupClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3] (ℳ : ι -> σ) [_inst_5 : DirectSum.Decomposition.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ] (x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (y : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))), Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) (HSub.hSub.{max u3 u2, max u3 u2, max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (instHSub.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (SubNegMonoid.toSub.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (AddGroup.toSubNegMonoid.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (AddCommGroup.toAddGroup.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (DirectSum.addCommGroupSetLike.{u3, u2, u1} ι M σ _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i)))))) x y)) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (Equiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (fun (_x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (Equiv.symm.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5)) (HSub.hSub.{max u3 u2, max u3 u2, max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (instHSub.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (SubNegMonoid.toSub.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (AddGroup.toSubNegMonoid.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (AddCommGroup.toAddGroup.{max u3 u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) i) (AddSubgroupClass.toAddCommGroup.{u1, u2} σ (ℳ i) M _inst_2 _inst_3 _inst_4))) (DirectSum.addCommGroupSetLike.{u3, u2, u1} ι M σ _inst_2 _inst_3 _inst_4 (fun (i : ι) => ℳ i)))))) x y)) (HSub.hSub.{u2, u2, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) y) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) (instHSub.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) (SubNegMonoid.toSub.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) (AddGroup.toSubNegMonoid.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) (AddCommGroup.toAddGroup.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) x) _inst_2)))) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (Equiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (fun (_x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (Equiv.symm.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5)) x) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (Equiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (fun (_x : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) => M) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u2), succ u2} (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) M) (Equiv.symm.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u1} M σ (SetLike.instMembership.{u1, u2} σ M _inst_3) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u1} M (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) σ _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) (ℳ i))) (DirectSum.decompose.{u3, u2, u1} ι M σ (fun (a : ι) (b : ι) => _inst_1 a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3 (AddSubgroupClass.toAddSubmonoidClass.{u1, u2} σ M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_2)) _inst_3 _inst_4) ℳ _inst_5)) y))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_symm_sub DirectSum.decompose_symm_subₓ'. -/
@[simp]
theorem decompose_symm_sub (x y : ⨁ i, ℳ i) :
    (decompose ℳ).symm (x - y) = (decompose ℳ).symm x - (decompose ℳ).symm y :=
  map_sub (decomposeAddEquiv ℳ).symm x y
#align direct_sum.decompose_symm_sub DirectSum.decompose_symm_sub

end AddCommGroup

section Module

variable [DecidableEq ι] [Semiring R] [AddCommMonoid M] [Module R M]

variable (ℳ : ι → Submodule R M)

variable [Decomposition ℳ]

include M

/- warning: direct_sum.decompose_linear_equiv -> DirectSum.decomposeLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_2 _inst_3] (ℳ : ι -> (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4)) [_inst_5 : DirectSum.Decomposition.{u1, u3, u3} ι M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) ℳ], LinearEquiv.{u2, u2, u3, max u1 u3} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) M (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => Submodule.addCommMonoid.{u2, u3} R M _inst_2 _inst_3 _inst_4 (ℳ i))) _inst_3 (DirectSum.addCommMonoid.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => Submodule.addCommMonoid.{u2, u3} R M _inst_2 _inst_3 _inst_4 (ℳ i))) _inst_4 (DirectSum.module.{u2, u1, u3} R _inst_2 ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => Submodule.addCommMonoid.{u2, u3} R M _inst_2 _inst_3 _inst_4 (ℳ i)) (fun (i : ι) => Submodule.module.{u2, u3} R M _inst_2 _inst_3 _inst_4 (ℳ i)))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_2 _inst_3] (ℳ : ι -> (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4)) [_inst_5 : DirectSum.Decomposition.{u1, u3, u3} ι M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) ℳ], LinearEquiv.{u2, u2, u3, max u3 u1} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) M (DirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u3} R M _inst_2 _inst_3 _inst_4 (ℳ i))) _inst_3 (instAddCommMonoidDirectSum.{u1, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u3} R M _inst_2 _inst_3 _inst_4 (ℳ i))) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u3} R _inst_2 ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u3} R M _inst_2 _inst_3 _inst_4 (ℳ i)) (fun (i : ι) => Submodule.module.{u2, u3} R M _inst_2 _inst_3 _inst_4 (ℳ i)))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_linear_equiv DirectSum.decomposeLinearEquivₓ'. -/
/-- If `M` is graded by `ι` with degree `i` component `ℳ i`, then it is isomorphic as
a module to a direct sum of components. -/
@[simps (config := { fullyApplied := false })]
def decomposeLinearEquiv : M ≃ₗ[R] ⨁ i, ℳ i :=
  LinearEquiv.symm
    { (decomposeAddEquiv ℳ).symm with map_smul' := map_smul (DirectSum.coeLinearMap ℳ) }
#align direct_sum.decompose_linear_equiv DirectSum.decomposeLinearEquiv

/- warning: direct_sum.decompose_smul -> DirectSum.decompose_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {M : Type.{u3}} [_inst_1 : DecidableEq.{succ u1} ι] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_2 _inst_3] (ℳ : ι -> (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4)) [_inst_5 : DirectSum.Decomposition.{u1, u3, u3} ι M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) ℳ] (r : R) (x : M), Eq.{succ (max u1 u3)} (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (coeFn.{max 1 (max (succ u3) (succ (max u1 u3))) (succ (max u1 u3)) (succ u3), max (succ u3) (succ (max u1 u3))} (Equiv.{succ u3, succ (max u1 u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) (fun (_x : Equiv.{succ u3, succ (max u1 u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) => M -> (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) (Equiv.hasCoeToFun.{succ u3, succ (max u1 u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u1, u3, u3} ι M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) ℳ _inst_5) (SMul.smul.{u2, u3} R M (SMulZeroClass.toHasSmul.{u2, u3} R M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u2, u3} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Module.toMulActionWithZero.{u2, u3} R M _inst_2 _inst_3 _inst_4)))) r x)) (SMul.smul.{u2, max u1 u3} R (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (SMulZeroClass.toHasSmul.{u2, max u1 u3} R (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (AddZeroClass.toHasZero.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (DirectSum.addCommMonoid.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))))) (SMulWithZero.toSmulZeroClass.{u2, max u1 u3} R (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)))) (AddZeroClass.toHasZero.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (DirectSum.addCommMonoid.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))))) (MulActionWithZero.toSMulWithZero.{u2, max u1 u3} R (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddZeroClass.toHasZero.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (AddMonoid.toAddZeroClass.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (AddCommMonoid.toAddMonoid.{max u1 u3} (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (DirectSum.addCommMonoid.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))))) (Module.toMulActionWithZero.{u2, max u1 u3} R (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) _inst_2 (DirectSum.addCommMonoid.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (DirectSum.module.{u2, u1, u3} R _inst_2 ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)) (fun (i : ι) => Submodule.module.{u2, u3} R M _inst_2 _inst_3 _inst_4 (ℳ i))))))) r (coeFn.{max 1 (max (succ u3) (succ (max u1 u3))) (succ (max u1 u3)) (succ u3), max (succ u3) (succ (max u1 u3))} (Equiv.{succ u3, succ (max u1 u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) (fun (_x : Equiv.{succ u3, succ (max u1 u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) => M -> (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) (Equiv.hasCoeToFun.{succ u3, succ (max u1 u3)} M (DirectSum.{u1, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (ℳ i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u3, u3} M _inst_3 (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u1, u3, u3} ι M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u2, u3} R M _inst_2 _inst_3 _inst_4) ℳ _inst_5) x))
but is expected to have type
  forall {ι : Type.{u3}} {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : DecidableEq.{succ u3} ι] [_inst_2 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_2 _inst_3] (ℳ : ι -> (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4)) [_inst_5 : DirectSum.Decomposition.{u3, u2, u2} ι M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) ℳ] (r : R) (x : M), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_2)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_2) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u1, u2} R M _inst_2 _inst_3 _inst_4))))) r x)) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u3, u2, u2} ι M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) ℳ _inst_5) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_2)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_2) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (Module.toMulActionWithZero.{u1, u2} R M _inst_2 _inst_3 _inst_4))))) r x)) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} R ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (instHSMul.{u1, max u3 u2} R ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (SMulZeroClass.toSMul.{u1, max u3 u2} R ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (AddMonoid.toZero.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (AddCommMonoid.toAddMonoid.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))))) (SMulWithZero.toSMulZeroClass.{u1, max u3 u2} R ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_2)) (AddMonoid.toZero.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (AddCommMonoid.toAddMonoid.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))))) (MulActionWithZero.toSMulWithZero.{u1, max u3 u2} R ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (Semiring.toMonoidWithZero.{u1} R _inst_2) (AddMonoid.toZero.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (AddCommMonoid.toAddMonoid.{max u3 u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))))) (Module.toMulActionWithZero.{u1, max u3 u2} R ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) x) _inst_2 (instAddCommMonoidDirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u3, u2} R _inst_2 ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i)) (fun (i : ι) => Submodule.module.{u1, u2} R M _inst_2 _inst_3 _inst_4 (ℳ i)))))))) r (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (Equiv.{succ u2, max (succ u2) (succ u3)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i))) _x) (Equiv.instFunLikeEquiv.{succ u2, max (succ u3) (succ u2)} M (DirectSum.{u3, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4)) x (ℳ i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u2} M _inst_3 (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) (ℳ i)))) (DirectSum.decompose.{u3, u2, u2} ι M (Submodule.{u1, u2} R M _inst_2 _inst_3 _inst_4) (fun (a : ι) (b : ι) => _inst_1 a b) _inst_3 (Submodule.setLike.{u1, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.addSubmonoidClass.{u1, u2} R M _inst_2 _inst_3 _inst_4) ℳ _inst_5) x))
Case conversion may be inaccurate. Consider using '#align direct_sum.decompose_smul DirectSum.decompose_smulₓ'. -/
@[simp]
theorem decompose_smul (r : R) (x : M) : decompose ℳ (r • x) = r • decompose ℳ x :=
  map_smul (decomposeLinearEquiv ℳ) r x
#align direct_sum.decompose_smul DirectSum.decompose_smul

end Module

end DirectSum

