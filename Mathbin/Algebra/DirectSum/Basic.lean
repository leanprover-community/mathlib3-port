/-
Copyright (c) 2019 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau

! This file was ported from Lean 3 source module algebra.direct_sum.basic
! leanprover-community/mathlib commit 13a5329a8625701af92e9a96ffc90fa787fff24d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Dfinsupp.Basic
import Mathbin.GroupTheory.Submonoid.Operations

/-!
# Direct sum

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines the direct sum of abelian groups, indexed by a discrete type.

## Notation

`⨁ i, β i` is the n-ary direct sum `direct_sum`.
This notation is in the `direct_sum` locale, accessible after `open_locale direct_sum`.

## References

* https://en.wikipedia.org/wiki/Direct_sum
-/


open BigOperators

universe u v w u₁

variable (ι : Type v) [dec_ι : DecidableEq ι] (β : ι → Type w)

#print DirectSum /-
/-- `direct_sum β` is the direct sum of a family of additive commutative monoids `β i`.

Note: `open_locale direct_sum` will enable the notation `⨁ i, β i` for `direct_sum β`. -/
def DirectSum [∀ i, AddCommMonoid (β i)] : Type _ :=
  Π₀ i, β i deriving AddCommMonoid, Inhabited
#align direct_sum DirectSum
-/

instance [∀ i, AddCommMonoid (β i)] : CoeFun (DirectSum ι β) fun _ => ∀ i : ι, β i :=
  Dfinsupp.hasCoeToFun

-- mathport name: direct_sum
scoped[DirectSum] notation3"⨁ "(...)", "r:(scoped f => DirectSum _ f) => r

namespace DirectSum

variable {ι}

section AddCommGroup

variable [∀ i, AddCommGroup (β i)]

instance : AddCommGroup (DirectSum ι β) :=
  Dfinsupp.addCommGroup

variable {β}

/- warning: direct_sum.sub_apply -> DirectSum.sub_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommGroup.{u2} (β i)] (g₁ : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g₂ : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (i : ι), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHSub.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (SubNegMonoid.toHasSub.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (AddGroup.toSubNegMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (AddCommGroup.toAddGroup.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (DirectSum.addCommGroup.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))) g₁ g₂) i) (HSub.hSub.{u2, u2, u2} (β i) (β i) (β i) (instHSub.{u2} (β i) (SubNegMonoid.toHasSub.{u2} (β i) (AddGroup.toSubNegMonoid.{u2} (β i) (AddCommGroup.toAddGroup.{u2} (β i) (_inst_1 i))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) g₁ i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) => forall (i : ι), β i) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) g₂ i))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommGroup.{u2} (β i)] (g₁ : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (g₂ : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i))) i)) (HSub.hSub.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (instHSub.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (SubNegMonoid.toSub.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (AddGroup.toSubNegMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (AddCommGroup.toAddGroup.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i))) (DirectSum.instAddCommGroupDirectSumToAddCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))) g₁ g₂) i) (HSub.hSub.{u2, u2, u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (instHSub.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (SubNegMonoid.toSub.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (AddGroup.toSubNegMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (AddCommGroup.toAddGroup.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (_inst_1 i))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i))) i)) g₁ i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} ((fun (i : ι) => β i) i) (_inst_1 i)) i))) i)) g₂ i))
Case conversion may be inaccurate. Consider using '#align direct_sum.sub_apply DirectSum.sub_applyₓ'. -/
@[simp]
theorem sub_apply (g₁ g₂ : ⨁ i, β i) (i : ι) : (g₁ - g₂) i = g₁ i - g₂ i :=
  rfl
#align direct_sum.sub_apply DirectSum.sub_apply

end AddCommGroup

variable [∀ i, AddCommMonoid (β i)]

/- warning: direct_sum.zero_apply -> DirectSum.zero_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (i : ι), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (OfNat.mk.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (Zero.zero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toHasZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))))) i) (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))))))
but is expected to have type
  forall {ι : Type.{u1}} (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (Zero.toOfNat0.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))) i) (OfNat.ofNat.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) 0 (Zero.toOfNat0.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (_inst_1 i)))))
Case conversion may be inaccurate. Consider using '#align direct_sum.zero_apply DirectSum.zero_applyₓ'. -/
@[simp]
theorem zero_apply (i : ι) : (0 : ⨁ i, β i) i = 0 :=
  rfl
#align direct_sum.zero_apply DirectSum.zero_apply

variable {β}

/- warning: direct_sum.add_apply -> DirectSum.add_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (g₁ : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (g₂ : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (i : ι), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instHAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))) g₁ g₂) i) (HAdd.hAdd.{u2, u2, u2} (β i) (β i) (β i) (instHAdd.{u2} (β i) (AddZeroClass.toHasAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) g₁ i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) g₂ i))
but is expected to have type
  forall {ι : Type.{u1}} {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (g₁ : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (g₂ : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (i : ι), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instHAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))) g₁ g₂) i) (HAdd.hAdd.{u2, u2, u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (instHAdd.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (AddZeroClass.toAdd.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (_inst_1 i))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) g₁ i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) g₂ i))
Case conversion may be inaccurate. Consider using '#align direct_sum.add_apply DirectSum.add_applyₓ'. -/
@[simp]
theorem add_apply (g₁ g₂ : ⨁ i, β i) (i : ι) : (g₁ + g₂) i = g₁ i + g₂ i :=
  rfl
#align direct_sum.add_apply DirectSum.add_apply

variable (β)

include dec_ι

/- warning: direct_sum.mk -> DirectSum.mk is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (s : Finset.{u1} ι), AddMonoidHom.{max u1 u2, max u1 u2} (forall (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) i)) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Pi.addZeroClass.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) i)) (fun (i : coeSort.{succ u1, succ (succ u1)} (Set.{u1} ι) Type.{u1} (Set.hasCoeToSort.{u1} ι) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) => AddMonoid.toAddZeroClass.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) i)) (AddCommMonoid.toAddMonoid.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) i)) (_inst_1 (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.Mem.{u1, u1} ι (Set.{u1} ι) (Set.hasMem.{u1} ι) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) i))))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (s : Finset.{u1} ι), AddMonoidHom.{max u1 u2, max u2 u1} (forall (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)), β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Pi.addZeroClass.{u1, u2} (Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (fun (i : Set.Elem.{u1} ι (Finset.toSet.{u1} ι s)) => AddMonoid.toAddZeroClass.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (AddCommMonoid.toAddMonoid.{u2} (β (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i)) (_inst_1 (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x (Finset.toSet.{u1} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))
Case conversion may be inaccurate. Consider using '#align direct_sum.mk DirectSum.mkₓ'. -/
/-- `mk β s x` is the element of `⨁ i, β i` that is zero outside `s`
and has coefficient `x i` for `i` in `s`. -/
def mk (s : Finset ι) : (∀ i : (↑s : Set ι), β i.1) →+ ⨁ i, β i
    where
  toFun := Dfinsupp.mk s
  map_add' _ _ := Dfinsupp.mk_add
  map_zero' := Dfinsupp.mk_zero
#align direct_sum.mk DirectSum.mk

/- warning: direct_sum.of -> DirectSum.of is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (i : ι), AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (i : ι), AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))
Case conversion may be inaccurate. Consider using '#align direct_sum.of DirectSum.ofₓ'. -/
/-- `of i` is the natural inclusion map from `β i` to `⨁ i, β i`. -/
def of (i : ι) : β i →+ ⨁ i, β i :=
  Dfinsupp.singleAddHom β i
#align direct_sum.of DirectSum.of

/- warning: direct_sum.of_eq_same -> DirectSum.of_eq_same is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (i : ι) (x : β i), Eq.{succ u2} (β i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (_x : AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) => (β i) -> (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddMonoidHom.hasCoeToFun.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) i) x) i) x
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (i : ι) (x : β i), Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (fun (_x : β i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β i) => DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _x) (AddHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.addMonoidHomClass.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i) x) i) x
Case conversion may be inaccurate. Consider using '#align direct_sum.of_eq_same DirectSum.of_eq_sameₓ'. -/
@[simp]
theorem of_eq_same (i : ι) (x : β i) : (of _ i x) i = x :=
  Dfinsupp.single_eq_same
#align direct_sum.of_eq_same DirectSum.of_eq_same

/- warning: direct_sum.of_eq_of_ne -> DirectSum.of_eq_of_ne is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (i : ι) (j : ι) (x : β i), (Ne.{succ u1} ι i j) -> (Eq.{succ u2} (β j) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (_x : AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) => (β i) -> (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddMonoidHom.hasCoeToFun.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) i) x) j) (OfNat.ofNat.{u2} (β j) 0 (OfNat.mk.{u2} (β j) 0 (Zero.zero.{u2} (β j) (AddZeroClass.toHasZero.{u2} (β j) (AddMonoid.toAddZeroClass.{u2} (β j) (AddCommMonoid.toAddMonoid.{u2} (β j) (_inst_1 j))))))))
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (i : ι) (j : ι) (x : β i), (Ne.{succ u1} ι i j) -> (Eq.{succ u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) j) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (fun (_x : β i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β i) => DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _x) (AddHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.addMonoidHomClass.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i) x) j) (OfNat.ofNat.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) j) 0 (Zero.toOfNat0.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) j) (AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) j) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) j) (_inst_1 j))))))
Case conversion may be inaccurate. Consider using '#align direct_sum.of_eq_of_ne DirectSum.of_eq_of_neₓ'. -/
theorem of_eq_of_ne (i j : ι) (x : β i) (h : i ≠ j) : (of _ i x) j = 0 :=
  Dfinsupp.single_eq_of_ne h
#align direct_sum.of_eq_of_ne DirectSum.of_eq_of_ne

/- warning: direct_sum.support_zero -> DirectSum.support_zero is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))], Eq.{succ u1} (Finset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i)))) (fun (i : ι) (x : β i) => _inst_2 i x) (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (OfNat.mk.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (Zero.zero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toHasZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))))) (EmptyCollection.emptyCollection.{u1} (Finset.{u1} ι) (Finset.hasEmptyc.{u1} ι))
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))], Eq.{succ u1} (Finset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) (fun (i : ι) (x : β i) => _inst_2 i x) (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (Zero.toOfNat0.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))) (EmptyCollection.emptyCollection.{u1} (Finset.{u1} ι) (Finset.instEmptyCollectionFinset.{u1} ι))
Case conversion may be inaccurate. Consider using '#align direct_sum.support_zero DirectSum.support_zeroₓ'. -/
@[simp]
theorem support_zero [∀ (i : ι) (x : β i), Decidable (x ≠ 0)] : (0 : ⨁ i, β i).support = ∅ :=
  Dfinsupp.support_zero
#align direct_sum.support_zero DirectSum.support_zero

/- warning: direct_sum.support_of -> DirectSum.support_of is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))] (i : ι) (x : β i), (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))))))) -> (Eq.{succ u1} (Finset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i)))) (fun (i : ι) (x : β i) => _inst_2 i x) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (_x : AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) => (β i) -> (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddMonoidHom.hasCoeToFun.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) i) x)) (Singleton.singleton.{u1, u1} ι (Finset.{u1} ι) (Finset.hasSingleton.{u1} ι) i))
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))] (i : ι) (x : β i), (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))))) -> (Eq.{succ u1} (Finset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) (fun (i : ι) (x : β i) => _inst_2 i x) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (fun (_x : β i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β i) => DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _x) (AddHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.addMonoidHomClass.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i) x)) (Singleton.singleton.{u1, u1} ι (Finset.{u1} ι) (Finset.instSingletonFinset.{u1} ι) i))
Case conversion may be inaccurate. Consider using '#align direct_sum.support_of DirectSum.support_ofₓ'. -/
@[simp]
theorem support_of [∀ (i : ι) (x : β i), Decidable (x ≠ 0)] (i : ι) (x : β i) (h : x ≠ 0) :
    (of _ i x).support = {i} :=
  Dfinsupp.support_single_ne_zero h
#align direct_sum.support_of DirectSum.support_of

/- warning: direct_sum.support_of_subset -> DirectSum.support_of_subset is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))] {i : ι} {b : β i}, HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.hasSubset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i)))) (fun (i : ι) (x : β i) => _inst_2 i x) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (fun (_x : AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) => (β i) -> (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))) (AddMonoidHom.hasCoeToFun.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun {i : ι} => β i) (fun (i : ι) => _inst_1 i) i) b)) (Singleton.singleton.{u1, u1} ι (Finset.{u1} ι) (Finset.hasSingleton.{u1} ι) i)
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))] {i : ι} {b : β i}, HasSubset.Subset.{u1} (Finset.{u1} ι) (Finset.instHasSubsetFinset.{u1} ι) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) (fun (i : ι) (x : β i) => _inst_2 i x) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (fun (_x : β i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β i) => DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _x) (AddHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.addMonoidHomClass.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i) b)) (Singleton.singleton.{u1, u1} ι (Finset.{u1} ι) (Finset.instSingletonFinset.{u1} ι) i)
Case conversion may be inaccurate. Consider using '#align direct_sum.support_of_subset DirectSum.support_of_subsetₓ'. -/
theorem support_of_subset [∀ (i : ι) (x : β i), Decidable (x ≠ 0)] {i : ι} {b : β i} :
    (of _ i b).support ⊆ {i} :=
  Dfinsupp.support_single_subset
#align direct_sum.support_of_subset DirectSum.support_of_subset

/- warning: direct_sum.sum_support_of -> DirectSum.sum_support_of is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (OfNat.mk.{u2} (β i) 0 (Zero.zero.{u2} (β i) (AddZeroClass.toHasZero.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))))] (x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)), Eq.{succ (max u1 u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (Finset.sum.{max u1 u2, u1} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) ι (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => β i) i) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => β i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => β i) i) ((fun (i : ι) => _inst_1 i) i)))) (fun (i : ι) (x : β i) => _inst_2 i x) x) (fun (i : ι) => coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) ((fun (i : ι) => _inst_1 i) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))))) (fun (_x : AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) ((fun (i : ι) => _inst_1 i) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))))) => (β i) -> (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))) (AddMonoidHom.hasCoeToFun.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) ((fun (i : ι) => _inst_1 i) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i) (coeFn.{succ (max u1 u2), max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (fun (_x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) => forall (i : ι), β i) (DirectSum.hasCoeToFun.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) x i))) x
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] (β : ι -> Type.{u2}) [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] [_inst_2 : forall (i : ι) (x : β i), Decidable (Ne.{succ u2} (β i) x (OfNat.ofNat.{u2} (β i) 0 (Zero.toOfNat0.{u2} (β i) (AddMonoid.toZero.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))))))] (x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)), Eq.{max (succ u1) (succ u2)} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Finset.sum.{max u1 u2, u1} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) ι (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (Dfinsupp.support.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => β i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) (fun (i : ι) (x : β i) => _inst_2 i x) x) (fun (i : ι) => FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (fun (_x : β i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β i) => DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _x) (AddHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.addMonoidHomClass.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Dfinsupp.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) _x) (Dfinsupp.funLike.{u1, u2} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => β i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (i : ι) => β i) i) i) ((fun (i : ι) => _inst_1 i) i))) i)) x i))) x
Case conversion may be inaccurate. Consider using '#align direct_sum.sum_support_of DirectSum.sum_support_ofₓ'. -/
theorem sum_support_of [∀ (i : ι) (x : β i), Decidable (x ≠ 0)] (x : ⨁ i, β i) :
    (∑ i in x.support, of β i (x i)) = x :=
  Dfinsupp.sum_single
#align direct_sum.sum_support_of DirectSum.sum_support_of

variable {β}

/- warning: direct_sum.mk_injective -> DirectSum.mk_injective is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.mk_injective DirectSum.mk_injectiveₓ'. -/
theorem mk_injective (s : Finset ι) : Function.Injective (mk β s) :=
  Dfinsupp.mk_injective s
#align direct_sum.mk_injective DirectSum.mk_injective

/- warning: direct_sum.of_injective -> DirectSum.of_injective is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (i : ι), Function.Injective.{succ u2, succ (max u1 u2)} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) ((fun (i : ι) => _inst_1 i) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))))) (fun (_x : AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) ((fun (i : ι) => _inst_1 i) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))))) => (β i) -> (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))) (AddMonoidHom.hasCoeToFun.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) ((fun (i : ι) => _inst_1 i) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i))
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] (i : ι), Function.Injective.{succ u2, max (succ u1) (succ u2)} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (fun (_x : β i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β i) => DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _x) (AddHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.addMonoidHomClass.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i))
Case conversion may be inaccurate. Consider using '#align direct_sum.of_injective DirectSum.of_injectiveₓ'. -/
theorem of_injective (i : ι) : Function.Injective (of β i) :=
  Dfinsupp.single_injective
#align direct_sum.of_injective DirectSum.of_injective

/- warning: direct_sum.induction_on -> DirectSum.induction_on is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] {C : (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) -> Prop} (x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)), (C (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (OfNat.mk.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (Zero.zero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toHasZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))))) -> (forall (i : ι) (x : β i), C (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ u2) (succ (max u1 u2))} (AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) ((fun (i : ι) => _inst_1 i) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))))) (fun (_x : AddMonoidHom.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) ((fun (i : ι) => _inst_1 i) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))))) => (β i) -> (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))) (AddMonoidHom.hasCoeToFun.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) ((fun (i : ι) => _inst_1 i) i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => (fun (i : ι) => _inst_1 i) i))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i) x)) -> (forall (x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (y : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)), (C x) -> (C y) -> (C (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instHAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))) x y))) -> (C x)
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] {C : (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) -> Prop} (x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)), (C (OfNat.ofNat.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) 0 (Zero.toOfNat0.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toZero.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))) -> (forall (i : ι) (x : β i), C (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (fun (_x : β i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : β i) => DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) _x) (AddHomClass.toFunLike.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toAdd.{u2} (β i) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, max u1 u2} (AddMonoidHom.{u2, max u2 u1} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoidHom.addMonoidHomClass.{u2, max u1 u2} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))))) (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i) x)) -> (forall (x : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (y : DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)), (C x) -> (C y) -> (C (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instHAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))) x y))) -> (C x)
Case conversion may be inaccurate. Consider using '#align direct_sum.induction_on DirectSum.induction_onₓ'. -/
@[elab_as_elim]
protected theorem induction_on {C : (⨁ i, β i) → Prop} (x : ⨁ i, β i) (H_zero : C 0)
    (H_basic : ∀ (i : ι) (x : β i), C (of β i x)) (H_plus : ∀ x y, C x → C y → C (x + y)) : C x :=
  by
  apply Dfinsupp.induction x H_zero
  intro i b f h1 h2 ih
  solve_by_elim
#align direct_sum.induction_on DirectSum.induction_on

/- warning: direct_sum.add_hom_ext -> DirectSum.addHom_ext is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.add_hom_ext DirectSum.addHom_extₓ'. -/
/-- If two additive homomorphisms from `⨁ i, β i` are equal on each `of β i y`,
then they are equal. -/
theorem addHom_ext {γ : Type _} [AddMonoid γ] ⦃f g : (⨁ i, β i) →+ γ⦄
    (H : ∀ (i : ι) (y : β i), f (of _ i y) = g (of _ i y)) : f = g :=
  Dfinsupp.addHom_ext H
#align direct_sum.add_hom_ext DirectSum.addHom_ext

/- warning: direct_sum.add_hom_ext' -> DirectSum.addHom_ext' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] {γ : Type.{u3}} [_inst_2 : AddMonoid.{u3} γ] {{f : AddMonoidHom.{max u1 u2, u3} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u3} γ _inst_2)}} {{g : AddMonoidHom.{max u1 u2, u3} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u3} γ _inst_2)}}, (forall (i : ι), Eq.{max (succ u3) (succ u2)} (AddMonoidHom.{u2, u3} (β i) γ (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{u3} γ _inst_2)) (AddMonoidHom.comp.{u2, max u1 u2, u3} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u3} γ _inst_2) f (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) i)) (AddMonoidHom.comp.{u2, max u1 u2, u3} (β i) (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u3} γ _inst_2) g (DirectSum.of.{u1, u2} ι (fun (a : ι) (b : ι) => dec_ι a b) β (fun (i : ι) => _inst_1 i) i))) -> (Eq.{max (succ u3) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, u3} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u3} γ _inst_2)) f g)
but is expected to have type
  forall {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {β : ι -> Type.{u3}} [_inst_1 : forall (i : ι), AddCommMonoid.{u3} (β i)] {γ : Type.{u1}} [_inst_2 : AddMonoid.{u1} γ] {{f : AddMonoidHom.{max u3 u2, u1} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u1} γ _inst_2)}} {{g : AddMonoidHom.{max u3 u2, u1} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u1} γ _inst_2)}}, (forall (i : ι), Eq.{max (succ u3) (succ u1)} (AddMonoidHom.{u3, u1} (β i) γ (AddMonoid.toAddZeroClass.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{u1} γ _inst_2)) (AddMonoidHom.comp.{u3, max u2 u3, u1} (β i) (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u1} γ _inst_2) f (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) i)) (AddMonoidHom.comp.{u3, max u2 u3, u1} (β i) (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{u3} (β i) (AddCommMonoid.toAddMonoid.{u3} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u1} γ _inst_2) g (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i) i))) -> (Eq.{max (max (succ u2) (succ u3)) (succ u1)} (AddMonoidHom.{max u3 u2, u1} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u1} γ _inst_2)) f g)
Case conversion may be inaccurate. Consider using '#align direct_sum.add_hom_ext' DirectSum.addHom_ext'ₓ'. -/
/-- If two additive homomorphisms from `⨁ i, β i` are equal on each `of β i y`,
then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext]
theorem addHom_ext' {γ : Type _} [AddMonoid γ] ⦃f g : (⨁ i, β i) →+ γ⦄
    (H : ∀ i : ι, f.comp (of _ i) = g.comp (of _ i)) : f = g :=
  addHom_ext fun i => AddMonoidHom.congr_fun <| H i
#align direct_sum.add_hom_ext' DirectSum.addHom_ext'

variable {γ : Type u₁} [AddCommMonoid γ]

section ToAddMonoid

variable (φ : ∀ i, β i →+ γ) (ψ : (⨁ i, β i) →+ γ)

/- warning: direct_sum.to_add_monoid -> DirectSum.toAddMonoid is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] {γ : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} γ], (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) -> (AddMonoidHom.{max u1 u2, u3} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)))
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] {γ : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} γ], (forall (i : ι), AddMonoidHom.{u2, u3} (β i) γ (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2))) -> (AddMonoidHom.{max u2 u1, u3} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) γ (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)))
Case conversion may be inaccurate. Consider using '#align direct_sum.to_add_monoid DirectSum.toAddMonoidₓ'. -/
/-- `to_add_monoid φ` is the natural homomorphism from `⨁ i, β i` to `γ`
induced by a family `φ` of homomorphisms `β i → γ`. -/
def toAddMonoid : (⨁ i, β i) →+ γ :=
  Dfinsupp.liftAddHom φ
#align direct_sum.to_add_monoid DirectSum.toAddMonoid

/- warning: direct_sum.to_add_monoid_of -> DirectSum.toAddMonoid_of is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.to_add_monoid_of DirectSum.toAddMonoid_ofₓ'. -/
@[simp]
theorem toAddMonoid_of (i) (x : β i) : toAddMonoid φ (of β i x) = φ i x :=
  Dfinsupp.liftAddHom_apply_single φ i x
#align direct_sum.to_add_monoid_of DirectSum.toAddMonoid_of

/- warning: direct_sum.to_add_monoid.unique -> DirectSum.toAddMonoid.unique is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.to_add_monoid.unique DirectSum.toAddMonoid.uniqueₓ'. -/
theorem toAddMonoid.unique (f : ⨁ i, β i) : ψ f = toAddMonoid (fun i => ψ.comp (of β i)) f :=
  by
  congr
  ext
  simp [to_add_monoid, of]
#align direct_sum.to_add_monoid.unique DirectSum.toAddMonoid.unique

end ToAddMonoid

section FromAddMonoid

/- warning: direct_sum.from_add_monoid -> DirectSum.fromAddMonoid is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] {γ : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} γ], AddMonoidHom.{max u1 u2 u3, max (max u1 u2) u3} (DirectSum.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (fun (i : ι) => AddMonoidHom.addCommMonoid.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (_inst_1 i))) (AddMonoidHom.{u3, max u1 u2} γ (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoid.toAddZeroClass.{max u1 u2 u3} (DirectSum.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (fun (i : ι) => AddMonoidHom.addCommMonoid.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (_inst_1 i))) (AddCommMonoid.toAddMonoid.{max u1 u2 u3} (DirectSum.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (fun (i : ι) => AddMonoidHom.addCommMonoid.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (_inst_1 i))) (DirectSum.addCommMonoid.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (fun (i : ι) => AddMonoidHom.addCommMonoid.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{max (max u1 u2) u3} (AddMonoidHom.{u3, max u1 u2} γ (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddCommMonoid.toAddMonoid.{max (max u1 u2) u3} (AddMonoidHom.{u3, max u1 u2} γ (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.addCommMonoid.{u3, max u1 u2} γ (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {β : ι -> Type.{u2}} [_inst_1 : forall (i : ι), AddCommMonoid.{u2} (β i)] {γ : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} γ], AddMonoidHom.{max (max u2 u3) u1, max (max u2 u1) u3} (DirectSum.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (fun (i : ι) => AddMonoidHom.addCommMonoid.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (_inst_1 i))) (AddMonoidHom.{u3, max u2 u1} γ (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoid.toAddZeroClass.{max (max u3 u1) u2} (DirectSum.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (fun (i : ι) => AddMonoidHom.addCommMonoid.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (_inst_1 i))) (AddCommMonoid.toAddMonoid.{max (max u3 u1) u2} (DirectSum.{u1, max u2 u3} ι (fun (i : ι) => AddMonoidHom.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (fun (i : ι) => AddMonoidHom.addCommMonoid.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (_inst_1 i))) (instAddCommMonoidDirectSum.{u1, max u3 u2} ι (fun (i : ι) => AddMonoidHom.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{u2} (β i) (AddCommMonoid.toAddMonoid.{u2} (β i) (_inst_1 i)))) (fun (i : ι) => AddMonoidHom.addCommMonoid.{u3, u2} γ (β i) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (_inst_1 i))))) (AddMonoid.toAddZeroClass.{max (max u3 u1) u2} (AddMonoidHom.{u3, max u2 u1} γ (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddCommMonoid.toAddMonoid.{max (max u3 u1) u2} (AddMonoidHom.{u3, max u2 u1} γ (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i))))) (AddMonoidHom.addCommMonoid.{u3, max u1 u2} γ (DirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ _inst_2)) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => β i) (fun (i : ι) => _inst_1 i)))))
Case conversion may be inaccurate. Consider using '#align direct_sum.from_add_monoid DirectSum.fromAddMonoidₓ'. -/
/-- `from_add_monoid φ` is the natural homomorphism from `γ` to `⨁ i, β i`
induced by a family `φ` of homomorphisms `γ → β i`.

Note that this is not an isomorphism. Not every homomorphism `γ →+ ⨁ i, β i` arises in this way. -/
def fromAddMonoid : (⨁ i, γ →+ β i) →+ γ →+ ⨁ i, β i :=
  toAddMonoid fun i => AddMonoidHom.compHom (of β i)
#align direct_sum.from_add_monoid DirectSum.fromAddMonoid

/- warning: direct_sum.from_add_monoid_of -> DirectSum.fromAddMonoid_of is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.from_add_monoid_of DirectSum.fromAddMonoid_ofₓ'. -/
@[simp]
theorem fromAddMonoid_of (i : ι) (f : γ →+ β i) : fromAddMonoid (of _ i f) = (of _ i).comp f :=
  by
  rw [from_add_monoid, to_add_monoid_of]
  rfl
#align direct_sum.from_add_monoid_of DirectSum.fromAddMonoid_of

/- warning: direct_sum.from_add_monoid_of_apply -> DirectSum.fromAddMonoid_of_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.from_add_monoid_of_apply DirectSum.fromAddMonoid_of_applyₓ'. -/
theorem fromAddMonoid_of_apply (i : ι) (f : γ →+ β i) (x : γ) :
    fromAddMonoid (of _ i f) x = of _ i (f x) := by rw [from_add_monoid_of, AddMonoidHom.coe_comp]
#align direct_sum.from_add_monoid_of_apply DirectSum.fromAddMonoid_of_apply

end FromAddMonoid

variable (β)

/- warning: direct_sum.set_to_set -> DirectSum.setToSet is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.set_to_set DirectSum.setToSetₓ'. -/
-- TODO: generalize this to remove the assumption `S ⊆ T`.
/-- `set_to_set β S T h` is the natural homomorphism `⨁ (i : S), β i → ⨁ (i : T), β i`,
where `h : S ⊆ T`. -/
def setToSet (S T : Set ι) (H : S ⊆ T) : (⨁ i : S, β i) →+ ⨁ i : T, β i :=
  toAddMonoid fun i => of (fun i : Subtype T => β i) ⟨↑i, H i.Prop⟩
#align direct_sum.set_to_set DirectSum.setToSet

variable {β}

omit dec_ι

#print DirectSum.unique /-
instance unique [∀ i, Subsingleton (β i)] : Unique (⨁ i, β i) :=
  Dfinsupp.unique
#align direct_sum.unique DirectSum.unique
-/

#print DirectSum.uniqueOfIsEmpty /-
/-- A direct sum over an empty type is trivial. -/
instance uniqueOfIsEmpty [IsEmpty ι] : Unique (⨁ i, β i) :=
  Dfinsupp.uniqueOfIsEmpty
#align direct_sum.unique_of_is_empty DirectSum.uniqueOfIsEmpty
-/

/- warning: direct_sum.id -> DirectSum.id is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) (ι : optParam.{succ (succ u2)} Type.{u2} PUnit.{succ u2}) [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Unique.{succ u2} ι], AddEquiv.{max u2 u1, u1} (DirectSum.{u2, u1} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_3)) M (AddZeroClass.toHasAdd.{max u2 u1} (DirectSum.{u2, u1} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_3)) (AddMonoid.toAddZeroClass.{max u2 u1} (DirectSum.{u2, u1} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_3)) (AddCommMonoid.toAddMonoid.{max u2 u1} (DirectSum.{u2, u1} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_3)) (DirectSum.addCommMonoid.{u2, u1} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_3))))) (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))
but is expected to have type
  forall (M : Type.{u1}) (ι : optParam.{succ (succ u2)} Type.{u2} PUnit.{succ u2}) [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Unique.{succ u2} ι], AddEquiv.{max u1 u2, u1} (DirectSum.{u2, u1} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_3)) M (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u2, u1} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_3)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u2, u1} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_3)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u2, u1} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_3)) (instAddCommMonoidDirectSum.{u2, u1} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_3))))) (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))
Case conversion may be inaccurate. Consider using '#align direct_sum.id DirectSum.idₓ'. -/
/-- The natural equivalence between `⨁ _ : ι, M` and `M` when `unique ι`. -/
protected def id (M : Type v) (ι : Type _ := PUnit) [AddCommMonoid M] [Unique ι] :
    (⨁ _ : ι, M) ≃+ M :=
  {
    DirectSum.toAddMonoid fun _ =>
      AddMonoidHom.id
        M with
    toFun := DirectSum.toAddMonoid fun _ => AddMonoidHom.id M
    invFun := of (fun _ => M) default
    left_inv := fun x =>
      DirectSum.induction_on x (by rw [AddMonoidHom.map_zero, AddMonoidHom.map_zero])
        (fun p x => by rw [Unique.default_eq p, to_add_monoid_of] <;> rfl) fun x y ihx ihy => by
        rw [AddMonoidHom.map_add, AddMonoidHom.map_add, ihx, ihy]
    right_inv := fun x => toAddMonoid_of _ _ _ }
#align direct_sum.id DirectSum.id

section CongrLeft

variable {κ : Type _}

#print DirectSum.equivCongrLeft /-
/-- Reindexing terms of a direct sum.-/
def equivCongrLeft (h : ι ≃ κ) : (⨁ i, β i) ≃+ ⨁ k, β (h.symm k) :=
  { Dfinsupp.equivCongrLeft h with map_add' := Dfinsupp.comapDomain'_add _ _ }
#align direct_sum.equiv_congr_left DirectSum.equivCongrLeft
-/

/- warning: direct_sum.equiv_congr_left_apply -> DirectSum.equivCongrLeft_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.equiv_congr_left_apply DirectSum.equivCongrLeft_applyₓ'. -/
@[simp]
theorem equivCongrLeft_apply (h : ι ≃ κ) (f : ⨁ i, β i) (k : κ) :
    equivCongrLeft h f k = f (h.symm k) :=
  Dfinsupp.comapDomain'_apply _ _ _ _
#align direct_sum.equiv_congr_left_apply DirectSum.equivCongrLeft_apply

end CongrLeft

section Option

variable {α : Option ι → Type w} [∀ i, AddCommMonoid (α i)]

include dec_ι

/- warning: direct_sum.add_equiv_prod_direct_sum -> DirectSum.addEquivProdDirectSum is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {α : (Option.{u1} ι) -> Type.{u2}} [_inst_3 : forall (i : Option.{u1} ι), AddCommMonoid.{u2} (α i)], AddEquiv.{max u1 u2, max u1 u2} (DirectSum.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_3 i)) (Prod.{u2, max u1 u2} (α (Option.none.{u1} ι)) (DirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i)))) (AddZeroClass.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_3 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_3 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_3 i)) (DirectSum.addCommMonoid.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_3 i))))) (Prod.hasAdd.{u2, max u1 u2} (α (Option.none.{u1} ι)) (DirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i))) (AddZeroClass.toHasAdd.{u2} (α (Option.none.{u1} ι)) (AddMonoid.toAddZeroClass.{u2} (α (Option.none.{u1} ι)) (AddCommMonoid.toAddMonoid.{u2} (α (Option.none.{u1} ι)) (_inst_3 (Option.none.{u1} ι))))) (AddZeroClass.toHasAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i)))))))
but is expected to have type
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {α : (Option.{u1} ι) -> Type.{u2}} [_inst_3 : forall (i : Option.{u1} ι), AddCommMonoid.{u2} (α i)], AddEquiv.{max u2 u1, max u2 u1} (DirectSum.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_3 i)) (Prod.{u2, max u2 u1} (α (Option.none.{u1} ι)) (DirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i)))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_3 i)) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_3 i)) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_3 i)) (instAddCommMonoidDirectSum.{u1, u2} (Option.{u1} ι) (fun (i : Option.{u1} ι) => α i) (fun (i : Option.{u1} ι) => _inst_3 i))))) (Prod.instAddSum.{u2, max u1 u2} (α (Option.none.{u1} ι)) (DirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i))) (AddZeroClass.toAdd.{u2} (α (Option.none.{u1} ι)) (AddMonoid.toAddZeroClass.{u2} (α (Option.none.{u1} ι)) (AddCommMonoid.toAddMonoid.{u2} (α (Option.none.{u1} ι)) (_inst_3 (Option.none.{u1} ι))))) (AddZeroClass.toAdd.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i))) (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i))) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => α (Option.some.{u1} ι i)) (fun (i : ι) => _inst_3 (Option.some.{u1} ι i)))))))
Case conversion may be inaccurate. Consider using '#align direct_sum.add_equiv_prod_direct_sum DirectSum.addEquivProdDirectSumₓ'. -/
/-- Isomorphism obtained by separating the term of index `none` of a direct sum over `option ι`.-/
@[simps]
noncomputable def addEquivProdDirectSum : (⨁ i, α i) ≃+ α none × ⨁ i, α (some i) :=
  { Dfinsupp.equivProdDfinsupp with map_add' := Dfinsupp.equivProdDfinsupp_add }
#align direct_sum.add_equiv_prod_direct_sum DirectSum.addEquivProdDirectSum

end Option

section Sigma

variable {α : ι → Type u} {δ : ∀ i, α i → Type w} [∀ i j, AddCommMonoid (δ i j)]

/- warning: direct_sum.sigma_curry -> DirectSum.sigmaCurry is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_3 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)], AddMonoidHom.{max (max u2 u1) u3, max u2 u1 u3} (DirectSum.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddMonoid.toAddZeroClass.{max (max u2 u1) u3} (DirectSum.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (AddCommMonoid.toAddMonoid.{max (max u2 u1) u3} (DirectSum.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))))) (AddMonoid.toAddZeroClass.{max u2 u1 u3} (DirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddCommMonoid.toAddMonoid.{max u2 u1 u3} (DirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (DirectSum.addCommMonoid.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_3 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)], AddMonoidHom.{max u3 u1 u2, max (max u3 u1) u2} (DirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u3 u1} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddMonoid.toAddZeroClass.{max (max u1 u2) u3} (DirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (AddCommMonoid.toAddMonoid.{max (max u1 u2) u3} (DirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))))) (AddMonoid.toAddZeroClass.{max (max u1 u2) u3} (DirectSum.{u2, max u3 u1} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddCommMonoid.toAddMonoid.{max (max u1 u2) u3} (DirectSum.{u2, max u3 u1} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (instAddCommMonoidDirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)))))
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_curry DirectSum.sigmaCurryₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/-- The natural map between `⨁ (i : Σ i, α i), δ i.1 i.2` and `⨁ i (j : α i), δ i j`.-/
noncomputable def sigmaCurry : (⨁ i : Σi, _, δ i.1 i.2) →+ ⨁ (i) (j), δ i j
    where
  toFun := @Dfinsupp.sigmaCurry _ _ δ _
  map_zero' := Dfinsupp.sigmaCurry_zero
  map_add' f g := @Dfinsupp.sigmaCurry_add _ _ δ _ f g
#align direct_sum.sigma_curry DirectSum.sigmaCurry

/- warning: direct_sum.sigma_curry_apply -> DirectSum.sigmaCurry_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_curry_apply DirectSum.sigmaCurry_applyₓ'. -/
@[simp]
theorem sigmaCurry_apply (f : ⨁ i : Σi, _, δ i.1 i.2) (i : ι) (j : α i) :
    sigmaCurry f i j = f ⟨i, j⟩ :=
  @Dfinsupp.sigmaCurry_apply _ _ δ _ f i j
#align direct_sum.sigma_curry_apply DirectSum.sigmaCurry_apply

/- warning: direct_sum.sigma_uncurry -> DirectSum.sigmaUncurry is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_3 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_4 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_5 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], AddMonoidHom.{max u2 u1 u3, max (max u2 u1) u3} (DirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (DirectSum.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (AddMonoid.toAddZeroClass.{max u2 u1 u3} (DirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddCommMonoid.toAddMonoid.{max u2 u1 u3} (DirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (DirectSum.addCommMonoid.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))))) (AddMonoid.toAddZeroClass.{max (max u2 u1) u3} (DirectSum.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (AddCommMonoid.toAddMonoid.{max (max u2 u1) u3} (DirectSum.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_3 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_4 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_5 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], AddMonoidHom.{max (max u3 u1) u2, max u3 u1 u2} (DirectSum.{u2, max u3 u1} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (DirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (AddMonoid.toAddZeroClass.{max (max u1 u2) u3} (DirectSum.{u2, max u3 u1} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddCommMonoid.toAddMonoid.{max (max u1 u2) u3} (DirectSum.{u2, max u3 u1} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (instAddCommMonoidDirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))))) (AddMonoid.toAddZeroClass.{max (max u1 u2) u3} (DirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (AddCommMonoid.toAddMonoid.{max (max u1 u2) u3} (DirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))))
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_uncurry DirectSum.sigmaUncurryₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/-- The natural map between `⨁ i (j : α i), δ i j` and `Π₀ (i : Σ i, α i), δ i.1 i.2`, inverse of
`curry`.-/
def sigmaUncurry [∀ i, DecidableEq (α i)] [∀ i j, DecidableEq (δ i j)] :
    (⨁ (i) (j), δ i j) →+ ⨁ i : Σi, _, δ i.1 i.2
    where
  toFun := Dfinsupp.sigmaUncurry
  map_zero' := Dfinsupp.sigmaUncurry_zero
  map_add' := Dfinsupp.sigmaUncurry_add
#align direct_sum.sigma_uncurry DirectSum.sigmaUncurry

/- warning: direct_sum.sigma_uncurry_apply -> DirectSum.sigmaUncurry_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_uncurry_apply DirectSum.sigmaUncurry_applyₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem sigmaUncurry_apply [∀ i, DecidableEq (α i)] [∀ i j, DecidableEq (δ i j)]
    (f : ⨁ (i) (j), δ i j) (i : ι) (j : α i) : sigmaUncurry f ⟨i, j⟩ = f i j :=
  Dfinsupp.sigmaUncurry_apply f i j
#align direct_sum.sigma_uncurry_apply DirectSum.sigmaUncurry_apply

/- warning: direct_sum.sigma_curry_equiv -> DirectSum.sigmaCurryEquiv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_3 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_4 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_5 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], AddEquiv.{max (max u2 u1) u3, max u2 u1 u3} (DirectSum.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddZeroClass.toHasAdd.{max (max u2 u1) u3} (DirectSum.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (AddMonoid.toAddZeroClass.{max (max u2 u1) u3} (DirectSum.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (AddCommMonoid.toAddMonoid.{max (max u2 u1) u3} (DirectSum.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{max u2 u1, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))))) (AddZeroClass.toHasAdd.{max u2 u1 u3} (DirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddMonoid.toAddZeroClass.{max u2 u1 u3} (DirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddCommMonoid.toAddMonoid.{max u2 u1 u3} (DirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (DirectSum.addCommMonoid.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))))))
but is expected to have type
  forall {ι : Type.{u2}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_3 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_4 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_5 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], AddEquiv.{max u3 u1 u2, max (max u3 u1) u2} (DirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u3 u1} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddZeroClass.toAdd.{max (max u1 u2) u3} (DirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (AddMonoid.toAddZeroClass.{max (max u1 u2) u3} (DirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (AddCommMonoid.toAddMonoid.{max (max u1 u2) u3} (DirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{max u1 u2, u3} (Sigma.{u2, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u1} ι (fun (i : ι) => α i)) => _inst_3 (Sigma.fst.{u2, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u1} ι (fun (i : ι) => α i) i)))))) (AddZeroClass.toAdd.{max (max u1 u2) u3} (DirectSum.{u2, max u3 u1} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddMonoid.toAddZeroClass.{max (max u1 u2) u3} (DirectSum.{u2, max u3 u1} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (AddCommMonoid.toAddMonoid.{max (max u1 u2) u3} (DirectSum.{u2, max u3 u1} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))) (instAddCommMonoidDirectSum.{u2, max u1 u3} ι (fun (i : ι) => DirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_3 i i_1))))))
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_curry_equiv DirectSum.sigmaCurryEquivₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/-- The natural map between `⨁ (i : Σ i, α i), δ i.1 i.2` and `⨁ i (j : α i), δ i j`.-/
noncomputable def sigmaCurryEquiv [∀ i, DecidableEq (α i)] [∀ i j, DecidableEq (δ i j)] :
    (⨁ i : Σi, _, δ i.1 i.2) ≃+ ⨁ (i) (j), δ i j :=
  { sigmaCurry, Dfinsupp.sigmaCurryEquiv with }
#align direct_sum.sigma_curry_equiv DirectSum.sigmaCurryEquiv

end Sigma

/- warning: direct_sum.coe_add_monoid_hom -> DirectSum.coeAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} {S : Type.{u3}} [_inst_3 : DecidableEq.{succ u1} ι] [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : SetLike.{u3, u2} S M] [_inst_6 : AddSubmonoidClass.{u3, u2} S M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5] (A : ι -> S), AddMonoidHom.{max u1 u2, u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} S Type.{u2} (SetLike.hasCoeToSort.{u3, u2} S M _inst_5) (A i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_4 S _inst_5 _inst_6 (A i))) M (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} S Type.{u2} (SetLike.hasCoeToSort.{u3, u2} S M _inst_5) (A i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_4 S _inst_5 _inst_6 (A i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} S Type.{u2} (SetLike.hasCoeToSort.{u3, u2} S M _inst_5) (A i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_4 S _inst_5 _inst_6 (A i))) (DirectSum.addCommMonoid.{u1, u2} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u2)} S Type.{u2} (SetLike.hasCoeToSort.{u3, u2} S M _inst_5) (A i)) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_4 S _inst_5 _inst_6 (A i))))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))
but is expected to have type
  forall {ι : Type.{u1}} {M : Type.{u2}} {S : Type.{u3}} [_inst_3 : DecidableEq.{succ u1} ι] [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : SetLike.{u3, u2} S M] [_inst_6 : AddSubmonoidClass.{u3, u2} S M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5] (A : ι -> S), AddMonoidHom.{max u2 u1, u2} (DirectSum.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u3} M S (SetLike.instMembership.{u3, u2} S M _inst_5) x (A i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_4 S _inst_5 _inst_6 (A i))) M (AddMonoid.toAddZeroClass.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u3} M S (SetLike.instMembership.{u3, u2} S M _inst_5) x (A i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_4 S _inst_5 _inst_6 (A i))) (AddCommMonoid.toAddMonoid.{max u1 u2} (DirectSum.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u3} M S (SetLike.instMembership.{u3, u2} S M _inst_5) x (A i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_4 S _inst_5 _inst_6 (A i))) (instAddCommMonoidDirectSum.{u1, u2} ι (fun (i : ι) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u3} M S (SetLike.instMembership.{u3, u2} S M _inst_5) x (A i))) (fun (i : ι) => AddSubmonoidClass.toAddCommMonoid.{u2, u3} M _inst_4 S _inst_5 _inst_6 (A i))))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))
Case conversion may be inaccurate. Consider using '#align direct_sum.coe_add_monoid_hom DirectSum.coeAddMonoidHomₓ'. -/
/-- The canonical embedding from `⨁ i, A i` to `M` where `A` is a collection of `add_submonoid M`
indexed by `ι`.

When `S = submodule _ M`, this is available as a `linear_map`, `direct_sum.coe_linear_map`. -/
protected def coeAddMonoidHom {M S : Type _} [DecidableEq ι] [AddCommMonoid M] [SetLike S M]
    [AddSubmonoidClass S M] (A : ι → S) : (⨁ i, A i) →+ M :=
  toAddMonoid fun i => AddSubmonoidClass.Subtype (A i)
#align direct_sum.coe_add_monoid_hom DirectSum.coeAddMonoidHom

/- warning: direct_sum.coe_add_monoid_hom_of -> DirectSum.coeAddMonoidHom_of is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.coe_add_monoid_hom_of DirectSum.coeAddMonoidHom_ofₓ'. -/
@[simp]
theorem coeAddMonoidHom_of {M S : Type _} [DecidableEq ι] [AddCommMonoid M] [SetLike S M]
    [AddSubmonoidClass S M] (A : ι → S) (i : ι) (x : A i) :
    DirectSum.coeAddMonoidHom A (of (fun i => A i) i x) = x :=
  toAddMonoid_of _ _ _
#align direct_sum.coe_add_monoid_hom_of DirectSum.coeAddMonoidHom_of

/- warning: direct_sum.coe_of_apply -> DirectSum.coe_of_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.coe_of_apply DirectSum.coe_of_applyₓ'. -/
theorem coe_of_apply {M S : Type _} [DecidableEq ι] [AddCommMonoid M] [SetLike S M]
    [AddSubmonoidClass S M] {A : ι → S} (i j : ι) (x : A i) :
    (of _ i x j : M) = if i = j then x else 0 :=
  by
  obtain rfl | h := Decidable.eq_or_ne i j
  · rw [DirectSum.of_eq_same, if_pos rfl]
  · rw [DirectSum.of_eq_of_ne _ _ _ _ h, if_neg h, ZeroMemClass.coe_zero]
#align direct_sum.coe_of_apply DirectSum.coe_of_apply

#print DirectSum.IsInternal /-
/-- The `direct_sum` formed by a collection of additive submonoids (or subgroups, or submodules) of
`M` is said to be internal if the canonical map `(⨁ i, A i) →+ M` is bijective.

For the alternate statement in terms of independence and spanning, see
`direct_sum.subgroup_is_internal_iff_independent_and_supr_eq_top` and
`direct_sum.is_internal_submodule_iff_independent_and_supr_eq_top`. -/
def IsInternal {M S : Type _} [DecidableEq ι] [AddCommMonoid M] [SetLike S M]
    [AddSubmonoidClass S M] (A : ι → S) : Prop :=
  Function.Bijective (DirectSum.coeAddMonoidHom A)
#align direct_sum.is_internal DirectSum.IsInternal
-/

/- warning: direct_sum.is_internal.add_submonoid_supr_eq_top -> DirectSum.IsInternal.addSubmonoid_iSup_eq_top is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {M : Type.{u2}} [_inst_3 : DecidableEq.{succ u1} ι] [_inst_4 : AddCommMonoid.{u2} M] (A : ι -> (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))), (DirectSum.IsInternal.{u1, u2, u2} ι M (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (fun (a : ι) (b : ι) => _inst_3 a b) _inst_4 (AddSubmonoid.setLike.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddSubmonoid.add_submonoidClass.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) A) -> (Eq.{succ u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (iSup.{u2, succ u1} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (CompleteSemilatticeSup.toHasSup.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (CompleteLattice.toCompleteSemilatticeSup.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddSubmonoid.completeLattice.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))))) ι A) (Top.top.{u2} (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddSubmonoid.hasTop.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))))
but is expected to have type
  forall {ι : Type.{u2}} {M : Type.{u1}} [_inst_3 : DecidableEq.{succ u2} ι] [_inst_4 : AddCommMonoid.{u1} M] (A : ι -> (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4)))), (DirectSum.IsInternal.{u2, u1, u1} ι M (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (fun (a : ι) (b : ι) => _inst_3 a b) _inst_4 (AddSubmonoid.instSetLikeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (AddSubmonoid.instAddSubmonoidClassAddSubmonoidInstSetLikeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) A) -> (Eq.{succ u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (iSup.{u1, succ u2} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (CompleteLattice.toSupSet.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4)))) ι A) (Top.top.{u1} (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (AddSubmonoid.instTopAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4)))))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.add_submonoid_supr_eq_top DirectSum.IsInternal.addSubmonoid_iSup_eq_topₓ'. -/
theorem IsInternal.addSubmonoid_iSup_eq_top {M : Type _} [DecidableEq ι] [AddCommMonoid M]
    (A : ι → AddSubmonoid M) (h : IsInternal A) : iSup A = ⊤ :=
  by
  rw [AddSubmonoid.iSup_eq_mrange_dfinsupp_sumAddHom, AddMonoidHom.mrange_top_iff_surjective]
  exact Function.Bijective.surjective h
#align direct_sum.is_internal.add_submonoid_supr_eq_top DirectSum.IsInternal.addSubmonoid_iSup_eq_top

end DirectSum

