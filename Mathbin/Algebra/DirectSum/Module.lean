/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau

! This file was ported from Lean 3 source module algebra.direct_sum.module
! leanprover-community/mathlib commit 932872382355f00112641d305ba0619305dc8642
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.DirectSum.Basic
import Mathbin.LinearAlgebra.Dfinsupp

/-!
# Direct sum of modules

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The first part of the file provides constructors for direct sums of modules. It provides a
construction of the direct sum using the universal property and proves its uniqueness
(`direct_sum.to_module.unique`).

The second part of the file covers the special case of direct sums of submodules of a fixed module
`M`.  There is a canonical linear map from this direct sum to `M` (`direct_sum.coe_linear_map`), and
the construction is of particular importance when this linear map is an equivalence; that is, when
the submodules provide an internal decomposition of `M`.  The property is defined more generally
elsewhere as `direct_sum.is_internal`, but its basic consequences on `submodule`s are established
in this file.

-/


universe u v w u₁

namespace DirectSum

open DirectSum

section General

variable {R : Type u} [Semiring R]

variable {ι : Type v} [dec_ι : DecidableEq ι]

include R

variable {M : ι → Type w} [∀ i, AddCommMonoid (M i)] [∀ i, Module R (M i)]

instance : Module R (⨁ i, M i) :=
  Dfinsupp.module

instance {S : Type _} [Semiring S] [∀ i, Module S (M i)] [∀ i, SMulCommClass R S (M i)] :
    SMulCommClass R S (⨁ i, M i) :=
  Dfinsupp.sMulCommClass

instance {S : Type _} [Semiring S] [SMul R S] [∀ i, Module S (M i)] [∀ i, IsScalarTower R S (M i)] :
    IsScalarTower R S (⨁ i, M i) :=
  Dfinsupp.isScalarTower

instance [∀ i, Module Rᵐᵒᵖ (M i)] [∀ i, IsCentralScalar R (M i)] : IsCentralScalar R (⨁ i, M i) :=
  Dfinsupp.isCentralScalar

/- warning: direct_sum.smul_apply -> DirectSum.smul_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (b : R) (v : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (i : ι), Eq.{succ u3} (M i) (coeFn.{succ (max u2 u3), max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), M i) (DirectSum.hasCoeToFun.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMul.smul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMulZeroClass.toHasSmul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (SMulWithZero.toSmulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (Module.toMulActionWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) b v) i) (SMul.smul.{u1, u3} R (M i) (SMulZeroClass.toHasSmul.{u1, u3} R (M i) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R (M i) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R (M i) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} R (M i) _inst_1 (_inst_2 i) (_inst_3 i))))) b (coeFn.{succ (max u2 u3), max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), M i) (DirectSum.hasCoeToFun.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) v i))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (b : R) (v : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (i : ι), Eq.{succ u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) (HSMul.hSMul.{u1, max u2 u3, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instHSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMulZeroClass.toSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (SMulWithZero.toSMulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (Module.toMulActionWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))))) b v) i) (HSMul.hSMul.{u1, u3, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (instHSMul.{u1, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (SMulZeroClass.toSMul.{u1, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) _inst_1 (_inst_2 i) (_inst_3 i)))))) b (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) v i))
Case conversion may be inaccurate. Consider using '#align direct_sum.smul_apply DirectSum.smul_applyₓ'. -/
theorem smul_apply (b : R) (v : ⨁ i, M i) (i : ι) : (b • v) i = b • v i :=
  Dfinsupp.smul_apply _ _ _
#align direct_sum.smul_apply DirectSum.smul_apply

include dec_ι

variable (R ι M)

/- warning: direct_sum.lmk -> DirectSum.lmk is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (s : Finset.{u2} ι), LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) R _inst_1 (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => _inst_3 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (s : Finset.{u2} ι), LinearMap.{u1, u1, max u2 u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) R _inst_1 (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => _inst_3 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
Case conversion may be inaccurate. Consider using '#align direct_sum.lmk DirectSum.lmkₓ'. -/
/-- Create the direct sum given a family `M` of `R` modules indexed over `ι`. -/
def lmk : ∀ s : Finset ι, (∀ i : (↑s : Set ι), M i.val) →ₗ[R] ⨁ i, M i :=
  Dfinsupp.lmk
#align direct_sum.lmk DirectSum.lmk

/- warning: direct_sum.lof -> DirectSum.lof is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι), LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι), LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
Case conversion may be inaccurate. Consider using '#align direct_sum.lof DirectSum.lofₓ'. -/
/-- Inclusion of each component into the direct sum. -/
def lof : ∀ i : ι, M i →ₗ[R] ⨁ i, M i :=
  Dfinsupp.lsingle
#align direct_sum.lof DirectSum.lof

/- warning: direct_sum.lof_eq_of -> DirectSum.lof_eq_of is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ (max u2 u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ u3) (succ (max u2 u3))} (AddMonoidHom.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (fun (_x : AddMonoidHom.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (AddMonoidHom.hasCoeToFun.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) i) b)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) b) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (AddHomClass.toFunLike.{max u2 u3, u3, max u2 u3} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddZeroClass.toAdd.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (AddZeroClass.toAdd.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u3, max u2 u3} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoidHom.addMonoidHomClass.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))))) (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) i) b)
Case conversion may be inaccurate. Consider using '#align direct_sum.lof_eq_of DirectSum.lof_eq_ofₓ'. -/
theorem lof_eq_of (i : ι) (b : M i) : lof R ι M i b = of M i b :=
  rfl
#align direct_sum.lof_eq_of DirectSum.lof_eq_of

variable {ι M}

/- warning: direct_sum.single_eq_lof -> DirectSum.single_eq_lof is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ (max u2 u3)} (Dfinsupp.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => M i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => M i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => M i) i) ((fun (i : ι) => (fun (i : ι) => _inst_2 i) i) i))))) (Dfinsupp.single.{u2, u3} ι (fun (i : ι) => M i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => M i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => M i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => M i) i) ((fun (i : ι) => (fun (i : ι) => _inst_2 i) i) i)))) i b) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{max (succ u2) (succ u3)} (Dfinsupp.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (Dfinsupp.single.{u2, u3} ι M (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) i b) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b)
Case conversion may be inaccurate. Consider using '#align direct_sum.single_eq_lof DirectSum.single_eq_lofₓ'. -/
theorem single_eq_lof (i : ι) (b : M i) : Dfinsupp.single i b = lof R ι M i b :=
  rfl
#align direct_sum.single_eq_lof DirectSum.single_eq_lof

/- warning: direct_sum.mk_smul -> DirectSum.mk_smul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.mk_smul DirectSum.mk_smulₓ'. -/
/-- Scalar multiplication commutes with direct sums. -/
theorem mk_smul (s : Finset ι) (c : R) (x) : mk M s (c • x) = c • mk M s x :=
  (lmk R ι M s).map_smul c x
#align direct_sum.mk_smul DirectSum.mk_smul

/- warning: direct_sum.of_smul -> DirectSum.of_smul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.of_smul DirectSum.of_smulₓ'. -/
/-- Scalar multiplication commutes with the inclusion of each component into the direct sum. -/
theorem of_smul (i : ι) (c : R) (x) : of M i (c • x) = c • of M i x :=
  (lof R ι M i).map_smul c x
#align direct_sum.of_smul DirectSum.of_smul

variable {R}

/- warning: direct_sum.support_smul -> DirectSum.support_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_4 : forall (i : ι) (x : M i), Decidable (Ne.{succ u3} (M i) x (OfNat.ofNat.{u3} (M i) 0 (OfNat.mk.{u3} (M i) 0 (Zero.zero.{u3} (M i) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))))))))] (c : R) (v : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)), HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.hasSubset.{u2} ι) (Dfinsupp.support.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => M i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => M i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => M i) i) ((fun (i : ι) => _inst_2 i) i)))) (fun (i : ι) (x : M i) => _inst_4 i x) (SMul.smul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMulZeroClass.toHasSmul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (SMulWithZero.toSmulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (Module.toMulActionWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) c v)) (Dfinsupp.support.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => M i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => M i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => M i) i) ((fun (i : ι) => _inst_2 i) i)))) (fun (i : ι) (x : M i) => _inst_4 i x) v)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_4 : forall (i : ι) (x : M i), Decidable (Ne.{succ u3} (M i) x (OfNat.ofNat.{u3} (M i) 0 (Zero.toOfNat0.{u3} (M i) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))))))] (c : R) (v : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)), HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (Dfinsupp.support.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) (fun (i : ι) (x : M i) => _inst_4 i x) (HSMul.hSMul.{u1, max u2 u3, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instHSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMulZeroClass.toSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (SMulWithZero.toSMulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (Module.toMulActionWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))))) c v)) (Dfinsupp.support.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) (fun (i : ι) (x : M i) => _inst_4 i x) v)
Case conversion may be inaccurate. Consider using '#align direct_sum.support_smul DirectSum.support_smulₓ'. -/
theorem support_smul [∀ (i : ι) (x : M i), Decidable (x ≠ 0)] (c : R) (v : ⨁ i, M i) :
    (c • v).support ⊆ v.support :=
  Dfinsupp.support_smul _ _
#align direct_sum.support_smul DirectSum.support_smul

variable {N : Type u₁} [AddCommMonoid N] [Module R N]

variable (φ : ∀ i, M i →ₗ[R] N)

variable (R ι N φ)

/- warning: direct_sum.to_module -> DirectSum.toModule is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (N : Type.{u4}) [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4], (forall (i : ι), LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5) -> (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (N : Type.{u4}) [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4], (forall (i : ι), LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5) -> (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5)
Case conversion may be inaccurate. Consider using '#align direct_sum.to_module DirectSum.toModuleₓ'. -/
/-- The linear map constructed using the universal property of the coproduct. -/
def toModule : (⨁ i, M i) →ₗ[R] N :=
  Dfinsupp.lsum ℕ φ
#align direct_sum.to_module DirectSum.toModule

/- warning: direct_sum.coe_to_module_eq_coe_to_add_monoid -> DirectSum.coe_toModule_eq_coe_toAddMonoid is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.coe_to_module_eq_coe_to_add_monoid DirectSum.coe_toModule_eq_coe_toAddMonoidₓ'. -/
/-- Coproducts in the categories of modules and additive monoids commute with the forgetful functor
from modules to additive monoids. -/
theorem coe_toModule_eq_coe_toAddMonoid :
    (toModule R ι N φ : (⨁ i, M i) → N) = toAddMonoid fun i => (φ i).toAddMonoidHom :=
  rfl
#align direct_sum.coe_to_module_eq_coe_to_add_monoid DirectSum.coe_toModule_eq_coe_toAddMonoid

variable {ι N φ}

/- warning: direct_sum.to_module_lof -> DirectSum.toModule_lof is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.to_module_lof DirectSum.toModule_lofₓ'. -/
/-- The map constructed using the universal property gives back the original maps when
restricted to each component. -/
@[simp]
theorem toModule_lof (i) (x : M i) : toModule R ι N φ (lof R ι M i x) = φ i x :=
  toAddMonoid_of (fun i => (φ i).toAddMonoidHom) i x
#align direct_sum.to_module_lof DirectSum.toModule_lof

variable (ψ : (⨁ i, M i) →ₗ[R] N)

/- warning: direct_sum.to_module.unique -> DirectSum.toModule.unique is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.to_module.unique DirectSum.toModule.uniqueₓ'. -/
/-- Every linear map from a direct sum agrees with the one obtained by applying
the universal property to each of its components. -/
theorem toModule.unique (f : ⨁ i, M i) : ψ f = toModule R ι N (fun i => ψ.comp <| lof R ι M i) f :=
  toAddMonoid.unique ψ.toAddMonoidHom f
#align direct_sum.to_module.unique DirectSum.toModule.unique

variable {ψ} {ψ' : (⨁ i, M i) →ₗ[R] N}

/- warning: direct_sum.linear_map_ext -> DirectSum.linearMap_ext is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.linear_map_ext DirectSum.linearMap_extₓ'. -/
/-- Two `linear_map`s out of a direct sum are equal if they agree on the generators.

See note [partially-applied ext lemmas]. -/
@[ext]
theorem linearMap_ext ⦃ψ ψ' : (⨁ i, M i) →ₗ[R] N⦄
    (H : ∀ i, ψ.comp (lof R ι M i) = ψ'.comp (lof R ι M i)) : ψ = ψ' :=
  Dfinsupp.lhom_ext' H
#align direct_sum.linear_map_ext DirectSum.linearMap_ext

/- warning: direct_sum.lset_to_set -> DirectSum.lsetToSet is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.lset_to_set DirectSum.lsetToSetₓ'. -/
/-- The inclusion of a subset of the direct summands
into a larger subset of the direct summands, as a linear map.
-/
def lsetToSet (S T : Set ι) (H : S ⊆ T) : (⨁ i : S, M i) →ₗ[R] ⨁ i : T, M i :=
  toModule R _ _ fun i => lof R T (fun i : Subtype T => M i) ⟨i, H i.Prop⟩
#align direct_sum.lset_to_set DirectSum.lsetToSet

omit dec_ι

variable (ι M)

/- warning: direct_sum.linear_equiv_fun_on_fintype -> DirectSum.linearEquivFunOnFintype is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_6 : Fintype.{u2} ι], LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_6 : Fintype.{u2} ι], LinearEquiv.{u1, u1, max u3 u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
Case conversion may be inaccurate. Consider using '#align direct_sum.linear_equiv_fun_on_fintype DirectSum.linearEquivFunOnFintypeₓ'. -/
/-- Given `fintype α`, `linear_equiv_fun_on_fintype R` is the natural `R`-linear equivalence
between `⨁ i, M i` and `Π i, M i`. -/
@[simps apply]
def linearEquivFunOnFintype [Fintype ι] : (⨁ i, M i) ≃ₗ[R] ∀ i, M i :=
  { Dfinsupp.equivFunOnFintype with
    toFun := coeFn
    map_add' := fun f g => by ext; simp only [add_apply, Pi.add_apply]
    map_smul' := fun c f => by ext; simp only [Dfinsupp.coe_smul, RingHom.id_apply] }
#align direct_sum.linear_equiv_fun_on_fintype DirectSum.linearEquivFunOnFintype

variable {ι M}

/- warning: direct_sum.linear_equiv_fun_on_fintype_lof -> DirectSum.linearEquivFunOnFintype_lof is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.linear_equiv_fun_on_fintype_lof DirectSum.linearEquivFunOnFintype_lofₓ'. -/
@[simp]
theorem linearEquivFunOnFintype_lof [Fintype ι] [DecidableEq ι] (i : ι) (m : M i) :
    (linearEquivFunOnFintype R ι M) (lof R ι M i m) = Pi.single i m :=
  by
  ext a
  change (Dfinsupp.equivFunOnFintype (lof R ι M i m)) a = _
  convert _root_.congr_fun (Dfinsupp.equivFunOnFintype_single i m) a
#align direct_sum.linear_equiv_fun_on_fintype_lof DirectSum.linearEquivFunOnFintype_lof

/- warning: direct_sum.linear_equiv_fun_on_fintype_symm_single -> DirectSum.linearEquivFunOnFintype_symm_single is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.linear_equiv_fun_on_fintype_symm_single DirectSum.linearEquivFunOnFintype_symm_singleₓ'. -/
@[simp]
theorem linearEquivFunOnFintype_symm_single [Fintype ι] [DecidableEq ι] (i : ι) (m : M i) :
    (linearEquivFunOnFintype R ι M).symm (Pi.single i m) = lof R ι M i m :=
  by
  ext a
  change (dfinsupp.equiv_fun_on_fintype.symm (Pi.single i m)) a = _
  rw [Dfinsupp.equivFunOnFintype_symm_single i m]
  rfl
#align direct_sum.linear_equiv_fun_on_fintype_symm_single DirectSum.linearEquivFunOnFintype_symm_single

/- warning: direct_sum.linear_equiv_fun_on_fintype_symm_coe -> DirectSum.linearEquivFunOnFintype_symm_coe is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.linear_equiv_fun_on_fintype_symm_coe DirectSum.linearEquivFunOnFintype_symm_coeₓ'. -/
@[simp]
theorem linearEquivFunOnFintype_symm_coe [Fintype ι] (f : ⨁ i, M i) :
    (linearEquivFunOnFintype R ι M).symm f = f := by ext; simp [linear_equiv_fun_on_fintype]
#align direct_sum.linear_equiv_fun_on_fintype_symm_coe DirectSum.linearEquivFunOnFintype_symm_coe

/- warning: direct_sum.lid -> DirectSum.lid is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (M : Type.{u2}) (ι : optParam.{succ (succ u3)} Type.{u3} PUnit.{succ u3}) [_inst_6 : AddCommMonoid.{u2} M] [_inst_7 : Module.{u1, u2} R M _inst_1 _inst_6] [_inst_8 : Unique.{succ u3} ι], LinearEquiv.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u3, u2} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6)) M (DirectSum.addCommMonoid.{u3, u2} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6)) _inst_6 (DirectSum.module.{u1, u3, u2} R _inst_1 ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6) (fun (i : ι) => _inst_7)) _inst_7
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (M : Type.{u2}) (ι : optParam.{succ (succ u3)} Type.{u3} PUnit.{succ u3}) [_inst_6 : AddCommMonoid.{u2} M] [_inst_7 : Module.{u1, u2} R M _inst_1 _inst_6] [_inst_8 : Unique.{succ u3} ι], LinearEquiv.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u3, u2} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6)) M (instAddCommMonoidDirectSum.{u3, u2} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6)) _inst_6 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u3, u2} R _inst_1 ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6) (fun (i : ι) => _inst_7)) _inst_7
Case conversion may be inaccurate. Consider using '#align direct_sum.lid DirectSum.lidₓ'. -/
/-- The natural linear equivalence between `⨁ _ : ι, M` and `M` when `unique ι`. -/
protected def lid (M : Type v) (ι : Type _ := PUnit) [AddCommMonoid M] [Module R M] [Unique ι] :
    (⨁ _ : ι, M) ≃ₗ[R] M :=
  { DirectSum.id M ι, toModule R ι M fun i => LinearMap.id with }
#align direct_sum.lid DirectSum.lid

variable (ι M)

/- warning: direct_sum.component -> DirectSum.component is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι), LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι), LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)
Case conversion may be inaccurate. Consider using '#align direct_sum.component DirectSum.componentₓ'. -/
/-- The projection map onto one component, as a linear map. -/
def component (i : ι) : (⨁ i, M i) →ₗ[R] M i :=
  Dfinsupp.lapply i
#align direct_sum.component DirectSum.component

variable {ι M}

/- warning: direct_sum.apply_eq_component -> DirectSum.apply_eq_component is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (i : ι), Eq.{succ u3} (M i) (coeFn.{succ (max u2 u3), max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), M i) (DirectSum.hasCoeToFun.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f i) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (i : ι), Eq.{succ u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) f i) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f)
Case conversion may be inaccurate. Consider using '#align direct_sum.apply_eq_component DirectSum.apply_eq_componentₓ'. -/
theorem apply_eq_component (f : ⨁ i, M i) (i : ι) : f i = component R ι M i f :=
  rfl
#align direct_sum.apply_eq_component DirectSum.apply_eq_component

/- warning: direct_sum.ext -> DirectSum.ext is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)} {g : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)}, (forall (i : ι), Eq.{succ u3} (M i) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) g)) -> (Eq.{succ (max u2 u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f g)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)} {g : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)}, (forall (i : ι), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) f) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) g)) -> (Eq.{max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f g)
Case conversion may be inaccurate. Consider using '#align direct_sum.ext DirectSum.extₓ'. -/
@[ext]
theorem ext {f g : ⨁ i, M i} (h : ∀ i, component R ι M i f = component R ι M i g) : f = g :=
  Dfinsupp.ext h
#align direct_sum.ext DirectSum.ext

/- warning: direct_sum.ext_iff -> DirectSum.ext_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)} {g : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)}, Iff (Eq.{succ (max u2 u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f g) (forall (i : ι), Eq.{succ u3} (M i) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) g))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)} {g : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)}, Iff (Eq.{max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f g) (forall (i : ι), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) f) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) g))
Case conversion may be inaccurate. Consider using '#align direct_sum.ext_iff DirectSum.ext_iffₓ'. -/
theorem ext_iff {f g : ⨁ i, M i} : f = g ↔ ∀ i, component R ι M i f = component R ι M i g :=
  ⟨fun h _ => by rw [h], ext R⟩
#align direct_sum.ext_iff DirectSum.ext_iff

include dec_ι

/- warning: direct_sum.lof_apply -> DirectSum.lof_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ u3} (M i) (coeFn.{succ (max u2 u3), max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) => forall (i : ι), M i) (DirectSum.hasCoeToFun.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b) i) b
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b) i) b
Case conversion may be inaccurate. Consider using '#align direct_sum.lof_apply DirectSum.lof_applyₓ'. -/
@[simp]
theorem lof_apply (i : ι) (b : M i) : ((lof R ι M i) b) i = b :=
  Dfinsupp.single_eq_same
#align direct_sum.lof_apply DirectSum.lof_apply

/- warning: direct_sum.component.lof_self -> DirectSum.component.lof_self is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ u3} (M i) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b)) b
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (a : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b)) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6193 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b)) b
Case conversion may be inaccurate. Consider using '#align direct_sum.component.lof_self DirectSum.component.lof_selfₓ'. -/
@[simp]
theorem component.lof_self (i : ι) (b : M i) : component R ι M i ((lof R ι M i) b) = b :=
  lof_apply R i b
#align direct_sum.component.lof_self DirectSum.component.lof_self

/- warning: direct_sum.component.of -> DirectSum.component.of is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.component.of DirectSum.component.ofₓ'. -/
theorem component.of (i j : ι) (b : M j) :
    component R ι M i ((lof R ι M j) b) = if h : j = i then Eq.recOn h b else 0 :=
  Dfinsupp.single_apply
#align direct_sum.component.of DirectSum.component.of

omit dec_ι

section CongrLeft

variable {κ : Type _}

#print DirectSum.lequivCongrLeft /-
/-- Reindexing terms of a direct sum is linear.-/
def lequivCongrLeft (h : ι ≃ κ) : (⨁ i, M i) ≃ₗ[R] ⨁ k, M (h.symm k) :=
  { equivCongrLeft h with map_smul' := Dfinsupp.comapDomain'_smul _ _ }
#align direct_sum.lequiv_congr_left DirectSum.lequivCongrLeft
-/

/- warning: direct_sum.lequiv_congr_left_apply -> DirectSum.lequivCongrLeft_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.lequiv_congr_left_apply DirectSum.lequivCongrLeft_applyₓ'. -/
@[simp]
theorem lequivCongrLeft_apply (h : ι ≃ κ) (f : ⨁ i, M i) (k : κ) :
    lequivCongrLeft R h f k = f (h.symm k) :=
  equivCongrLeft_apply _ _ _
#align direct_sum.lequiv_congr_left_apply DirectSum.lequivCongrLeft_apply

end CongrLeft

section Sigma

variable {α : ι → Type _} {δ : ∀ i, α i → Type w}

variable [∀ i j, AddCommMonoid (δ i j)] [∀ i j, Module R (δ i j)]

/- warning: direct_sum.sigma_lcurry -> DirectSum.sigmaLcurry is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)], LinearMap.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)], LinearMap.{u1, u1, max u3 u4 u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{max u4 u2, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (instAddCommMonoidDirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, max u3 u4} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_lcurry DirectSum.sigmaLcurryₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/-- `curry` as a linear map.-/
noncomputable def sigmaLcurry : (⨁ i : Σi, _, δ i.1 i.2) →ₗ[R] ⨁ (i) (j), δ i j :=
  { sigmaCurry with map_smul' := fun r => by convert@Dfinsupp.sigmaCurry_smul _ _ _ δ _ _ _ r }
#align direct_sum.sigma_lcurry DirectSum.sigmaLcurry

/- warning: direct_sum.sigma_lcurry_apply -> DirectSum.sigmaLcurry_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_lcurry_apply DirectSum.sigmaLcurry_applyₓ'. -/
@[simp]
theorem sigmaLcurry_apply (f : ⨁ i : Σi, _, δ i.1 i.2) (i : ι) (j : α i) :
    sigmaLcurry R f i j = f ⟨i, j⟩ :=
  sigmaCurry_apply f i j
#align direct_sum.sigma_lcurry_apply DirectSum.sigmaLcurry_apply

/- warning: direct_sum.sigma_luncurry -> DirectSum.sigmaLuncurry is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)] [_inst_8 : forall (i : ι), DecidableEq.{succ u4} (α i)] [_inst_9 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], LinearMap.{u1, u1, max u2 u4 u3, max (max u2 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)] [_inst_8 : forall (i : ι), DecidableEq.{succ u4} (α i)] [_inst_9 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], LinearMap.{u1, u1, max (max u3 u4) u2, max u3 u4 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.{max u4 u2, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (instAddCommMonoidDirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, max u3 u4} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)))
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_luncurry DirectSum.sigmaLuncurryₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/-- `uncurry` as a linear map.-/
def sigmaLuncurry [∀ i, DecidableEq (α i)] [∀ i j, DecidableEq (δ i j)] :
    (⨁ (i) (j), δ i j) →ₗ[R] ⨁ i : Σi, _, δ i.1 i.2 :=
  { sigmaUncurry with map_smul' := Dfinsupp.sigmaUncurry_smul }
#align direct_sum.sigma_luncurry DirectSum.sigmaLuncurry

/- warning: direct_sum.sigma_luncurry_apply -> DirectSum.sigmaLuncurry_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_luncurry_apply DirectSum.sigmaLuncurry_applyₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem sigmaLuncurry_apply [∀ i, DecidableEq (α i)] [∀ i j, DecidableEq (δ i j)]
    (f : ⨁ (i) (j), δ i j) (i : ι) (j : α i) : sigmaLuncurry R f ⟨i, j⟩ = f i j :=
  sigmaUncurry_apply f i j
#align direct_sum.sigma_luncurry_apply DirectSum.sigmaLuncurry_apply

/- warning: direct_sum.sigma_lcurry_equiv -> DirectSum.sigmaLcurryEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)] [_inst_8 : forall (i : ι), DecidableEq.{succ u4} (α i)] [_inst_9 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], LinearEquiv.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)] [_inst_8 : forall (i : ι), DecidableEq.{succ u4} (α i)] [_inst_9 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], LinearEquiv.{u1, u1, max u3 u4 u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{max u4 u2, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (instAddCommMonoidDirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, max u3 u4} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_lcurry_equiv DirectSum.sigmaLcurryEquivₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/-- `curry_equiv` as a linear equiv.-/
noncomputable def sigmaLcurryEquiv [∀ i, DecidableEq (α i)] [∀ i j, DecidableEq (δ i j)] :
    (⨁ i : Σi, _, δ i.1 i.2) ≃ₗ[R] ⨁ (i) (j), δ i j :=
  { sigmaCurryEquiv, sigmaLcurry R with }
#align direct_sum.sigma_lcurry_equiv DirectSum.sigmaLcurryEquiv

end Sigma

section Option

variable {α : Option ι → Type w} [∀ i, AddCommMonoid (α i)] [∀ i, Module R (α i)]

include dec_ι

/- warning: direct_sum.lequiv_prod_direct_sum -> DirectSum.lequivProdDirectSum is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {α : (Option.{u2} ι) -> Type.{u3}} [_inst_6 : forall (i : Option.{u2} ι), AddCommMonoid.{u3} (α i)] [_inst_7 : forall (i : Option.{u2} ι), Module.{u1, u3} R (α i) _inst_1 (_inst_6 i)], LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i)) (Prod.{u3, max u2 u3} (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)))) (DirectSum.addCommMonoid.{u2, u3} (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i)) (Prod.addCommMonoid.{u3, max u2 u3} (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) (_inst_6 (Option.none.{u2} ι)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)))) (DirectSum.module.{u1, u2, u3} R _inst_1 (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i) (fun (i : Option.{u2} ι) => _inst_7 i)) (Prod.module.{u1, u3, max u2 u3} R (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) _inst_1 (_inst_6 (Option.none.{u2} ι)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) (_inst_7 (Option.none.{u2} ι)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)) (fun (i : ι) => _inst_7 (Option.some.{u2} ι i))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {α : (Option.{u2} ι) -> Type.{u3}} [_inst_6 : forall (i : Option.{u2} ι), AddCommMonoid.{u3} (α i)] [_inst_7 : forall (i : Option.{u2} ι), Module.{u1, u3} R (α i) _inst_1 (_inst_6 i)], LinearEquiv.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i)) (Prod.{u3, max u3 u2} (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)))) (instAddCommMonoidDirectSum.{u2, u3} (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i)) (Prod.instAddCommMonoidSum.{u3, max u2 u3} (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) (_inst_6 (Option.none.{u2} ι)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i) (fun (i : Option.{u2} ι) => _inst_7 i)) (Prod.module.{u1, u3, max u2 u3} R (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) _inst_1 (_inst_6 (Option.none.{u2} ι)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) (_inst_7 (Option.none.{u2} ι)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)) (fun (i : ι) => _inst_7 (Option.some.{u2} ι i))))
Case conversion may be inaccurate. Consider using '#align direct_sum.lequiv_prod_direct_sum DirectSum.lequivProdDirectSumₓ'. -/
/-- Linear isomorphism obtained by separating the term of index `none` of a direct sum over
`option ι`.-/
@[simps]
noncomputable def lequivProdDirectSum : (⨁ i, α i) ≃ₗ[R] α none × ⨁ i, α (some i) :=
  { addEquivProdDirectSum with map_smul' := Dfinsupp.equivProdDfinsupp_smul }
#align direct_sum.lequiv_prod_direct_sum DirectSum.lequivProdDirectSum

end Option

end General

section Submodule

section Semiring

variable {R : Type u} [Semiring R]

variable {ι : Type v} [dec_ι : DecidableEq ι]

include dec_ι

variable {M : Type _} [AddCommMonoid M] [Module R M]

variable (A : ι → Submodule R M)

/- warning: direct_sum.coe_linear_map -> DirectSum.coeLinearMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] (A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)), LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) M (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_2 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) (fun (i : ι) => Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_3
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] (A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)), LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) M (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_2 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) (fun (i : ι) => Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_3
Case conversion may be inaccurate. Consider using '#align direct_sum.coe_linear_map DirectSum.coeLinearMapₓ'. -/
/-- The canonical embedding from `⨁ i, A i` to `M`  where `A` is a collection of `submodule R M`
indexed by `ι`. This is `direct_sum.coe_add_monoid_hom` as a `linear_map`. -/
def coeLinearMap : (⨁ i, A i) →ₗ[R] M :=
  toModule R ι M fun i => (A i).Subtype
#align direct_sum.coe_linear_map DirectSum.coeLinearMap

/- warning: direct_sum.coe_linear_map_of -> DirectSum.coeLinearMap_of is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.coe_linear_map_of DirectSum.coeLinearMap_ofₓ'. -/
@[simp]
theorem coeLinearMap_of (i : ι) (x : A i) : DirectSum.coeLinearMap A (of (fun i => A i) i x) = x :=
  toAddMonoid_of _ _ _
#align direct_sum.coe_linear_map_of DirectSum.coeLinearMap_of

variable {A}

/- warning: direct_sum.is_internal.submodule_supr_eq_top -> DirectSum.IsInternal.submodule_iSup_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)}, (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M _inst_1 _inst_2 _inst_3) A) -> (Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (iSup.{u3, succ u2} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u3} R M _inst_1 _inst_2 _inst_3))) ι A) (Top.top.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.hasTop.{u1, u3} R M _inst_1 _inst_2 _inst_3)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)}, (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M _inst_1 _inst_2 _inst_3) A) -> (Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (iSup.{u1, succ u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι A) (Top.top.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.instTopSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.submodule_supr_eq_top DirectSum.IsInternal.submodule_iSup_eq_topₓ'. -/
/-- If a direct sum of submodules is internal then the submodules span the module. -/
theorem IsInternal.submodule_iSup_eq_top (h : IsInternal A) : iSup A = ⊤ :=
  by
  rw [Submodule.iSup_eq_range_dfinsupp_lsum, LinearMap.range_eq_top]
  exact Function.Bijective.surjective h
#align direct_sum.is_internal.submodule_supr_eq_top DirectSum.IsInternal.submodule_iSup_eq_top

/- warning: direct_sum.is_internal.submodule_independent -> DirectSum.IsInternal.submodule_independent is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)}, (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M _inst_1 _inst_2 _inst_3) A) -> (CompleteLattice.Independent.{succ u2, u3} ι (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u3} R M _inst_1 _inst_2 _inst_3) A)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)}, (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M _inst_1 _inst_2 _inst_3) A) -> (CompleteLattice.Independent.{succ u3, u1} ι (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3) A)
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.submodule_independent DirectSum.IsInternal.submodule_independentₓ'. -/
/-- If a direct sum of submodules is internal then the submodules are independent. -/
theorem IsInternal.submodule_independent (h : IsInternal A) : CompleteLattice.Independent A :=
  CompleteLattice.independent_of_dfinsupp_lsum_injective _ h.Injective
#align direct_sum.is_internal.submodule_independent DirectSum.IsInternal.submodule_independent

#print DirectSum.IsInternal.collectedBasis /-
/-- Given an internal direct sum decomposition of a module `M`, and a basis for each of the
components of the direct sum, the disjoint union of these bases is a basis for `M`. -/
noncomputable def IsInternal.collectedBasis (h : IsInternal A) {α : ι → Type _}
    (v : ∀ i, Basis (α i) R (A i)) : Basis (Σi, α i) R M
    where repr :=
    ((LinearEquiv.ofBijective (DirectSum.coeLinearMap A) h).symm ≪≫ₗ
        Dfinsupp.mapRange.linearEquiv fun i => (v i).repr) ≪≫ₗ
      (sigmaFinsuppLequivDfinsupp R).symm
#align direct_sum.is_internal.collected_basis DirectSum.IsInternal.collectedBasis
-/

/- warning: direct_sum.is_internal.collected_basis_coe -> DirectSum.IsInternal.collectedBasis_coe is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.collected_basis_coe DirectSum.IsInternal.collectedBasis_coeₓ'. -/
@[simp]
theorem IsInternal.collectedBasis_coe (h : IsInternal A) {α : ι → Type _}
    (v : ∀ i, Basis (α i) R (A i)) : ⇑(h.collectedBasis v) = fun a : Σi, α i => ↑(v a.1 a.2) :=
  by
  funext a
  simp only [is_internal.collected_basis, to_module, coe_linear_map, [anonymous], Basis.coe_ofRepr,
    Basis.repr_symm_apply, Dfinsupp.lsum_apply_apply, Dfinsupp.mapRange.linearEquiv_apply,
    Dfinsupp.mapRange.linearEquiv_symm, Dfinsupp.mapRange_single, Finsupp.total_single,
    LinearEquiv.ofBijective_apply, LinearEquiv.symm_symm, LinearEquiv.symm_trans_apply, one_smul,
    sigmaFinsuppAddEquivDfinsupp_apply, sigmaFinsuppEquivDfinsupp_single,
    sigmaFinsuppLequivDfinsupp_apply]
  convert Dfinsupp.sumAddHom_single (fun i => (A i).Subtype.toAddMonoidHom) a.1 (v a.1 a.2)
#align direct_sum.is_internal.collected_basis_coe DirectSum.IsInternal.collectedBasis_coe

/- warning: direct_sum.is_internal.collected_basis_mem -> DirectSum.IsInternal.collectedBasis_mem is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.collected_basis_mem DirectSum.IsInternal.collectedBasis_memₓ'. -/
theorem IsInternal.collectedBasis_mem (h : IsInternal A) {α : ι → Type _}
    (v : ∀ i, Basis (α i) R (A i)) (a : Σi, α i) : h.collectedBasis v a ∈ A a.1 := by simp
#align direct_sum.is_internal.collected_basis_mem DirectSum.IsInternal.collectedBasis_mem

/- warning: direct_sum.is_internal.is_compl -> DirectSum.IsInternal.isCompl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)} {i : ι} {j : ι}, (Ne.{succ u2} ι i j) -> (Eq.{succ u2} (Set.{u2} ι) (Set.univ.{u2} ι) (Insert.insert.{u2, u2} ι (Set.{u2} ι) (Set.hasInsert.{u2} ι) i (Singleton.singleton.{u2, u2} ι (Set.{u2} ι) (Set.hasSingleton.{u2} ι) j))) -> (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M _inst_1 _inst_2 _inst_3) A) -> (IsCompl.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u3} R M _inst_1 _inst_2 _inst_3))) (CompleteLattice.toBoundedOrder.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i) (A j))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)} {i : ι} {j : ι}, (Ne.{succ u3} ι i j) -> (Eq.{succ u3} (Set.{u3} ι) (Set.univ.{u3} ι) (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.instInsertSet.{u3} ι) i (Singleton.singleton.{u3, u3} ι (Set.{u3} ι) (Set.instSingletonSet.{u3} ι) j))) -> (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M _inst_1 _inst_2 _inst_3) A) -> (IsCompl.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) (CompleteLattice.toBoundedOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3)) (A i) (A j))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.is_compl DirectSum.IsInternal.isComplₓ'. -/
/-- When indexed by only two distinct elements, `direct_sum.is_internal` implies
the two submodules are complementary. Over a `ring R`, this is true as an iff, as
`direct_sum.is_internal_iff_is_compl`. -/
theorem IsInternal.isCompl {A : ι → Submodule R M} {i j : ι} (hij : i ≠ j)
    (h : (Set.univ : Set ι) = {i, j}) (hi : IsInternal A) : IsCompl (A i) (A j) :=
  ⟨hi.submodule_independent.PairwiseDisjoint hij,
    codisjoint_iff.mpr <|
      Eq.symm <|
        hi.submodule_iSup_eq_top.symm.trans <| by
          rw [← sSup_pair, iSup, ← Set.image_univ, h, Set.image_insert_eq, Set.image_singleton]⟩
#align direct_sum.is_internal.is_compl DirectSum.IsInternal.isCompl

end Semiring

section Ring

variable {R : Type u} [Ring R]

variable {ι : Type v} [dec_ι : DecidableEq ι]

include dec_ι

variable {M : Type _} [AddCommGroup M] [Module R M]

/- warning: direct_sum.is_internal_submodule_of_independent_of_supr_eq_top -> DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : Module.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] {A : ι -> (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3)}, (CompleteLattice.Independent.{succ u2, u3} ι (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) A) -> (Eq.{succ u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (iSup.{u3, succ u2} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toHasSup.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3))) ι A) (Top.top.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.hasTop.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3))) -> (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Submodule.setLike.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) A)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {A : ι -> (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)}, (CompleteLattice.Independent.{succ u3, u1} ι (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) A) -> (Eq.{succ u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (iSup.{u1, succ u3} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))) ι A) (Top.top.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))) -> (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Submodule.setLike.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) A)
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal_submodule_of_independent_of_supr_eq_top DirectSum.isInternal_submodule_of_independent_of_iSup_eq_topₓ'. -/
/-- Note that this is not generally true for `[semiring R]`; see
`complete_lattice.independent.dfinsupp_lsum_injective` for details. -/
theorem isInternal_submodule_of_independent_of_iSup_eq_top {A : ι → Submodule R M}
    (hi : CompleteLattice.Independent A) (hs : iSup A = ⊤) : IsInternal A :=
  ⟨hi.dfinsupp_lsum_injective,
    LinearMap.range_eq_top.1 <| (Submodule.iSup_eq_range_dfinsupp_lsum _).symm.trans hs⟩
#align direct_sum.is_internal_submodule_of_independent_of_supr_eq_top DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top

/- warning: direct_sum.is_internal_submodule_iff_independent_and_supr_eq_top -> DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : Module.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (A : ι -> (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3)), Iff (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Submodule.setLike.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) A) (And (CompleteLattice.Independent.{succ u2, u3} ι (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) A) (Eq.{succ u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (iSup.{u3, succ u2} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toHasSup.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3))) ι A) (Top.top.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.hasTop.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (A : ι -> (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)), Iff (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Submodule.setLike.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) A) (And (CompleteLattice.Independent.{succ u3, u1} ι (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) A) (Eq.{succ u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (iSup.{u1, succ u3} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))) ι A) (Top.top.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal_submodule_iff_independent_and_supr_eq_top DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_topₓ'. -/
/-- `iff` version of `direct_sum.is_internal_submodule_of_independent_of_supr_eq_top`,
`direct_sum.is_internal.independent`, and `direct_sum.is_internal.supr_eq_top`.
-/
theorem isInternal_submodule_iff_independent_and_iSup_eq_top (A : ι → Submodule R M) :
    IsInternal A ↔ CompleteLattice.Independent A ∧ iSup A = ⊤ :=
  ⟨fun i => ⟨i.submodule_independent, i.submodule_iSup_eq_top⟩,
    And.ndrec isInternal_submodule_of_independent_of_iSup_eq_top⟩
#align direct_sum.is_internal_submodule_iff_independent_and_supr_eq_top DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top

/- warning: direct_sum.is_internal_submodule_iff_is_compl -> DirectSum.isInternal_submodule_iff_isCompl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : Module.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (A : ι -> (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3)) {i : ι} {j : ι}, (Ne.{succ u2} ι i j) -> (Eq.{succ u2} (Set.{u2} ι) (Set.univ.{u2} ι) (Insert.insert.{u2, u2} ι (Set.{u2} ι) (Set.hasInsert.{u2} ι) i (Singleton.singleton.{u2, u2} ι (Set.{u2} ι) (Set.hasSingleton.{u2} ι) j))) -> (Iff (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Submodule.setLike.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) A) (IsCompl.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3))) (CompleteLattice.toBoundedOrder.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3)) (A i) (A j)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (A : ι -> (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)) {i : ι} {j : ι}, (Ne.{succ u3} ι i j) -> (Eq.{succ u3} (Set.{u3} ι) (Set.univ.{u3} ι) (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.instInsertSet.{u3} ι) i (Singleton.singleton.{u3, u3} ι (Set.{u3} ι) (Set.instSingletonSet.{u3} ι) j))) -> (Iff (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Submodule.setLike.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) A) (IsCompl.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))) (CompleteLattice.toBoundedOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)) (A i) (A j)))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal_submodule_iff_is_compl DirectSum.isInternal_submodule_iff_isComplₓ'. -/
/-- If a collection of submodules has just two indices, `i` and `j`, then
`direct_sum.is_internal` is equivalent to `is_compl`. -/
theorem isInternal_submodule_iff_isCompl (A : ι → Submodule R M) {i j : ι} (hij : i ≠ j)
    (h : (Set.univ : Set ι) = {i, j}) : IsInternal A ↔ IsCompl (A i) (A j) :=
  by
  have : ∀ k, k = i ∨ k = j := fun k => by simpa using set.ext_iff.mp h k
  rw [is_internal_submodule_iff_independent_and_supr_eq_top, iSup, ← Set.image_univ, h,
    Set.image_insert_eq, Set.image_singleton, sSup_pair, CompleteLattice.independent_pair hij this]
  exact ⟨fun ⟨hd, ht⟩ => ⟨hd, codisjoint_iff.mpr ht⟩, fun ⟨hd, ht⟩ => ⟨hd, ht.eq_top⟩⟩
#align direct_sum.is_internal_submodule_iff_is_compl DirectSum.isInternal_submodule_iff_isCompl

/-! Now copy the lemmas for subgroup and submonoids. -/


/- warning: direct_sum.is_internal.add_submonoid_independent -> DirectSum.IsInternal.addSubmonoid_independent is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] {A : ι -> (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))}, (DirectSum.IsInternal.{u1, u2, u2} ι M (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (fun (a : ι) (b : ι) => dec_ι a b) _inst_4 (AddSubmonoid.setLike.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddSubmonoid.add_submonoidClass.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) A) -> (CompleteLattice.Independent.{succ u1, u2} ι (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddSubmonoid.completeLattice.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) A)
but is expected to have type
  forall {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u1}} [_inst_4 : AddCommMonoid.{u1} M] {A : ι -> (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4)))}, (DirectSum.IsInternal.{u2, u1, u1} ι M (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (fun (a : ι) (b : ι) => dec_ι a b) _inst_4 (AddSubmonoid.instSetLikeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (AddSubmonoid.instAddSubmonoidClassAddSubmonoidInstSetLikeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) A) -> (CompleteLattice.Independent.{succ u2, u1} ι (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) A)
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.add_submonoid_independent DirectSum.IsInternal.addSubmonoid_independentₓ'. -/
theorem IsInternal.addSubmonoid_independent {M : Type _} [AddCommMonoid M] {A : ι → AddSubmonoid M}
    (h : IsInternal A) : CompleteLattice.Independent A :=
  CompleteLattice.independent_of_dfinsupp_sumAddHom_injective _ h.Injective
#align direct_sum.is_internal.add_submonoid_independent DirectSum.IsInternal.addSubmonoid_independent

/- warning: direct_sum.is_internal.add_subgroup_independent -> DirectSum.IsInternal.addSubgroup_independent is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {M : Type.{u2}} [_inst_4 : AddCommGroup.{u2} M] {A : ι -> (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4))}, (DirectSum.IsInternal.{u1, u2, u2} ι M (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_4) (AddSubgroup.setLike.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) (AddSubgroupClass.to_addSubmonoidClass.{u2, u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) (AddSubgroup.setLike.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) (AddSubgroup.add_subgroupClass.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4))) A) -> (CompleteLattice.Independent.{succ u1, u2} ι (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) (AddSubgroup.completeLattice.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) A)
but is expected to have type
  forall {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u1}} [_inst_4 : AddCommGroup.{u1} M] {A : ι -> (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4))}, (DirectSum.IsInternal.{u2, u1, u1} ι M (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u1} M _inst_4) (AddSubgroup.instSetLikeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) (AddSubgroupClass.toAddSubmonoidClass.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) (AddSubgroup.instSetLikeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) (AddSubgroup.instAddSubgroupClassAddSubgroupToSubNegAddMonoidInstSetLikeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4))) A) -> (CompleteLattice.Independent.{succ u2, u1} ι (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) A)
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.add_subgroup_independent DirectSum.IsInternal.addSubgroup_independentₓ'. -/
theorem IsInternal.addSubgroup_independent {M : Type _} [AddCommGroup M] {A : ι → AddSubgroup M}
    (h : IsInternal A) : CompleteLattice.Independent A :=
  CompleteLattice.independent_of_dfinsupp_sumAddHom_injective' _ h.Injective
#align direct_sum.is_internal.add_subgroup_independent DirectSum.IsInternal.addSubgroup_independent

end Ring

end Submodule

end DirectSum

