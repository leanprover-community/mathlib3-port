/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau

! This file was ported from Lean 3 source module algebra.direct_sum.module
! leanprover-community/mathlib commit 932872382355f00112641d305ba0619305dc8642
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.DirectSum.Basic
import Mathbin.LinearAlgebra.Dfinsupp

/-!
# Direct sum of modules

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The first part of the file provides constructors for direct sums of modules. It provides a
construction of the direct sum using the universal property and proves its uniqueness
(`direct_sum.to_module.unique`).

The second part of the file covers the special case of direct sums of submodules of a fixed module
`M`.  There is a canonical linear map from this direct sum to `M` (`direct_sum.coe_linear_map`), and
the construction is of particular importance when this linear map is an equivalence; that is, when
the submodules provide an internal decomposition of `M`.  The property is defined more generally
elsewhere as `direct_sum.is_internal`, but its basic consequences on `submodule`s are established
in this file.

-/


universe u v w u₁

namespace DirectSum

open DirectSum

section General

variable {R : Type u} [Semiring R]

variable {ι : Type v} [dec_ι : DecidableEq ι]

include R

variable {M : ι → Type w} [∀ i, AddCommMonoid (M i)] [∀ i, Module R (M i)]

instance : Module R (⨁ i, M i) :=
  Dfinsupp.module

instance {S : Type _} [Semiring S] [∀ i, Module S (M i)] [∀ i, SMulCommClass R S (M i)] :
    SMulCommClass R S (⨁ i, M i) :=
  Dfinsupp.sMulCommClass

instance {S : Type _} [Semiring S] [SMul R S] [∀ i, Module S (M i)] [∀ i, IsScalarTower R S (M i)] :
    IsScalarTower R S (⨁ i, M i) :=
  Dfinsupp.isScalarTower

instance [∀ i, Module Rᵐᵒᵖ (M i)] [∀ i, IsCentralScalar R (M i)] : IsCentralScalar R (⨁ i, M i) :=
  Dfinsupp.isCentralScalar

/- warning: direct_sum.smul_apply -> DirectSum.smul_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (b : R) (v : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (i : ι), Eq.{succ u3} (M i) (coeFn.{succ (max u2 u3), max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), M i) (DirectSum.hasCoeToFun.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMul.smul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMulZeroClass.toHasSmul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (SMulWithZero.toSmulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (Module.toMulActionWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) b v) i) (SMul.smul.{u1, u3} R (M i) (SMulZeroClass.toHasSmul.{u1, u3} R (M i) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R (M i) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R (M i) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} R (M i) _inst_1 (_inst_2 i) (_inst_3 i))))) b (coeFn.{succ (max u2 u3), max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), M i) (DirectSum.hasCoeToFun.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) v i))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (b : R) (v : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (i : ι), Eq.{succ u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) (HSMul.hSMul.{u1, max u2 u3, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instHSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMulZeroClass.toSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (SMulWithZero.toSMulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (Module.toMulActionWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))))) b v) i) (HSMul.hSMul.{u1, u3, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (instHSMul.{u1, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (SMulZeroClass.toSMul.{u1, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u3} R ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) _inst_1 (_inst_2 i) (_inst_3 i)))))) b (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) v i))
Case conversion may be inaccurate. Consider using '#align direct_sum.smul_apply DirectSum.smul_applyₓ'. -/
theorem smul_apply (b : R) (v : ⨁ i, M i) (i : ι) : (b • v) i = b • v i :=
  Dfinsupp.smul_apply _ _ _
#align direct_sum.smul_apply DirectSum.smul_apply

include dec_ι

variable (R ι M)

/- warning: direct_sum.lmk -> DirectSum.lmk is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (s : Finset.{u2} ι), LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) R _inst_1 (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => _inst_3 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (s : Finset.{u2} ι), LinearMap.{u1, u1, max u2 u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) R _inst_1 (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => _inst_3 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
Case conversion may be inaccurate. Consider using '#align direct_sum.lmk DirectSum.lmkₓ'. -/
/-- Create the direct sum given a family `M` of `R` modules indexed over `ι`. -/
def lmk : ∀ s : Finset ι, (∀ i : (↑s : Set ι), M i.val) →ₗ[R] ⨁ i, M i :=
  Dfinsupp.lmk
#align direct_sum.lmk DirectSum.lmk

/- warning: direct_sum.lof -> DirectSum.lof is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι), LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι), LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
Case conversion may be inaccurate. Consider using '#align direct_sum.lof DirectSum.lofₓ'. -/
/-- Inclusion of each component into the direct sum. -/
def lof : ∀ i : ι, M i →ₗ[R] ⨁ i, M i :=
  Dfinsupp.lsingle
#align direct_sum.lof DirectSum.lof

/- warning: direct_sum.lof_eq_of -> DirectSum.lof_eq_of is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ (max u2 u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ u3) (succ (max u2 u3))} (AddMonoidHom.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (fun (_x : AddMonoidHom.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (AddMonoidHom.hasCoeToFun.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) i) b)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) b) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (AddHomClass.toFunLike.{max u2 u3, u3, max u2 u3} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddZeroClass.toAdd.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (AddZeroClass.toAdd.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u3, max u2 u3} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoidHom.addMonoidHomClass.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))))) (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) i) b)
Case conversion may be inaccurate. Consider using '#align direct_sum.lof_eq_of DirectSum.lof_eq_ofₓ'. -/
theorem lof_eq_of (i : ι) (b : M i) : lof R ι M i b = of M i b :=
  rfl
#align direct_sum.lof_eq_of DirectSum.lof_eq_of

variable {ι M}

/- warning: direct_sum.single_eq_lof -> DirectSum.single_eq_lof is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ (max u2 u3)} (Dfinsupp.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => M i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => M i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => M i) i) ((fun (i : ι) => (fun (i : ι) => _inst_2 i) i) i))))) (Dfinsupp.single.{u2, u3} ι (fun (i : ι) => M i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => M i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => M i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => M i) i) ((fun (i : ι) => (fun (i : ι) => _inst_2 i) i) i)))) i b) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{max (succ u2) (succ u3)} (Dfinsupp.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (Dfinsupp.single.{u2, u3} ι M (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) i b) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b)
Case conversion may be inaccurate. Consider using '#align direct_sum.single_eq_lof DirectSum.single_eq_lofₓ'. -/
theorem single_eq_lof (i : ι) (b : M i) : Dfinsupp.single i b = lof R ι M i b :=
  rfl
#align direct_sum.single_eq_lof DirectSum.single_eq_lof

/- warning: direct_sum.mk_smul -> DirectSum.mk_smul is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (s : Finset.{u2} ι) (c : R) (x : forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)), Eq.{succ (max u2 u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (AddMonoidHom.{max u2 u3, max u2 u3} (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addZeroClass.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) ((fun (i : ι) => _inst_2 i) (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (fun (_x : AddMonoidHom.{max u2 u3, max u2 u3} (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addZeroClass.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) ((fun (i : ι) => _inst_2 i) (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) => (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (AddMonoidHom.hasCoeToFun.{max u2 u3, max u2 u3} (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addZeroClass.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) ((fun (i : ι) => _inst_2 i) (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (DirectSum.mk.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) s) (SMul.smul.{u1, max u2 u3} R (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (Pi.instSMul.{u2, u3, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) R (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => SMulZeroClass.toHasSmul.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddZeroClass.toHasZero.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))))) (SMulWithZero.toSmulZeroClass.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))))) (MulActionWithZero.toSMulWithZero.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))))) (Module.toMulActionWithZero.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) _inst_1 (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (_inst_3 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))))))) c x)) (SMul.smul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (SMulZeroClass.toHasSmul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (SMulWithZero.toSmulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (Module.toMulActionWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => _inst_3 i)))))) c (coeFn.{succ (max u2 u3), succ (max u2 u3)} (AddMonoidHom.{max u2 u3, max u2 u3} (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addZeroClass.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) ((fun (i : ι) => _inst_2 i) (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (fun (_x : AddMonoidHom.{max u2 u3, max u2 u3} (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addZeroClass.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) ((fun (i : ι) => _inst_2 i) (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) => (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (AddMonoidHom.hasCoeToFun.{max u2 u3, max u2 u3} (forall (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addZeroClass.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i)) ((fun (i : ι) => _inst_2 i) (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (DirectSum.mk.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) s) x))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (s : Finset.{u2} ι) (c : R) (x : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (HSMul.hSMul.{u1, max u2 u3, max u2 u3} R (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (instHSMul.{u1, max u2 u3} R (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (Pi.instSMul.{u2, u3, u1} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) R (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => SMulZeroClass.toSMul.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddMonoid.toZero.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)))) (SMulWithZero.toSMulZeroClass.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)))) (Module.toMulActionWithZero.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) _inst_1 (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_3 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)))))))) c x)) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (AddMonoidHom.{max u2 u3, max u3 u2} (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (_x : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (AddHomClass.toFunLike.{max u2 u3, max u2 u3, max u2 u3} (AddMonoidHom.{max u2 u3, max u3 u2} (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddZeroClass.toAdd.{max u2 u3} (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)))))) (AddZeroClass.toAdd.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, max u2 u3, max u2 u3} (AddMonoidHom.{max u2 u3, max u3 u2} (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoidHom.addMonoidHomClass.{max u2 u3, max u2 u3} (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))))) (DirectSum.mk.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) s) (HSMul.hSMul.{u1, max u2 u3, max u2 u3} R (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (instHSMul.{u1, max u2 u3} R (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (Pi.instSMul.{u2, u3, u1} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) R (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => SMulZeroClass.toSMul.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddMonoid.toZero.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)))) (SMulWithZero.toSMulZeroClass.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)))) (Module.toMulActionWithZero.{u1, u3} R (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) _inst_1 (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_3 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)))))))) c x)) (HSMul.hSMul.{u1, max u2 u3, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (instHSMul.{u1, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (SMulZeroClass.toSMul.{u1, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (AddMonoid.toZero.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (AddCommMonoid.toAddMonoid.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (SMulWithZero.toSMulZeroClass.{u1, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (AddCommMonoid.toAddMonoid.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (AddCommMonoid.toAddMonoid.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (Module.toMulActionWithZero.{u1, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))))) c (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (AddMonoidHom.{max u2 u3, max u3 u2} (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (_x : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (AddHomClass.toFunLike.{max u2 u3, max u2 u3, max u2 u3} (AddMonoidHom.{max u2 u3, max u3 u2} (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddZeroClass.toAdd.{max u2 u3} (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)))))) (AddZeroClass.toAdd.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, max u2 u3, max u2 u3} (AddMonoidHom.{max u2 u3, max u3 u2} (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoidHom.addMonoidHomClass.{max u2 u3, max u2 u3} (forall (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)), M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addZeroClass.{u2, u3} (Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (fun (i : Set.Elem.{u2} ι (Finset.toSet.{u2} ι s)) => AddMonoid.toAddZeroClass.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (AddCommMonoid.toAddMonoid.{u3} (M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i)) (_inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x (Finset.toSet.{u2} ι s)) i))))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))))) (DirectSum.mk.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) s) x))
Case conversion may be inaccurate. Consider using '#align direct_sum.mk_smul DirectSum.mk_smulₓ'. -/
/-- Scalar multiplication commutes with direct sums. -/
theorem mk_smul (s : Finset ι) (c : R) (x) : mk M s (c • x) = c • mk M s x :=
  (lmk R ι M s).map_smul c x
#align direct_sum.mk_smul DirectSum.mk_smul

/- warning: direct_sum.of_smul -> DirectSum.of_smul is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (c : R) (x : M i), Eq.{succ (max u2 u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ u3) (succ (max u2 u3))} (AddMonoidHom.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (fun (_x : AddMonoidHom.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (AddMonoidHom.hasCoeToFun.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) i) (SMul.smul.{u1, u3} R (M i) (SMulZeroClass.toHasSmul.{u1, u3} R (M i) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R (M i) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R (M i) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (Module.toMulActionWithZero.{u1, u3} R (M i) _inst_1 (_inst_2 i) (_inst_3 i))))) c x)) (SMul.smul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (SMulZeroClass.toHasSmul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (SMulWithZero.toSmulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (Module.toMulActionWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => _inst_3 i)))))) c (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ u3) (succ (max u2 u3))} (AddMonoidHom.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (fun (_x : AddMonoidHom.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (AddMonoidHom.hasCoeToFun.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) ((fun (i : ι) => _inst_2 i) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))))) (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) i) x))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (c : R) (x : M i), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (HSMul.hSMul.{u1, u3, u3} R (M i) (M i) (instHSMul.{u1, u3} R (M i) (SMulZeroClass.toSMul.{u1, u3} R (M i) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u3} R (M i) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u3} R (M i) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u3} R (M i) _inst_1 (_inst_2 i) (_inst_3 i)))))) c x)) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (AddHomClass.toFunLike.{max u2 u3, u3, max u2 u3} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddZeroClass.toAdd.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (AddZeroClass.toAdd.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u3, max u2 u3} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoidHom.addMonoidHomClass.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))))) (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) i) (HSMul.hSMul.{u1, u3, u3} R (M i) (M i) (instHSMul.{u1, u3} R (M i) (SMulZeroClass.toSMul.{u1, u3} R (M i) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (SMulWithZero.toSMulZeroClass.{u1, u3} R (M i) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (MulActionWithZero.toSMulWithZero.{u1, u3} R (M i) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (Module.toMulActionWithZero.{u1, u3} R (M i) _inst_1 (_inst_2 i) (_inst_3 i)))))) c x)) (HSMul.hSMul.{u1, max u2 u3, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (instHSMul.{u1, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (SMulZeroClass.toSMul.{u1, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (AddMonoid.toZero.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (AddCommMonoid.toAddMonoid.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (SMulWithZero.toSMulZeroClass.{u1, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (AddCommMonoid.toAddMonoid.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (AddCommMonoid.toAddMonoid.{max u2 u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (Module.toMulActionWithZero.{u1, max u2 u3} R ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) x) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))))) c (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (AddHomClass.toFunLike.{max u2 u3, u3, max u2 u3} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddZeroClass.toAdd.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) (AddZeroClass.toAdd.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (AddMonoidHomClass.toAddHomClass.{max u2 u3, u3, max u2 u3} (AddMonoidHom.{u3, max u3 u2} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoidHom.addMonoidHomClass.{u3, max u2 u3} (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))))) (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) i) x))
Case conversion may be inaccurate. Consider using '#align direct_sum.of_smul DirectSum.of_smulₓ'. -/
/-- Scalar multiplication commutes with the inclusion of each component into the direct sum. -/
theorem of_smul (i : ι) (c : R) (x) : of M i (c • x) = c • of M i x :=
  (lof R ι M i).map_smul c x
#align direct_sum.of_smul DirectSum.of_smul

variable {R}

/- warning: direct_sum.support_smul -> DirectSum.support_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_4 : forall (i : ι) (x : M i), Decidable (Ne.{succ u3} (M i) x (OfNat.ofNat.{u3} (M i) 0 (OfNat.mk.{u3} (M i) 0 (Zero.zero.{u3} (M i) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))))))))] (c : R) (v : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)), HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.hasSubset.{u2} ι) (Dfinsupp.support.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => M i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => M i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => M i) i) ((fun (i : ι) => _inst_2 i) i)))) (fun (i : ι) (x : M i) => _inst_4 i x) (SMul.smul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMulZeroClass.toHasSmul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (SMulWithZero.toSmulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (Module.toMulActionWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) c v)) (Dfinsupp.support.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => M i) i) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => M i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => M i) i) ((fun (i : ι) => _inst_2 i) i)))) (fun (i : ι) (x : M i) => _inst_4 i x) v)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_4 : forall (i : ι) (x : M i), Decidable (Ne.{succ u3} (M i) x (OfNat.ofNat.{u3} (M i) 0 (Zero.toOfNat0.{u3} (M i) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))))))] (c : R) (v : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)), HasSubset.Subset.{u2} (Finset.{u2} ι) (Finset.instHasSubsetFinset.{u2} ι) (Dfinsupp.support.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) (fun (i : ι) (x : M i) => _inst_4 i x) (HSMul.hSMul.{u1, max u2 u3, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instHSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMulZeroClass.toSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (SMulWithZero.toSMulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (MulActionWithZero.toSMulWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (Module.toMulActionWithZero.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))))) c v)) (Dfinsupp.support.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) (fun (i : ι) (x : M i) => _inst_4 i x) v)
Case conversion may be inaccurate. Consider using '#align direct_sum.support_smul DirectSum.support_smulₓ'. -/
theorem support_smul [∀ (i : ι) (x : M i), Decidable (x ≠ 0)] (c : R) (v : ⨁ i, M i) :
    (c • v).support ⊆ v.support :=
  Dfinsupp.support_smul _ _
#align direct_sum.support_smul DirectSum.support_smul

variable {N : Type u₁} [AddCommMonoid N] [Module R N]

variable (φ : ∀ i, M i →ₗ[R] N)

variable (R ι N φ)

/- warning: direct_sum.to_module -> DirectSum.toModule is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (N : Type.{u4}) [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4], (forall (i : ι), LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5) -> (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (N : Type.{u4}) [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4], (forall (i : ι), LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5) -> (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5)
Case conversion may be inaccurate. Consider using '#align direct_sum.to_module DirectSum.toModuleₓ'. -/
/-- The linear map constructed using the universal property of the coproduct. -/
def toModule : (⨁ i, M i) →ₗ[R] N :=
  Dfinsupp.lsum ℕ φ
#align direct_sum.to_module DirectSum.toModule

/- warning: direct_sum.coe_to_module_eq_coe_to_add_monoid -> DirectSum.coe_toModule_eq_coe_toAddMonoid is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (N : Type.{u4}) [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4] (φ : forall (i : ι), LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5), Eq.{max (succ (max u2 u3)) (succ u4)} ((fun (_x : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) _inst_5) => (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> N) (DirectSum.toModule.{u1, u2, u3, u4} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) N _inst_4 _inst_5 φ)) (coeFn.{max (succ (max u2 u3)) (succ u4), max (succ (max u2 u3)) (succ u4)} (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) _inst_5) (fun (_x : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) _inst_5) => (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> N) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u4} R R (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.toModule.{u1, u2, u3, u4} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) N _inst_4 _inst_5 φ)) (coeFn.{max (succ u4) (succ (max u2 u3)), max (succ (max u2 u3)) (succ u4)} (AddMonoidHom.{max u2 u3, u4} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)))) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_4))) (fun (_x : AddMonoidHom.{max u2 u3, u4} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)))) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_4))) => (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> N) (AddMonoidHom.hasCoeToFun.{max u2 u3, u4} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)))) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_4))) (DirectSum.toAddMonoid.{u2, u3, u4} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) N _inst_4 (fun (i : ι) => LinearMap.toAddMonoidHom.{u1, u1, u3, u4} R R (M i) N _inst_1 _inst_1 (_inst_2 i) _inst_4 (_inst_3 i) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (N : Type.{u4}) [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4] (φ : forall (i : ι), LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5), Eq.{max (max (succ u4) (succ u2)) (succ u3)} (forall (a : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => N) a) (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u4} (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => N) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u4} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.toModule.{u1, u2, u3, u4} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) N _inst_4 _inst_5 φ)) (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u4} (AddMonoidHom.{max u3 u2, u4} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_4))) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => N) _x) (AddHomClass.toFunLike.{max (max u4 u2) u3, max u2 u3, u4} (AddMonoidHom.{max u3 u2, u4} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_4))) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (AddZeroClass.toAdd.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))))) (AddZeroClass.toAdd.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_4))) (AddMonoidHomClass.toAddHomClass.{max (max u4 u2) u3, max u2 u3, u4} (AddMonoidHom.{max u3 u2, u4} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_4))) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_4)) (AddMonoidHom.addMonoidHomClass.{max u2 u3, u4} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_4))))) (DirectSum.toAddMonoid.{u2, u3, u4} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) N _inst_4 (fun (i : ι) => LinearMap.toAddMonoidHom.{u1, u1, u3, u4} R R (M i) N _inst_1 _inst_1 (_inst_2 i) _inst_4 (_inst_3 i) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i))))
Case conversion may be inaccurate. Consider using '#align direct_sum.coe_to_module_eq_coe_to_add_monoid DirectSum.coe_toModule_eq_coe_toAddMonoidₓ'. -/
/-- Coproducts in the categories of modules and additive monoids commute with the forgetful functor
from modules to additive monoids. -/
theorem coe_toModule_eq_coe_toAddMonoid :
    (toModule R ι N φ : (⨁ i, M i) → N) = toAddMonoid fun i => (φ i).toAddMonoidHom :=
  rfl
#align direct_sum.coe_to_module_eq_coe_to_add_monoid DirectSum.coe_toModule_eq_coe_toAddMonoid

variable {ι N φ}

/- warning: direct_sum.to_module_lof -> DirectSum.toModule_lof is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {N : Type.{u4}} [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4] {φ : forall (i : ι), LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5} (i : ι) (x : M i), Eq.{succ u4} N (coeFn.{max (succ (max u2 u3)) (succ u4), max (succ (max u2 u3)) (succ u4)} (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) _inst_5) (fun (_x : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) _inst_5) => (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> N) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u4} R R (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.toModule.{u1, u2, u3, u4} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) N _inst_4 _inst_5 φ) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) x)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5) (fun (_x : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5) => (M i) -> N) (LinearMap.hasCoeToFun.{u1, u1, u3, u4} R R (M i) N _inst_1 _inst_1 (_inst_2 i) _inst_4 (_inst_3 i) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (φ i) x)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {N : Type.{u4}} [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4] {φ : forall (i : ι), LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5} (i : ι) (x : M i), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => N) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (a : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) x)) (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u4} (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => N) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u4} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.toModule.{u1, u2, u3, u4} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) N _inst_4 _inst_5 φ) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) x)) (FunLike.coe.{max (succ u4) (succ u3), succ u3, succ u4} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => N) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, u4} R R (M i) N _inst_1 _inst_1 (_inst_2 i) _inst_4 (_inst_3 i) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (φ i) x)
Case conversion may be inaccurate. Consider using '#align direct_sum.to_module_lof DirectSum.toModule_lofₓ'. -/
/-- The map constructed using the universal property gives back the original maps when
restricted to each component. -/
@[simp]
theorem toModule_lof (i) (x : M i) : toModule R ι N φ (lof R ι M i x) = φ i x :=
  toAddMonoid_of (fun i => (φ i).toAddMonoidHom) i x
#align direct_sum.to_module_lof DirectSum.toModule_lof

variable (ψ : (⨁ i, M i) →ₗ[R] N)

/- warning: direct_sum.to_module.unique -> DirectSum.toModule.unique is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {N : Type.{u4}} [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4] (ψ : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5) (f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)), Eq.{succ u4} N (coeFn.{max (succ (max u2 u3)) (succ u4), max (succ (max u2 u3)) (succ u4)} (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5) (fun (_x : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) -> N) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u4} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ψ f) (coeFn.{max (succ (max u2 u3)) (succ u4), max (succ (max u2 u3)) (succ u4)} (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) _inst_5) (fun (_x : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) _inst_5) => (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> N) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u4} R R (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) N _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => (fun (i : ι) => M i) i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.toModule.{u1, u2, u3, u4} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) N _inst_4 _inst_5 (fun (i : ι) => LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 _inst_1 (_inst_2 i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (_inst_3 i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ψ (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i))) f)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {N : Type.{u4}} [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4] (ψ : LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5) (f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => N) f) (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u4} (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => N) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u4} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ψ f) (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u4} (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => N) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u4} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.toModule.{u1, u2, u3, u4} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) N _inst_4 _inst_5 (fun (i : ι) => LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ψ (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i))) f)
Case conversion may be inaccurate. Consider using '#align direct_sum.to_module.unique DirectSum.toModule.uniqueₓ'. -/
/-- Every linear map from a direct sum agrees with the one obtained by applying
the universal property to each of its components. -/
theorem toModule.unique (f : ⨁ i, M i) : ψ f = toModule R ι N (fun i => ψ.comp <| lof R ι M i) f :=
  toAddMonoid.unique ψ.toAddMonoidHom f
#align direct_sum.to_module.unique DirectSum.toModule.unique

variable {ψ} {ψ' : (⨁ i, M i) →ₗ[R] N}

/- warning: direct_sum.linear_map_ext -> DirectSum.linearMap_ext is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {N : Type.{u4}} [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4] {{ψ : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5}} {{ψ' : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5}}, (forall (i : ι), Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 _inst_1 (_inst_2 i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (_inst_3 i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ψ (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i)) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 _inst_1 (_inst_2 i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (_inst_3 i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ψ' (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i))) -> (Eq.{max (succ (max u2 u3)) (succ u4)} (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5) ψ ψ')
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {N : Type.{u4}} [_inst_4 : AddCommMonoid.{u4} N] [_inst_5 : Module.{u1, u4} R N _inst_1 _inst_4] {{ψ : LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5}} {{ψ' : LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5}}, (forall (i : ι), Eq.{max (succ u4) (succ u3)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) N (_inst_2 i) _inst_4 (_inst_3 i) _inst_5) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ψ (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i)) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N _inst_1 _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) ψ' (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i))) -> (Eq.{max (max (succ u4) (succ u2)) (succ u3)} (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) N (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_4 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) _inst_5) ψ ψ')
Case conversion may be inaccurate. Consider using '#align direct_sum.linear_map_ext DirectSum.linearMap_extₓ'. -/
/-- Two `linear_map`s out of a direct sum are equal if they agree on the generators.

See note [partially-applied ext lemmas]. -/
@[ext]
theorem linearMap_ext ⦃ψ ψ' : (⨁ i, M i) →ₗ[R] N⦄
    (H : ∀ i, ψ.comp (lof R ι M i) = ψ'.comp (lof R ι M i)) : ψ = ψ' :=
  Dfinsupp.lhom_ext' H
#align direct_sum.linear_map_ext DirectSum.linearMap_ext

/- warning: direct_sum.lset_to_set -> DirectSum.lsetToSet is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (S : Set.{u2} ι) (T : Set.{u2} ι), (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.hasSubset.{u2} ι) S T) -> (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) => M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x S))))) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) => _inst_2 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x S))))) i))) (DirectSum.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) => M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x T))))) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) => _inst_2 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x T))))) i))) (DirectSum.addCommMonoid.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) => M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x S))))) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) => _inst_2 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x S))))) i))) (DirectSum.addCommMonoid.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) => M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x T))))) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) => _inst_2 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x T))))) i))) (DirectSum.module.{u1, u2, u3} R _inst_1 (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) => M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x S))))) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) => _inst_2 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x S))))) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) => _inst_3 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) S) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x S))))) i))) (DirectSum.module.{u1, u2, u3} R _inst_1 (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) => M ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x T))))) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) => _inst_2 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x T))))) i)) (fun (i : coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) => _inst_3 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} ι) Type.{u2} (Set.hasCoeToSort.{u2} ι) T) ι (coeSubtype.{succ u2} ι (fun (x : ι) => Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) x T))))) i))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (S : Set.{u2} ι) (T : Set.{u2} ι), (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) S T) -> (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} (Set.Elem.{u2} ι S) (fun (i : Set.Elem.{u2} ι S) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x S) i)) (fun (i : Set.Elem.{u2} ι S) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x S) i))) (DirectSum.{u2, u3} (Set.Elem.{u2} ι T) (fun (i : Set.Elem.{u2} ι T) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x T) i)) (fun (i : Set.Elem.{u2} ι T) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x T) i))) (instAddCommMonoidDirectSum.{u2, u3} (Set.Elem.{u2} ι S) (fun (i : Set.Elem.{u2} ι S) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x S) i)) (fun (i : Set.Elem.{u2} ι S) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x S) i))) (instAddCommMonoidDirectSum.{u2, u3} (Set.Elem.{u2} ι T) (fun (i : Set.Elem.{u2} ι T) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x T) i)) (fun (i : Set.Elem.{u2} ι T) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x T) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 (Set.Elem.{u2} ι S) (fun (i : Set.Elem.{u2} ι S) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x S) i)) (fun (i : Set.Elem.{u2} ι S) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x S) i)) (fun (i : Set.Elem.{u2} ι S) => _inst_3 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x S) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 (Set.Elem.{u2} ι T) (fun (i : Set.Elem.{u2} ι T) => M (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x T) i)) (fun (i : Set.Elem.{u2} ι T) => _inst_2 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x T) i)) (fun (i : Set.Elem.{u2} ι T) => _inst_3 (Subtype.val.{succ u2} ι (fun (x : ι) => Membership.mem.{u2, u2} ι (Set.{u2} ι) (Set.instMembershipSet.{u2} ι) x T) i))))
Case conversion may be inaccurate. Consider using '#align direct_sum.lset_to_set DirectSum.lsetToSetₓ'. -/
/-- The inclusion of a subset of the direct summands
into a larger subset of the direct summands, as a linear map.
-/
def lsetToSet (S T : Set ι) (H : S ⊆ T) : (⨁ i : S, M i) →ₗ[R] ⨁ i : T, M i :=
  toModule R _ _ fun i => lof R T (fun i : Subtype T => M i) ⟨i, H i.Prop⟩
#align direct_sum.lset_to_set DirectSum.lsetToSet

omit dec_ι

variable (ι M)

/- warning: direct_sum.linear_equiv_fun_on_fintype -> DirectSum.linearEquivFunOnFintype is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_6 : Fintype.{u2} ι], LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_6 : Fintype.{u2} ι], LinearEquiv.{u1, u1, max u3 u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))
Case conversion may be inaccurate. Consider using '#align direct_sum.linear_equiv_fun_on_fintype DirectSum.linearEquivFunOnFintypeₓ'. -/
/-- Given `fintype α`, `linear_equiv_fun_on_fintype R` is the natural `R`-linear equivalence
between `⨁ i, M i` and `Π i, M i`. -/
@[simps apply]
def linearEquivFunOnFintype [Fintype ι] : (⨁ i, M i) ≃ₗ[R] ∀ i, M i :=
  { Dfinsupp.equivFunOnFintype with
    toFun := coeFn
    map_add' := fun f g => by
      ext
      simp only [add_apply, Pi.add_apply]
    map_smul' := fun c f => by
      ext
      simp only [Dfinsupp.coe_smul, RingHom.id_apply] }
#align direct_sum.linear_equiv_fun_on_fintype DirectSum.linearEquivFunOnFintype

variable {ι M}

/- warning: direct_sum.linear_equiv_fun_on_fintype_lof -> DirectSum.linearEquivFunOnFintype_lof is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_6 : Fintype.{u2} ι] [_inst_7 : DecidableEq.{succ u2} ι] (i : ι) (m : M i), Eq.{max (succ u2) (succ u3)} (forall (i : ι), M i) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (forall (i : ι), M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (forall (i : ι), M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (forall (i : ι), M i)) (LinearEquiv.hasCoeToFun.{u1, u1, max u2 u3, max u2 u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (forall (i : ι), M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (DirectSum.linearEquivFunOnFintype.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) _inst_6) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => _inst_7 a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) m)) (Pi.single.{u2, u3} ι (fun (i : ι) => M i) (fun (a : ι) (b : ι) => _inst_7 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) i m)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_6 : Fintype.{u2} ι] [_inst_7 : DecidableEq.{succ u2} ι] (i : ι) (m : M i), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), M i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (a : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => _inst_7 a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) m)) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, max u3 u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), M i) _x) (SMulHomClass.toFunLike.{max u2 u3, u1, max u2 u3, max u2 u3} (LinearEquiv.{u1, u1, max u3 u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (SMulZeroClass.toSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribSMul.toSMulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribMulAction.toDistribSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) (SMulZeroClass.toSMul.{u1, max u2 u3} R (forall (i : ι), M i) (AddMonoid.toZero.{max u2 u3} (forall (i : ι), M i) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribSMul.toSMulZeroClass.{u1, max u2 u3} R (forall (i : ι), M i) (AddMonoid.toAddZeroClass.{max u2 u3} (forall (i : ι), M i) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribMulAction.toDistribSMul.{u1, max u2 u3} R (forall (i : ι), M i) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (forall (i : ι), M i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, max u2 u3, max u2 u3} (LinearEquiv.{u1, u1, max u3 u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (forall (i : ι), M i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (SemilinearMapClass.distribMulActionHomClass.{u1, max u2 u3, max u2 u3, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (LinearEquiv.{u1, u1, max u3 u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max u2 u3, max u2 u3, max u2 u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (LinearEquiv.{u1, u1, max u3 u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (DirectSum.linearEquivFunOnFintype.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) _inst_6) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => _inst_7 a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) m)) (Pi.single.{u2, u3} ι M (fun (a : ι) (b : ι) => _inst_7 a b) (fun (i : ι) => AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) i m)
Case conversion may be inaccurate. Consider using '#align direct_sum.linear_equiv_fun_on_fintype_lof DirectSum.linearEquivFunOnFintype_lofₓ'. -/
@[simp]
theorem linearEquivFunOnFintype_lof [Fintype ι] [DecidableEq ι] (i : ι) (m : M i) :
    (linearEquivFunOnFintype R ι M) (lof R ι M i m) = Pi.single i m :=
  by
  ext a
  change (Dfinsupp.equivFunOnFintype (lof R ι M i m)) a = _
  convert _root_.congr_fun (Dfinsupp.equivFunOnFintype_single i m) a
#align direct_sum.linear_equiv_fun_on_fintype_lof DirectSum.linearEquivFunOnFintype_lof

/- warning: direct_sum.linear_equiv_fun_on_fintype_symm_single -> DirectSum.linearEquivFunOnFintype_symm_single is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_6 : Fintype.{u2} ι] [_inst_7 : DecidableEq.{succ u2} ι] (i : ι) (m : M i), Eq.{succ (max u2 u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (forall (i : ι), M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearEquiv.hasCoeToFun.{u1, u1, max u2 u3, max u2 u3} R R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.symm.{u1, u1, max u2 u3, max u2 u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (forall (i : ι), M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.linearEquivFunOnFintype.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) _inst_6)) (Pi.single.{u2, u3} ι (fun (i : ι) => M i) (fun (a : ι) (b : ι) => _inst_7 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i)))) i m)) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => _inst_7 a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) m)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_6 : Fintype.{u2} ι] [_inst_7 : DecidableEq.{succ u2} ι] (i : ι) (m : M i), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : forall (i : ι), M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.single.{u2, u3} ι (fun (i : ι) => M i) (fun (a : ι) (b : ι) => _inst_7 a b) (fun (i : ι) => AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) i m)) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (forall (i : ι), M i) (fun (_x : forall (i : ι), M i) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : forall (i : ι), M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (SMulHomClass.toFunLike.{max u2 u3, u1, max u2 u3, max u2 u3} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMulZeroClass.toSMul.{u1, max u2 u3} R (forall (i : ι), M i) (AddMonoid.toZero.{max u2 u3} (forall (i : ι), M i) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribSMul.toSMulZeroClass.{u1, max u2 u3} R (forall (i : ι), M i) (AddMonoid.toAddZeroClass.{max u2 u3} (forall (i : ι), M i) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribMulAction.toDistribSMul.{u1, max u2 u3} R (forall (i : ι), M i) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (forall (i : ι), M i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) (SMulZeroClass.toSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribSMul.toSMulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribMulAction.toDistribSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, max u2 u3, max u2 u3} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (forall (i : ι), M i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (SemilinearMapClass.distribMulActionHomClass.{u1, max u2 u3, max u2 u3, max u2 u3} R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max u2 u3, max u2 u3, max u2 u3} R R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, max u2 u3, max u2 u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.linearEquivFunOnFintype.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) _inst_6)) (Pi.single.{u2, u3} ι (fun (i : ι) => M i) (fun (a : ι) (b : ι) => _inst_7 a b) (fun (i : ι) => AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))) i m)) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => _inst_7 a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) m)
Case conversion may be inaccurate. Consider using '#align direct_sum.linear_equiv_fun_on_fintype_symm_single DirectSum.linearEquivFunOnFintype_symm_singleₓ'. -/
@[simp]
theorem linearEquivFunOnFintype_symm_single [Fintype ι] [DecidableEq ι] (i : ι) (m : M i) :
    (linearEquivFunOnFintype R ι M).symm (Pi.single i m) = lof R ι M i m :=
  by
  ext a
  change (dfinsupp.equiv_fun_on_fintype.symm (Pi.single i m)) a = _
  rw [Dfinsupp.equivFunOnFintype_symm_single i m]
  rfl
#align direct_sum.linear_equiv_fun_on_fintype_symm_single DirectSum.linearEquivFunOnFintype_symm_single

/- warning: direct_sum.linear_equiv_fun_on_fintype_symm_coe -> DirectSum.linearEquivFunOnFintype_symm_coe is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_6 : Fintype.{u2} ι] (f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)), Eq.{succ (max u2 u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (forall (i : ι), M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearEquiv.hasCoeToFun.{u1, u1, max u2 u3, max u2 u3} R R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.symm.{u1, u1, max u2 u3, max u2 u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (forall (i : ι), M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.linearEquivFunOnFintype.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) _inst_6)) (coeFn.{succ (max u2 u3), max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), M i) (DirectSum.hasCoeToFun.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f)) f
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] [_inst_6 : Fintype.{u2} ι] (f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : forall (i : ι), M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (a : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) a) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) f)) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (forall (i : ι), M i) (fun (_x : forall (i : ι), M i) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : forall (i : ι), M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (SMulHomClass.toFunLike.{max u2 u3, u1, max u2 u3, max u2 u3} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (SMulZeroClass.toSMul.{u1, max u2 u3} R (forall (i : ι), M i) (AddMonoid.toZero.{max u2 u3} (forall (i : ι), M i) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribSMul.toSMulZeroClass.{u1, max u2 u3} R (forall (i : ι), M i) (AddMonoid.toAddZeroClass.{max u2 u3} (forall (i : ι), M i) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribMulAction.toDistribSMul.{u1, max u2 u3} R (forall (i : ι), M i) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (forall (i : ι), M i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) (SMulZeroClass.toSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toZero.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribSMul.toSMulZeroClass.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribMulAction.toDistribSMul.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, max u2 u3, max u2 u3} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u3} (forall (i : ι), M i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (forall (i : ι), M i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Module.toDistribMulAction.{u1, max u2 u3} R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (SemilinearMapClass.distribMulActionHomClass.{u1, max u2 u3, max u2 u3, max u2 u3} R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max u2 u3, max u2 u3, max u2 u3} R R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R (forall (i : ι), M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, max u2 u3, max u2 u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (forall (i : ι), M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => M i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.linearEquivFunOnFintype.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) _inst_6)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) f)) f
Case conversion may be inaccurate. Consider using '#align direct_sum.linear_equiv_fun_on_fintype_symm_coe DirectSum.linearEquivFunOnFintype_symm_coeₓ'. -/
@[simp]
theorem linearEquivFunOnFintype_symm_coe [Fintype ι] (f : ⨁ i, M i) :
    (linearEquivFunOnFintype R ι M).symm f = f :=
  by
  ext
  simp [linear_equiv_fun_on_fintype]
#align direct_sum.linear_equiv_fun_on_fintype_symm_coe DirectSum.linearEquivFunOnFintype_symm_coe

/- warning: direct_sum.lid -> DirectSum.lid is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (M : Type.{u2}) (ι : optParam.{succ (succ u3)} Type.{u3} PUnit.{succ u3}) [_inst_6 : AddCommMonoid.{u2} M] [_inst_7 : Module.{u1, u2} R M _inst_1 _inst_6] [_inst_8 : Unique.{succ u3} ι], LinearEquiv.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u3, u2} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6)) M (DirectSum.addCommMonoid.{u3, u2} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6)) _inst_6 (DirectSum.module.{u1, u3, u2} R _inst_1 ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6) (fun (i : ι) => _inst_7)) _inst_7
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (M : Type.{u2}) (ι : optParam.{succ (succ u3)} Type.{u3} PUnit.{succ u3}) [_inst_6 : AddCommMonoid.{u2} M] [_inst_7 : Module.{u1, u2} R M _inst_1 _inst_6] [_inst_8 : Unique.{succ u3} ι], LinearEquiv.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u3, u2} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6)) M (instAddCommMonoidDirectSum.{u3, u2} ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6)) _inst_6 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u3, u2} R _inst_1 ι (fun (_x : ι) => M) (fun (i : ι) => _inst_6) (fun (i : ι) => _inst_7)) _inst_7
Case conversion may be inaccurate. Consider using '#align direct_sum.lid DirectSum.lidₓ'. -/
/-- The natural linear equivalence between `⨁ _ : ι, M` and `M` when `unique ι`. -/
protected def lid (M : Type v) (ι : Type _ := PUnit) [AddCommMonoid M] [Module R M] [Unique ι] :
    (⨁ _ : ι, M) ≃ₗ[R] M :=
  { DirectSum.id M ι, toModule R ι M fun i => LinearMap.id with }
#align direct_sum.lid DirectSum.lid

variable (ι M)

/- warning: direct_sum.component -> DirectSum.component is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι), LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (ι : Type.{u2}) (M : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι), LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)
Case conversion may be inaccurate. Consider using '#align direct_sum.component DirectSum.componentₓ'. -/
/-- The projection map onto one component, as a linear map. -/
def component (i : ι) : (⨁ i, M i) →ₗ[R] M i :=
  Dfinsupp.lapply i
#align direct_sum.component DirectSum.component

variable {ι M}

/- warning: direct_sum.apply_eq_component -> DirectSum.apply_eq_component is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (i : ι), Eq.{succ u3} (M i) (coeFn.{succ (max u2 u3), max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), M i) (DirectSum.hasCoeToFun.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f i) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (i : ι), Eq.{succ u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) f i) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f)
Case conversion may be inaccurate. Consider using '#align direct_sum.apply_eq_component DirectSum.apply_eq_componentₓ'. -/
theorem apply_eq_component (f : ⨁ i, M i) (i : ι) : f i = component R ι M i f :=
  rfl
#align direct_sum.apply_eq_component DirectSum.apply_eq_component

/- warning: direct_sum.ext -> DirectSum.ext is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)} {g : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)}, (forall (i : ι), Eq.{succ u3} (M i) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) g)) -> (Eq.{succ (max u2 u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f g)
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)} {g : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)}, (forall (i : ι), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) f) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) g)) -> (Eq.{max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f g)
Case conversion may be inaccurate. Consider using '#align direct_sum.ext DirectSum.extₓ'. -/
@[ext]
theorem ext {f g : ⨁ i, M i} (h : ∀ i, component R ι M i f = component R ι M i g) : f = g :=
  Dfinsupp.ext h
#align direct_sum.ext DirectSum.ext

/- warning: direct_sum.ext_iff -> DirectSum.ext_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)} {g : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)}, Iff (Eq.{succ (max u2 u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f g) (forall (i : ι), Eq.{succ u3} (M i) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) g))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)} {g : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)}, Iff (Eq.{max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f g) (forall (i : ι), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) f) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) f) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) g))
Case conversion may be inaccurate. Consider using '#align direct_sum.ext_iff DirectSum.ext_iffₓ'. -/
theorem ext_iff {f g : ⨁ i, M i} : f = g ↔ ∀ i, component R ι M i f = component R ι M i g :=
  ⟨fun h _ => by rw [h], ext R⟩
#align direct_sum.ext_iff DirectSum.ext_iff

include dec_ι

/- warning: direct_sum.lof_apply -> DirectSum.lof_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ u3} (M i) (coeFn.{succ (max u2 u3), max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) => forall (i : ι), M i) (DirectSum.hasCoeToFun.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b) i) b
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Dfinsupp.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) _x) (Dfinsupp.funLike.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b) i) b
Case conversion may be inaccurate. Consider using '#align direct_sum.lof_apply DirectSum.lof_applyₓ'. -/
@[simp]
theorem lof_apply (i : ι) (b : M i) : ((lof R ι M i) b) i = b :=
  Dfinsupp.single_eq_same
#align direct_sum.lof_apply DirectSum.lof_apply

/- warning: direct_sum.component.lof_self -> DirectSum.component.lof_self is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ u3} (M i) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M i) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b)) b
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (b : M i), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (a : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b)) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M i) (fun (_x : M i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M i) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M i) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) b)) b
Case conversion may be inaccurate. Consider using '#align direct_sum.component.lof_self DirectSum.component.lof_selfₓ'. -/
@[simp]
theorem component.lof_self (i : ι) (b : M i) : component R ι M i ((lof R ι M i) b) = b :=
  lof_apply R i b
#align direct_sum.component.lof_self DirectSum.component.lof_self

/- warning: direct_sum.component.of -> DirectSum.component.of is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (j : ι) (b : M j), Eq.{succ u3} (M i) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i)) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) -> (M i)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) (M i) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) i) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) ((fun (i : ι) => _inst_3 i) i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) j) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) j) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_2 i) j) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) j) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (M j) -> (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i))) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) j) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) j) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) j) b)) (dite.{succ u3} (M i) (Eq.{succ u2} ι j i) (dec_ι j i) (fun (h : Eq.{succ u2} ι j i) => Eq.recOn.{succ u3, succ u2} ι j (fun (_x : ι) => M _x) i h b) (fun (h : Not (Eq.{succ u2} ι j i)) => OfNat.ofNat.{u3} (M i) 0 (OfNat.mk.{u3} (M i) 0 (Zero.zero.{u3} (M i) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (_inst_2 i))))))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] (i : ι) (j : ι) (b : M j), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M j) (fun (a : M j) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M j) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) j) b)) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (M i) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.component.{u1, u2, u3} R _inst_1 ι M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M j) (fun (_x : M j) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M j) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) j) b)) (dite.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M j) (fun (a : M j) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M j) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) j) b)) (Eq.{succ u2} ι j i) (dec_ι j i) (fun (h : Eq.{succ u2} ι j i) => Eq.recOn.{succ u3, succ u2} ι j (fun (_x : ι) (x._@.Mathlib.Algebra.DirectSum.Module._hyg.4825 : Eq.{succ u2} ι j _x) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M _x) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M j) (fun (a : M j) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M j) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) j) b)) i h b) (fun (h : Not (Eq.{succ u2} ι j i)) => OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M j) (fun (a : M j) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M j) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) j) b)) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M j) (fun (a : M j) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M j) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) j) b)) (AddMonoid.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M j) (fun (a : M j) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M j) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) j) b)) (AddCommMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => M i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (M j) (fun (a : M j) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : M j) => DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (M j) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 _inst_1 (_inst_2 j) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (_inst_3 j) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.lof.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) j) b)) (_inst_2 i))))))
Case conversion may be inaccurate. Consider using '#align direct_sum.component.of DirectSum.component.ofₓ'. -/
theorem component.of (i j : ι) (b : M j) :
    component R ι M i ((lof R ι M j) b) = if h : j = i then Eq.recOn h b else 0 :=
  Dfinsupp.single_apply
#align direct_sum.component.of DirectSum.component.of

omit dec_ι

section CongrLeft

variable {κ : Type _}

#print DirectSum.lequivCongrLeft /-
/-- Reindexing terms of a direct sum is linear.-/
def lequivCongrLeft (h : ι ≃ κ) : (⨁ i, M i) ≃ₗ[R] ⨁ k, M (h.symm k) :=
  { equivCongrLeft h with map_smul' := Dfinsupp.comapDomain'_smul _ _ }
#align direct_sum.lequiv_congr_left DirectSum.lequivCongrLeft
-/

/- warning: direct_sum.lequiv_congr_left_apply -> DirectSum.lequivCongrLeft_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {M : ι -> Type.{u3}} [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (M i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (M i) _inst_1 (_inst_2 i)] {κ : Type.{u4}} (h : Equiv.{succ u2, succ u4} ι κ) (f : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (k : κ), Eq.{succ u3} (M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (coeFn.{succ (max u4 u3), max (succ u4) (succ u3)} (DirectSum.{u4, u3} κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i))) (fun (_x : DirectSum.{u4, u3} κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i))) => forall (i : κ), M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i)) (DirectSum.hasCoeToFun.{u4, u3} κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i))) (coeFn.{max (succ (max u2 u3)) (succ (max u4 u3)), max (succ (max u2 u3)) (succ (max u4 u3))} (LinearEquiv.{u1, u1, max u2 u3, max u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u4, u3} κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i))) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u4, u3} κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i))) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.module.{u1, u4, u3} R _inst_1 κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i)) (fun (i : κ) => _inst_3 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i)))) (fun (_x : LinearEquiv.{u1, u1, max u2 u3, max u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u4, u3} κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i))) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u4, u3} κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i))) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.module.{u1, u4, u3} R _inst_1 κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i)) (fun (i : κ) => _inst_3 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i)))) => (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) -> (DirectSum.{u4, u3} κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i)))) (LinearEquiv.hasCoeToFun.{u1, u1, max u2 u3, max u4 u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u4, u3} κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i))) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.addCommMonoid.{u4, u3} κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i))) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.module.{u1, u4, u3} R _inst_1 κ (fun (k : κ) => M (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k)) (fun (i : κ) => _inst_2 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i)) (fun (i : κ) => _inst_3 (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) i))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (DirectSum.lequivCongrLeft.{u1, u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) κ h) f) k) (coeFn.{succ (max u2 u3), max (succ u2) (succ u3)} (DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => forall (i : ι), M i) (DirectSum.hasCoeToFun.{u2, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) f (coeFn.{max 1 (max (succ u4) (succ u2)) (succ u2) (succ u4), max (succ u4) (succ u2)} (Equiv.{succ u4, succ u2} κ ι) (fun (_x : Equiv.{succ u4, succ u2} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u4, succ u2} κ ι) (Equiv.symm.{succ u2, succ u4} ι κ h) k))
but is expected to have type
  forall (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] {ι : Type.{u3}} {M : ι -> Type.{u4}} [_inst_2 : forall (i : ι), AddCommMonoid.{u4} (M i)] [_inst_3 : forall (i : ι), Module.{u2, u4} R (M i) _inst_1 (_inst_2 i)] {κ : Type.{u1}} (h : Equiv.{succ u3, succ u1} ι κ) (f : DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (k : κ), Eq.{succ u4} ((fun (i : κ) => (fun (i : κ) => (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) i) i) k) (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (Dfinsupp.{u1, u4} κ (fun (i : κ) => (fun (i : κ) => (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) i) i) (fun (i : κ) => (fun (i : κ) => AddMonoid.toZero.{u4} ((fun (i : κ) => (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) i) i) (AddCommMonoid.toAddMonoid.{u4} ((fun (i : κ) => (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) i) i) ((fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) i))) i)) κ (fun (_x : κ) => (fun (i : κ) => (fun (i : κ) => (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) i) i) _x) (Dfinsupp.funLike.{u1, u4} κ (fun (k : κ) => (fun (i : κ) => (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) i) k) (fun (i : κ) => (fun (i : κ) => AddMonoid.toZero.{u4} ((fun (i : κ) => (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) i) i) (AddCommMonoid.toAddMonoid.{u4} ((fun (i : κ) => (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) i) i) ((fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) i))) i)) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u4), max (succ u3) (succ u4), max (succ u1) (succ u4)} (LinearEquiv.{u2, u2, max u4 u3, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) (fun (i : κ) => _inst_3 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)))) (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (fun (_x : DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) => DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) _x) (SMulHomClass.toFunLike.{max (max u3 u1) u4, u2, max u3 u4, max u1 u4} (LinearEquiv.{u2, u2, max u4 u3, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) (fun (i : κ) => _inst_3 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)))) R (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (SMulZeroClass.toSMul.{u2, max u3 u4} R (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toZero.{max u3 u4} (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u3 u4} (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribSMul.toSMulZeroClass.{u2, max u3 u4} R (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddMonoid.toAddZeroClass.{max u3 u4} (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (AddCommMonoid.toAddMonoid.{max u3 u4} (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)))) (DistribMulAction.toDistribSMul.{u2, max u3 u4} R (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u3 u4} (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (Module.toDistribMulAction.{u2, max u3 u4} R (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)))))) (SMulZeroClass.toSMul.{u2, max u1 u4} R (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (AddMonoid.toZero.{max u1 u4} (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (AddCommMonoid.toAddMonoid.{max u1 u4} (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))))) (DistribSMul.toSMulZeroClass.{u2, max u1 u4} R (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (AddMonoid.toAddZeroClass.{max u1 u4} (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (AddCommMonoid.toAddMonoid.{max u1 u4} (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))))) (DistribMulAction.toDistribSMul.{u2, max u1 u4} R (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u1 u4} (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)))) (Module.toDistribMulAction.{u2, max u1 u4} R (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) _inst_1 (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) (fun (i : κ) => _inst_3 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u1) u4, u2, max u3 u4, max u1 u4} (LinearEquiv.{u2, u2, max u4 u3, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) (fun (i : κ) => _inst_3 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)))) R (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u3 u4} (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i))) (AddCommMonoid.toAddMonoid.{max u1 u4} (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)))) (Module.toDistribMulAction.{u2, max u3 u4} R (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) _inst_1 (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Module.toDistribMulAction.{u2, max u1 u4} R (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) _inst_1 (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) (fun (i : κ) => _inst_3 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)))) (SemilinearMapClass.distribMulActionHomClass.{u2, max u3 u4, max u1 u4, max (max u3 u1) u4} R (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (LinearEquiv.{u2, u2, max u4 u3, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) (fun (i : κ) => _inst_3 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)))) _inst_1 (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) (fun (i : κ) => _inst_3 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, max u3 u4, max u1 u4, max (max u3 u1) u4} R R (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (LinearEquiv.{u2, u2, max u4 u3, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) (fun (i : κ) => _inst_3 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)))) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) (fun (i : κ) => _inst_3 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, max u3 u4, max u1 u4} R R (DirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (DirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u3, u4} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i)) (instAddCommMonoidDirectSum.{u1, u4} κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u4} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 κ (fun (k : κ) => M (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k)) (fun (i : κ) => _inst_2 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i)) (fun (i : κ) => _inst_3 (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (a : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) a) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) i))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)))))) (DirectSum.lequivCongrLeft.{u2, u3, u4, u1} R _inst_1 ι (fun (i : ι) => M i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) κ h) f) k) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (Dfinsupp.{u3, u4} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u4} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u4} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) _x) (Dfinsupp.funLike.{u3, u4} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{u4} ((fun (i : ι) => (fun (i : ι) => M i) i) i) (AddCommMonoid.toAddMonoid.{u4} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => _inst_2 i) i))) i)) f (FunLike.coe.{max (succ u3) (succ u1), succ u1, succ u3} (Equiv.{succ u1, succ u3} κ ι) κ (fun (_x : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u3} κ ι) (Equiv.symm.{succ u3, succ u1} ι κ h) k))
Case conversion may be inaccurate. Consider using '#align direct_sum.lequiv_congr_left_apply DirectSum.lequivCongrLeft_applyₓ'. -/
@[simp]
theorem lequivCongrLeft_apply (h : ι ≃ κ) (f : ⨁ i, M i) (k : κ) :
    lequivCongrLeft R h f k = f (h.symm k) :=
  equivCongrLeft_apply _ _ _
#align direct_sum.lequiv_congr_left_apply DirectSum.lequivCongrLeft_apply

end CongrLeft

section Sigma

variable {α : ι → Type _} {δ : ∀ i, α i → Type w}

variable [∀ i j, AddCommMonoid (δ i j)] [∀ i j, Module R (δ i j)]

/- warning: direct_sum.sigma_lcurry -> DirectSum.sigmaLcurry is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)], LinearMap.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)], LinearMap.{u1, u1, max u3 u4 u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{max u4 u2, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (instAddCommMonoidDirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, max u3 u4} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_lcurry DirectSum.sigmaLcurryₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/-- `curry` as a linear map.-/
noncomputable def sigmaLcurry : (⨁ i : Σi, _, δ i.1 i.2) →ₗ[R] ⨁ (i) (j), δ i j :=
  { sigmaCurry with map_smul' := fun r => by convert@Dfinsupp.sigmaCurry_smul _ _ _ δ _ _ _ r }
#align direct_sum.sigma_lcurry DirectSum.sigmaLcurry

/- warning: direct_sum.sigma_lcurry_apply -> DirectSum.sigmaLcurry_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)] (f : DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (i : ι) (j : α i), Eq.{succ u3} (δ i j) (coeFn.{succ (max u4 u3), max (succ u4) (succ u3)} (DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (_x : DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) => forall (i_1 : α i), δ i i_1) (DirectSum.hasCoeToFun.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (coeFn.{succ (max u2 u4 u3), max (succ u2) (succ (max u4 u3))} (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (fun (_x : DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) => forall (i : ι), DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (DirectSum.hasCoeToFun.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (coeFn.{max (succ (max (max u2 u4) u3)) (succ (max u2 u4 u3)), max (succ (max (max u2 u4) u3)) (succ (max u2 u4 u3))} (LinearMap.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))) (fun (_x : LinearMap.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))) => (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) -> (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)))) (LinearMap.hasCoeToFun.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) _inst_1 _inst_1 (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.sigmaLcurry.{u1, u2, u3, u4} R _inst_1 ι (fun (i : ι) => α i) δ _inst_6 (fun (i : ι) (j : α i) => _inst_7 i j)) f) i) j) (coeFn.{succ (max (max u2 u4) u3), max (succ (max u2 u4)) (succ u3)} (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (fun (_x : DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) => forall (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)), δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (DirectSum.hasCoeToFun.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) f (Sigma.mk.{u2, u4} ι (fun (i : ι) => α i) i j))
but is expected to have type
  forall (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] {ι : Type.{u3}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u4}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u4} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u2, u4} R (δ i j) _inst_1 (_inst_6 i j)] (f : DirectSum.{max u1 u3, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) (i : ι) (j : α i), Eq.{succ u4} ((fun (i_1 : α i) => (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) j) (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (Dfinsupp.{u1, u4} (α i) (fun (i_1 : α i) => (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) (fun (i_1 : α i) => (fun (i_1 : α i) => AddMonoid.toZero.{u4} ((fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) (AddCommMonoid.toAddMonoid.{u4} ((fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) ((fun (i_1 : α i) => _inst_6 i i_1) i_1))) i_1)) (α i) (fun (_x : α i) => (fun (i_1 : α i) => (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) _x) (Dfinsupp.funLike.{u1, u4} (α i) (fun (j : α i) => (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) j) (fun (i_1 : α i) => (fun (i_1 : α i) => AddMonoid.toZero.{u4} ((fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) (AddCommMonoid.toAddMonoid.{u4} ((fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) ((fun (i_1 : α i) => _inst_6 i i_1) i_1))) i_1)) (FunLike.coe.{max (succ u3) (succ (max u4 u1)), succ u3, succ (max u4 u1)} (Dfinsupp.{u3, max u4 u1} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{max u4 u1} ((fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) (AddCommMonoid.toAddMonoid.{max u4 u1} ((fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) ((fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) _x) (Dfinsupp.funLike.{u3, max u4 u1} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{max u4 u1} ((fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) (AddCommMonoid.toAddMonoid.{max u4 u1} ((fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) ((fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i))) i)) (FunLike.coe.{max (max (succ u1) (succ u4)) (succ u3), max (max (succ u1) (succ u4)) (succ u3), max (max (succ u1) (succ u4)) (succ u3)} (LinearMap.{u2, u2, max u4 u1 u3, max (max u4 u1) u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (DirectSum.{max u1 u3, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) (DirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (instAddCommMonoidDirectSum.{max u3 u1, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, max u3 u1, u4} R _inst_1 (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, max u4 u1} R _inst_1 ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))) (DirectSum.{max u1 u3, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) (fun (_x : DirectSum.{max u1 u3, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{max u1 u3, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) => DirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max (max u1 u4) u3, max (max u1 u4) u3} R R (DirectSum.{max u1 u3, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) (DirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{max u3 u1, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, max u3 u1, u4} R _inst_1 (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, max u4 u1} R _inst_1 ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (DirectSum.sigmaLcurry.{u2, u3, u4, u1} R _inst_1 ι (fun (i : ι) => α i) δ _inst_6 (fun (i : ι) (j : α i) => _inst_7 i j)) f) i) j) (FunLike.coe.{max (succ (max u3 u1)) (succ u4), succ (max u3 u1), succ u4} (Dfinsupp.{max u3 u1, u4} (Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i)) i) i) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => AddMonoid.toZero.{u4} ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i)) i) i) (AddCommMonoid.toAddMonoid.{u4} ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i)) i) i) ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i)) i))) i)) (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (_x : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i)) i) i) _x) (Dfinsupp.funLike.{max u3 u1, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i)) i) i) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => AddMonoid.toZero.{u4} ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i)) i) i) (AddCommMonoid.toAddMonoid.{u4} ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i)) i) i) ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.5946) i)) i))) i)) f (Sigma.mk.{u3, u1} ι (fun (i : ι) => α i) i j))
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_lcurry_apply DirectSum.sigmaLcurry_applyₓ'. -/
@[simp]
theorem sigmaLcurry_apply (f : ⨁ i : Σi, _, δ i.1 i.2) (i : ι) (j : α i) :
    sigmaLcurry R f i j = f ⟨i, j⟩ :=
  sigmaCurry_apply f i j
#align direct_sum.sigma_lcurry_apply DirectSum.sigmaLcurry_apply

/- warning: direct_sum.sigma_luncurry -> DirectSum.sigmaLuncurry is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)] [_inst_8 : forall (i : ι), DecidableEq.{succ u4} (α i)] [_inst_9 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], LinearMap.{u1, u1, max u2 u4 u3, max (max u2 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)] [_inst_8 : forall (i : ι), DecidableEq.{succ u4} (α i)] [_inst_9 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], LinearMap.{u1, u1, max (max u3 u4) u2, max u3 u4 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.{max u4 u2, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (instAddCommMonoidDirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, max u3 u4} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)))
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_luncurry DirectSum.sigmaLuncurryₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/-- `uncurry` as a linear map.-/
def sigmaLuncurry [∀ i, DecidableEq (α i)] [∀ i j, DecidableEq (δ i j)] :
    (⨁ (i) (j), δ i j) →ₗ[R] ⨁ i : Σi, _, δ i.1 i.2 :=
  { sigmaUncurry with map_smul' := Dfinsupp.sigmaUncurry_smul }
#align direct_sum.sigma_luncurry DirectSum.sigmaLuncurry

/- warning: direct_sum.sigma_luncurry_apply -> DirectSum.sigmaLuncurry_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)] [_inst_8 : forall (i : ι), DecidableEq.{succ u4} (α i)] [_inst_9 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)] (f : DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (i : ι) (j : α i), Eq.{succ u3} (δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) (Sigma.mk.{u2, u4} ι (fun (i : ι) => α i) i j)) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) (Sigma.mk.{u2, u4} ι (fun (i : ι) => α i) i j))) (coeFn.{succ (max (max u2 u4) u3), max (succ (max u2 u4)) (succ u3)} (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (fun (_x : DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) => forall (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)), δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (DirectSum.hasCoeToFun.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (coeFn.{max (succ (max u2 u4 u3)) (succ (max (max u2 u4) u3)), max (succ (max u2 u4 u3)) (succ (max (max u2 u4) u3))} (LinearMap.{u1, u1, max u2 u4 u3, max (max u2 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)))) (fun (_x : LinearMap.{u1, u1, max u2 u4 u3, max (max u2 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)))) => (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) -> (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)))) (LinearMap.hasCoeToFun.{u1, u1, max u2 u4 u3, max (max u2 u4) u3} R R (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.sigmaLuncurry.{u1, u2, u3, u4} R _inst_1 ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_6 i i_1) (fun (i : ι) (j : α i) => _inst_7 i j) (fun (i : ι) (a : α i) (b : α i) => _inst_8 i a b) (fun (i : ι) (j : α i) (a : δ i j) (b : δ i j) => _inst_9 i j a b)) f) (Sigma.mk.{u2, u4} ι (fun (i : ι) => α i) i j)) (coeFn.{succ (max u4 u3), max (succ u4) (succ u3)} (DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (_x : DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) => forall (i_1 : α i), δ i i_1) (DirectSum.hasCoeToFun.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (coeFn.{succ (max u2 u4 u3), max (succ u2) (succ (max u4 u3))} (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (fun (_x : DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) => forall (i : ι), DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (DirectSum.hasCoeToFun.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) f i) j)
but is expected to have type
  forall (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] {ι : Type.{u3}} {α : ι -> Type.{u1}} {δ : forall (i : ι), (α i) -> Type.{u4}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u4} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u2, u4} R (δ i j) _inst_1 (_inst_6 i j)] [_inst_8 : forall (i : ι), DecidableEq.{succ u1} (α i)] [_inst_9 : forall (i : ι) (j : α i), DecidableEq.{succ u4} (δ i j)] (f : DirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (i : ι) (j : α i), Eq.{succ u4} ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) i) i) (Sigma.mk.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i j)) (FunLike.coe.{max (succ (max u3 u1)) (succ u4), succ (max u3 u1), succ u4} (Dfinsupp.{max u3 u1, u4} (Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) i) i) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => AddMonoid.toZero.{u4} ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) i) i) (AddCommMonoid.toAddMonoid.{u4} ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) i) i) ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) i))) i)) (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (_x : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) i) i) _x) (Dfinsupp.funLike.{max u3 u1, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) i) i) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => AddMonoid.toZero.{u4} ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) i) i) (AddCommMonoid.toAddMonoid.{u4} ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) i) i) ((fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) i))) i)) (FunLike.coe.{max (max (succ u1) (succ u4)) (succ u3), max (max (succ u1) (succ u4)) (succ u3), max (max (succ u1) (succ u4)) (succ u3)} (LinearMap.{u2, u2, max (max u4 u1) u3, max u4 u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (DirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.{max u1 u3, u4} (Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i))) (instAddCommMonoidDirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (instAddCommMonoidDirectSum.{max u3 u1, u4} (Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, max u4 u1} R _inst_1 ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, max u3 u1, u4} R _inst_1 (Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => _inst_7 (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)))) (DirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (fun (_x : DirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) => DirectSum.{max u1 u3, u4} (Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => δ (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i)) (fun (i : Sigma.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i) (Sigma.snd.{u3, u1} ι (fun (x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195 : ι) => α x._@.Mathlib.Algebra.DirectSum.Module._hyg.6195) i))) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max (max u1 u4) u3, max (max u1 u4) u3} R R (DirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.{max u1 u3, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u3, max u4 u1} ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (instAddCommMonoidDirectSum.{max u3 u1, u4} (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, max u4 u1} R _inst_1 ι (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u1, u4} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, max u3 u1, u4} R _inst_1 (Sigma.{u3, u1} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u3, u1} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u3, u1} ι (fun (i : ι) => α i) i) (Sigma.snd.{u3, u1} ι (fun (i : ι) => α i) i))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (DirectSum.sigmaLuncurry.{u2, u3, u4, u1} R _inst_1 ι (fun (i : ι) => α i) (fun (i : ι) (j : α i) => δ i j) (fun (i : ι) (i_1 : α i) => _inst_6 i i_1) (fun (i : ι) (j : α i) => _inst_7 i j) (fun (i : ι) (a : α i) (b : α i) => _inst_8 i a b) (fun (i : ι) (j : α i) (a : δ i j) (b : δ i j) => _inst_9 i j a b)) f) (Sigma.mk.{u3, u1} ι (fun (i : ι) => α i) i j)) (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (Dfinsupp.{u1, u4} (α i) (fun (i_1 : α i) => (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) (fun (i_1 : α i) => (fun (i_1 : α i) => AddMonoid.toZero.{u4} ((fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) (AddCommMonoid.toAddMonoid.{u4} ((fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) ((fun (i_1 : α i) => _inst_6 i i_1) i_1))) i_1)) (α i) (fun (_x : α i) => (fun (i_1 : α i) => (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) _x) (Dfinsupp.funLike.{u1, u4} (α i) (fun (j : α i) => (fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) j) (fun (i_1 : α i) => (fun (i_1 : α i) => AddMonoid.toZero.{u4} ((fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) (AddCommMonoid.toAddMonoid.{u4} ((fun (i_1 : α i) => (fun (j : α i) => δ i j) i_1) i_1) ((fun (i_1 : α i) => _inst_6 i i_1) i_1))) i_1)) (FunLike.coe.{max (succ u3) (succ (max u4 u1)), succ u3, succ (max u4 u1)} (Dfinsupp.{u3, max u4 u1} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{max u4 u1} ((fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) (AddCommMonoid.toAddMonoid.{max u4 u1} ((fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) ((fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i))) i)) ι (fun (_x : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) _x) (Dfinsupp.funLike.{u3, max u4 u1} ι (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) (fun (i : ι) => (fun (i : ι) => AddMonoid.toZero.{max u4 u1} ((fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) (AddCommMonoid.toAddMonoid.{max u4 u1} ((fun (i : ι) => (fun (i : ι) => DirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i) i) ((fun (i : ι) => instAddCommMonoidDirectSum.{u1, u4} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) i))) i)) f i) j)
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_luncurry_apply DirectSum.sigmaLuncurry_applyₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
@[simp]
theorem sigmaLuncurry_apply [∀ i, DecidableEq (α i)] [∀ i j, DecidableEq (δ i j)]
    (f : ⨁ (i) (j), δ i j) (i : ι) (j : α i) : sigmaLuncurry R f ⟨i, j⟩ = f i j :=
  sigmaUncurry_apply f i j
#align direct_sum.sigma_luncurry_apply DirectSum.sigmaLuncurry_apply

/- warning: direct_sum.sigma_lcurry_equiv -> DirectSum.sigmaLcurryEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)] [_inst_8 : forall (i : ι), DecidableEq.{succ u4} (α i)] [_inst_9 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], LinearEquiv.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.addCommMonoid.{u2, max u4 u3} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.module.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.module.{u1, u2, max u4 u3} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.addCommMonoid.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.module.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} {α : ι -> Type.{u4}} {δ : forall (i : ι), (α i) -> Type.{u3}} [_inst_6 : forall (i : ι) (j : α i), AddCommMonoid.{u3} (δ i j)] [_inst_7 : forall (i : ι) (j : α i), Module.{u1, u3} R (δ i j) _inst_1 (_inst_6 i j)] [_inst_8 : forall (i : ι), DecidableEq.{succ u4} (α i)] [_inst_9 : forall (i : ι) (j : α i), DecidableEq.{succ u3} (δ i j)], LinearEquiv.{u1, u1, max u3 u4 u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{max u4 u2, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (instAddCommMonoidDirectSum.{max u2 u4, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (instAddCommMonoidDirectSum.{u2, max u3 u4} ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, max u2 u4, u3} R _inst_1 (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => δ (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_6 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i)) (fun (i : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => _inst_7 (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) i) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) i))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, max u3 u4} R _inst_1 ι (fun (i : ι) => DirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => instAddCommMonoidDirectSum.{u4, u3} (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1)) (fun (i : ι) => DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u4, u3} R _inst_1 (α i) (fun (j : α i) => δ i j) (fun (i_1 : α i) => _inst_6 i i_1) (fun (i_1 : α i) => _inst_7 i i_1)))
Case conversion may be inaccurate. Consider using '#align direct_sum.sigma_lcurry_equiv DirectSum.sigmaLcurryEquivₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/
/-- `curry_equiv` as a linear equiv.-/
noncomputable def sigmaLcurryEquiv [∀ i, DecidableEq (α i)] [∀ i j, DecidableEq (δ i j)] :
    (⨁ i : Σi, _, δ i.1 i.2) ≃ₗ[R] ⨁ (i) (j), δ i j :=
  { sigmaCurryEquiv, sigmaLcurry R with }
#align direct_sum.sigma_lcurry_equiv DirectSum.sigmaLcurryEquiv

end Sigma

section Option

variable {α : Option ι → Type w} [∀ i, AddCommMonoid (α i)] [∀ i, Module R (α i)]

include dec_ι

/- warning: direct_sum.lequiv_prod_direct_sum -> DirectSum.lequivProdDirectSum is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {α : (Option.{u2} ι) -> Type.{u3}} [_inst_6 : forall (i : Option.{u2} ι), AddCommMonoid.{u3} (α i)] [_inst_7 : forall (i : Option.{u2} ι), Module.{u1, u3} R (α i) _inst_1 (_inst_6 i)], LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i)) (Prod.{u3, max u2 u3} (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)))) (DirectSum.addCommMonoid.{u2, u3} (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i)) (Prod.addCommMonoid.{u3, max u2 u3} (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) (_inst_6 (Option.none.{u2} ι)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)))) (DirectSum.module.{u1, u2, u3} R _inst_1 (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i) (fun (i : Option.{u2} ι) => _inst_7 i)) (Prod.module.{u1, u3, max u2 u3} R (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) _inst_1 (_inst_6 (Option.none.{u2} ι)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) (_inst_7 (Option.none.{u2} ι)) (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)) (fun (i : ι) => _inst_7 (Option.some.{u2} ι i))))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {α : (Option.{u2} ι) -> Type.{u3}} [_inst_6 : forall (i : Option.{u2} ι), AddCommMonoid.{u3} (α i)] [_inst_7 : forall (i : Option.{u2} ι), Module.{u1, u3} R (α i) _inst_1 (_inst_6 i)], LinearEquiv.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (DirectSum.{u2, u3} (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i)) (Prod.{u3, max u3 u2} (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)))) (instAddCommMonoidDirectSum.{u2, u3} (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i)) (Prod.instAddCommMonoidSum.{u3, max u2 u3} (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) (_inst_6 (Option.none.{u2} ι)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)))) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 (Option.{u2} ι) (fun (i : Option.{u2} ι) => α i) (fun (i : Option.{u2} ι) => _inst_6 i) (fun (i : Option.{u2} ι) => _inst_7 i)) (Prod.module.{u1, u3, max u2 u3} R (α (Option.none.{u2} ι)) (DirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) _inst_1 (_inst_6 (Option.none.{u2} ι)) (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i))) (_inst_7 (Option.none.{u2} ι)) (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => α (Option.some.{u2} ι i)) (fun (i : ι) => _inst_6 (Option.some.{u2} ι i)) (fun (i : ι) => _inst_7 (Option.some.{u2} ι i))))
Case conversion may be inaccurate. Consider using '#align direct_sum.lequiv_prod_direct_sum DirectSum.lequivProdDirectSumₓ'. -/
/-- Linear isomorphism obtained by separating the term of index `none` of a direct sum over
`option ι`.-/
@[simps]
noncomputable def lequivProdDirectSum : (⨁ i, α i) ≃ₗ[R] α none × ⨁ i, α (some i) :=
  { addEquivProdDirectSum with map_smul' := Dfinsupp.equivProdDfinsupp_smul }
#align direct_sum.lequiv_prod_direct_sum DirectSum.lequivProdDirectSum

end Option

end General

section Submodule

section Semiring

variable {R : Type u} [Semiring R]

variable {ι : Type v} [dec_ι : DecidableEq ι]

include dec_ι

variable {M : Type _} [AddCommMonoid M] [Module R M]

variable (A : ι → Submodule R M)

/- warning: direct_sum.coe_linear_map -> DirectSum.coeLinearMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] (A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)), LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) M (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_2 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) (fun (i : ι) => Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_3
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] (A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)), LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) M (instAddCommMonoidDirectSum.{u2, u3} ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_2 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => Subtype.{succ u3} M (fun (x : M) => Membership.mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) (fun (i : ι) => Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_3
Case conversion may be inaccurate. Consider using '#align direct_sum.coe_linear_map DirectSum.coeLinearMapₓ'. -/
/-- The canonical embedding from `⨁ i, A i` to `M`  where `A` is a collection of `submodule R M`
indexed by `ι`. This is `direct_sum.coe_add_monoid_hom` as a `linear_map`. -/
def coeLinearMap : (⨁ i, A i) →ₗ[R] M :=
  toModule R ι M fun i => (A i).Subtype
#align direct_sum.coe_linear_map DirectSum.coeLinearMap

/- warning: direct_sum.coe_linear_map_of -> DirectSum.coeLinearMap_of is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] (A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (i : ι) (x : coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)), Eq.{succ u3} M (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) M (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_2 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) (fun (i : ι) => Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (DirectSum.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) M (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_2 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) (fun (i : ι) => Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_3) => (DirectSum.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (DirectSum.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) M _inst_1 _inst_1 (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_2 (DirectSum.module.{u1, u2, u3} R _inst_1 ι (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) (fun (i : ι) => Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (DirectSum.coeLinearMap.{u1, u2, u3} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M _inst_2 _inst_3 A) (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ u3) (succ (max u2 u3))} (AddMonoidHom.{u3, max u2 u3} ((fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i)) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) ((fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i))))) (fun (_x : AddMonoidHom.{u3, max u2 u3} ((fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i)) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) ((fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i))))) => (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) -> (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i))) (AddMonoidHom.hasCoeToFun.{u3, max u2 u3} ((fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i)) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) ((fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i))) (AddMonoid.toAddZeroClass.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i)) (AddCommMonoid.toAddMonoid.{max u2 u3} (DirectSum.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i)) (DirectSum.addCommMonoid.{u2, u3} ι (fun (i : ι) => (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) i) (fun (i : ι) => (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i))))) (DirectSum.of.{u2, u3} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) (fun (i : ι) => Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) i) x)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (A i)))))) x)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] (A : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) (i : ι) (x : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) => M) (FunLike.coe.{max (succ u3) (succ u1), succ u1, max (succ u3) (succ u1)} (AddMonoidHom.{u1, max u1 u3} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (a : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) => DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) a) (AddHomClass.toFunLike.{max u3 u1, u1, max u3 u1} (AddMonoidHom.{u1, max u1 u3} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddZeroClass.toAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))))) (AddZeroClass.toAdd.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))))) (AddMonoidHomClass.toAddHomClass.{max u3 u1, u1, max u3 u1} (AddMonoidHom.{u1, max u1 u3} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))))) (AddMonoidHom.addMonoidHomClass.{u1, max u3 u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))))))) (DirectSum.of.{u3, u1} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)) i) x)) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), succ u1} (LinearMap.{u2, u2, max u1 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) M (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_2 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u1} R _inst_1 ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)) (fun (i : ι) => Submodule.module.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_3) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (fun (_x : DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u1, u1} R R (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) M _inst_1 _inst_1 (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_2 (DirectSum.instModuleDirectSumInstAddCommMonoidDirectSum.{u2, u3, u1} R _inst_1 ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)) (fun (i : ι) => Submodule.module.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (DirectSum.coeLinearMap.{u2, u3, u1} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M _inst_2 _inst_3 A) (FunLike.coe.{max (succ u3) (succ u1), succ u1, max (succ u3) (succ u1)} (AddMonoidHom.{u1, max u1 u3} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (_x : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) => DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) _x) (AddHomClass.toFunLike.{max u3 u1, u1, max u3 u1} (AddMonoidHom.{u1, max u1 u3} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddZeroClass.toAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))))) (AddZeroClass.toAdd.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))))) (AddMonoidHomClass.toAddHomClass.{max u3 u1, u1, max u3 u1} (AddMonoidHom.{u1, max u1 u3} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))))) (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))))) (AddMonoidHom.addMonoidHomClass.{u1, max u3 u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddMonoid.toAddZeroClass.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (AddCommMonoid.toAddMonoid.{u1} (Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))) (AddMonoid.toAddZeroClass.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (AddCommMonoid.toAddMonoid.{max u3 u1} (DirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i))) (instAddCommMonoidDirectSum.{u3, u1} ι (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)))))))) (DirectSum.of.{u3, u1} ι (fun (a : ι) (b : ι) => dec_ι a b) (fun (i : ι) => Subtype.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) x (A i))) (fun (i : ι) => Submodule.addCommMonoid.{u2, u1} R M _inst_1 _inst_2 _inst_3 (A i)) i) x)) (Subtype.val.{succ u1} M (fun (x : M) => Membership.mem.{u1, u1} M (Set.{u1} M) (Set.instMembershipSet.{u1} M) x (SetLike.coe.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3) (A i))) x)
Case conversion may be inaccurate. Consider using '#align direct_sum.coe_linear_map_of DirectSum.coeLinearMap_ofₓ'. -/
@[simp]
theorem coeLinearMap_of (i : ι) (x : A i) : DirectSum.coeLinearMap A (of (fun i => A i) i x) = x :=
  toAddMonoid_of _ _ _
#align direct_sum.coe_linear_map_of DirectSum.coeLinearMap_of

variable {A}

/- warning: direct_sum.is_internal.submodule_supr_eq_top -> DirectSum.IsInternal.submodule_iSup_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)}, (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M _inst_1 _inst_2 _inst_3) A) -> (Eq.{succ u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (iSup.{u3, succ u2} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u3} R M _inst_1 _inst_2 _inst_3))) ι A) (Top.top.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.hasTop.{u1, u3} R M _inst_1 _inst_2 _inst_3)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)}, (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M _inst_1 _inst_2 _inst_3) A) -> (Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (iSup.{u1, succ u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι A) (Top.top.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.instTopSubmodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.submodule_supr_eq_top DirectSum.IsInternal.submodule_iSup_eq_topₓ'. -/
/-- If a direct sum of submodules is internal then the submodules span the module. -/
theorem IsInternal.submodule_iSup_eq_top (h : IsInternal A) : iSup A = ⊤ :=
  by
  rw [Submodule.iSup_eq_range_dfinsupp_lsum, LinearMap.range_eq_top]
  exact Function.Bijective.surjective h
#align direct_sum.is_internal.submodule_supr_eq_top DirectSum.IsInternal.submodule_iSup_eq_top

/- warning: direct_sum.is_internal.submodule_independent -> DirectSum.IsInternal.submodule_independent is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)}, (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M _inst_1 _inst_2 _inst_3) A) -> (CompleteLattice.Independent.{succ u2, u3} ι (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u3} R M _inst_1 _inst_2 _inst_3) A)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)}, (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M _inst_1 _inst_2 _inst_3) A) -> (CompleteLattice.Independent.{succ u3, u1} ι (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3) A)
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.submodule_independent DirectSum.IsInternal.submodule_independentₓ'. -/
/-- If a direct sum of submodules is internal then the submodules are independent. -/
theorem IsInternal.submodule_independent (h : IsInternal A) : CompleteLattice.Independent A :=
  CompleteLattice.independent_of_dfinsupp_lsum_injective _ h.Injective
#align direct_sum.is_internal.submodule_independent DirectSum.IsInternal.submodule_independent

#print DirectSum.IsInternal.collectedBasis /-
/-- Given an internal direct sum decomposition of a module `M`, and a basis for each of the
components of the direct sum, the disjoint union of these bases is a basis for `M`. -/
noncomputable def IsInternal.collectedBasis (h : IsInternal A) {α : ι → Type _}
    (v : ∀ i, Basis (α i) R (A i)) : Basis (Σi, α i) R M
    where repr :=
    ((LinearEquiv.ofBijective (DirectSum.coeLinearMap A) h).symm ≪≫ₗ
        Dfinsupp.mapRange.linearEquiv fun i => (v i).repr) ≪≫ₗ
      (sigmaFinsuppLequivDfinsupp R).symm
#align direct_sum.is_internal.collected_basis DirectSum.IsInternal.collectedBasis
-/

/- warning: direct_sum.is_internal.collected_basis_coe -> DirectSum.IsInternal.collectedBasis_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)} (h : DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M _inst_1 _inst_2 _inst_3) A) {α : ι -> Type.{u4}} (v : forall (i : ι), Basis.{u4, u1, u3} (α i) R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) _inst_1 (Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) (Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))), Eq.{max (succ (max u2 u4)) (succ u3)} ((Sigma.{u2, u4} ι (fun (i : ι) => α i)) -> M) (coeFn.{max (succ (max u2 u4)) (succ u1) (succ u3), max (succ (max u2 u4)) (succ u3)} (Basis.{max u2 u4, u1, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) R M _inst_1 _inst_2 _inst_3) (fun (_x : Basis.{max u2 u4, u1, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) R M _inst_1 _inst_2 _inst_3) => (Sigma.{u2, u4} ι (fun (i : ι) => α i)) -> M) (FunLike.hasCoeToFun.{max (succ (max u2 u4)) (succ u1) (succ u3), succ (max u2 u4), succ u3} (Basis.{max u2 u4, u1, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) R M _inst_1 _inst_2 _inst_3) (Sigma.{u2, u4} ι (fun (i : ι) => α i)) (fun (_x : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => M) (Basis.funLike.{max u2 u4, u1, u3} (Sigma.{u2, u4} ι (fun (i : ι) => α i)) R M _inst_1 _inst_2 _inst_3)) (DirectSum.IsInternal.collectedBasis.{u1, u2, u3, u4} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M _inst_2 _inst_3 A h (fun (i : ι) => α i) v)) (fun (a : Sigma.{u2, u4} ι (fun (i : ι) => α i)) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) M (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) M (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) M (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) M (coeSubtype.{succ u3} M (fun (x : M) => Membership.Mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) x (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))))))) (coeFn.{max (succ u4) (succ u1) (succ u3), max (succ u4) (succ u3)} (Basis.{u4, u1, u3} (α (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)) R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) _inst_1 (Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) (Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)))) (fun (_x : Basis.{u4, u1, u3} (α (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)) R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) _inst_1 (Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) (Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)))) => (α (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)) -> (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)))) (FunLike.hasCoeToFun.{max (succ u4) (succ u1) (succ u3), succ u4, succ u3} (Basis.{u4, u1, u3} (α (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)) R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) _inst_1 (Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) (Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)))) (α (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)) (fun (_x : α (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)) => coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) (Basis.funLike.{u4, u1, u3} (α (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)) R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) _inst_1 (Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))) (Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))))) (v (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a)) (Sigma.snd.{u2, u4} ι (fun (i : ι) => α i) a)))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] {ι : Type.{u4}} [dec_ι : DecidableEq.{succ u4} ι] {M : Type.{u2}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3)} (h : DirectSum.IsInternal.{u4, u2, u2} ι M (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u3, u2} R M _inst_1 _inst_2 _inst_3) A) {α : ι -> Type.{u1}} (v : forall (i : ι), Basis.{u1, u3, u2} (α i) R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3)) x (A i))) _inst_1 (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3 (A i)) (Submodule.module.{u3, u2} R M _inst_1 _inst_2 _inst_3 (A i))), Eq.{max (max (succ u4) (succ u2)) (succ u1)} (forall (a : Sigma.{u4, u1} ι (fun (i : ι) => α i)), (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : Sigma.{u4, u1} ι (fun (i : ι) => α i)) => M) a) (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u2)) (succ u1), max (succ u4) (succ u1), succ u2} (Basis.{max u1 u4, u3, u2} (Sigma.{u4, u1} ι (fun (i : ι) => α i)) R M _inst_1 _inst_2 _inst_3) (Sigma.{u4, u1} ι (fun (i : ι) => α i)) (fun (_x : Sigma.{u4, u1} ι (fun (i : ι) => α i)) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : Sigma.{u4, u1} ι (fun (i : ι) => α i)) => M) _x) (Basis.funLike.{max u4 u1, u3, u2} (Sigma.{u4, u1} ι (fun (i : ι) => α i)) R M _inst_1 _inst_2 _inst_3) (DirectSum.IsInternal.collectedBasis.{u3, u4, u2, u1} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M _inst_2 _inst_3 A h (fun (i : ι) => α i) v)) (fun (a : Sigma.{u4, u1} ι (fun (i : ι) => α i)) => Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3) (A (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u1, succ u2} (Basis.{u1, u3, u2} (α (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)) R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3)) x (A (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)))) _inst_1 (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a))) (Submodule.module.{u3, u2} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)))) (α (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)) (fun (_x : α (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : α (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)) => Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3)) x (A (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)))) _x) (Basis.funLike.{u1, u3, u2} (α (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)) R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3)) x (A (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)))) _inst_1 (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a))) (Submodule.module.{u3, u2} R M _inst_1 _inst_2 _inst_3 (A (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)))) (v (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a)) (Sigma.snd.{u4, u1} ι (fun (i : ι) => α i) a)))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.collected_basis_coe DirectSum.IsInternal.collectedBasis_coeₓ'. -/
@[simp]
theorem IsInternal.collectedBasis_coe (h : IsInternal A) {α : ι → Type _}
    (v : ∀ i, Basis (α i) R (A i)) : ⇑(h.collectedBasis v) = fun a : Σi, α i => ↑(v a.1 a.2) :=
  by
  funext a
  simp only [is_internal.collected_basis, to_module, coe_linear_map, [anonymous], Basis.coe_ofRepr,
    Basis.repr_symm_apply, Dfinsupp.lsum_apply_apply, Dfinsupp.mapRange.linearEquiv_apply,
    Dfinsupp.mapRange.linearEquiv_symm, Dfinsupp.mapRange_single, Finsupp.total_single,
    LinearEquiv.ofBijective_apply, LinearEquiv.symm_symm, LinearEquiv.symm_trans_apply, one_smul,
    sigmaFinsuppAddEquivDfinsupp_apply, sigmaFinsuppEquivDfinsupp_single,
    sigmaFinsuppLequivDfinsupp_apply]
  convert Dfinsupp.sumAddHom_single (fun i => (A i).Subtype.toAddMonoidHom) a.1 (v a.1 a.2)
#align direct_sum.is_internal.collected_basis_coe DirectSum.IsInternal.collectedBasis_coe

/- warning: direct_sum.is_internal.collected_basis_mem -> DirectSum.IsInternal.collectedBasis_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)} (h : DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M _inst_1 _inst_2 _inst_3) A) {α : ι -> Type.{u4}} (v : forall (i : ι), Basis.{u4, u1, u3} (α i) R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i)) _inst_1 (Submodule.addCommMonoid.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i)) (Submodule.module.{u1, u3} R M _inst_1 _inst_2 _inst_3 (A i))) (a : Sigma.{u2, u4} ι (fun (i : ι) => α i)), Membership.Mem.{u3, u3} M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (coeFn.{max (succ (max u2 u4)) (succ u1) (succ u3), max (succ (max u2 u4)) (succ u3)} (Basis.{max u2 u4, u1, u3} (Sigma.{u2, u4} ι (fun (i : ι) => (fun (i : ι) => α i) i)) R M _inst_1 _inst_2 _inst_3) (fun (_x : Basis.{max u2 u4, u1, u3} (Sigma.{u2, u4} ι (fun (i : ι) => (fun (i : ι) => α i) i)) R M _inst_1 _inst_2 _inst_3) => (Sigma.{u2, u4} ι (fun (i : ι) => (fun (i : ι) => α i) i)) -> M) (FunLike.hasCoeToFun.{max (succ (max u2 u4)) (succ u1) (succ u3), succ (max u2 u4), succ u3} (Basis.{max u2 u4, u1, u3} (Sigma.{u2, u4} ι (fun (i : ι) => (fun (i : ι) => α i) i)) R M _inst_1 _inst_2 _inst_3) (Sigma.{u2, u4} ι (fun (i : ι) => (fun (i : ι) => α i) i)) (fun (_x : Sigma.{u2, u4} ι (fun (i : ι) => (fun (i : ι) => α i) i)) => M) (Basis.funLike.{max u2 u4, u1, u3} (Sigma.{u2, u4} ι (fun (i : ι) => (fun (i : ι) => α i) i)) R M _inst_1 _inst_2 _inst_3)) (DirectSum.IsInternal.collectedBasis.{u1, u2, u3, u4} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M _inst_2 _inst_3 A h (fun (i : ι) => α i) v) a) (A (Sigma.fst.{u2, u4} ι (fun (i : ι) => α i) a))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] {ι : Type.{u4}} [dec_ι : DecidableEq.{succ u4} ι] {M : Type.{u2}} [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3)} (h : DirectSum.IsInternal.{u4, u2, u2} ι M (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u3, u2} R M _inst_1 _inst_2 _inst_3) A) {α : ι -> Type.{u1}} (v : forall (i : ι), Basis.{u1, u3, u2} (α i) R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3)) x (A i))) _inst_1 (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_2 _inst_3 (A i)) (Submodule.module.{u3, u2} R M _inst_1 _inst_2 _inst_3 (A i))) (a : Sigma.{u4, u1} ι (fun (i : ι) => α i)), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : Sigma.{u4, u1} ι (fun (i : ι) => α i)) => M) a) (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_2 _inst_3)) (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u2)) (succ u1), max (succ u4) (succ u1), succ u2} (Basis.{max u1 u4, u3, u2} (Sigma.{u4, u1} ι (fun (i : ι) => α i)) R M _inst_1 _inst_2 _inst_3) (Sigma.{u4, u1} ι (fun (i : ι) => α i)) (fun (_x : Sigma.{u4, u1} ι (fun (i : ι) => α i)) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : Sigma.{u4, u1} ι (fun (i : ι) => α i)) => M) _x) (Basis.funLike.{max u4 u1, u3, u2} (Sigma.{u4, u1} ι (fun (i : ι) => α i)) R M _inst_1 _inst_2 _inst_3) (DirectSum.IsInternal.collectedBasis.{u3, u4, u2, u1} R _inst_1 ι (fun (a : ι) (b : ι) => dec_ι a b) M _inst_2 _inst_3 A h (fun (i : ι) => α i) v) a) (A (Sigma.fst.{u4, u1} ι (fun (i : ι) => α i) a))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.collected_basis_mem DirectSum.IsInternal.collectedBasis_memₓ'. -/
theorem IsInternal.collectedBasis_mem (h : IsInternal A) {α : ι → Type _}
    (v : ∀ i, Basis (α i) R (A i)) (a : Σi, α i) : h.collectedBasis v a ∈ A a.1 := by simp
#align direct_sum.is_internal.collected_basis_mem DirectSum.IsInternal.collectedBasis_mem

/- warning: direct_sum.is_internal.is_compl -> DirectSum.IsInternal.isCompl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u1, u3} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3)} {i : ι} {j : ι}, (Ne.{succ u2} ι i j) -> (Eq.{succ u2} (Set.{u2} ι) (Set.univ.{u2} ι) (Insert.insert.{u2, u2} ι (Set.{u2} ι) (Set.hasInsert.{u2} ι) i (Singleton.singleton.{u2, u2} ι (Set.{u2} ι) (Set.hasSingleton.{u2} ι) j))) -> (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M _inst_1 _inst_2 _inst_3) A) -> (IsCompl.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u3} R M _inst_1 _inst_2 _inst_3))) (CompleteLattice.toBoundedOrder.{u3} (Submodule.{u1, u3} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u3} R M _inst_1 _inst_2 _inst_3)) (A i) (A j))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {A : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)} {i : ι} {j : ι}, (Ne.{succ u3} ι i j) -> (Eq.{succ u3} (Set.{u3} ι) (Set.univ.{u3} ι) (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.instInsertSet.{u3} ι) i (Singleton.singleton.{u3, u3} ι (Set.{u3} ι) (Set.instSingletonSet.{u3} ι) j))) -> (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) _inst_2 (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M _inst_1 _inst_2 _inst_3) A) -> (IsCompl.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) (CompleteLattice.toBoundedOrder.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3)) (A i) (A j))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.is_compl DirectSum.IsInternal.isComplₓ'. -/
/-- When indexed by only two distinct elements, `direct_sum.is_internal` implies
the two submodules are complementary. Over a `ring R`, this is true as an iff, as
`direct_sum.is_internal_iff_is_compl`. -/
theorem IsInternal.isCompl {A : ι → Submodule R M} {i j : ι} (hij : i ≠ j)
    (h : (Set.univ : Set ι) = {i, j}) (hi : IsInternal A) : IsCompl (A i) (A j) :=
  ⟨hi.submodule_independent.PairwiseDisjoint hij,
    codisjoint_iff.mpr <|
      Eq.symm <|
        hi.submodule_iSup_eq_top.symm.trans <| by
          rw [← sSup_pair, iSup, ← Set.image_univ, h, Set.image_insert_eq, Set.image_singleton]⟩
#align direct_sum.is_internal.is_compl DirectSum.IsInternal.isCompl

end Semiring

section Ring

variable {R : Type u} [Ring R]

variable {ι : Type v} [dec_ι : DecidableEq ι]

include dec_ι

variable {M : Type _} [AddCommGroup M] [Module R M]

/- warning: direct_sum.is_internal_submodule_of_independent_of_supr_eq_top -> DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : Module.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] {A : ι -> (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3)}, (CompleteLattice.Independent.{succ u2, u3} ι (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) A) -> (Eq.{succ u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (iSup.{u3, succ u2} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toHasSup.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3))) ι A) (Top.top.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.hasTop.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3))) -> (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Submodule.setLike.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) A)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] {A : ι -> (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)}, (CompleteLattice.Independent.{succ u3, u1} ι (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) A) -> (Eq.{succ u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (iSup.{u1, succ u3} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))) ι A) (Top.top.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))) -> (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Submodule.setLike.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) A)
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal_submodule_of_independent_of_supr_eq_top DirectSum.isInternal_submodule_of_independent_of_iSup_eq_topₓ'. -/
/-- Note that this is not generally true for `[semiring R]`; see
`complete_lattice.independent.dfinsupp_lsum_injective` for details. -/
theorem isInternal_submodule_of_independent_of_iSup_eq_top {A : ι → Submodule R M}
    (hi : CompleteLattice.Independent A) (hs : iSup A = ⊤) : IsInternal A :=
  ⟨hi.dfinsupp_lsum_injective,
    LinearMap.range_eq_top.1 <| (Submodule.iSup_eq_range_dfinsupp_lsum _).symm.trans hs⟩
#align direct_sum.is_internal_submodule_of_independent_of_supr_eq_top DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top

/- warning: direct_sum.is_internal_submodule_iff_independent_and_supr_eq_top -> DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : Module.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (A : ι -> (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3)), Iff (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Submodule.setLike.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) A) (And (CompleteLattice.Independent.{succ u2, u3} ι (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) A) (Eq.{succ u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (iSup.{u3, succ u2} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toHasSup.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3))) ι A) (Top.top.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.hasTop.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (A : ι -> (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)), Iff (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Submodule.setLike.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) A) (And (CompleteLattice.Independent.{succ u3, u1} ι (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) A) (Eq.{succ u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (iSup.{u1, succ u3} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))) ι A) (Top.top.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal_submodule_iff_independent_and_supr_eq_top DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_topₓ'. -/
/-- `iff` version of `direct_sum.is_internal_submodule_of_independent_of_supr_eq_top`,
`direct_sum.is_internal.independent`, and `direct_sum.is_internal.supr_eq_top`.
-/
theorem isInternal_submodule_iff_independent_and_iSup_eq_top (A : ι → Submodule R M) :
    IsInternal A ↔ CompleteLattice.Independent A ∧ iSup A = ⊤ :=
  ⟨fun i => ⟨i.submodule_independent, i.submodule_iSup_eq_top⟩,
    And.ndrec isInternal_submodule_of_independent_of_iSup_eq_top⟩
#align direct_sum.is_internal_submodule_iff_independent_and_supr_eq_top DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top

/- warning: direct_sum.is_internal_submodule_iff_is_compl -> DirectSum.isInternal_submodule_iff_isCompl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u3}} [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : Module.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] (A : ι -> (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3)) {i : ι} {j : ι}, (Ne.{succ u2} ι i j) -> (Eq.{succ u2} (Set.{u2} ι) (Set.univ.{u2} ι) (Insert.insert.{u2, u2} ι (Set.{u2} ι) (Set.hasInsert.{u2} ι) i (Singleton.singleton.{u2, u2} ι (Set.{u2} ι) (Set.hasSingleton.{u2} ι) j))) -> (Iff (DirectSum.IsInternal.{u2, u3, u3} ι M (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (Submodule.setLike.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) A) (IsCompl.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3))) (CompleteLattice.toBoundedOrder.{u3} (Submodule.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R M (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3)) (A i) (A j)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {ι : Type.{u3}} [dec_ι : DecidableEq.{succ u3} ι] {M : Type.{u1}} [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (A : ι -> (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)) {i : ι} {j : ι}, (Ne.{succ u3} ι i j) -> (Eq.{succ u3} (Set.{u3} ι) (Set.univ.{u3} ι) (Insert.insert.{u3, u3} ι (Set.{u3} ι) (Set.instInsertSet.{u3} ι) i (Singleton.singleton.{u3, u3} ι (Set.{u3} ι) (Set.instSingletonSet.{u3} ι) j))) -> (Iff (DirectSum.IsInternal.{u3, u1, u1} ι M (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) (Submodule.setLike.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.addSubmonoidClass.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) A) (IsCompl.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3))) (CompleteLattice.toBoundedOrder.{u1} (Submodule.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3) (Submodule.completeLattice.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2) _inst_3)) (A i) (A j)))
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal_submodule_iff_is_compl DirectSum.isInternal_submodule_iff_isComplₓ'. -/
/-- If a collection of submodules has just two indices, `i` and `j`, then
`direct_sum.is_internal` is equivalent to `is_compl`. -/
theorem isInternal_submodule_iff_isCompl (A : ι → Submodule R M) {i j : ι} (hij : i ≠ j)
    (h : (Set.univ : Set ι) = {i, j}) : IsInternal A ↔ IsCompl (A i) (A j) :=
  by
  have : ∀ k, k = i ∨ k = j := fun k => by simpa using set.ext_iff.mp h k
  rw [is_internal_submodule_iff_independent_and_supr_eq_top, iSup, ← Set.image_univ, h,
    Set.image_insert_eq, Set.image_singleton, sSup_pair, CompleteLattice.independent_pair hij this]
  exact ⟨fun ⟨hd, ht⟩ => ⟨hd, codisjoint_iff.mpr ht⟩, fun ⟨hd, ht⟩ => ⟨hd, ht.eq_top⟩⟩
#align direct_sum.is_internal_submodule_iff_is_compl DirectSum.isInternal_submodule_iff_isCompl

/-! Now copy the lemmas for subgroup and submonoids. -/


/- warning: direct_sum.is_internal.add_submonoid_independent -> DirectSum.IsInternal.addSubmonoid_independent is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] {A : ι -> (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))}, (DirectSum.IsInternal.{u1, u2, u2} ι M (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (fun (a : ι) (b : ι) => dec_ι a b) _inst_4 (AddSubmonoid.setLike.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddSubmonoid.add_submonoidClass.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) A) -> (CompleteLattice.Independent.{succ u1, u2} ι (AddSubmonoid.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddSubmonoid.completeLattice.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) A)
but is expected to have type
  forall {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u1}} [_inst_4 : AddCommMonoid.{u1} M] {A : ι -> (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4)))}, (DirectSum.IsInternal.{u2, u1, u1} ι M (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (fun (a : ι) (b : ι) => dec_ι a b) _inst_4 (AddSubmonoid.instSetLikeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (AddSubmonoid.instAddSubmonoidClassAddSubmonoidInstSetLikeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) A) -> (CompleteLattice.Independent.{succ u2, u1} ι (AddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) (AddSubmonoid.instCompleteLatticeAddSubmonoid.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4))) A)
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.add_submonoid_independent DirectSum.IsInternal.addSubmonoid_independentₓ'. -/
theorem IsInternal.addSubmonoid_independent {M : Type _} [AddCommMonoid M] {A : ι → AddSubmonoid M}
    (h : IsInternal A) : CompleteLattice.Independent A :=
  CompleteLattice.independent_of_dfinsupp_sumAddHom_injective _ h.Injective
#align direct_sum.is_internal.add_submonoid_independent DirectSum.IsInternal.addSubmonoid_independent

/- warning: direct_sum.is_internal.add_subgroup_independent -> DirectSum.IsInternal.addSubgroup_independent is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} [dec_ι : DecidableEq.{succ u1} ι] {M : Type.{u2}} [_inst_4 : AddCommGroup.{u2} M] {A : ι -> (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4))}, (DirectSum.IsInternal.{u1, u2, u2} ι M (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u2} M _inst_4) (AddSubgroup.setLike.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) (AddSubgroupClass.to_addSubmonoidClass.{u2, u2} (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) M (AddGroup.toSubNegMonoid.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) (AddSubgroup.setLike.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) (AddSubgroup.add_subgroupClass.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4))) A) -> (CompleteLattice.Independent.{succ u1, u2} ι (AddSubgroup.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) (AddSubgroup.completeLattice.{u2} M (AddCommGroup.toAddGroup.{u2} M _inst_4)) A)
but is expected to have type
  forall {ι : Type.{u2}} [dec_ι : DecidableEq.{succ u2} ι] {M : Type.{u1}} [_inst_4 : AddCommGroup.{u1} M] {A : ι -> (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4))}, (DirectSum.IsInternal.{u2, u1, u1} ι M (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) (fun (a : ι) (b : ι) => dec_ι a b) (AddCommGroup.toAddCommMonoid.{u1} M _inst_4) (AddSubgroup.instSetLikeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) (AddSubgroupClass.toAddSubmonoidClass.{u1, u1} (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) M (AddGroup.toSubNegMonoid.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) (AddSubgroup.instSetLikeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) (AddSubgroup.instAddSubgroupClassAddSubgroupToSubNegAddMonoidInstSetLikeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4))) A) -> (CompleteLattice.Independent.{succ u2, u1} ι (AddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) (AddSubgroup.instCompleteLatticeAddSubgroup.{u1} M (AddCommGroup.toAddGroup.{u1} M _inst_4)) A)
Case conversion may be inaccurate. Consider using '#align direct_sum.is_internal.add_subgroup_independent DirectSum.IsInternal.addSubgroup_independentₓ'. -/
theorem IsInternal.addSubgroup_independent {M : Type _} [AddCommGroup M] {A : ι → AddSubgroup M}
    (h : IsInternal A) : CompleteLattice.Independent A :=
  CompleteLattice.independent_of_dfinsupp_sumAddHom_injective' _ h.Injective
#align direct_sum.is_internal.add_subgroup_independent DirectSum.IsInternal.addSubgroup_independent

end Ring

end Submodule

end DirectSum

