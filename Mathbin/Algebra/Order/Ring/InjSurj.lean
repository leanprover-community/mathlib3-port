/-
Copyright (c) 2016 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Leonardo de Moura, Mario Carneiro

! This file was ported from Lean 3 source module algebra.order.ring.inj_surj
! leanprover-community/mathlib commit 1e05171a5e8cf18d98d9cf7b207540acb044acae
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.Ring.Defs
import Mathbin.Algebra.Order.Monoid.Cancel.Basic
import Mathbin.Algebra.Ring.InjSurj

/-!
# Pulling back ordered rings along injective maps.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> https://github.com/leanprover-community/mathlib4/pull/917
> Any changes to this file require a corresponding PR to mathlib4.

-/


open Function

universe u

variable {α : Type u} {β : Type _}

namespace Function.Injective

/- warning: function.injective.ordered_semiring -> Function.Injective.orderedSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : HasSmul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_7 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_8))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1)))))))) n)) -> (OrderedSemiring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_8 n)) (Nat.cast.{u1} α (Semiring.toNatCast.{u1} α (OrderedSemiring.toSemiring.{u1} α _inst_1)) n)) -> (OrderedSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.ordered_semiring Function.Injective.orderedSemiringₓ'. -/
-- See note [reducible non-instances]
/-- Pullback an `ordered_semiring` under an injective map. -/
@[reducible]
protected def orderedSemiring [OrderedSemiring α] [Zero β] [One β] [Add β] [Mul β] [Pow β ℕ]
    [HasSmul ℕ β] [NatCast β] (f : β → α) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : OrderedSemiring β :=
  { hf.OrderedAddCommMonoid f zero add nsmul,
    hf.Semiring f zero one add mul nsmul npow
      nat_cast with
    zero_le_one := show f 0 ≤ f 1 by simp only [zero, one, zero_le_one]
    mul_le_mul_of_nonneg_left := fun a b c h hc =>
      show f (c * a) ≤ f (c * b) by
        rw [mul, mul]
        refine' mul_le_mul_of_nonneg_left h _
        rwa [← zero]
    mul_le_mul_of_nonneg_right := fun a b c h hc =>
      show f (a * c) ≤ f (b * c) by
        rw [mul, mul]
        refine' mul_le_mul_of_nonneg_right h _
        rwa [← zero] }
#align function.injective.ordered_semiring Function.Injective.orderedSemiring

/- warning: function.injective.ordered_comm_semiring -> Function.Injective.orderedCommSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : OrderedCommSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : HasSmul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1)))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1)))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_7 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_8))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1))))))))) n)) -> (OrderedCommSemiring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : OrderedCommSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (OrderedCommSemiring.toCommSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1)))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1)))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_8 n)) (Nat.cast.{u1} α (Semiring.toNatCast.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α _inst_1))) n)) -> (OrderedCommSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.ordered_comm_semiring Function.Injective.orderedCommSemiringₓ'. -/
-- See note [reducible non-instances]
/-- Pullback an `ordered_comm_semiring` under an injective map. -/
@[reducible]
protected def orderedCommSemiring [OrderedCommSemiring α] [Zero β] [One β] [Add β] [Mul β] [Pow β ℕ]
    [HasSmul ℕ β] [NatCast β] (f : β → α) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : OrderedCommSemiring β :=
  { hf.CommSemiring f zero one add mul nsmul npow nat_cast,
    hf.OrderedSemiring f zero one add mul nsmul npow nat_cast with }
#align function.injective.ordered_comm_semiring Function.Injective.orderedCommSemiring

/- warning: function.injective.ordered_ring -> Function.Injective.orderedRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : OrderedRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : HasSmul.{0, u2} Nat β] [_inst_9 : HasSmul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_8 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Int β _inst_9 n x)) (HasSmul.smul.{0, u1} Int α (SubNegMonoid.hasSmulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (Ring.toMonoid.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))))))) n)) -> (forall (n : Int), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1))))))) n)) -> (OrderedRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : OrderedRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedRing.toOrderedSemiring.{u1} α _inst_1))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (Ring.toNeg.{u1} α (OrderedRing.toRing.{u1} α _inst_1)) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (Ring.toSub.{u1} α (OrderedRing.toRing.{u1} α _inst_1))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_8) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_9) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (OrderedRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedRing.toOrderedSemiring.{u1} α _inst_1)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_11 n)) (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α _inst_1))) n)) -> (forall (n : Int), Eq.{succ u1} α (f (Int.cast.{u2} β _inst_12 n)) (Int.cast.{u1} α (Ring.toIntCast.{u1} α (OrderedRing.toRing.{u1} α _inst_1)) n)) -> (OrderedRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.ordered_ring Function.Injective.orderedRingₓ'. -/
-- See note [reducible non-instances]
/-- Pullback an `ordered_ring` under an injective map. -/
@[reducible]
protected def orderedRing [OrderedRing α] [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] (f : β → α) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : OrderedRing β :=
  { hf.OrderedSemiring f zero one add mul nsmul npow nat_cast,
    hf.Ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with
    mul_nonneg := fun a b ha hb =>
      show f 0 ≤ f (a * b) by
        rw [zero, mul]
        apply mul_nonneg <;> rwa [← zero] }
#align function.injective.ordered_ring Function.Injective.orderedRing

/- warning: function.injective.ordered_comm_ring -> Function.Injective.orderedCommRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : OrderedCommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : Pow.{u2, 0} β Nat] [_inst_9 : HasSmul.{0, u2} Nat β] [_inst_10 : HasSmul.{0, u2} Int β] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1)))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1)))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_9 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Int β _inst_10 n x)) (HasSmul.smul.{0, u1} Int α (SubNegMonoid.hasSmulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_8) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (Ring.toMonoid.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))))))) n)) -> (forall (n : Int), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1)))))))) n)) -> (OrderedCommRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : OrderedCommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : Pow.{u2, 0} β Nat] [_inst_9 : SMul.{0, u2} Nat β] [_inst_10 : SMul.{0, u2} Int β] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (OrderedCommSemiring.toCommSemiring.{u1} α (OrderedCommRing.toOrderedCommSemiring.{u1} α _inst_1))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1)))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (Ring.toNeg.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (Ring.toSub.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_9) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_10) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_8) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (OrderedSemiring.toSemiring.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (OrderedCommRing.toOrderedCommSemiring.{u1} α _inst_1))))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_11 n)) (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1)))) n)) -> (forall (n : Int), Eq.{succ u1} α (f (Int.cast.{u2} β _inst_12 n)) (Int.cast.{u1} α (Ring.toIntCast.{u1} α (OrderedRing.toRing.{u1} α (OrderedCommRing.toOrderedRing.{u1} α _inst_1))) n)) -> (OrderedCommRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.ordered_comm_ring Function.Injective.orderedCommRingₓ'. -/
-- See note [reducible non-instances]
/-- Pullback an `ordered_comm_ring` under an injective map. -/
@[reducible]
protected def orderedCommRing [OrderedCommRing α] [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [Pow β ℕ] [HasSmul ℕ β] [HasSmul ℤ β] [NatCast β] [IntCast β] (f : β → α) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : OrderedCommRing β :=
  { hf.OrderedRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast,
    hf.CommRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with }
#align function.injective.ordered_comm_ring Function.Injective.orderedCommRing

/- warning: function.injective.strict_ordered_semiring -> Function.Injective.strictOrderedSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : StrictOrderedSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : HasSmul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_7 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_8))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1)))))))) n)) -> (StrictOrderedSemiring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : StrictOrderedSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_8 n)) (Nat.cast.{u1} α (Semiring.toNatCast.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α _inst_1)) n)) -> (StrictOrderedSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.strict_ordered_semiring Function.Injective.strictOrderedSemiringₓ'. -/
-- See note [reducible non-instances]
/-- Pullback a `strict_ordered_semiring` under an injective map. -/
@[reducible]
protected def strictOrderedSemiring [StrictOrderedSemiring α] [Zero β] [One β] [Add β] [Mul β]
    [Pow β ℕ] [HasSmul ℕ β] [NatCast β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : StrictOrderedSemiring β :=
  { hf.OrderedCancelAddCommMonoid f zero add nsmul,
    hf.OrderedSemiring f zero one add mul nsmul npow nat_cast,
    pullback_nonzero f zero
      one with
    mul_lt_mul_of_pos_left := fun a b c h hc =>
      show f (c * a) < f (c * b) by
        simpa only [mul, zero] using mul_lt_mul_of_pos_left ‹f a < f b› (by rwa [← zero])
    mul_lt_mul_of_pos_right := fun a b c h hc =>
      show f (a * c) < f (b * c) by
        simpa only [mul, zero] using mul_lt_mul_of_pos_right ‹f a < f b› (by rwa [← zero]) }
#align function.injective.strict_ordered_semiring Function.Injective.strictOrderedSemiring

/- warning: function.injective.strict_ordered_comm_semiring -> Function.Injective.strictOrderedCommSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : StrictOrderedCommSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : HasSmul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_7 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_8))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))))) n)) -> (StrictOrderedCommSemiring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : StrictOrderedCommSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (StrictOrderedCommSemiring.toCommSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_8 n)) (Nat.cast.{u1} α (Semiring.toNatCast.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α _inst_1))) n)) -> (StrictOrderedCommSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.strict_ordered_comm_semiring Function.Injective.strictOrderedCommSemiringₓ'. -/
-- See note [reducible non-instances]
/-- Pullback a `strict_ordered_comm_semiring` under an injective map. -/
@[reducible]
protected def strictOrderedCommSemiring [StrictOrderedCommSemiring α] [Zero β] [One β] [Add β]
    [Mul β] [Pow β ℕ] [HasSmul ℕ β] [NatCast β] (f : β → α) (hf : Injective f) (zero : f 0 = 0)
    (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : StrictOrderedCommSemiring β :=
  { hf.CommSemiring f zero one add mul nsmul npow nat_cast,
    hf.StrictOrderedSemiring f zero one add mul nsmul npow nat_cast with }
#align function.injective.strict_ordered_comm_semiring Function.Injective.strictOrderedCommSemiring

/- warning: function.injective.strict_ordered_ring -> Function.Injective.strictOrderedRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : StrictOrderedRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : HasSmul.{0, u2} Nat β] [_inst_9 : HasSmul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_8 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Int β _inst_9 n x)) (HasSmul.smul.{0, u1} Int α (SubNegMonoid.hasSmulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (Ring.toMonoid.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))))))) n)) -> (forall (n : Int), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1))))))) n)) -> (StrictOrderedRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : StrictOrderedRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α _inst_1))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (Ring.toNeg.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (Ring.toSub.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_8) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_9) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α _inst_1)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_11 n)) (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1))) n)) -> (forall (n : Int), Eq.{succ u1} α (f (Int.cast.{u2} β _inst_12 n)) (Int.cast.{u1} α (Ring.toIntCast.{u1} α (StrictOrderedRing.toRing.{u1} α _inst_1)) n)) -> (StrictOrderedRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.strict_ordered_ring Function.Injective.strictOrderedRingₓ'. -/
-- See note [reducible non-instances]
/-- Pullback a `strict_ordered_ring` under an injective map. -/
@[reducible]
protected def strictOrderedRing [StrictOrderedRing α] [Zero β] [One β] [Add β] [Mul β] [Neg β]
    [Sub β] [HasSmul ℕ β] [HasSmul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] (f : β → α)
    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : StrictOrderedRing β :=
  { hf.StrictOrderedSemiring f zero one add mul nsmul npow nat_cast,
    hf.Ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with
    mul_pos := fun a b a0 b0 =>
      show f 0 < f (a * b) by
        rw [zero, mul]
        apply mul_pos <;> rwa [← zero] }
#align function.injective.strict_ordered_ring Function.Injective.strictOrderedRing

/- warning: function.injective.strict_ordered_comm_ring -> Function.Injective.strictOrderedCommRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : StrictOrderedCommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : Pow.{u2, 0} β Nat] [_inst_9 : HasSmul.{0, u2} Nat β] [_inst_10 : HasSmul.{0, u2} Int β] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1)))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1)))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_9 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Int β _inst_10 n x)) (HasSmul.smul.{0, u1} Int α (SubNegMonoid.hasSmulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_8) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (Ring.toMonoid.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))))))) n)) -> (forall (n : Int), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1)))))))) n)) -> (StrictOrderedCommRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : StrictOrderedCommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : Pow.{u2, 0} β Nat] [_inst_9 : SMul.{0, u2} Nat β] [_inst_10 : SMul.{0, u2} Int β] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (StrictOrderedCommSemiring.toCommSemiring.{u1} α (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u1} α _inst_1))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1)))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (Ring.toNeg.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (Ring.toSub.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_9) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_10) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_8) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (StrictOrderedCommSemiring.toStrictOrderedSemiring.{u1} α (StrictOrderedCommRing.toStrictOrderedCommSemiring.{u1} α _inst_1))))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_11 n)) (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1)))) n)) -> (forall (n : Int), Eq.{succ u1} α (f (Int.cast.{u2} β _inst_12 n)) (Int.cast.{u1} α (Ring.toIntCast.{u1} α (StrictOrderedRing.toRing.{u1} α (StrictOrderedCommRing.toStrictOrderedRing.{u1} α _inst_1))) n)) -> (StrictOrderedCommRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.strict_ordered_comm_ring Function.Injective.strictOrderedCommRingₓ'. -/
-- See note [reducible non-instances]
/-- Pullback a `strict_ordered_comm_ring` under an injective map. -/
@[reducible]
protected def strictOrderedCommRing [StrictOrderedCommRing α] [Zero β] [One β] [Add β] [Mul β]
    [Neg β] [Sub β] [Pow β ℕ] [HasSmul ℕ β] [HasSmul ℤ β] [NatCast β] [IntCast β] (f : β → α)
    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) : StrictOrderedCommRing β :=
  { hf.StrictOrderedRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast,
    hf.CommRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with }
#align function.injective.strict_ordered_comm_ring Function.Injective.strictOrderedCommRing

/- warning: function.injective.linear_ordered_semiring -> Function.Injective.linearOrderedSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : HasSmul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] [_inst_9 : HasSup.{u2} β] [_inst_10 : HasInf.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_7 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_8))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))))) n)) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasSup.sup.{u2} β _inst_9 x y)) (LinearOrder.max.{u1} α (LinearOrderedAddCommMonoid.toLinearOrder.{u1} α (LinearOrderedSemiring.toLinearOrderedAddCommMonoid.{u1} α _inst_1)) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasInf.inf.{u2} β _inst_10 x y)) (LinearOrder.min.{u1} α (LinearOrderedAddCommMonoid.toLinearOrder.{u1} α (LinearOrderedSemiring.toLinearOrderedAddCommMonoid.{u1} α _inst_1)) (f x) (f y))) -> (LinearOrderedSemiring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] [_inst_9 : HasSup.{u2} β] [_inst_10 : HasInf.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_8 n)) (Nat.cast.{u1} α (Semiring.toNatCast.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α _inst_1))) n)) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasSup.sup.{u2} β _inst_9 x y)) (Max.max.{u1} α (LinearOrderedSemiring.toMax.{u1} α _inst_1) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasInf.inf.{u2} β _inst_10 x y)) (Min.min.{u1} α (LinearOrderedSemiring.toMin.{u1} α _inst_1) (f x) (f y))) -> (LinearOrderedSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.linear_ordered_semiring Function.Injective.linearOrderedSemiringₓ'. -/
-- See note [reducible non-instances]
/-- Pullback a `linear_ordered_semiring` under an injective map. -/
@[reducible]
protected def linearOrderedSemiring [LinearOrderedSemiring α] [Zero β] [One β] [Add β] [Mul β]
    [Pow β ℕ] [HasSmul ℕ β] [NatCast β] [HasSup β] [HasInf β] (f : β → α) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (nat_cast : ∀ n : ℕ, f n = n)
    (hsup : ∀ x y, f (x ⊔ y) = max (f x) (f y)) (hinf : ∀ x y, f (x ⊓ y) = min (f x) (f y)) :
    LinearOrderedSemiring β :=
  { LinearOrder.lift f hf hsup hinf,
    hf.StrictOrderedSemiring f zero one add mul nsmul npow nat_cast with }
#align function.injective.linear_ordered_semiring Function.Injective.linearOrderedSemiring

/- warning: function.injective.linear_ordered_comm_semiring -> Function.Injective.linearOrderedCommSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedCommSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : HasSmul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] [_inst_9 : HasSup.{u2} β] [_inst_10 : HasInf.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1))))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1))))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1)))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1)))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_7 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1)))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1))))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_8))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1)))))))))) n)) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasSup.sup.{u2} β _inst_9 x y)) (LinearOrder.max.{u1} α (LinearOrderedAddCommMonoid.toLinearOrder.{u1} α (LinearOrderedSemiring.toLinearOrderedAddCommMonoid.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasInf.inf.{u2} β _inst_10 x y)) (LinearOrder.min.{u1} α (LinearOrderedAddCommMonoid.toLinearOrder.{u1} α (LinearOrderedSemiring.toLinearOrderedAddCommMonoid.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1))) (f x) (f y))) -> (LinearOrderedCommSemiring.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedCommSemiring.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Pow.{u2, 0} β Nat] [_inst_7 : SMul.{0, u2} Nat β] [_inst_8 : NatCast.{u2} β] [_inst_9 : HasSup.{u2} β] [_inst_10 : HasInf.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (StrictOrderedCommSemiring.toCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α _inst_1))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1)))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_7) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1))))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_6) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1))))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_8 n)) (Nat.cast.{u1} α (Semiring.toNatCast.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α _inst_1)))) n)) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasSup.sup.{u2} β _inst_9 x y)) (Max.max.{u1} α (LinearOrderedCommSemiring.toMax.{u1} α _inst_1) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasInf.inf.{u2} β _inst_10 x y)) (Min.min.{u1} α (LinearOrderedCommSemiring.toMin.{u1} α _inst_1) (f x) (f y))) -> (LinearOrderedCommSemiring.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.linear_ordered_comm_semiring Function.Injective.linearOrderedCommSemiringₓ'. -/
-- See note [reducible non-instances]
/-- Pullback a `linear_ordered_semiring` under an injective map. -/
@[reducible]
protected def linearOrderedCommSemiring [LinearOrderedCommSemiring α] [Zero β] [One β] [Add β]
    [Mul β] [Pow β ℕ] [HasSmul ℕ β] [NatCast β] [HasSup β] [HasInf β] (f : β → α) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (nat_cast : ∀ n : ℕ, f n = n)
    (hsup : ∀ x y, f (x ⊔ y) = max (f x) (f y)) (hinf : ∀ x y, f (x ⊓ y) = min (f x) (f y)) :
    LinearOrderedCommSemiring β :=
  { hf.LinearOrderedSemiring f zero one add mul nsmul npow nat_cast hsup hinf,
    hf.StrictOrderedCommSemiring f zero one add mul nsmul npow nat_cast with }
#align function.injective.linear_ordered_comm_semiring Function.Injective.linearOrderedCommSemiring

/- warning: function.injective.linear_ordered_ring -> Function.Injective.linearOrderedRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : HasSmul.{0, u2} Nat β] [_inst_9 : HasSmul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] [_inst_13 : HasSup.{u2} β] [_inst_14 : HasInf.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_8 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Int β _inst_9 n x)) (HasSmul.smul.{0, u1} Int α (SubNegMonoid.hasSmulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (Ring.toMonoid.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))))))) n)) -> (forall (n : Int), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))))) n)) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasSup.sup.{u2} β _inst_13 x y)) (LinearOrder.max.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α _inst_1) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasInf.inf.{u2} β _inst_14 x y)) (LinearOrder.min.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α _inst_1) (f x) (f y))) -> (LinearOrderedRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : SMul.{0, u2} Nat β] [_inst_9 : SMul.{0, u2} Int β] [_inst_10 : Pow.{u2, 0} β Nat] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] [_inst_13 : HasSup.{u2} β] [_inst_14 : HasInf.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (Ring.toNeg.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (Ring.toSub.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_8) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_9) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_10) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_11 n)) (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) n)) -> (forall (n : Int), Eq.{succ u1} α (f (Int.cast.{u2} β _inst_12 n)) (Int.cast.{u1} α (Ring.toIntCast.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) n)) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasSup.sup.{u2} β _inst_13 x y)) (Max.max.{u1} α (LinearOrderedRing.toMax.{u1} α _inst_1) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasInf.inf.{u2} β _inst_14 x y)) (Min.min.{u1} α (LinearOrderedRing.toMin.{u1} α _inst_1) (f x) (f y))) -> (LinearOrderedRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.linear_ordered_ring Function.Injective.linearOrderedRingₓ'. -/
-- See note [reducible non-instances]
/-- Pullback a `linear_ordered_ring` under an injective map. -/
@[reducible]
def linearOrderedRing [LinearOrderedRing α] [Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β]
    [HasSmul ℕ β] [HasSmul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] [HasSup β] [HasInf β] (f : β → α)
    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n)
    (hsup : ∀ x y, f (x ⊔ y) = max (f x) (f y)) (hinf : ∀ x y, f (x ⊓ y) = min (f x) (f y)) :
    LinearOrderedRing β :=
  { LinearOrder.lift f hf hsup hinf,
    hf.StrictOrderedRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with }
#align function.injective.linear_ordered_ring Function.Injective.linearOrderedRing

/- warning: function.injective.linear_ordered_comm_ring -> Function.Injective.linearOrderedCommRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedCommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : Pow.{u2, 0} β Nat] [_inst_9 : HasSmul.{0, u2} Nat β] [_inst_10 : HasSmul.{0, u2} Int β] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] [_inst_13 : HasSup.{u2} β] [_inst_14 : HasInf.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1))))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1))))))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Nat β _inst_9 n x)) (HasSmul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HasSmul.smul.{0, u2} Int β _inst_10 n x)) (HasSmul.smul.{0, u1} Int α (SubNegMonoid.hasSmulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_8) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (Ring.toMonoid.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β _inst_11))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α (AddMonoidWithOne.toNatCast.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))))))) n)) -> (forall (n : Int), Eq.{succ u1} α (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int β (HasLiftT.mk.{1, succ u2} Int β (CoeTCₓ.coe.{1, succ u2} Int β (Int.castCoe.{u2} β _inst_12))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int α (HasLiftT.mk.{1, succ u1} Int α (CoeTCₓ.coe.{1, succ u1} Int α (Int.castCoe.{u1} α (AddGroupWithOne.toHasIntCast.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1))))))))) n)) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasSup.sup.{u2} β _inst_13 x y)) (LinearOrder.max.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasInf.inf.{u2} β _inst_14 x y)) (LinearOrder.min.{u1} α (LinearOrderedRing.toLinearOrder.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)) (f x) (f y))) -> (LinearOrderedCommRing.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedCommRing.{u1} α] [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Add.{u2} β] [_inst_5 : Mul.{u2} β] [_inst_6 : Neg.{u2} β] [_inst_7 : Sub.{u2} β] [_inst_8 : Pow.{u2, 0} β Nat] [_inst_9 : SMul.{0, u2} Nat β] [_inst_10 : SMul.{0, u2} Int β] [_inst_11 : NatCast.{u2} β] [_inst_12 : IntCast.{u2} β] [_inst_13 : HasSup.{u2} β] [_inst_14 : HasInf.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (StrictOrderedCommSemiring.toCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} α _inst_1)))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocRing.toOne.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1))))))))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_5) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1))))))) (f x) (f y))) -> (forall (x : β), Eq.{succ u1} α (f (Neg.neg.{u2} β _inst_6 x)) (Neg.neg.{u1} α (Ring.toNeg.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))) (f x))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β _inst_7) x y)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (Ring.toSub.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β _inst_9) n x)) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))))) n (f x))) -> (forall (x : β) (n : Int), Eq.{succ u1} α (f (HSMul.hSMul.{0, u2, u2} Int β β (instHSMul.{0, u2} Int β _inst_10) n x)) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (Ring.toAddGroupWithOne.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))))))) n (f x))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_8) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} α (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u1} α _inst_1)))))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} α (f (Nat.cast.{u2} β _inst_11 n)) (Nat.cast.{u1} α (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1))))) n)) -> (forall (n : Int), Eq.{succ u1} α (f (Int.cast.{u2} β _inst_12 n)) (Int.cast.{u1} α (Ring.toIntCast.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)))) n)) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasSup.sup.{u2} β _inst_13 x y)) (Max.max.{u1} α (LinearOrderedRing.toMax.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasInf.inf.{u2} β _inst_14 x y)) (Min.min.{u1} α (LinearOrderedRing.toMin.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α _inst_1)) (f x) (f y))) -> (LinearOrderedCommRing.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.linear_ordered_comm_ring Function.Injective.linearOrderedCommRingₓ'. -/
-- See note [reducible non-instances]
/-- Pullback a `linear_ordered_comm_ring` under an injective map. -/
@[reducible]
protected def linearOrderedCommRing [LinearOrderedCommRing α] [Zero β] [One β] [Add β] [Mul β]
    [Neg β] [Sub β] [Pow β ℕ] [HasSmul ℕ β] [HasSmul ℤ β] [NatCast β] [IntCast β] [HasSup β]
    [HasInf β] (f : β → α) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)
    (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y)
    (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x) (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (nat_cast : ∀ n : ℕ, f n = n)
    (int_cast : ∀ n : ℤ, f n = n) (hsup : ∀ x y, f (x ⊔ y) = max (f x) (f y))
    (hinf : ∀ x y, f (x ⊓ y) = min (f x) (f y)) : LinearOrderedCommRing β :=
  { LinearOrder.lift f hf hsup hinf,
    hf.StrictOrderedCommRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with }
#align function.injective.linear_ordered_comm_ring Function.Injective.linearOrderedCommRing

end Function.Injective

