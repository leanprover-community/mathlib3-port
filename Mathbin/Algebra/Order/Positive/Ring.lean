/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov

! This file was ported from Lean 3 source module algebra.order.positive.ring
! leanprover-community/mathlib commit 26f081a2fb920140ed5bc5cc5344e84bcc7cb2b2
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.Ring.Defs
import Mathbin.Algebra.Ring.InjSurj

/-!
# Algebraic structures on the set of positive numbers

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define various instances (`add_semigroup`, `ordered_comm_monoid` etc) on the
type `{x : R // 0 < x}`. In each case we try to require the weakest possible typeclass
assumptions on `R` but possibly, there is a room for improvements.
-/


open Function

namespace Positive

variable {M R K : Type _}

section AddBasic

variable [AddMonoid M] [Preorder M] [CovariantClass M M (· + ·) (· < ·)]

instance : Add { x : M // 0 < x } :=
  ⟨fun x y => ⟨x + y, add_pos x.2 y.2⟩⟩

/- warning: positive.coe_add -> Positive.coe_add is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2))] (x : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (y : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)), Eq.{succ u1} M ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (coeBase.{succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (coeSubtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x))))) (HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Positive.Subtype.hasAdd.{u1} M _inst_1 _inst_2 _inst_3)) x y)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (coeBase.{succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (coeSubtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x))))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (coeBase.{succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) M (coeSubtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x))))) y))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.161 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.163 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.161 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.163) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.176 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.178 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.176 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.178)] (x : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (y : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)), Eq.{succ u1} M (Subtype.val.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x) (HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Positive.instAddSubtypeLtToLTOfNatToOfNat0ToZero.{u1} M _inst_1 _inst_2 _inst_3)) x y)) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) (Subtype.val.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x) x) (Subtype.val.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x) y))
Case conversion may be inaccurate. Consider using '#align positive.coe_add Positive.coe_addₓ'. -/
@[simp, norm_cast]
theorem coe_add (x y : { x : M // 0 < x }) : ↑(x + y) = (x + y : M) :=
  rfl
#align positive.coe_add Positive.coe_add

instance : AddSemigroup { x : M // 0 < x } :=
  Subtype.coe_injective.AddSemigroup _ coe_add

instance {M : Type _} [AddCommMonoid M] [Preorder M] [CovariantClass M M (· + ·) (· < ·)] :
    AddCommSemigroup { x : M // 0 < x } :=
  Subtype.coe_injective.AddCommSemigroup _ coe_add

instance {M : Type _} [AddLeftCancelMonoid M] [Preorder M] [CovariantClass M M (· + ·) (· < ·)] :
    AddLeftCancelSemigroup { x : M // 0 < x } :=
  Subtype.coe_injective.AddLeftCancelSemigroup _ coe_add

instance {M : Type _} [AddRightCancelMonoid M] [Preorder M] [CovariantClass M M (· + ·) (· < ·)] :
    AddRightCancelSemigroup { x : M // 0 < x } :=
  Subtype.coe_injective.AddRightCancelSemigroup _ coe_add

/- warning: positive.covariant_class_add_lt -> Positive.covariantClass_add_lt is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2))], CovariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Positive.Subtype.hasAdd.{u1} M _inst_1 _inst_2 _inst_3))) (LT.lt.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.hasLt.{u1} M (Preorder.toLT.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.628 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.630 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.628 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.630) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.643 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.645 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.643 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.645)], CovariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.685 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.687 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Positive.instAddSubtypeLtToLTOfNatToOfNat0ToZero.{u1} M _inst_1 _inst_2 _inst_3)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.685 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.687) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.700 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.702 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => LT.lt.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.700 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.702)
Case conversion may be inaccurate. Consider using '#align positive.covariant_class_add_lt Positive.covariantClass_add_ltₓ'. -/
instance covariantClass_add_lt :
    CovariantClass { x : M // 0 < x } { x : M // 0 < x } (· + ·) (· < ·) :=
  ⟨fun x y z hyz => Subtype.coe_lt_coe.1 <| add_lt_add_left hyz _⟩
#align positive.covariant_class_add_lt Positive.covariantClass_add_lt

/- warning: positive.covariant_class_swap_add_lt -> Positive.covariantClass_swap_add_lt is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2))] [_inst_4 : CovariantClass.{u1, u1} M M (Function.swap.{succ u1, succ u1, succ u1} M M (fun (ᾰ : M) (ᾰ : M) => M) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) (LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2))], CovariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Function.swap.{succ u1, succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (fun (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) => Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Positive.Subtype.hasAdd.{u1} M _inst_1 _inst_2 _inst_3)))) (LT.lt.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.hasLt.{u1} M (Preorder.toLT.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.760 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.762 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.760 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.762) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.775 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.777 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.775 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.777)] [_inst_4 : CovariantClass.{u1, u1} M M (Function.swap.{succ u1, succ u1, succ u1} M M (fun (ᾰ : M) (ᾰ : M) => M) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.797 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.799 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.797 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.799)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.812 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.814 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.812 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.814)], CovariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Function.swap.{succ u1, succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (fun (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.857 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.859 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Positive.instAddSubtypeLtToLTOfNatToOfNat0ToZero.{u1} M _inst_1 _inst_2 _inst_3)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.857 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.859)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.872 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.874 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => LT.lt.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.872 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.874)
Case conversion may be inaccurate. Consider using '#align positive.covariant_class_swap_add_lt Positive.covariantClass_swap_add_ltₓ'. -/
instance covariantClass_swap_add_lt [CovariantClass M M (swap (· + ·)) (· < ·)] :
    CovariantClass { x : M // 0 < x } { x : M // 0 < x } (swap (· + ·)) (· < ·) :=
  ⟨fun x y z hyz => Subtype.coe_lt_coe.1 <| add_lt_add_right hyz _⟩
#align positive.covariant_class_swap_add_lt Positive.covariantClass_swap_add_lt

/- warning: positive.contravariant_class_add_lt -> Positive.contravariantClass_add_lt is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2))] [_inst_4 : ContravariantClass.{u1, u1} M M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2))], ContravariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Positive.Subtype.hasAdd.{u1} M _inst_1 _inst_2 _inst_3))) (LT.lt.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.hasLt.{u1} M (Preorder.toLT.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.932 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.934 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.932 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.934) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.947 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.949 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.947 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.949)] [_inst_4 : ContravariantClass.{u1, u1} M M (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.966 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.968 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.966 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.968) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.981 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.983 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.981 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.983)], ContravariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1023 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1025 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Positive.instAddSubtypeLtToLTOfNatToOfNat0ToZero.{u1} M _inst_1 _inst_2 _inst_3)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1023 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1025) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1038 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1040 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => LT.lt.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1038 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1040)
Case conversion may be inaccurate. Consider using '#align positive.contravariant_class_add_lt Positive.contravariantClass_add_ltₓ'. -/
instance contravariantClass_add_lt [ContravariantClass M M (· + ·) (· < ·)] :
    ContravariantClass { x : M // 0 < x } { x : M // 0 < x } (· + ·) (· < ·) :=
  ⟨fun x y z h => Subtype.coe_lt_coe.1 <| lt_of_add_lt_add_left h⟩
#align positive.contravariant_class_add_lt Positive.contravariantClass_add_lt

/- warning: positive.contravariant_class_swap_add_lt -> Positive.contravariantClass_swap_add_lt is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2))] [_inst_4 : ContravariantClass.{u1, u1} M M (Function.swap.{succ u1, succ u1, succ u1} M M (fun (ᾰ : M) (ᾰ : M) => M) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) (LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2))], ContravariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Function.swap.{succ u1, succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (fun (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) => Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Positive.Subtype.hasAdd.{u1} M _inst_1 _inst_2 _inst_3)))) (LT.lt.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.hasLt.{u1} M (Preorder.toLT.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1084 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1086 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1084 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1086) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1099 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1101 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1099 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1101)] [_inst_4 : ContravariantClass.{u1, u1} M M (Function.swap.{succ u1, succ u1, succ u1} M M (fun (ᾰ : M) (ᾰ : M) => M) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1121 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1123 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1121 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1123)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1136 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1138 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1136 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1138)], ContravariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Function.swap.{succ u1, succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (fun (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1181 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1183 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Positive.instAddSubtypeLtToLTOfNatToOfNat0ToZero.{u1} M _inst_1 _inst_2 _inst_3)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1181 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1183)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1196 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1198 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => LT.lt.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1196 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1198)
Case conversion may be inaccurate. Consider using '#align positive.contravariant_class_swap_add_lt Positive.contravariantClass_swap_add_ltₓ'. -/
instance contravariantClass_swap_add_lt [ContravariantClass M M (swap (· + ·)) (· < ·)] :
    ContravariantClass { x : M // 0 < x } { x : M // 0 < x } (swap (· + ·)) (· < ·) :=
  ⟨fun x y z h => Subtype.coe_lt_coe.1 <| lt_of_add_lt_add_right h⟩
#align positive.contravariant_class_swap_add_lt Positive.contravariantClass_swap_add_lt

/- warning: positive.contravariant_class_add_le -> Positive.contravariantClass_add_le is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2))] [_inst_4 : ContravariantClass.{u1, u1} M M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (LE.le.{u1} M (Preorder.toLE.{u1} M _inst_2))], ContravariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Positive.Subtype.hasAdd.{u1} M _inst_1 _inst_2 _inst_3))) (LE.le.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.hasLe.{u1} M (Preorder.toLE.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1242 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1244 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1242 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1244) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1257 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1259 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1257 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1259)] [_inst_4 : ContravariantClass.{u1, u1} M M (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1276 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1278 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1276 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1278) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1291 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1293 : M) => LE.le.{u1} M (Preorder.toLE.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1291 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1293)], ContravariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1333 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1335 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Positive.instAddSubtypeLtToLTOfNatToOfNat0ToZero.{u1} M _inst_1 _inst_2 _inst_3)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1333 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1335) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1348 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1350 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => LE.le.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.le.{u1} M (Preorder.toLE.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1348 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1350)
Case conversion may be inaccurate. Consider using '#align positive.contravariant_class_add_le Positive.contravariantClass_add_leₓ'. -/
instance contravariantClass_add_le [ContravariantClass M M (· + ·) (· ≤ ·)] :
    ContravariantClass { x : M // 0 < x } { x : M // 0 < x } (· + ·) (· ≤ ·) :=
  ⟨fun x y z h => Subtype.coe_le_coe.1 <| le_of_add_le_add_left h⟩
#align positive.contravariant_class_add_le Positive.contravariantClass_add_le

/- warning: positive.contravariant_class_swap_add_le -> Positive.contravariantClass_swap_add_le is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2))] [_inst_4 : ContravariantClass.{u1, u1} M M (Function.swap.{succ u1, succ u1, succ u1} M M (fun (ᾰ : M) (ᾰ : M) => M) (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) (LE.le.{u1} M (Preorder.toLE.{u1} M _inst_2))], ContravariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Function.swap.{succ u1, succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (fun (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) => Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Positive.Subtype.hasAdd.{u1} M _inst_1 _inst_2 _inst_3)))) (LE.le.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.hasLe.{u1} M (Preorder.toLE.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : Preorder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1394 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1396 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1394 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1396) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1409 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1411 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1409 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1411)] [_inst_4 : ContravariantClass.{u1, u1} M M (Function.swap.{succ u1, succ u1, succ u1} M M (fun (ᾰ : M) (ᾰ : M) => M) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1431 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1433 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1431 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1433)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1446 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1448 : M) => LE.le.{u1} M (Preorder.toLE.{u1} M _inst_2) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1446 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1448)], ContravariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Function.swap.{succ u1, succ u1, succ u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (fun (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (ᾰ : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1491 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1493 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Positive.instAddSubtypeLtToLTOfNatToOfNat0ToZero.{u1} M _inst_1 _inst_2 _inst_3)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1491 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1493)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1506 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1508 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => LE.le.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.le.{u1} M (Preorder.toLE.{u1} M _inst_2) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M _inst_2) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1506 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1508)
Case conversion may be inaccurate. Consider using '#align positive.contravariant_class_swap_add_le Positive.contravariantClass_swap_add_leₓ'. -/
instance contravariantClass_swap_add_le [ContravariantClass M M (swap (· + ·)) (· ≤ ·)] :
    ContravariantClass { x : M // 0 < x } { x : M // 0 < x } (swap (· + ·)) (· ≤ ·) :=
  ⟨fun x y z h => Subtype.coe_le_coe.1 <| le_of_add_le_add_right h⟩
#align positive.contravariant_class_swap_add_le Positive.contravariantClass_swap_add_le

end AddBasic

/- warning: positive.covariant_class_add_le -> Positive.covariantClass_add_le is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : PartialOrder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1)))) (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)))], CovariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Positive.Subtype.hasAdd.{u1} M _inst_1 (PartialOrder.toPreorder.{u1} M _inst_2) _inst_3))) (LE.le.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)) (Subtype.hasLe.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (OfNat.mk.{u1} M 0 (Zero.zero.{u1} M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))))) x)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : AddMonoid.{u1} M] [_inst_2 : PartialOrder.{u1} M] [_inst_3 : CovariantClass.{u1, u1} M M (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1553 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1555 : M) => HAdd.hAdd.{u1, u1, u1} M M M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M _inst_1))) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1553 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1555) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1568 : M) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1570 : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1568 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1570)], CovariantClass.{u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1610 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1612 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => HAdd.hAdd.{u1, u1, u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (instHAdd.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Positive.instAddSubtypeLtToLTOfNatToOfNat0ToZero.{u1} M _inst_1 (PartialOrder.toPreorder.{u1} M _inst_2) _inst_3)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1610 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1612) (fun (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1625 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1627 : Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) => LE.le.{u1} (Subtype.{succ u1} M (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) (Subtype.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (fun (x : M) => LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M _inst_2)) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M _inst_1))) x)) x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1625 x._@.Mathlib.Algebra.Order.Positive.Ring._hyg.1627)
Case conversion may be inaccurate. Consider using '#align positive.covariant_class_add_le Positive.covariantClass_add_leₓ'. -/
instance covariantClass_add_le [AddMonoid M] [PartialOrder M] [CovariantClass M M (· + ·) (· < ·)] :
    CovariantClass { x : M // 0 < x } { x : M // 0 < x } (· + ·) (· ≤ ·) :=
  ⟨fun x => StrictMono.monotone fun _ _ h => add_lt_add_left h _⟩
#align positive.covariant_class_add_le Positive.covariantClass_add_le

section Mul

variable [StrictOrderedSemiring R]

instance : Mul { x : R // 0 < x } :=
  ⟨fun x y => ⟨x * y, mul_pos x.2 y.2⟩⟩

/- warning: positive.coe_mul -> Positive.val_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] (x : Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) (y : Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)), Eq.{succ u1} R ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (coeBase.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (coeSubtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x))))) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) (Positive.Subtype.hasMul.{u1} R _inst_1)) x y)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (coeBase.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (coeSubtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x))))) x) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (coeBase.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (coeSubtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x))))) y))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] (x : Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x)) (y : Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x)), Eq.{succ u1} R (Subtype.val.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x) (HMul.hMul.{u1, u1, u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x)) (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x)) (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x)) (instHMul.{u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x)) (Positive.instMulSubtypeLtToLTToPreorderToPartialOrderOfNatToOfNat0ToZeroToMonoidWithZeroToSemiring.{u1} R _inst_1)) x y)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) (Subtype.val.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x) x) (Subtype.val.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x) y))
Case conversion may be inaccurate. Consider using '#align positive.coe_mul Positive.val_mulₓ'. -/
@[simp]
theorem val_mul (x y : { x : R // 0 < x }) : ↑(x * y) = (x * y : R) :=
  rfl
#align positive.coe_mul Positive.val_mul

instance : Pow { x : R // 0 < x } ℕ :=
  ⟨fun x n => ⟨x ^ n, pow_pos x.2 n⟩⟩

/- warning: positive.coe_pow -> Positive.val_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] (x : Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) (n : Nat), Eq.{succ u1} R ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (coeBase.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (coeSubtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x))))) (HPow.hPow.{u1, 0, u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) Nat (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) (instHPow.{u1, 0} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) Nat (Positive.Nat.hasPow.{u1} R _inst_1)) x n)) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (coeBase.{succ u1, succ u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x)) R (coeSubtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedCancelAddCommMonoid.toPartialOrder.{u1} R (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1)))))))) x))))) x) n)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : StrictOrderedSemiring.{u1} R] (x : Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x)) (n : Nat), Eq.{succ u1} R (Subtype.val.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x) (HPow.hPow.{u1, 0, u1} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x)) Nat (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x)) (instHPow.{u1, 0} (Subtype.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x)) Nat (Positive.instPowSubtypeLtToLTToPreorderToPartialOrderOfNatToOfNat0ToZeroToMonoidWithZeroToSemiringNat.{u1} R _inst_1)) x n)) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) (Subtype.val.{succ u1} R (fun (x : R) => LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (StrictOrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (StrictOrderedSemiring.toSemiring.{u1} R _inst_1))))) x) x) n)
Case conversion may be inaccurate. Consider using '#align positive.coe_pow Positive.val_powₓ'. -/
@[simp]
theorem val_pow (x : { x : R // 0 < x }) (n : ℕ) : ↑(x ^ n) = (x ^ n : R) :=
  rfl
#align positive.coe_pow Positive.val_pow

instance : Semigroup { x : R // 0 < x } :=
  Subtype.coe_injective.Semigroup coe val_mul

instance : Distrib { x : R // 0 < x } :=
  Subtype.coe_injective.Distrib _ coe_add val_mul

instance [Nontrivial R] : One { x : R // 0 < x } :=
  ⟨⟨1, one_pos⟩⟩

#print Positive.val_one /-
@[simp]
theorem val_one [Nontrivial R] : ((1 : { x : R // 0 < x }) : R) = 1 :=
  rfl
#align positive.coe_one Positive.val_one
-/

instance [Nontrivial R] : Monoid { x : R // 0 < x } :=
  Subtype.coe_injective.Monoid _ val_one val_mul val_pow

end Mul

section mul_comm

instance [StrictOrderedCommSemiring R] [Nontrivial R] : OrderedCommMonoid { x : R // 0 < x } :=
  { Subtype.partialOrder _,
    Subtype.coe_injective.CommMonoid (coe : { x : R // 0 < x } → R) val_one val_mul val_pow with
    mul_le_mul_left := fun x y hxy c =>
      Subtype.coe_le_coe.1 <| mul_le_mul_of_nonneg_left hxy c.2.le }

/-- If `R` is a nontrivial linear ordered commutative semiring, then `{x : R // 0 < x}` is a linear
ordered cancellative commutative monoid. -/
instance [LinearOrderedCommSemiring R] : LinearOrderedCancelCommMonoid { x : R // 0 < x } :=
  { Subtype.linearOrder _, Positive.Subtype.orderedCommMonoid with
    le_of_mul_le_mul_left := fun a b c h => Subtype.coe_le_coe.1 <| (mul_le_mul_left a.2).1 h }

end mul_comm

end Positive

