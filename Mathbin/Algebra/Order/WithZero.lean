/-
Copyright (c) 2020 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Johan Commelin, Patrick Massot

! This file was ported from Lean 3 source module algebra.order.with_zero
! leanprover-community/mathlib commit dc6c365e751e34d100e80fe6e314c3c3e0fd2988
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Hom.Equiv.Units.GroupWithZero
import Mathbin.Algebra.GroupWithZero.InjSurj
import Mathbin.Algebra.Order.Group.Units
import Mathbin.Algebra.Order.Monoid.Basic
import Mathbin.Algebra.Order.Monoid.WithZero.Defs
import Mathbin.Algebra.Order.Group.Instances
import Mathbin.Algebra.Order.Monoid.TypeTags

/-!
# Linearly ordered commutative groups and monoids with a zero element adjoined

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file sets up a special class of linearly ordered commutative monoids
that show up as the target of so-called “valuations” in algebraic number theory.

Usually, in the informal literature, these objects are constructed
by taking a linearly ordered commutative group Γ and formally adjoining a zero element: Γ ∪ {0}.

The disadvantage is that a type such as `nnreal` is not of that form,
whereas it is a very common target for valuations.
The solutions is to use a typeclass, and that is exactly what we do in this file.

Note that to avoid issues with import cycles, `linear_ordered_comm_monoid_with_zero` is defined
in another file. However, the lemmas about it are stated here.
-/


#print LinearOrderedCommGroupWithZero /-
/-- A linearly ordered commutative group with a zero element. -/
@[protect_proj]
class LinearOrderedCommGroupWithZero (α : Type _) extends LinearOrderedCommMonoidWithZero α,
  CommGroupWithZero α
#align linear_ordered_comm_group_with_zero LinearOrderedCommGroupWithZero
-/

variable {α : Type _}

variable {a b c d x y z : α}

instance [LinearOrderedAddCommMonoidWithTop α] :
    LinearOrderedCommMonoidWithZero (Multiplicative αᵒᵈ) :=
  { Multiplicative.orderedCommMonoid,
    Multiplicative.linearOrder with
    zero := Multiplicative.ofAdd (⊤ : α)
    zero_mul := top_add
    mul_zero := add_top
    zero_le_one := (le_top : (0 : α) ≤ ⊤) }

instance [LinearOrderedAddCommGroupWithTop α] :
    LinearOrderedCommGroupWithZero (Multiplicative αᵒᵈ) :=
  { Multiplicative.divInvMonoid, instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual,
    instNontrivialMultiplicative with
    inv_zero := LinearOrderedAddCommGroupWithTop.neg_top
    mul_inv_cancel := LinearOrderedAddCommGroupWithTop.add_neg_cancel }

instance [LinearOrderedCommMonoid α] : LinearOrderedCommMonoidWithZero (WithZero α) :=
  { WithZero.linearOrder,
    WithZero.commMonoidWithZero with
    mul_le_mul_left := fun x y => mul_le_mul_left'
    zero_le_one := WithZero.zero_le _ }

instance [LinearOrderedCommGroup α] : LinearOrderedCommGroupWithZero (WithZero α) :=
  { instLinearOrderedCommMonoidWithZeroWithZero, WithZero.commGroupWithZero with }

section LinearOrderedCommMonoid

variable [LinearOrderedCommMonoidWithZero α]

/- warning: function.injective.linear_ordered_comm_monoid_with_zero -> Function.Injective.linearOrderedCommMonoidWithZero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α] {β : Type.{u2}} [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Pow.{u2, 0} β Nat] [_inst_6 : HasSup.{u2} β] [_inst_7 : HasInf.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β _inst_3)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1))))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_5) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1))))) (f x) n)) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasSup.sup.{u2} β _inst_6 x y)) (LinearOrder.max.{u1} α (LinearOrderedCommMonoid.toLinearOrder.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1)) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasInf.inf.{u2} β _inst_7 x y)) (LinearOrder.min.{u1} α (LinearOrderedCommMonoid.toLinearOrder.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1)) (f x) (f y))) -> (LinearOrderedCommMonoidWithZero.{u2} β)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α] {β : Type.{u2}} [_inst_2 : Zero.{u2} β] [_inst_3 : One.{u2} β] [_inst_4 : Mul.{u2} β] [_inst_5 : Pow.{u2, 0} β Nat] [_inst_6 : HasSup.{u2} β] [_inst_7 : HasInf.{u2} β] (f : β -> α), (Function.Injective.{succ u2, succ u1} β α f) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α _inst_1)))) -> (Eq.{succ u1} α (f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β _inst_3))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Monoid.toOne.{u1} α (MonoidWithZero.toMonoid.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1))))))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β _inst_4) x y)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1)))))) (f x) (f y))) -> (forall (x : β) (n : Nat), Eq.{succ u1} α (f (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat _inst_5) x n)) (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat (Monoid.Pow.{u1} α (MonoidWithZero.toMonoid.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1))))) (f x) n)) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasSup.sup.{u2} β _inst_6 x y)) (Max.max.{u1} α (LinearOrder.toMax.{u1} α (LinearOrderedCommMonoid.toLinearOrder.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))) (f x) (f y))) -> (forall (x : β) (y : β), Eq.{succ u1} α (f (HasInf.inf.{u2} β _inst_7 x y)) (Min.min.{u1} α (LinearOrder.toMin.{u1} α (LinearOrderedCommMonoid.toLinearOrder.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))) (f x) (f y))) -> (LinearOrderedCommMonoidWithZero.{u2} β)
Case conversion may be inaccurate. Consider using '#align function.injective.linear_ordered_comm_monoid_with_zero Function.Injective.linearOrderedCommMonoidWithZeroₓ'. -/
/-
The following facts are true more generally in a (linearly) ordered commutative monoid.
-/
/-- Pullback a `linear_ordered_comm_monoid_with_zero` under an injective map.
See note [reducible non-instances]. -/
@[reducible]
def Function.Injective.linearOrderedCommMonoidWithZero {β : Type _} [Zero β] [One β] [Mul β]
    [Pow β ℕ] [HasSup β] [HasInf β] (f : β → α) (hf : Function.Injective f) (zero : f 0 = 0)
    (one : f 1 = 1) (mul : ∀ x y, f (x * y) = f x * f y) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (hsup : ∀ x y, f (x ⊔ y) = max (f x) (f y)) (hinf : ∀ x y, f (x ⊓ y) = min (f x) (f y)) :
    LinearOrderedCommMonoidWithZero β :=
  { LinearOrder.lift f hf hsup hinf, hf.OrderedCommMonoid f one mul npow,
    hf.CommMonoidWithZero f zero one mul npow with
    zero_le_one :=
      show f 0 ≤ f 1 by simp only [zero, one, LinearOrderedCommMonoidWithZero.zero_le_one] }
#align function.injective.linear_ordered_comm_monoid_with_zero Function.Injective.linearOrderedCommMonoidWithZero

/- warning: zero_le' -> zero_le' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α], LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1)))))))) a
but is expected to have type
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α], LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α _inst_1))) a
Case conversion may be inaccurate. Consider using '#align zero_le' zero_le'ₓ'. -/
@[simp]
theorem zero_le' : 0 ≤ a := by simpa only [mul_zero, mul_one] using mul_le_mul_left' zero_le_one a
#align zero_le' zero_le'

/- warning: not_lt_zero' -> not_lt_zero' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α], Not (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))))) a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α], Not (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))))) a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α _inst_1))))
Case conversion may be inaccurate. Consider using '#align not_lt_zero' not_lt_zero'ₓ'. -/
@[simp]
theorem not_lt_zero' : ¬a < 0 :=
  not_lt_of_le zero_le'
#align not_lt_zero' not_lt_zero'

/- warning: le_zero_iff -> le_zero_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α], Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))))) a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1))))))))) (Eq.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α], Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))))) a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α _inst_1)))) (Eq.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α _inst_1))))
Case conversion may be inaccurate. Consider using '#align le_zero_iff le_zero_iffₓ'. -/
@[simp]
theorem le_zero_iff : a ≤ 0 ↔ a = 0 :=
  ⟨fun h => le_antisymm h zero_le', fun h => h ▸ le_rfl⟩
#align le_zero_iff le_zero_iff

/- warning: zero_lt_iff -> zero_lt_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α], Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1)))))))) a) (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α], Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α _inst_1))) a) (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α _inst_1))))
Case conversion may be inaccurate. Consider using '#align zero_lt_iff zero_lt_iffₓ'. -/
theorem zero_lt_iff : 0 < a ↔ a ≠ 0 :=
  ⟨ne_of_gt, fun h => lt_of_le_of_ne zero_le' h.symm⟩
#align zero_lt_iff zero_lt_iff

/- warning: ne_zero_of_lt -> ne_zero_of_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))))) b a) -> (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (CommMonoidWithZero.toMonoidWithZero.{u1} α (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{u1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommMonoidWithZero.{u1} α], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α _inst_1))))) b a) -> (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α _inst_1))))
Case conversion may be inaccurate. Consider using '#align ne_zero_of_lt ne_zero_of_ltₓ'. -/
theorem ne_zero_of_lt (h : b < a) : a ≠ 0 := fun h1 => not_lt_zero' <| show b < 0 from h1 ▸ h
#align ne_zero_of_lt ne_zero_of_lt

instance : LinearOrderedAddCommMonoidWithTop (Additive αᵒᵈ) :=
  { Additive.orderedAddCommMonoid,
    Additive.linearOrder with
    top := (0 : α)
    top_add' := fun a => (zero_mul a : (0 : α) * a = 0)
    le_top := fun _ => zero_le' }

end LinearOrderedCommMonoid

variable [LinearOrderedCommGroupWithZero α]

/- warning: mul_le_one₀ -> mul_le_one₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) b (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a b) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroupWithZero.toDivisionCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) b (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroupWithZero.toDivisionCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a b) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroupWithZero.toDivisionCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align mul_le_one₀ mul_le_one₀ₓ'. -/
-- TODO: Do we really need the following two?
/-- Alias of `mul_le_one'` for unification. -/
theorem mul_le_one₀ (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1 :=
  mul_le_one' ha hb
#align mul_le_one₀ mul_le_one₀

/- warning: one_le_mul₀ -> one_le_mul₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))) a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a b))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroupWithZero.toDivisionCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))) a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroupWithZero.toDivisionCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroupWithZero.toDivisionCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a b))
Case conversion may be inaccurate. Consider using '#align one_le_mul₀ one_le_mul₀ₓ'. -/
/-- Alias of `one_le_mul'` for unification. -/
theorem one_le_mul₀ (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b :=
  one_le_mul ha hb
#align one_le_mul₀ one_le_mul₀

/- warning: le_of_le_mul_right -> le_of_le_mul_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b)
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b)
Case conversion may be inaccurate. Consider using '#align le_of_le_mul_right le_of_le_mul_rightₓ'. -/
theorem le_of_le_mul_right (h : c ≠ 0) (hab : a * c ≤ b * c) : a ≤ b := by
  simpa only [mul_inv_cancel_right₀ h] using mul_le_mul_right' hab c⁻¹
#align le_of_le_mul_right le_of_le_mul_right

/- warning: le_mul_inv_of_mul_le -> le_mul_inv_of_mul_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) c)))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) c)))
Case conversion may be inaccurate. Consider using '#align le_mul_inv_of_mul_le le_mul_inv_of_mul_leₓ'. -/
theorem le_mul_inv_of_mul_le (h : c ≠ 0) (hab : a * c ≤ b) : a ≤ b * c⁻¹ :=
  le_of_le_mul_right h (by simpa [h] using hab)
#align le_mul_inv_of_mul_le le_mul_inv_of_mul_le

/- warning: mul_inv_le_of_le_mul -> mul_inv_le_of_le_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) c)) b)
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) c)) b)
Case conversion may be inaccurate. Consider using '#align mul_inv_le_of_le_mul mul_inv_le_of_le_mulₓ'. -/
theorem mul_inv_le_of_le_mul (hab : a ≤ b * c) : a * c⁻¹ ≤ b :=
  by
  by_cases h : c = 0
  · simp [h]
  · exact le_of_le_mul_right h (by simpa [h] using hab)
#align mul_inv_le_of_le_mul mul_inv_le_of_le_mul

/- warning: inv_le_one₀ -> inv_le_one₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) a) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))) a))
but is expected to have type
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) a) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroupWithZero.toDivisionCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroupWithZero.toDivisionCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))) a))
Case conversion may be inaccurate. Consider using '#align inv_le_one₀ inv_le_one₀ₓ'. -/
theorem inv_le_one₀ (ha : a ≠ 0) : a⁻¹ ≤ 1 ↔ 1 ≤ a :=
  @inv_le_one' _ _ _ _ <| Units.mk0 a ha
#align inv_le_one₀ inv_le_one₀

/- warning: one_le_inv₀ -> one_le_inv₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))))
but is expected to have type
  forall {α : Type.{u1}} {a : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroupWithZero.toDivisionCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))) (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (InvOneClass.toOne.{u1} α (DivInvOneMonoid.toInvOneClass.{u1} α (DivisionMonoid.toDivInvOneMonoid.{u1} α (DivisionCommMonoid.toDivisionMonoid.{u1} α (CommGroupWithZero.toDivisionCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))))
Case conversion may be inaccurate. Consider using '#align one_le_inv₀ one_le_inv₀ₓ'. -/
theorem one_le_inv₀ (ha : a ≠ 0) : 1 ≤ a⁻¹ ↔ a ≤ 1 :=
  @one_le_inv' _ _ _ _ <| Units.mk0 a ha
#align one_le_inv₀ one_le_inv₀

/- warning: le_mul_inv_iff₀ -> le_mul_inv_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) c))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) c))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) b))
Case conversion may be inaccurate. Consider using '#align le_mul_inv_iff₀ le_mul_inv_iff₀ₓ'. -/
theorem le_mul_inv_iff₀ (hc : c ≠ 0) : a ≤ b * c⁻¹ ↔ a * c ≤ b :=
  ⟨fun h => inv_inv c ▸ mul_inv_le_of_le_mul h, le_mul_inv_of_mul_le hc⟩
#align le_mul_inv_iff₀ le_mul_inv_iff₀

/- warning: mul_inv_le_iff₀ -> mul_inv_le_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) c)) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c)))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) c)) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c)))
Case conversion may be inaccurate. Consider using '#align mul_inv_le_iff₀ mul_inv_le_iff₀ₓ'. -/
theorem mul_inv_le_iff₀ (hc : c ≠ 0) : a * c⁻¹ ≤ b ↔ a ≤ b * c :=
  ⟨fun h => inv_inv c ▸ le_mul_inv_of_mul_le (inv_ne_zero hc) h, mul_inv_le_of_le_mul⟩
#align mul_inv_le_iff₀ mul_inv_le_iff₀

/- warning: div_le_div₀ -> div_le_div₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] (a : α) (b : α) (c : α) (d : α), (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Ne.{succ u1} α d (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) b)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) c (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) d))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a d) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) c b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] (a : α) (b : α) (c : α) (d : α), (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Ne.{succ u1} α d (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) b)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) c (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) d))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a d) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) c b)))
Case conversion may be inaccurate. Consider using '#align div_le_div₀ div_le_div₀ₓ'. -/
theorem div_le_div₀ (a b c d : α) (hb : b ≠ 0) (hd : d ≠ 0) : a * b⁻¹ ≤ c * d⁻¹ ↔ a * d ≤ c * b :=
  if ha : a = 0 then by simp [ha]
  else
    if hc : c = 0 then by simp [inv_ne_zero hb, hc, hd]
    else
      show
        Units.mk0 a ha * (Units.mk0 b hb)⁻¹ ≤ Units.mk0 c hc * (Units.mk0 d hd)⁻¹ ↔
          Units.mk0 a ha * Units.mk0 d hd ≤ Units.mk0 c hc * Units.mk0 b hb
        from mul_inv_le_mul_inv_iff'
#align div_le_div₀ div_le_div₀

/- warning: units.zero_lt -> Units.zero_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] (u : Units.{u1} α (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))), LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} α (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))) α (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} α (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))) α (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} α (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))) α (coeBase.{succ u1, succ u1} (Units.{u1} α (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))) α (Units.hasCoe.{u1} α (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))) u)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] (u : Units.{u1} α (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))), LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))) (Units.val.{u1} α (MonoidWithZero.toMonoid.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) u)
Case conversion may be inaccurate. Consider using '#align units.zero_lt Units.zero_ltₓ'. -/
@[simp]
theorem Units.zero_lt (u : αˣ) : (0 : α) < u :=
  zero_lt_iff.2 <| u.NeZero
#align units.zero_lt Units.zero_lt

/- warning: mul_lt_mul_of_lt_of_le₀ -> mul_lt_mul_of_lt_of_le₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} {d : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) c d) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b d))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} {d : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) c d) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b d))
Case conversion may be inaccurate. Consider using '#align mul_lt_mul_of_lt_of_le₀ mul_lt_mul_of_lt_of_le₀ₓ'. -/
theorem mul_lt_mul_of_lt_of_le₀ (hab : a ≤ b) (hb : b ≠ 0) (hcd : c < d) : a * c < b * d :=
  have hd : d ≠ 0 := ne_zero_of_lt hcd
  if ha : a = 0 then by
    rw [ha, zero_mul, zero_lt_iff]
    exact mul_ne_zero hb hd
  else
    if hc : c = 0 then by
      rw [hc, mul_zero, zero_lt_iff]
      exact mul_ne_zero hb hd
    else
      show Units.mk0 a ha * Units.mk0 c hc < Units.mk0 b hb * Units.mk0 d hd from
        mul_lt_mul_of_le_of_lt hab hcd
#align mul_lt_mul_of_lt_of_le₀ mul_lt_mul_of_lt_of_le₀

/- warning: mul_lt_mul₀ -> mul_lt_mul₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} {d : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) c d) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b d))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} {d : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) c d) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b d))
Case conversion may be inaccurate. Consider using '#align mul_lt_mul₀ mul_lt_mul₀ₓ'. -/
theorem mul_lt_mul₀ (hab : a < b) (hcd : c < d) : a * c < b * d :=
  mul_lt_mul_of_lt_of_le₀ hab.le (ne_zero_of_lt hab) hcd
#align mul_lt_mul₀ mul_lt_mul₀

/- warning: mul_inv_lt_of_lt_mul₀ -> mul_inv_lt_of_lt_mul₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {x : α} {y : α} {z : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) x (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) y z)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) x (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) z)) y)
but is expected to have type
  forall {α : Type.{u1}} {x : α} {y : α} {z : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) x (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) y z)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) x (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) z)) y)
Case conversion may be inaccurate. Consider using '#align mul_inv_lt_of_lt_mul₀ mul_inv_lt_of_lt_mul₀ₓ'. -/
theorem mul_inv_lt_of_lt_mul₀ (h : x < y * z) : x * z⁻¹ < y :=
  by
  contrapose! h
  simpa only [inv_inv] using mul_inv_le_of_le_mul h
#align mul_inv_lt_of_lt_mul₀ mul_inv_lt_of_lt_mul₀

/- warning: inv_mul_lt_of_lt_mul₀ -> inv_mul_lt_of_lt_mul₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {x : α} {y : α} {z : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) x (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) y z)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) y) x) z)
but is expected to have type
  forall {α : Type.{u1}} {x : α} {y : α} {z : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) x (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) y z)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) y) x) z)
Case conversion may be inaccurate. Consider using '#align inv_mul_lt_of_lt_mul₀ inv_mul_lt_of_lt_mul₀ₓ'. -/
theorem inv_mul_lt_of_lt_mul₀ (h : x < y * z) : y⁻¹ * x < z :=
  by
  rw [mul_comm] at *
  exact mul_inv_lt_of_lt_mul₀ h
#align inv_mul_lt_of_lt_mul₀ inv_mul_lt_of_lt_mul₀

/- warning: mul_lt_right₀ -> mul_lt_right₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] (c : α), (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b) -> (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] (c : α), (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b) -> (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c))
Case conversion may be inaccurate. Consider using '#align mul_lt_right₀ mul_lt_right₀ₓ'. -/
theorem mul_lt_right₀ (c : α) (h : a < b) (hc : c ≠ 0) : a * c < b * c :=
  by
  contrapose! h
  exact le_of_le_mul_right hc h
#align mul_lt_right₀ mul_lt_right₀

/- warning: inv_lt_inv₀ -> inv_lt_inv₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) a) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) b)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) b a))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) a) (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) b)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) b a))
Case conversion may be inaccurate. Consider using '#align inv_lt_inv₀ inv_lt_inv₀ₓ'. -/
theorem inv_lt_inv₀ (ha : a ≠ 0) (hb : b ≠ 0) : a⁻¹ < b⁻¹ ↔ b < a :=
  show (Units.mk0 a ha)⁻¹ < (Units.mk0 b hb)⁻¹ ↔ Units.mk0 b hb < Units.mk0 a ha from inv_lt_inv_iff
#align inv_lt_inv₀ inv_lt_inv₀

/- warning: inv_le_inv₀ -> inv_le_inv₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) a) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) b)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) b a))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) a) (Inv.inv.{u1} α (LinearOrderedCommGroupWithZero.toInv.{u1} α _inst_1) b)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) b a))
Case conversion may be inaccurate. Consider using '#align inv_le_inv₀ inv_le_inv₀ₓ'. -/
theorem inv_le_inv₀ (ha : a ≠ 0) (hb : b ≠ 0) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a :=
  show (Units.mk0 a ha)⁻¹ ≤ (Units.mk0 b hb)⁻¹ ↔ Units.mk0 b hb ≤ Units.mk0 a ha from inv_le_inv_iff
#align inv_le_inv₀ inv_le_inv₀

/- warning: lt_of_mul_lt_mul_of_le₀ -> lt_of_mul_lt_mul_of_le₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} {d : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a b) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) c d)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) b d)
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} {d : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a b) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) c d)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) b d)
Case conversion may be inaccurate. Consider using '#align lt_of_mul_lt_mul_of_le₀ lt_of_mul_lt_mul_of_le₀ₓ'. -/
theorem lt_of_mul_lt_mul_of_le₀ (h : a * b < c * d) (hc : 0 < c) (hh : c ≤ a) : b < d :=
  by
  have ha : a ≠ 0 := ne_of_gt (lt_of_lt_of_le hc hh)
  simp_rw [← inv_le_inv₀ ha (ne_of_gt hc)] at hh
  have := mul_lt_mul_of_lt_of_le₀ hh (inv_ne_zero (ne_of_gt hc)) h
  simpa [inv_mul_cancel_left₀ ha, inv_mul_cancel_left₀ (ne_of_gt hc)] using this
#align lt_of_mul_lt_mul_of_le₀ lt_of_mul_lt_mul_of_le₀

/- warning: mul_le_mul_right₀ -> mul_le_mul_right₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b))
Case conversion may be inaccurate. Consider using '#align mul_le_mul_right₀ mul_le_mul_right₀ₓ'. -/
theorem mul_le_mul_right₀ (hc : c ≠ 0) : a * c ≤ b * c ↔ a ≤ b :=
  ⟨le_of_le_mul_right hc, fun hab => mul_le_mul_right' hab _⟩
#align mul_le_mul_right₀ mul_le_mul_right₀

/- warning: mul_le_mul_left₀ -> mul_le_mul_left₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a b) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) b c))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a b) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) b c))
Case conversion may be inaccurate. Consider using '#align mul_le_mul_left₀ mul_le_mul_left₀ₓ'. -/
theorem mul_le_mul_left₀ (ha : a ≠ 0) : a * b ≤ a * c ↔ b ≤ c :=
  by
  simp only [mul_comm a]
  exact mul_le_mul_right₀ ha
#align mul_le_mul_left₀ mul_le_mul_left₀

/- warning: div_le_div_right₀ -> div_le_div_right₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))) a c) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (LinearOrderedCommGroupWithZero.toDiv.{u1} α _inst_1)) a c) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (LinearOrderedCommGroupWithZero.toDiv.{u1} α _inst_1)) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a b))
Case conversion may be inaccurate. Consider using '#align div_le_div_right₀ div_le_div_right₀ₓ'. -/
theorem div_le_div_right₀ (hc : c ≠ 0) : a / c ≤ b / c ↔ a ≤ b := by
  rw [div_eq_mul_inv, div_eq_mul_inv, mul_le_mul_right₀ (inv_ne_zero hc)]
#align div_le_div_right₀ div_le_div_right₀

/- warning: div_le_div_left₀ -> div_le_div_left₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))) a b) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) c b))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (LinearOrderedCommGroupWithZero.toDiv.{u1} α _inst_1)) a b) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (LinearOrderedCommGroupWithZero.toDiv.{u1} α _inst_1)) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) c b))
Case conversion may be inaccurate. Consider using '#align div_le_div_left₀ div_le_div_left₀ₓ'. -/
theorem div_le_div_left₀ (ha : a ≠ 0) (hb : b ≠ 0) (hc : c ≠ 0) : a / b ≤ a / c ↔ c ≤ b := by
  simp only [div_eq_mul_inv, mul_le_mul_left₀ ha, inv_le_inv₀ hb hc]
#align div_le_div_left₀ div_le_div_left₀

/- warning: le_div_iff₀ -> le_div_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (LinearOrderedCommGroupWithZero.toDiv.{u1} α _inst_1)) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) a c) b))
Case conversion may be inaccurate. Consider using '#align le_div_iff₀ le_div_iff₀ₓ'. -/
theorem le_div_iff₀ (hc : c ≠ 0) : a ≤ b / c ↔ a * c ≤ b := by
  rw [div_eq_mul_inv, le_mul_inv_iff₀ hc]
#align le_div_iff₀ le_div_iff₀

/- warning: div_le_iff₀ -> div_le_iff₀ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))) a c) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c)))
but is expected to have type
  forall {α : Type.{u1}} {a : α} {b : α} {c : α} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α], (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (LinearOrderedCommGroupWithZero.toDiv.{u1} α _inst_1)) a c) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toMul.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))))))) b c)))
Case conversion may be inaccurate. Consider using '#align div_le_iff₀ div_le_iff₀ₓ'. -/
theorem div_le_iff₀ (hc : c ≠ 0) : a / c ≤ b ↔ a ≤ b * c := by
  rw [div_eq_mul_inv, mul_inv_le_iff₀ hc]
#align div_le_iff₀ div_le_iff₀

/- warning: order_iso.mul_left₀' -> OrderIso.mulLeft₀' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (OrderIso.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (OrderIso.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align order_iso.mul_left₀' OrderIso.mulLeft₀'ₓ'. -/
/-- `equiv.mul_left₀` as an order_iso on a `linear_ordered_comm_group_with_zero.`.

Note that `order_iso.mul_left₀` refers to the `linear_ordered_field` version. -/
@[simps (config := { simpRhs := true }) apply toEquiv]
def OrderIso.mulLeft₀' {a : α} (ha : a ≠ 0) : α ≃o α :=
  { Equiv.mulLeft₀ a ha with map_rel_iff' := fun x y => mul_le_mul_left₀ ha }
#align order_iso.mul_left₀' OrderIso.mulLeft₀'

/- warning: order_iso.mul_left₀'_symm -> OrderIso.mulLeft₀'_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] {a : α} (ha : Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))), Eq.{succ u1} (OrderIso.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))))) (OrderIso.symm.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OrderIso.mulLeft₀'.{u1} α _inst_1 a ha)) (OrderIso.mulLeft₀'.{u1} α _inst_1 (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) a) (inv_ne_zero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)) a ha))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] {a : α} (ha : Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))), Eq.{succ u1} (OrderIso.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))))) (OrderIso.symm.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OrderIso.mulLeft₀'.{u1} α _inst_1 a ha)) (OrderIso.mulLeft₀'.{u1} α _inst_1 (Inv.inv.{u1} α (GroupWithZero.toInv.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))) a) (inv_ne_zero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)) a ha))
Case conversion may be inaccurate. Consider using '#align order_iso.mul_left₀'_symm OrderIso.mulLeft₀'_symmₓ'. -/
theorem OrderIso.mulLeft₀'_symm {a : α} (ha : a ≠ 0) :
    (OrderIso.mulLeft₀' ha).symm = OrderIso.mulLeft₀' (inv_ne_zero ha) :=
  by
  ext
  rfl
#align order_iso.mul_left₀'_symm OrderIso.mulLeft₀'_symm

/- warning: order_iso.mul_right₀' -> OrderIso.mulRight₀' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))) -> (OrderIso.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] {a : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))) -> (OrderIso.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align order_iso.mul_right₀' OrderIso.mulRight₀'ₓ'. -/
/-- `equiv.mul_right₀` as an order_iso on a `linear_ordered_comm_group_with_zero.`.

Note that `order_iso.mul_right₀` refers to the `linear_ordered_field` version. -/
@[simps (config := { simpRhs := true }) apply toEquiv]
def OrderIso.mulRight₀' {a : α} (ha : a ≠ 0) : α ≃o α :=
  { Equiv.mulRight₀ a ha with map_rel_iff' := fun _ _ => mul_le_mul_right₀ ha }
#align order_iso.mul_right₀' OrderIso.mulRight₀'

/- warning: order_iso.mul_right₀'_symm -> OrderIso.mulRight₀'_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] {a : α} (ha : Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (MulZeroOneClass.toMulZeroClass.{u1} α (MonoidWithZero.toMulZeroOneClass.{u1} α (GroupWithZero.toMonoidWithZero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))))))))), Eq.{succ u1} (OrderIso.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))))) (OrderIso.symm.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OrderIso.mulRight₀'.{u1} α _inst_1 a ha)) (OrderIso.mulRight₀'.{u1} α _inst_1 (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)))) a) (inv_ne_zero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)) a ha))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : LinearOrderedCommGroupWithZero.{u1} α] {a : α} (ha : Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (LinearOrderedCommMonoidWithZero.toZero.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))), Eq.{succ u1} (OrderIso.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1))))))) (OrderIso.symm.{u1, u1} α α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedCommMonoid.toPartialOrder.{u1} α (LinearOrderedCommMonoid.toOrderedCommMonoid.{u1} α (LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid.{u1} α (LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero.{u1} α _inst_1)))))) (OrderIso.mulRight₀'.{u1} α _inst_1 a ha)) (OrderIso.mulRight₀'.{u1} α _inst_1 (Inv.inv.{u1} α (GroupWithZero.toInv.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1))) a) (inv_ne_zero.{u1} α (CommGroupWithZero.toGroupWithZero.{u1} α (LinearOrderedCommGroupWithZero.toCommGroupWithZero.{u1} α _inst_1)) a ha))
Case conversion may be inaccurate. Consider using '#align order_iso.mul_right₀'_symm OrderIso.mulRight₀'_symmₓ'. -/
theorem OrderIso.mulRight₀'_symm {a : α} (ha : a ≠ 0) :
    (OrderIso.mulRight₀' ha).symm = OrderIso.mulRight₀' (inv_ne_zero ha) :=
  by
  ext
  rfl
#align order_iso.mul_right₀'_symm OrderIso.mulRight₀'_symm

instance : LinearOrderedAddCommGroupWithTop (Additive αᵒᵈ) :=
  { Additive.subNegMonoid, instLinearOrderedAddCommMonoidWithTopAdditiveOrderDual,
    instNontrivialAdditive with
    neg_top := inv_zero
    add_neg_cancel := fun a ha => mul_inv_cancel ha }

