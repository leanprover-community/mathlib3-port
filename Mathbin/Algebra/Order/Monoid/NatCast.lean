/-
Copyright (c) 2016 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Leonardo de Moura, Mario Carneiro, Johannes Hölzl, Yuyang Zhao

! This file was ported from Lean 3 source module algebra.order.monoid.nat_cast
! leanprover-community/mathlib commit f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.Monoid.Lemmas
import Mathbin.Algebra.Order.ZeroLeOne
import Mathbin.Data.Nat.Cast.Defs

/-!
# Order of numerials in an `add_monoid_with_one`.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
-/


variable {α : Type _}

open Function

/- warning: lt_add_one -> lt_add_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : One.{u1} α] [_inst_2 : AddZeroClass.{u1} α] [_inst_3 : PartialOrder.{u1} α] [_inst_4 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α _inst_2) _inst_1 (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3))] [_inst_5 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α _inst_2) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α _inst_1)))] [_inst_6 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α _inst_2))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3)))] (a : α), LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α _inst_2)) a (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α _inst_1))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : One.{u1} α] [_inst_2 : AddZeroClass.{u1} α] [_inst_3 : PartialOrder.{u1} α] [_inst_4 : ZeroLEOneClass.{u1} α (AddZeroClass.toZero.{u1} α _inst_2) _inst_1 (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3))] [_inst_5 : NeZero.{u1} α (AddZeroClass.toZero.{u1} α _inst_2) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α _inst_1))] [_inst_6 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.36 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.38 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.36 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.38) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.51 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.53 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.51 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.53)] (a : α), LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α _inst_2)) a (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α _inst_1)))
Case conversion may be inaccurate. Consider using '#align lt_add_one lt_add_oneₓ'. -/
theorem lt_add_one [One α] [AddZeroClass α] [PartialOrder α] [ZeroLEOneClass α] [NeZero (1 : α)]
    [CovariantClass α α (· + ·) (· < ·)] (a : α) : a < a + 1 :=
  lt_add_of_pos_right _ zero_lt_one
#align lt_add_one lt_add_one

/- warning: lt_one_add -> lt_one_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : One.{u1} α] [_inst_2 : AddZeroClass.{u1} α] [_inst_3 : PartialOrder.{u1} α] [_inst_4 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α _inst_2) _inst_1 (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3))] [_inst_5 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α _inst_2) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α _inst_1)))] [_inst_6 : CovariantClass.{u1, u1} α α (Function.swap.{succ u1, succ u1, succ u1} α α (fun (ᾰ : α) (ᾰ : α) => α) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α _inst_2)))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3)))] (a : α), LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α _inst_1))) a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : One.{u1} α] [_inst_2 : AddZeroClass.{u1} α] [_inst_3 : PartialOrder.{u1} α] [_inst_4 : ZeroLEOneClass.{u1} α (AddZeroClass.toZero.{u1} α _inst_2) _inst_1 (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3))] [_inst_5 : NeZero.{u1} α (AddZeroClass.toZero.{u1} α _inst_2) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α _inst_1))] [_inst_6 : CovariantClass.{u1, u1} α α (Function.swap.{succ u1, succ u1, succ u1} α α (fun (ᾰ : α) (ᾰ : α) => α) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.107 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.109 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.107 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.109)) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.122 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.124 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.122 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.124)] (a : α), LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_3)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α _inst_1)) a)
Case conversion may be inaccurate. Consider using '#align lt_one_add lt_one_addₓ'. -/
theorem lt_one_add [One α] [AddZeroClass α] [PartialOrder α] [ZeroLEOneClass α] [NeZero (1 : α)]
    [CovariantClass α α (swap (· + ·)) (· < ·)] (a : α) : a < 1 + a :=
  lt_add_of_pos_left _ zero_lt_one
#align lt_one_add lt_one_add

variable [AddMonoidWithOne α]

/- warning: zero_le_two -> zero_le_two is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α _inst_2)] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2))], LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α _inst_2)] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.172 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.174 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.172 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.174) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.187 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.189 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.187 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.189)], LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 2 (instOfNat.{u1} α 2 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align zero_le_two zero_le_twoₓ'. -/
theorem zero_le_two [Preorder α] [ZeroLEOneClass α] [CovariantClass α α (· + ·) (· ≤ ·)] :
    (0 : α) ≤ 2 :=
  add_nonneg zero_le_one zero_le_one
#align zero_le_two zero_le_two

/- warning: zero_le_three -> zero_le_three is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α _inst_2)] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2))], LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 3 (OfNat.mk.{u1} α 3 (bit1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α _inst_2)] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.265 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.267 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.265 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.267) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.280 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.282 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.280 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.282)], LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 3 (instOfNat.{u1} α 3 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))
Case conversion may be inaccurate. Consider using '#align zero_le_three zero_le_threeₓ'. -/
theorem zero_le_three [Preorder α] [ZeroLEOneClass α] [CovariantClass α α (· + ·) (· ≤ ·)] :
    (0 : α) ≤ 3 :=
  add_nonneg zero_le_two zero_le_one
#align zero_le_three zero_le_three

/- warning: zero_le_four -> zero_le_four is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α _inst_2)] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2))], LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 4 (OfNat.mk.{u1} α 4 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α _inst_2)] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.358 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.360 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.358 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.360) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.373 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.375 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.373 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.375)], LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 4 (instOfNat.{u1} α 4 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))
Case conversion may be inaccurate. Consider using '#align zero_le_four zero_le_fourₓ'. -/
theorem zero_le_four [Preorder α] [ZeroLEOneClass α] [CovariantClass α α (· + ·) (· ≤ ·)] :
    (0 : α) ≤ 4 :=
  add_nonneg zero_le_two zero_le_two
#align zero_le_four zero_le_four

/- warning: one_le_two -> one_le_two is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : LE.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) _inst_2] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α _inst_2)], LE.le.{u1} α _inst_2 (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : LE.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) _inst_2] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.451 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.453 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.451 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.453) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.466 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.468 : α) => LE.le.{u1} α _inst_2 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.466 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.468)], LE.le.{u1} α _inst_2 (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 2 (instOfNat.{u1} α 2 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align one_le_two one_le_twoₓ'. -/
theorem one_le_two [LE α] [ZeroLEOneClass α] [CovariantClass α α (· + ·) (· ≤ ·)] : (1 : α) ≤ 2 :=
  calc
    1 = 1 + 0 := (add_zero 1).symm
    _ ≤ 1 + 1 := add_le_add_left zero_le_one _
    
#align one_le_two one_le_two

/- warning: one_le_two' -> one_le_two' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : LE.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) _inst_2] [_inst_4 : CovariantClass.{u1, u1} α α (Function.swap.{succ u1, succ u1, succ u1} α α (fun (ᾰ : α) (ᾰ : α) => α) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (LE.le.{u1} α _inst_2)], LE.le.{u1} α _inst_2 (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : LE.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) _inst_2] [_inst_4 : CovariantClass.{u1, u1} α α (Function.swap.{succ u1, succ u1, succ u1} α α (fun (ᾰ : α) (ᾰ : α) => α) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.556 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.558 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.556 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.558)) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.571 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.573 : α) => LE.le.{u1} α _inst_2 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.571 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.573)], LE.le.{u1} α _inst_2 (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 2 (instOfNat.{u1} α 2 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align one_le_two' one_le_two'ₓ'. -/
theorem one_le_two' [LE α] [ZeroLEOneClass α] [CovariantClass α α (swap (· + ·)) (· ≤ ·)] :
    (1 : α) ≤ 2 :=
  calc
    1 = 0 + 1 := (zero_add 1).symm
    _ ≤ 1 + 1 := add_le_add_right zero_le_one _
    
#align one_le_two' one_le_two'

section

variable [PartialOrder α] [ZeroLEOneClass α] [NeZero (1 : α)]

section

variable [CovariantClass α α (· + ·) (· ≤ ·)]

/- warning: zero_lt_two -> zero_lt_two is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))] [_inst_5 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))] [_inst_5 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.738 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.740 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.738 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.740) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.753 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.755 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.753 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.755)], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 2 (instOfNat.{u1} α 2 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align zero_lt_two zero_lt_twoₓ'. -/
/-- See `zero_lt_two'` for a version with the type explicit. -/
@[simp]
theorem zero_lt_two : (0 : α) < 2 :=
  zero_lt_one.trans_le one_le_two
#align zero_lt_two zero_lt_two

/- warning: zero_lt_three -> zero_lt_three is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))] [_inst_5 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 3 (OfNat.mk.{u1} α 3 (bit1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))] [_inst_5 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.802 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.804 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.802 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.804) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.817 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.819 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.817 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.819)], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 3 (instOfNat.{u1} α 3 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))
Case conversion may be inaccurate. Consider using '#align zero_lt_three zero_lt_threeₓ'. -/
/-- See `zero_lt_three'` for a version with the type explicit. -/
@[simp]
theorem zero_lt_three : (0 : α) < 3 :=
  lt_add_of_lt_of_nonneg zero_lt_two zero_le_one
#align zero_lt_three zero_lt_three

/- warning: zero_lt_four -> zero_lt_four is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))] [_inst_5 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 4 (OfNat.mk.{u1} α 4 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))] [_inst_5 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.900 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.902 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.900 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.902) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.915 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.917 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.915 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.917)], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 4 (instOfNat.{u1} α 4 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))
Case conversion may be inaccurate. Consider using '#align zero_lt_four zero_lt_fourₓ'. -/
/-- See `zero_lt_four'` for a version with the type explicit. -/
@[simp]
theorem zero_lt_four : (0 : α) < 4 :=
  lt_add_of_lt_of_nonneg zero_lt_two zero_le_two
#align zero_lt_four zero_lt_four

variable (α)

/- warning: zero_lt_two' -> zero_lt_two' is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))] [_inst_5 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))] [_inst_5 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1053 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1055 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1053 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1055) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1068 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1070 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1068 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1070)], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 2 (instOfNat.{u1} α 2 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align zero_lt_two' zero_lt_two'ₓ'. -/
/-- See `zero_lt_two` for a version with the type implicit. -/
theorem zero_lt_two' : (0 : α) < 2 :=
  zero_lt_two
#align zero_lt_two' zero_lt_two'

/- warning: zero_lt_three' -> zero_lt_three' is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))] [_inst_5 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 3 (OfNat.mk.{u1} α 3 (bit1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))] [_inst_5 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1116 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1118 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1116 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1118) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1131 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1133 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1131 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1133)], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 3 (instOfNat.{u1} α 3 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))
Case conversion may be inaccurate. Consider using '#align zero_lt_three' zero_lt_three'ₓ'. -/
/-- See `zero_lt_three` for a version with the type implicit. -/
theorem zero_lt_three' : (0 : α) < 3 :=
  zero_lt_three
#align zero_lt_three' zero_lt_three'

/- warning: zero_lt_four' -> zero_lt_four' is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))] [_inst_5 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 4 (OfNat.mk.{u1} α 4 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))] [_inst_5 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1179 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1181 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1179 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1181) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1194 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1196 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1194 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1196)], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 4 (instOfNat.{u1} α 4 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))
Case conversion may be inaccurate. Consider using '#align zero_lt_four' zero_lt_four'ₓ'. -/
/-- See `zero_lt_four` for a version with the type implicit. -/
theorem zero_lt_four' : (0 : α) < 4 :=
  zero_lt_four
#align zero_lt_four' zero_lt_four'

instance ZeroLEOneClass.NeZero.two : NeZero (2 : α) :=
  ⟨zero_lt_two.ne'⟩
#align zero_le_one_class.ne_zero.two ZeroLEOneClass.NeZero.two

instance ZeroLEOneClass.NeZero.three : NeZero (3 : α) :=
  ⟨zero_lt_three.ne'⟩
#align zero_le_one_class.ne_zero.three ZeroLEOneClass.NeZero.three

instance ZeroLEOneClass.NeZero.four : NeZero (4 : α) :=
  ⟨zero_lt_four.ne'⟩
#align zero_le_one_class.ne_zero.four ZeroLEOneClass.NeZero.four

end

/- warning: one_lt_two -> one_lt_two is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))] [_inst_5 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))] [_inst_5 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1435 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1437 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1435 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1437) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1450 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1452 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1450 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.1452)], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 2 (instOfNat.{u1} α 2 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align one_lt_two one_lt_twoₓ'. -/
theorem one_lt_two [CovariantClass α α (· + ·) (· < ·)] : (1 : α) < 2 :=
  lt_add_one _
#align one_lt_two one_lt_two

end

/- warning: two_pos -> two_pos is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))] [_inst_5 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))] [_inst_5 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.738 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.740 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.738 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.740) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.753 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.755 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.753 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.755)], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 2 (instOfNat.{u1} α 2 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))
Case conversion may be inaccurate. Consider using '#align two_pos two_posₓ'. -/
alias zero_lt_two ← two_pos
#align two_pos two_pos

/- warning: three_pos -> three_pos is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))] [_inst_5 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 3 (OfNat.mk.{u1} α 3 (bit1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))] [_inst_5 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.802 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.804 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.802 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.804) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.817 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.819 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.817 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.819)], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 3 (instOfNat.{u1} α 3 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))
Case conversion may be inaccurate. Consider using '#align three_pos three_posₓ'. -/
alias zero_lt_three ← three_pos
#align three_pos three_pos

/- warning: four_pos -> four_pos is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))] [_inst_5 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 4 (OfNat.mk.{u1} α 4 (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (bit0.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddMonoidWithOne.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ZeroLEOneClass.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (AddMonoidWithOne.toOne.{u1} α _inst_1) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : NeZero.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (AddMonoidWithOne.toOne.{u1} α _inst_1)))] [_inst_5 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.900 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.902 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.900 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.902) (fun (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.915 : α) (x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.917 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.915 x._@.Mathlib.Algebra.Order.Monoid.NatCast._hyg.917)], LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 4 (instOfNat.{u1} α 4 (AddMonoidWithOne.toNatCast.{u1} α _inst_1) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))))
Case conversion may be inaccurate. Consider using '#align four_pos four_posₓ'. -/
alias zero_lt_four ← four_pos
#align four_pos four_pos

