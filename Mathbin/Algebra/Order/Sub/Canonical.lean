/-
Copyright (c) 2021 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn

! This file was ported from Lean 3 source module algebra.order.sub.canonical
! leanprover-community/mathlib commit b3f25363ae62cb169e72cd6b8b1ac97bacf21ca7
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.Monoid.Canonical.Defs
import Mathbin.Algebra.Order.Sub.Defs

/-!
# Lemmas about subtraction in canonically ordered monoids

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> https://github.com/leanprover-community/mathlib4/pull/814
> Any changes to this file require a corresponding PR to mathlib4.
-/


variable {α : Type _}

section ExistsAddOfLE

variable [AddCommSemigroup α] [PartialOrder α] [ExistsAddOfLE α]
  [CovariantClass α α (· + ·) (· ≤ ·)] [Sub α] [OrderedSub α] {a b c d : α}

/- warning: add_tsub_cancel_of_le -> add_tsub_cancel_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.90 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.92 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.90 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.92) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.105 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.107 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.105 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.107)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) b)
Case conversion may be inaccurate. Consider using '#align add_tsub_cancel_of_le add_tsub_cancel_of_leₓ'. -/
@[simp]
theorem add_tsub_cancel_of_le (h : a ≤ b) : a + (b - a) = b := by
  refine' le_antisymm _ le_add_tsub
  obtain ⟨c, rfl⟩ := exists_add_of_le h
  exact add_le_add_left add_tsub_le_left a
#align add_tsub_cancel_of_le add_tsub_cancel_of_le

/- warning: tsub_add_cancel_of_le -> tsub_add_cancel_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a) a) b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.176 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.178 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.176 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.178) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.191 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.193 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.191 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.193)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a) a) b)
Case conversion may be inaccurate. Consider using '#align tsub_add_cancel_of_le tsub_add_cancel_of_leₓ'. -/
theorem tsub_add_cancel_of_le (h : a ≤ b) : b - a + a = b := by
  rw [add_comm]
  exact add_tsub_cancel_of_le h
#align tsub_add_cancel_of_le tsub_add_cancel_of_le

/- warning: add_le_of_le_tsub_right_of_le -> add_le_of_le_tsub_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.281 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.283 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.281 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.283) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.296 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.298 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.296 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.298)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c)
Case conversion may be inaccurate. Consider using '#align add_le_of_le_tsub_right_of_le add_le_of_le_tsub_right_of_leₓ'. -/
theorem add_le_of_le_tsub_right_of_le (h : b ≤ c) (h2 : a ≤ c - b) : a + b ≤ c :=
  (add_le_add_right h2 b).trans_eq <| tsub_add_cancel_of_le h
#align add_le_of_le_tsub_right_of_le add_le_of_le_tsub_right_of_le

/- warning: add_le_of_le_tsub_left_of_le -> add_le_of_le_tsub_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.366 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.368 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.366 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.368) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.381 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.383 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.381 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.383)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c)
Case conversion may be inaccurate. Consider using '#align add_le_of_le_tsub_left_of_le add_le_of_le_tsub_left_of_leₓ'. -/
theorem add_le_of_le_tsub_left_of_le (h : a ≤ c) (h2 : b ≤ c - a) : a + b ≤ c :=
  (add_le_add_left h2 a).trans_eq <| add_tsub_cancel_of_le h
#align add_le_of_le_tsub_left_of_le add_le_of_le_tsub_left_of_le

/- warning: tsub_le_tsub_iff_right -> tsub_le_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.451 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.453 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.451 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.453) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.466 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.468 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.466 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.468)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b))
Case conversion may be inaccurate. Consider using '#align tsub_le_tsub_iff_right tsub_le_tsub_iff_rightₓ'. -/
theorem tsub_le_tsub_iff_right (h : c ≤ b) : a - c ≤ b - c ↔ a ≤ b := by
  rw [tsub_le_iff_right, tsub_add_cancel_of_le h]
#align tsub_le_tsub_iff_right tsub_le_tsub_iff_right

/- warning: tsub_left_inj -> tsub_left_inj is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.559 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.561 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.559 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.561) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.574 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.576 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.574 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.576)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α a b))
Case conversion may be inaccurate. Consider using '#align tsub_left_inj tsub_left_injₓ'. -/
theorem tsub_left_inj (h1 : c ≤ a) (h2 : c ≤ b) : a - c = b - c ↔ a = b := by
  simp_rw [le_antisymm_iff, tsub_le_tsub_iff_right h1, tsub_le_tsub_iff_right h2]
#align tsub_left_inj tsub_left_inj

/- warning: tsub_inj_left -> tsub_inj_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) -> (Eq.{succ u1} α b c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.661 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.663 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.661 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.663) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.676 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.678 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.676 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.678)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) -> (Eq.{succ u1} α b c)
Case conversion may be inaccurate. Consider using '#align tsub_inj_left tsub_inj_leftₓ'. -/
theorem tsub_inj_left (h₁ : a ≤ b) (h₂ : a ≤ c) : b - a = c - a → b = c :=
  (tsub_left_inj h₁ h₂).1
#align tsub_inj_left tsub_inj_left

/- warning: lt_of_tsub_lt_tsub_right_of_le -> lt_of_tsub_lt_tsub_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.748 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.750 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.748 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.750) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.763 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.765 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.763 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.765)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b)
Case conversion may be inaccurate. Consider using '#align lt_of_tsub_lt_tsub_right_of_le lt_of_tsub_lt_tsub_right_of_leₓ'. -/
/-- See `lt_of_tsub_lt_tsub_right` for a stronger statement in a linear order. -/
theorem lt_of_tsub_lt_tsub_right_of_le (h : c ≤ b) (h2 : a - c < b - c) : a < b := by
  refine' ((tsub_le_tsub_iff_right h).mp h2.le).lt_of_ne _
  rintro rfl
  exact h2.false
#align lt_of_tsub_lt_tsub_right_of_le lt_of_tsub_lt_tsub_right_of_le

/- warning: tsub_add_tsub_cancel -> tsub_add_tsub_cancel is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.841 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.843 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.841 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.843) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.856 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.858 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.856 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.858)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
Case conversion may be inaccurate. Consider using '#align tsub_add_tsub_cancel tsub_add_tsub_cancelₓ'. -/
theorem tsub_add_tsub_cancel (hab : b ≤ a) (hcb : c ≤ b) : a - b + (b - c) = a - c := by
  convert tsub_add_cancel_of_le (tsub_le_tsub_right hab c) using 2
  rw [tsub_tsub, add_tsub_cancel_of_le hcb]
#align tsub_add_tsub_cancel tsub_add_tsub_cancel

/- warning: tsub_tsub_tsub_cancel_right -> tsub_tsub_tsub_cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.960 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.962 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.960 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.962) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.975 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.977 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.975 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.977)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b))
Case conversion may be inaccurate. Consider using '#align tsub_tsub_tsub_cancel_right tsub_tsub_tsub_cancel_rightₓ'. -/
theorem tsub_tsub_tsub_cancel_right (h : c ≤ b) : a - c - (b - c) = a - b := by
  rw [tsub_tsub, add_tsub_cancel_of_le h]
#align tsub_tsub_tsub_cancel_right tsub_tsub_tsub_cancel_right

/-! #### Lemmas that assume that an element is `add_le_cancellable`. -/


namespace AddLECancellable

/- warning: add_le_cancellable.eq_tsub_iff_add_eq_of_le -> AddLECancellable.eq_tsub_iff_add_eq_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1067 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1069 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1067 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1069) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1082 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1084 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1082 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1084)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.eq_tsub_iff_add_eq_of_le AddLECancellable.eq_tsub_iff_add_eq_of_leₓ'. -/
protected theorem eq_tsub_iff_add_eq_of_le (hc : AddLECancellable c) (h : c ≤ b) :
    a = b - c ↔ a + c = b :=
  ⟨by 
    rintro rfl
    exact tsub_add_cancel_of_le h, hc.eq_tsub_of_add_eq⟩
#align add_le_cancellable.eq_tsub_iff_add_eq_of_le AddLECancellable.eq_tsub_iff_add_eq_of_le

/- warning: add_le_cancellable.tsub_eq_iff_eq_add_of_le -> AddLECancellable.tsub_eq_iff_eq_add_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (Eq.{succ u1} α a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1158 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1160 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1158 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1160) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1173 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1175 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1173 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1175)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (Eq.{succ u1} α a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_eq_iff_eq_add_of_le AddLECancellable.tsub_eq_iff_eq_add_of_leₓ'. -/
protected theorem tsub_eq_iff_eq_add_of_le (hb : AddLECancellable b) (h : b ≤ a) :
    a - b = c ↔ a = c + b := by rw [eq_comm, hb.eq_tsub_iff_add_eq_of_le h, eq_comm]
#align add_le_cancellable.tsub_eq_iff_eq_add_of_le AddLECancellable.tsub_eq_iff_eq_add_of_le

/- warning: add_le_cancellable.add_tsub_assoc_of_le -> AddLECancellable.add_tsub_assoc_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (forall (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1269 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1271 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1269 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1271) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1284 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1286 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1284 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1286)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (forall (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.add_tsub_assoc_of_le AddLECancellable.add_tsub_assoc_of_leₓ'. -/
protected theorem add_tsub_assoc_of_le (hc : AddLECancellable c) (h : c ≤ b) (a : α) :
    a + b - c = a + (b - c) := by
  conv_lhs => rw [← add_tsub_cancel_of_le h, add_comm c, ← add_assoc, hc.add_tsub_cancel_right]
#align add_le_cancellable.add_tsub_assoc_of_le AddLECancellable.add_tsub_assoc_of_le

/- warning: add_le_cancellable.tsub_add_eq_add_tsub -> AddLECancellable.tsub_add_eq_add_tsub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1375 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1377 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1375 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1377) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1390 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1392 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1390 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1392)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_add_eq_add_tsub AddLECancellable.tsub_add_eq_add_tsubₓ'. -/
protected theorem tsub_add_eq_add_tsub (hb : AddLECancellable b) (h : b ≤ a) :
    a - b + c = a + c - b := by rw [add_comm a, hb.add_tsub_assoc_of_le h, add_comm]
#align add_le_cancellable.tsub_add_eq_add_tsub AddLECancellable.tsub_add_eq_add_tsub

/- warning: add_le_cancellable.tsub_tsub_assoc -> AddLECancellable.tsub_tsub_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1484 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1486 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1484 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1486) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1499 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1501 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1499 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1501)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_tsub_assoc AddLECancellable.tsub_tsub_assocₓ'. -/
protected theorem tsub_tsub_assoc (hbc : AddLECancellable (b - c)) (h₁ : b ≤ a) (h₂ : c ≤ b) :
    a - (b - c) = a - b + c :=
  hbc.tsub_eq_of_eq_add <| by rw [add_assoc, add_tsub_cancel_of_le h₂, tsub_add_cancel_of_le h₁]
#align add_le_cancellable.tsub_tsub_assoc AddLECancellable.tsub_tsub_assoc

/- warning: add_le_cancellable.tsub_add_tsub_comm -> AddLECancellable.tsub_add_tsub_comm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} {d : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d c) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c d)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b d)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1607 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1609 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1607 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1609) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1622 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1624 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1622 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1624)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} {d : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d c) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c d)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b d)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_add_tsub_comm AddLECancellable.tsub_add_tsub_commₓ'. -/
protected theorem tsub_add_tsub_comm (hb : AddLECancellable b) (hd : AddLECancellable d)
    (hba : b ≤ a) (hdc : d ≤ c) : a - b + (c - d) = a + c - (b + d) := by
  rw [hb.tsub_add_eq_add_tsub hba, ← hd.add_tsub_assoc_of_le hdc, tsub_tsub, add_comm d]
#align add_le_cancellable.tsub_add_tsub_comm AddLECancellable.tsub_add_tsub_comm

/- warning: add_le_cancellable.le_tsub_iff_left -> AddLECancellable.le_tsub_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1729 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1731 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1729 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1731) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1744 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1746 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1744 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1746)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.le_tsub_iff_left AddLECancellable.le_tsub_iff_leftₓ'. -/
protected theorem le_tsub_iff_left (ha : AddLECancellable a) (h : a ≤ c) : b ≤ c - a ↔ a + b ≤ c :=
  ⟨add_le_of_le_tsub_left_of_le h, ha.le_tsub_of_add_le_left⟩
#align add_le_cancellable.le_tsub_iff_left AddLECancellable.le_tsub_iff_left

/- warning: add_le_cancellable.le_tsub_iff_right -> AddLECancellable.le_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b a) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1814 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1816 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1814 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1816) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1829 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1831 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1829 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1831)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b a) c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.le_tsub_iff_right AddLECancellable.le_tsub_iff_rightₓ'. -/
protected theorem le_tsub_iff_right (ha : AddLECancellable a) (h : a ≤ c) : b ≤ c - a ↔ b + a ≤ c :=
  by 
  rw [add_comm]
  exact ha.le_tsub_iff_left h
#align add_le_cancellable.le_tsub_iff_right AddLECancellable.le_tsub_iff_right

/- warning: add_le_cancellable.tsub_lt_iff_left -> AddLECancellable.tsub_lt_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1929 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1931 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1929 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1931) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1944 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1946 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1944 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1946)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_iff_left AddLECancellable.tsub_lt_iff_leftₓ'. -/
protected theorem tsub_lt_iff_left (hb : AddLECancellable b) (hba : b ≤ a) :
    a - b < c ↔ a < b + c := by 
  refine' ⟨hb.lt_add_of_tsub_lt_left, _⟩
  intro h; refine' (tsub_le_iff_left.mpr h.le).lt_of_ne _
  rintro rfl; exact h.ne' (add_tsub_cancel_of_le hba)
#align add_le_cancellable.tsub_lt_iff_left AddLECancellable.tsub_lt_iff_left

/- warning: add_le_cancellable.tsub_lt_iff_right -> AddLECancellable.tsub_lt_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2033 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2035 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2033 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2035) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2048 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2050 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2048 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2050)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_iff_right AddLECancellable.tsub_lt_iff_rightₓ'. -/
protected theorem tsub_lt_iff_right (hb : AddLECancellable b) (hba : b ≤ a) :
    a - b < c ↔ a < c + b := by 
  rw [add_comm]
  exact hb.tsub_lt_iff_left hba
#align add_le_cancellable.tsub_lt_iff_right AddLECancellable.tsub_lt_iff_right

/- warning: add_le_cancellable.tsub_lt_iff_tsub_lt -> AddLECancellable.tsub_lt_iff_tsub_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2148 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2150 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2148 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2150) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2163 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2165 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2163 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2165)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_iff_tsub_lt AddLECancellable.tsub_lt_iff_tsub_ltₓ'. -/
protected theorem tsub_lt_iff_tsub_lt (hb : AddLECancellable b) (hc : AddLECancellable c)
    (h₁ : b ≤ a) (h₂ : c ≤ a) : a - b < c ↔ a - c < b := by
  rw [hb.tsub_lt_iff_left h₁, hc.tsub_lt_iff_right h₂]
#align add_le_cancellable.tsub_lt_iff_tsub_lt AddLECancellable.tsub_lt_iff_tsub_lt

/- warning: add_le_cancellable.le_tsub_iff_le_tsub -> AddLECancellable.le_tsub_iff_le_tsub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2266 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2268 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2266 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2268) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2281 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2283 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2281 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2283)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.le_tsub_iff_le_tsub AddLECancellable.le_tsub_iff_le_tsubₓ'. -/
protected theorem le_tsub_iff_le_tsub (ha : AddLECancellable a) (hc : AddLECancellable c)
    (h₁ : a ≤ b) (h₂ : c ≤ b) : a ≤ b - c ↔ c ≤ b - a := by
  rw [ha.le_tsub_iff_left h₁, hc.le_tsub_iff_right h₂]
#align add_le_cancellable.le_tsub_iff_le_tsub AddLECancellable.le_tsub_iff_le_tsub

/- warning: add_le_cancellable.lt_tsub_iff_right_of_le -> AddLECancellable.lt_tsub_iff_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2384 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2386 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2384 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2386) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2399 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2401 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2399 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2401)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.lt_tsub_iff_right_of_le AddLECancellable.lt_tsub_iff_right_of_leₓ'. -/
protected theorem lt_tsub_iff_right_of_le (hc : AddLECancellable c) (h : c ≤ b) :
    a < b - c ↔ a + c < b := by
  refine' ⟨fun h' => (add_le_of_le_tsub_right_of_le h h'.le).lt_of_ne _, hc.lt_tsub_of_add_lt_right⟩
  rintro rfl
  exact h'.ne' hc.add_tsub_cancel_right
#align add_le_cancellable.lt_tsub_iff_right_of_le AddLECancellable.lt_tsub_iff_right_of_le

/- warning: add_le_cancellable.lt_tsub_iff_left_of_le -> AddLECancellable.lt_tsub_iff_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c a) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2486 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2488 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2486 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2488) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2501 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2503 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2501 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2503)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c a) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.lt_tsub_iff_left_of_le AddLECancellable.lt_tsub_iff_left_of_leₓ'. -/
protected theorem lt_tsub_iff_left_of_le (hc : AddLECancellable c) (h : c ≤ b) :
    a < b - c ↔ c + a < b := by 
  rw [add_comm]
  exact hc.lt_tsub_iff_right_of_le h
#align add_le_cancellable.lt_tsub_iff_left_of_le AddLECancellable.lt_tsub_iff_left_of_le

/- warning: add_le_cancellable.tsub_inj_right -> AddLECancellable.tsub_inj_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (Eq.{succ u1} α b c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2601 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2603 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2601 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2603) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2616 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2618 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2616 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2618)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (Eq.{succ u1} α b c)
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_inj_right AddLECancellable.tsub_inj_rightₓ'. -/
protected theorem tsub_inj_right (hab : AddLECancellable (a - b)) (h₁ : b ≤ a) (h₂ : c ≤ a)
    (h₃ : a - b = a - c) : b = c := by 
  rw [← hab.inj]
  rw [tsub_add_cancel_of_le h₁, h₃, tsub_add_cancel_of_le h₂]
#align add_le_cancellable.tsub_inj_right AddLECancellable.tsub_inj_right

/- warning: add_le_cancellable.lt_of_tsub_lt_tsub_left_of_le -> AddLECancellable.lt_of_tsub_lt_tsub_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2751 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2753 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2751 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2753) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2766 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2768 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2766 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2768)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2795 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2797 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2795 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2797) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2810 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2812 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2810 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2812)], (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b)
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.lt_of_tsub_lt_tsub_left_of_le AddLECancellable.lt_of_tsub_lt_tsub_left_of_leₓ'. -/
protected theorem lt_of_tsub_lt_tsub_left_of_le [ContravariantClass α α (· + ·) (· < ·)]
    (hb : AddLECancellable b) (hca : c ≤ a) (h : a - b < a - c) : c < b := by
  conv_lhs at h => rw [← tsub_add_cancel_of_le hca]
  exact lt_of_add_lt_add_left (hb.lt_add_of_tsub_lt_right h)
#align
  add_le_cancellable.lt_of_tsub_lt_tsub_left_of_le AddLECancellable.lt_of_tsub_lt_tsub_left_of_le

/- warning: add_le_cancellable.tsub_lt_tsub_left_of_le -> AddLECancellable.tsub_lt_tsub_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2883 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2885 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2883 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2885) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2898 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2900 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2898 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2900)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_tsub_left_of_le AddLECancellable.tsub_lt_tsub_left_of_leₓ'. -/
protected theorem tsub_lt_tsub_left_of_le (hab : AddLECancellable (a - b)) (h₁ : b ≤ a)
    (h : c < b) : a - b < a - c :=
  (tsub_le_tsub_left h.le _).lt_of_ne fun h' => h.ne' <| hab.tsub_inj_right h₁ (h.le.trans h₁) h'
#align add_le_cancellable.tsub_lt_tsub_left_of_le AddLECancellable.tsub_lt_tsub_left_of_le

/- warning: add_le_cancellable.tsub_lt_tsub_right_of_le -> AddLECancellable.tsub_lt_tsub_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2985 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2987 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2985 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2987) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3000 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3002 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3000 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3002)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_tsub_right_of_le AddLECancellable.tsub_lt_tsub_right_of_leₓ'. -/
protected theorem tsub_lt_tsub_right_of_le (hc : AddLECancellable c) (h : c ≤ a) (h2 : a < b) :
    a - c < b - c := by 
  apply hc.lt_tsub_of_add_lt_left
  rwa [add_tsub_cancel_of_le h]
#align add_le_cancellable.tsub_lt_tsub_right_of_le AddLECancellable.tsub_lt_tsub_right_of_le

/- warning: add_le_cancellable.tsub_lt_tsub_iff_left_of_le_of_le -> AddLECancellable.tsub_lt_tsub_iff_left_of_le_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3102 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3104 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3102 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3104) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3117 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3119 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3117 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3119)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3146 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3148 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3146 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3148) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3161 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3163 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3161 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3163)], (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_tsub_iff_left_of_le_of_le AddLECancellable.tsub_lt_tsub_iff_left_of_le_of_leₓ'. -/
protected theorem tsub_lt_tsub_iff_left_of_le_of_le [ContravariantClass α α (· + ·) (· < ·)]
    (hb : AddLECancellable b) (hab : AddLECancellable (a - b)) (h₁ : b ≤ a) (h₂ : c ≤ a) :
    a - b < a - c ↔ c < b :=
  ⟨hb.lt_of_tsub_lt_tsub_left_of_le h₂, hab.tsub_lt_tsub_left_of_le h₁⟩
#align
  add_le_cancellable.tsub_lt_tsub_iff_left_of_le_of_le AddLECancellable.tsub_lt_tsub_iff_left_of_le_of_le

/- warning: add_le_cancellable.add_tsub_tsub_cancel -> AddLECancellable.add_tsub_tsub_cancel is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3235 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3237 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3235 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3237) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3250 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3252 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3250 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3252)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.add_tsub_tsub_cancel AddLECancellable.add_tsub_tsub_cancelₓ'. -/
@[simp]
protected theorem add_tsub_tsub_cancel (hac : AddLECancellable (a - c)) (h : c ≤ a) :
    a + b - (a - c) = b + c :=
  hac.tsub_eq_of_eq_add <| by rw [add_assoc, add_tsub_cancel_of_le h, add_comm]
#align add_le_cancellable.add_tsub_tsub_cancel AddLECancellable.add_tsub_tsub_cancel

/- warning: add_le_cancellable.tsub_tsub_cancel_of_le -> AddLECancellable.tsub_tsub_cancel_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3352 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3354 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3352 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3354) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3367 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3369 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3367 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3369)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) a)
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_tsub_cancel_of_le AddLECancellable.tsub_tsub_cancel_of_leₓ'. -/
protected theorem tsub_tsub_cancel_of_le (hba : AddLECancellable (b - a)) (h : a ≤ b) :
    b - (b - a) = a :=
  hba.tsub_eq_of_eq_add (add_tsub_cancel_of_le h).symm
#align add_le_cancellable.tsub_tsub_cancel_of_le AddLECancellable.tsub_tsub_cancel_of_le

/- warning: add_le_cancellable.tsub_tsub_tsub_cancel_left -> AddLECancellable.tsub_tsub_tsub_cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3436 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3438 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3436 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3438) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3451 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3453 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3451 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3453)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_tsub_tsub_cancel_left AddLECancellable.tsub_tsub_tsub_cancel_leftₓ'. -/
protected theorem tsub_tsub_tsub_cancel_left (hab : AddLECancellable (a - b)) (h : b ≤ a) :
    a - c - (a - b) = b - c := by rw [tsub_right_comm, hab.tsub_tsub_cancel_of_le h]
#align add_le_cancellable.tsub_tsub_tsub_cancel_left AddLECancellable.tsub_tsub_tsub_cancel_left

end AddLECancellable

section Contra

/-! ### Lemmas where addition is order-reflecting. -/


variable [ContravariantClass α α (· + ·) (· ≤ ·)]

/- warning: eq_tsub_iff_add_eq_of_le -> eq_tsub_iff_add_eq_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3642 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3644 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3642 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3644) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3657 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3659 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3657 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3659)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3686 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3688 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3686 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3688) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3701 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3703 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3701 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3703)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align eq_tsub_iff_add_eq_of_le eq_tsub_iff_add_eq_of_leₓ'. -/
theorem eq_tsub_iff_add_eq_of_le (h : c ≤ b) : a = b - c ↔ a + c = b :=
  Contravariant.AddLECancellable.eq_tsub_iff_add_eq_of_le h
#align eq_tsub_iff_add_eq_of_le eq_tsub_iff_add_eq_of_le

/- warning: tsub_eq_iff_eq_add_of_le -> tsub_eq_iff_eq_add_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (Eq.{succ u1} α a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3756 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3758 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3756 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3758) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3771 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3773 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3771 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3773)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3800 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3802 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3800 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3802) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3815 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3817 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3815 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3817)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (Eq.{succ u1} α a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
Case conversion may be inaccurate. Consider using '#align tsub_eq_iff_eq_add_of_le tsub_eq_iff_eq_add_of_leₓ'. -/
theorem tsub_eq_iff_eq_add_of_le (h : b ≤ a) : a - b = c ↔ a = c + b :=
  Contravariant.AddLECancellable.tsub_eq_iff_eq_add_of_le h
#align tsub_eq_iff_eq_add_of_le tsub_eq_iff_eq_add_of_le

/- warning: add_tsub_assoc_of_le -> add_tsub_assoc_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (forall (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3870 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3872 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3870 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3872) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3885 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3887 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3885 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3887)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3914 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3916 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3914 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3916) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3929 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3931 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3929 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3931)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (forall (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)))
Case conversion may be inaccurate. Consider using '#align add_tsub_assoc_of_le add_tsub_assoc_of_leₓ'. -/
/-- See `add_tsub_le_assoc` for an inequality. -/
theorem add_tsub_assoc_of_le (h : c ≤ b) (a : α) : a + b - c = a + (b - c) :=
  Contravariant.AddLECancellable.add_tsub_assoc_of_le h a
#align add_tsub_assoc_of_le add_tsub_assoc_of_le

/- warning: tsub_add_eq_add_tsub -> tsub_add_eq_add_tsub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3982 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3984 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3982 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3984) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3997 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3999 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3997 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3999)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4026 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4028 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4026 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4028) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4041 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4043 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4041 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4043)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align tsub_add_eq_add_tsub tsub_add_eq_add_tsubₓ'. -/
theorem tsub_add_eq_add_tsub (h : b ≤ a) : a - b + c = a + c - b :=
  Contravariant.AddLECancellable.tsub_add_eq_add_tsub h
#align tsub_add_eq_add_tsub tsub_add_eq_add_tsub

/- warning: tsub_tsub_assoc -> tsub_tsub_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4092 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4094 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4092 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4094) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4107 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4109 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4107 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4109)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4136 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4138 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4136 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4138) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4151 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4153 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4151 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4153)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c))
Case conversion may be inaccurate. Consider using '#align tsub_tsub_assoc tsub_tsub_assocₓ'. -/
theorem tsub_tsub_assoc (h₁ : b ≤ a) (h₂ : c ≤ b) : a - (b - c) = a - b + c :=
  Contravariant.AddLECancellable.tsub_tsub_assoc h₁ h₂
#align tsub_tsub_assoc tsub_tsub_assoc

/- warning: tsub_add_tsub_comm -> tsub_add_tsub_comm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} {d : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d c) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c d)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b d)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4208 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4210 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4208 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4210) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4223 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4225 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4223 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4225)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} {d : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4252 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4254 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4252 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4254) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4267 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4269 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4267 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4269)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d c) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c d)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b d)))
Case conversion may be inaccurate. Consider using '#align tsub_add_tsub_comm tsub_add_tsub_commₓ'. -/
theorem tsub_add_tsub_comm (hba : b ≤ a) (hdc : d ≤ c) : a - b + (c - d) = a + c - (b + d) :=
  Contravariant.AddLECancellable.tsub_add_tsub_comm Contravariant.AddLECancellable hba hdc
#align tsub_add_tsub_comm tsub_add_tsub_comm

/- warning: le_tsub_iff_left -> le_tsub_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4329 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4331 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4329 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4331) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4344 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4346 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4344 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4346)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4373 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4375 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4373 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4375) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4388 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4390 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4388 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4390)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c))
Case conversion may be inaccurate. Consider using '#align le_tsub_iff_left le_tsub_iff_leftₓ'. -/
theorem le_tsub_iff_left (h : a ≤ c) : b ≤ c - a ↔ a + b ≤ c :=
  Contravariant.AddLECancellable.le_tsub_iff_left h
#align le_tsub_iff_left le_tsub_iff_left

/- warning: le_tsub_iff_right -> le_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b a) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4443 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4445 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4443 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4445) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4458 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4460 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4458 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4460)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4487 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4489 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4487 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4489) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4502 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4504 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4502 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4504)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b a) c))
Case conversion may be inaccurate. Consider using '#align le_tsub_iff_right le_tsub_iff_rightₓ'. -/
theorem le_tsub_iff_right (h : a ≤ c) : b ≤ c - a ↔ b + a ≤ c :=
  Contravariant.AddLECancellable.le_tsub_iff_right h
#align le_tsub_iff_right le_tsub_iff_right

/- warning: tsub_lt_iff_left -> tsub_lt_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4557 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4559 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4557 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4559) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4572 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4574 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4572 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4574)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4601 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4603 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4601 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4603) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4616 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4618 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4616 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4618)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c)))
Case conversion may be inaccurate. Consider using '#align tsub_lt_iff_left tsub_lt_iff_leftₓ'. -/
theorem tsub_lt_iff_left (hbc : b ≤ a) : a - b < c ↔ a < b + c :=
  Contravariant.AddLECancellable.tsub_lt_iff_left hbc
#align tsub_lt_iff_left tsub_lt_iff_left

/- warning: tsub_lt_iff_right -> tsub_lt_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4671 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4673 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4671 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4673) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4686 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4688 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4686 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4688)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4715 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4717 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4715 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4717) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4730 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4732 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4730 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4732)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
Case conversion may be inaccurate. Consider using '#align tsub_lt_iff_right tsub_lt_iff_rightₓ'. -/
theorem tsub_lt_iff_right (hbc : b ≤ a) : a - b < c ↔ a < c + b :=
  Contravariant.AddLECancellable.tsub_lt_iff_right hbc
#align tsub_lt_iff_right tsub_lt_iff_right

/- warning: tsub_lt_iff_tsub_lt -> tsub_lt_iff_tsub_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4785 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4787 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4785 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4787) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4800 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4802 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4800 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4802)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4829 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4831 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4829 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4831) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4844 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4846 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4844 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4846)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) b))
Case conversion may be inaccurate. Consider using '#align tsub_lt_iff_tsub_lt tsub_lt_iff_tsub_ltₓ'. -/
theorem tsub_lt_iff_tsub_lt (h₁ : b ≤ a) (h₂ : c ≤ a) : a - b < c ↔ a - c < b :=
  Contravariant.AddLECancellable.tsub_lt_iff_tsub_lt Contravariant.AddLECancellable h₁ h₂
#align tsub_lt_iff_tsub_lt tsub_lt_iff_tsub_lt

/- warning: le_tsub_iff_le_tsub -> le_tsub_iff_le_tsub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4906 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4908 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4906 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4908) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4921 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4923 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4921 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4923)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4950 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4952 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4950 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4952) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4965 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4967 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4965 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4967)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)))
Case conversion may be inaccurate. Consider using '#align le_tsub_iff_le_tsub le_tsub_iff_le_tsubₓ'. -/
theorem le_tsub_iff_le_tsub (h₁ : a ≤ b) (h₂ : c ≤ b) : a ≤ b - c ↔ c ≤ b - a :=
  Contravariant.AddLECancellable.le_tsub_iff_le_tsub Contravariant.AddLECancellable h₁ h₂
#align le_tsub_iff_le_tsub le_tsub_iff_le_tsub

/- warning: lt_tsub_iff_right_of_le -> lt_tsub_iff_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5027 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5029 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5027 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5029) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5042 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5044 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5042 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5044)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5071 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5073 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5071 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5073) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5086 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5088 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5086 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5088)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align lt_tsub_iff_right_of_le lt_tsub_iff_right_of_leₓ'. -/
/-- See `lt_tsub_iff_right` for a stronger statement in a linear order. -/
theorem lt_tsub_iff_right_of_le (h : c ≤ b) : a < b - c ↔ a + c < b :=
  Contravariant.AddLECancellable.lt_tsub_iff_right_of_le h
#align lt_tsub_iff_right_of_le lt_tsub_iff_right_of_le

/- warning: lt_tsub_iff_left_of_le -> lt_tsub_iff_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c a) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5141 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5143 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5141 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5143) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5156 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5158 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5156 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5158)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5185 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5187 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5185 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5187) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5200 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5202 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5200 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5202)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c a) b))
Case conversion may be inaccurate. Consider using '#align lt_tsub_iff_left_of_le lt_tsub_iff_left_of_leₓ'. -/
/-- See `lt_tsub_iff_left` for a stronger statement in a linear order. -/
theorem lt_tsub_iff_left_of_le (h : c ≤ b) : a < b - c ↔ c + a < b :=
  Contravariant.AddLECancellable.lt_tsub_iff_left_of_le h
#align lt_tsub_iff_left_of_le lt_tsub_iff_left_of_le

/- warning: lt_of_tsub_lt_tsub_left_of_le -> lt_of_tsub_lt_tsub_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_8 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5255 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5257 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5255 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5257) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5270 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5272 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5270 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5272)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5299 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5301 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5299 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5301) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5314 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5316 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5314 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5316)] [_inst_8 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5333 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5335 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5333 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5335) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5348 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5350 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5348 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5350)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b)
Case conversion may be inaccurate. Consider using '#align lt_of_tsub_lt_tsub_left_of_le lt_of_tsub_lt_tsub_left_of_leₓ'. -/
/-- See `lt_of_tsub_lt_tsub_left` for a stronger statement in a linear order. -/
theorem lt_of_tsub_lt_tsub_left_of_le [ContravariantClass α α (· + ·) (· < ·)] (hca : c ≤ a)
    (h : a - b < a - c) : c < b :=
  Contravariant.AddLECancellable.lt_of_tsub_lt_tsub_left_of_le hca h
#align lt_of_tsub_lt_tsub_left_of_le lt_of_tsub_lt_tsub_left_of_le

/- warning: tsub_lt_tsub_left_of_le -> tsub_lt_tsub_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5401 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5403 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5401 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5403) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5416 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5418 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5416 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5418)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5445 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5447 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5445 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5447) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5460 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5462 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5460 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5462)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
Case conversion may be inaccurate. Consider using '#align tsub_lt_tsub_left_of_le tsub_lt_tsub_left_of_leₓ'. -/
theorem tsub_lt_tsub_left_of_le : b ≤ a → c < b → a - b < a - c :=
  Contravariant.AddLECancellable.tsub_lt_tsub_left_of_le
#align tsub_lt_tsub_left_of_le tsub_lt_tsub_left_of_le

/- warning: tsub_lt_tsub_right_of_le -> tsub_lt_tsub_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5513 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5515 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5513 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5515) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5528 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5530 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5528 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5530)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5557 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5559 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5557 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5559) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5572 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5574 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5572 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5574)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
Case conversion may be inaccurate. Consider using '#align tsub_lt_tsub_right_of_le tsub_lt_tsub_right_of_leₓ'. -/
theorem tsub_lt_tsub_right_of_le (h : c ≤ a) (h2 : a < b) : a - c < b - c :=
  Contravariant.AddLECancellable.tsub_lt_tsub_right_of_le h h2
#align tsub_lt_tsub_right_of_le tsub_lt_tsub_right_of_le

/- warning: tsub_inj_right -> tsub_inj_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (Eq.{succ u1} α b c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5625 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5627 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5625 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5627) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5640 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5642 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5640 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5642)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5669 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5671 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5669 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5671) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5684 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5686 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5684 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5686)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (Eq.{succ u1} α b c)
Case conversion may be inaccurate. Consider using '#align tsub_inj_right tsub_inj_rightₓ'. -/
theorem tsub_inj_right (h₁ : b ≤ a) (h₂ : c ≤ a) (h₃ : a - b = a - c) : b = c :=
  Contravariant.AddLECancellable.tsub_inj_right h₁ h₂ h₃
#align tsub_inj_right tsub_inj_right

/- warning: tsub_lt_tsub_iff_left_of_le_of_le -> tsub_lt_tsub_iff_left_of_le_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_8 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5743 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5745 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5743 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5745) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5758 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5760 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5758 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5760)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5787 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5789 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5787 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5789) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5802 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5804 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5802 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5804)] [_inst_8 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5821 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5823 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5821 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5823) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5836 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5838 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5836 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5838)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b))
Case conversion may be inaccurate. Consider using '#align tsub_lt_tsub_iff_left_of_le_of_le tsub_lt_tsub_iff_left_of_le_of_leₓ'. -/
/-- See `tsub_lt_tsub_iff_left_of_le` for a stronger statement in a linear order. -/
theorem tsub_lt_tsub_iff_left_of_le_of_le [ContravariantClass α α (· + ·) (· < ·)] (h₁ : b ≤ a)
    (h₂ : c ≤ a) : a - b < a - c ↔ c < b :=
  Contravariant.AddLECancellable.tsub_lt_tsub_iff_left_of_le_of_le Contravariant.AddLECancellable h₁
    h₂
#align tsub_lt_tsub_iff_left_of_le_of_le tsub_lt_tsub_iff_left_of_le_of_le

/- warning: add_tsub_tsub_cancel -> add_tsub_tsub_cancel is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5898 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5900 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5898 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5900) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5913 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5915 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5913 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5915)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5942 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5944 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5942 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5944) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5957 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5959 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5957 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5959)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c))
Case conversion may be inaccurate. Consider using '#align add_tsub_tsub_cancel add_tsub_tsub_cancelₓ'. -/
@[simp]
theorem add_tsub_tsub_cancel (h : c ≤ a) : a + b - (a - c) = b + c :=
  Contravariant.AddLECancellable.add_tsub_tsub_cancel h
#align add_tsub_tsub_cancel add_tsub_tsub_cancel

/- warning: tsub_tsub_cancel_of_le -> tsub_tsub_cancel_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6008 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6010 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6008 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6010) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6023 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6025 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6023 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6025)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6052 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6054 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6052 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6054) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6067 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6069 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6067 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6069)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) a)
Case conversion may be inaccurate. Consider using '#align tsub_tsub_cancel_of_le tsub_tsub_cancel_of_leₓ'. -/
/-- See `tsub_tsub_le` for an inequality. -/
theorem tsub_tsub_cancel_of_le (h : a ≤ b) : b - (b - a) = a :=
  Contravariant.AddLECancellable.tsub_tsub_cancel_of_le h
#align tsub_tsub_cancel_of_le tsub_tsub_cancel_of_le

/- warning: tsub_tsub_tsub_cancel_left -> tsub_tsub_tsub_cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6114 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6116 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6114 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6116) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6129 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6131 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6129 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6131)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6158 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6160 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6158 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6160) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6173 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6175 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6173 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6175)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
Case conversion may be inaccurate. Consider using '#align tsub_tsub_tsub_cancel_left tsub_tsub_tsub_cancel_leftₓ'. -/
theorem tsub_tsub_tsub_cancel_left (h : b ≤ a) : a - c - (a - b) = b - c :=
  Contravariant.AddLECancellable.tsub_tsub_tsub_cancel_left h
#align tsub_tsub_tsub_cancel_left tsub_tsub_tsub_cancel_left

end Contra

end ExistsAddOfLE

/-! ### Lemmas in a canonically ordered monoid. -/


section CanonicallyOrderedAddMonoid

variable [CanonicallyOrderedAddMonoid α] [Sub α] [OrderedSub α] {a b c d : α}

/- warning: add_tsub_cancel_iff_le -> add_tsub_cancel_iff_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a)) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a)) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
Case conversion may be inaccurate. Consider using '#align add_tsub_cancel_iff_le add_tsub_cancel_iff_leₓ'. -/
theorem add_tsub_cancel_iff_le : a + (b - a) = b ↔ a ≤ b :=
  ⟨fun h => le_iff_exists_add.mpr ⟨b - a, h.symm⟩, add_tsub_cancel_of_le⟩
#align add_tsub_cancel_iff_le add_tsub_cancel_iff_le

/- warning: tsub_add_cancel_iff_le -> tsub_add_cancel_iff_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a) a) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a) a) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
Case conversion may be inaccurate. Consider using '#align tsub_add_cancel_iff_le tsub_add_cancel_iff_leₓ'. -/
theorem tsub_add_cancel_iff_le : b - a + a = b ↔ a ≤ b := by
  rw [add_comm]
  exact add_tsub_cancel_iff_le
#align tsub_add_cancel_iff_le tsub_add_cancel_iff_le

/- warning: tsub_eq_zero_iff_le -> tsub_eq_zero_iff_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
Case conversion may be inaccurate. Consider using '#align tsub_eq_zero_iff_le tsub_eq_zero_iff_leₓ'. -/
@[simp]
theorem tsub_eq_zero_iff_le : a - b = 0 ↔ a ≤ b := by
  rw [← nonpos_iff_eq_zero, tsub_le_iff_left, add_zero]
#align tsub_eq_zero_iff_le tsub_eq_zero_iff_le

alias tsub_eq_zero_iff_le ↔ _ tsub_eq_zero_of_le

attribute [simp] tsub_eq_zero_of_le

/- warning: tsub_self -> tsub_self is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a a) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a a) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align tsub_self tsub_selfₓ'. -/
@[simp]
theorem tsub_self (a : α) : a - a = 0 :=
  tsub_eq_zero_of_le le_rfl
#align tsub_self tsub_self

/- warning: tsub_le_self -> tsub_le_self is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a
Case conversion may be inaccurate. Consider using '#align tsub_le_self tsub_le_selfₓ'. -/
@[simp]
theorem tsub_le_self : a - b ≤ a :=
  tsub_le_iff_left.mpr <| le_add_left le_rfl
#align tsub_le_self tsub_le_self

/- warning: zero_tsub -> zero_tsub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))) a) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) a) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align zero_tsub zero_tsubₓ'. -/
@[simp]
theorem zero_tsub (a : α) : 0 - a = 0 :=
  tsub_eq_zero_of_le <| zero_le a
#align zero_tsub zero_tsub

/- warning: tsub_self_add -> tsub_self_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α) (b : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) a b)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α) (b : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) a b)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align tsub_self_add tsub_self_addₓ'. -/
theorem tsub_self_add (a b : α) : a - (a + b) = 0 :=
  tsub_eq_zero_of_le <| self_le_add_right _ _
#align tsub_self_add tsub_self_add

/- warning: tsub_pos_iff_not_le -> tsub_pos_iff_not_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)) (Not (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)) (Not (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b))
Case conversion may be inaccurate. Consider using '#align tsub_pos_iff_not_le tsub_pos_iff_not_leₓ'. -/
theorem tsub_pos_iff_not_le : 0 < a - b ↔ ¬a ≤ b := by
  rw [pos_iff_ne_zero, Ne.def, tsub_eq_zero_iff_le]
#align tsub_pos_iff_not_le tsub_pos_iff_not_le

/- warning: tsub_pos_of_lt -> tsub_pos_of_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a))
Case conversion may be inaccurate. Consider using '#align tsub_pos_of_lt tsub_pos_of_ltₓ'. -/
theorem tsub_pos_of_lt (h : a < b) : 0 < b - a :=
  tsub_pos_iff_not_le.mpr h.not_le
#align tsub_pos_of_lt tsub_pos_of_lt

/- warning: tsub_lt_of_lt -> tsub_lt_of_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) b)
Case conversion may be inaccurate. Consider using '#align tsub_lt_of_lt tsub_lt_of_ltₓ'. -/
theorem tsub_lt_of_lt (h : a < b) : a - c < b :=
  lt_of_le_of_lt tsub_le_self h
#align tsub_lt_of_lt tsub_lt_of_lt

namespace AddLECancellable

/- warning: add_le_cancellable.tsub_le_tsub_iff_left -> AddLECancellable.tsub_le_tsub_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_le_tsub_iff_left AddLECancellable.tsub_le_tsub_iff_leftₓ'. -/
protected theorem tsub_le_tsub_iff_left (ha : AddLECancellable a) (hc : AddLECancellable c)
    (h : c ≤ a) : a - b ≤ a - c ↔ c ≤ b := by
  refine' ⟨_, fun h => tsub_le_tsub_left h a⟩
  rw [tsub_le_iff_left, ← hc.add_tsub_assoc_of_le h, hc.le_tsub_iff_right (h.trans le_add_self),
    add_comm b]
  apply ha
#align add_le_cancellable.tsub_le_tsub_iff_left AddLECancellable.tsub_le_tsub_iff_left

/- warning: add_le_cancellable.tsub_right_inj -> AddLECancellable.tsub_right_inj is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b) -> (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (Eq.{succ u1} α b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b) -> (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (Eq.{succ u1} α b c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_right_inj AddLECancellable.tsub_right_injₓ'. -/
protected theorem tsub_right_inj (ha : AddLECancellable a) (hb : AddLECancellable b)
    (hc : AddLECancellable c) (hba : b ≤ a) (hca : c ≤ a) : a - b = a - c ↔ b = c := by
  simp_rw [le_antisymm_iff, ha.tsub_le_tsub_iff_left hb hba, ha.tsub_le_tsub_iff_left hc hca,
    and_comm']
#align add_le_cancellable.tsub_right_inj AddLECancellable.tsub_right_inj

end AddLECancellable

/-! #### Lemmas where addition is order-reflecting. -/


section Contra

variable [ContravariantClass α α (· + ·) (· ≤ ·)]

/- warning: tsub_le_tsub_iff_left -> tsub_le_tsub_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6892 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6894 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6892 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6894) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6907 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6909 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6907 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6909)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c b))
Case conversion may be inaccurate. Consider using '#align tsub_le_tsub_iff_left tsub_le_tsub_iff_leftₓ'. -/
theorem tsub_le_tsub_iff_left (h : c ≤ a) : a - b ≤ a - c ↔ c ≤ b :=
  Contravariant.AddLECancellable.tsub_le_tsub_iff_left Contravariant.AddLECancellable h
#align tsub_le_tsub_iff_left tsub_le_tsub_iff_left

/- warning: tsub_right_inj -> tsub_right_inj is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (Eq.{succ u1} α b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6967 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6969 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6967 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6969) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6982 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6984 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6982 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6984)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (Eq.{succ u1} α b c))
Case conversion may be inaccurate. Consider using '#align tsub_right_inj tsub_right_injₓ'. -/
theorem tsub_right_inj (hba : b ≤ a) (hca : c ≤ a) : a - b = a - c ↔ b = c :=
  Contravariant.AddLECancellable.tsub_right_inj Contravariant.AddLECancellable
    Contravariant.AddLECancellable hba hca
#align tsub_right_inj tsub_right_inj

variable (α)

/- warning: canonically_ordered_add_monoid.to_add_cancel_comm_monoid -> CanonicallyOrderedAddMonoid.toAddCancelCommMonoid is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))], AddCancelCommMonoid.{u1} α
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7102 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7104 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7102 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7104) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7117 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7119 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7117 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7119)], AddCancelCommMonoid.{u1} α
Case conversion may be inaccurate. Consider using '#align canonically_ordered_add_monoid.to_add_cancel_comm_monoid CanonicallyOrderedAddMonoid.toAddCancelCommMonoidₓ'. -/
/-- A `canonically_ordered_add_monoid` with ordered subtraction and order-reflecting addition is
cancellative. This is not an instance at it would form a typeclass loop.

See note [reducible non-instances]. -/
@[reducible]
def CanonicallyOrderedAddMonoid.toAddCancelCommMonoid : AddCancelCommMonoid α :=
  { (by infer_instance : AddCommMonoid α) with
    add_left_cancel := fun a b c h => by
      simpa only [add_tsub_cancel_left] using congr_arg (fun x => x - a) h }
#align
  canonically_ordered_add_monoid.to_add_cancel_comm_monoid CanonicallyOrderedAddMonoid.toAddCancelCommMonoid

end Contra

end CanonicallyOrderedAddMonoid

/-! ### Lemmas in a linearly canonically ordered monoid. -/


section CanonicallyLinearOrderedAddMonoid

variable [CanonicallyLinearOrderedAddMonoid α] [Sub α] [OrderedSub α] {a b c d : α}

/- warning: tsub_pos_iff_lt -> tsub_pos_iff_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a)
Case conversion may be inaccurate. Consider using '#align tsub_pos_iff_lt tsub_pos_iff_ltₓ'. -/
@[simp]
theorem tsub_pos_iff_lt : 0 < a - b ↔ b < a := by rw [tsub_pos_iff_not_le, not_le]
#align tsub_pos_iff_lt tsub_pos_iff_lt

/- warning: tsub_eq_tsub_min -> tsub_eq_tsub_min is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] (a : α) (b : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (LinearOrder.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] (a : α) (b : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (Min.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toMin.{u1} α _inst_1) a b))
Case conversion may be inaccurate. Consider using '#align tsub_eq_tsub_min tsub_eq_tsub_minₓ'. -/
theorem tsub_eq_tsub_min (a b : α) : a - b = a - min a b := by
  cases' le_total a b with h h
  · rw [min_eq_left h, tsub_self, tsub_eq_zero_of_le h]
  · rw [min_eq_right h]
#align tsub_eq_tsub_min tsub_eq_tsub_min

namespace AddLECancellable

/- warning: add_le_cancellable.lt_tsub_iff_right -> AddLECancellable.lt_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a c) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.lt_tsub_iff_right AddLECancellable.lt_tsub_iff_rightₓ'. -/
protected theorem lt_tsub_iff_right (hc : AddLECancellable c) : a < b - c ↔ a + c < b :=
  ⟨lt_imp_lt_of_le_imp_le tsub_le_iff_right.mpr, hc.lt_tsub_of_add_lt_right⟩
#align add_le_cancellable.lt_tsub_iff_right AddLECancellable.lt_tsub_iff_right

/- warning: add_le_cancellable.lt_tsub_iff_left -> AddLECancellable.lt_tsub_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) c a) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) c a) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.lt_tsub_iff_left AddLECancellable.lt_tsub_iff_leftₓ'. -/
protected theorem lt_tsub_iff_left (hc : AddLECancellable c) : a < b - c ↔ c + a < b :=
  ⟨lt_imp_lt_of_le_imp_le tsub_le_iff_left.mpr, hc.lt_tsub_of_add_lt_left⟩
#align add_le_cancellable.lt_tsub_iff_left AddLECancellable.lt_tsub_iff_left

/- warning: add_le_cancellable.tsub_lt_tsub_iff_right -> AddLECancellable.tsub_lt_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_tsub_iff_right AddLECancellable.tsub_lt_tsub_iff_rightₓ'. -/
protected theorem tsub_lt_tsub_iff_right (hc : AddLECancellable c) (h : c ≤ a) :
    a - c < b - c ↔ a < b := by rw [hc.lt_tsub_iff_left, add_tsub_cancel_of_le h]
#align add_le_cancellable.tsub_lt_tsub_iff_right AddLECancellable.tsub_lt_tsub_iff_right

/- warning: add_le_cancellable.tsub_lt_self -> AddLECancellable.tsub_lt_self is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a)
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_self AddLECancellable.tsub_lt_selfₓ'. -/
protected theorem tsub_lt_self (ha : AddLECancellable a) (h₁ : 0 < a) (h₂ : 0 < b) : a - b < a := by
  refine' tsub_le_self.lt_of_ne fun h => _
  rw [← h, tsub_pos_iff_lt] at h₁
  exact h₂.not_le (ha.add_le_iff_nonpos_left.1 <| add_le_of_le_tsub_left_of_le h₁.le h.ge)
#align add_le_cancellable.tsub_lt_self AddLECancellable.tsub_lt_self

/- warning: add_le_cancellable.tsub_lt_self_iff -> AddLECancellable.tsub_lt_self_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a) (And (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) a) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a) (And (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) b)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_self_iff AddLECancellable.tsub_lt_self_iffₓ'. -/
protected theorem tsub_lt_self_iff (ha : AddLECancellable a) : a - b < a ↔ 0 < a ∧ 0 < b := by
  refine'
    ⟨fun h => ⟨(zero_le _).trans_lt h, (zero_le b).lt_of_ne _⟩, fun h => ha.tsub_lt_self h.1 h.2⟩
  rintro rfl
  rw [tsub_zero] at h
  exact h.false
#align add_le_cancellable.tsub_lt_self_iff AddLECancellable.tsub_lt_self_iff

/- warning: add_le_cancellable.tsub_lt_tsub_iff_left_of_le -> AddLECancellable.tsub_lt_tsub_iff_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_tsub_iff_left_of_le AddLECancellable.tsub_lt_tsub_iff_left_of_leₓ'. -/
/-- See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order. -/
protected theorem tsub_lt_tsub_iff_left_of_le (ha : AddLECancellable a) (hb : AddLECancellable b)
    (h : b ≤ a) : a - b < a - c ↔ c < b :=
  lt_iff_lt_of_le_iff_le <| ha.tsub_le_tsub_iff_left hb h
#align add_le_cancellable.tsub_lt_tsub_iff_left_of_le AddLECancellable.tsub_lt_tsub_iff_left_of_le

end AddLECancellable

section Contra

variable [ContravariantClass α α (· + ·) (· ≤ ·)]

/- warning: tsub_lt_tsub_iff_right -> tsub_lt_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7834 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7836 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7834 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7836) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7849 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7851 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7849 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7851)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a b))
Case conversion may be inaccurate. Consider using '#align tsub_lt_tsub_iff_right tsub_lt_tsub_iff_rightₓ'. -/
/-- This lemma also holds for `ennreal`, but we need a different proof for that. -/
theorem tsub_lt_tsub_iff_right (h : c ≤ a) : a - c < b - c ↔ a < b :=
  Contravariant.AddLECancellable.tsub_lt_tsub_iff_right h
#align tsub_lt_tsub_iff_right tsub_lt_tsub_iff_right

/- warning: tsub_lt_self -> tsub_lt_self is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7908 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7910 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7908 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7910) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7923 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7925 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7923 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7925)], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a)
Case conversion may be inaccurate. Consider using '#align tsub_lt_self tsub_lt_selfₓ'. -/
theorem tsub_lt_self : 0 < a → 0 < b → a - b < a :=
  Contravariant.AddLECancellable.tsub_lt_self
#align tsub_lt_self tsub_lt_self

/- warning: tsub_lt_self_iff -> tsub_lt_self_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))], Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a) (And (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) a) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7978 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7980 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7978 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7980) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7993 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7995 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7993 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7995)], Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a) (And (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) b))
Case conversion may be inaccurate. Consider using '#align tsub_lt_self_iff tsub_lt_self_iffₓ'. -/
theorem tsub_lt_self_iff : a - b < a ↔ 0 < a ∧ 0 < b :=
  Contravariant.AddLECancellable.tsub_lt_self_iff
#align tsub_lt_self_iff tsub_lt_self_iff

/- warning: tsub_lt_tsub_iff_left_of_le -> tsub_lt_tsub_iff_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8052 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8054 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8052 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8054) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8067 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8069 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8067 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8069)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c b))
Case conversion may be inaccurate. Consider using '#align tsub_lt_tsub_iff_left_of_le tsub_lt_tsub_iff_left_of_leₓ'. -/
/-- See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order. -/
theorem tsub_lt_tsub_iff_left_of_le (h : b ≤ a) : a - b < a - c ↔ c < b :=
  Contravariant.AddLECancellable.tsub_lt_tsub_iff_left_of_le Contravariant.AddLECancellable h
#align tsub_lt_tsub_iff_left_of_le tsub_lt_tsub_iff_left_of_le

end Contra

/-! ### Lemmas about `max` and `min`. -/


/- warning: tsub_add_eq_max -> tsub_add_eq_max is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) b) (LinearOrder.max.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) b) (Max.max.{u1} α (CanonicallyLinearOrderedAddMonoid.toMax.{u1} α _inst_1) a b)
Case conversion may be inaccurate. Consider using '#align tsub_add_eq_max tsub_add_eq_maxₓ'. -/
theorem tsub_add_eq_max : a - b + b = max a b := by
  cases' le_total a b with h h
  · rw [max_eq_right h, tsub_eq_zero_of_le h, zero_add]
  · rw [max_eq_left h, tsub_add_cancel_of_le h]
#align tsub_add_eq_max tsub_add_eq_max

/- warning: add_tsub_eq_max -> add_tsub_eq_max is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a)) (LinearOrder.max.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a)) (Max.max.{u1} α (CanonicallyLinearOrderedAddMonoid.toMax.{u1} α _inst_1) a b)
Case conversion may be inaccurate. Consider using '#align add_tsub_eq_max add_tsub_eq_maxₓ'. -/
theorem add_tsub_eq_max : a + (b - a) = max a b := by rw [add_comm, max_comm, tsub_add_eq_max]
#align add_tsub_eq_max add_tsub_eq_max

/- warning: tsub_min -> tsub_min is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (LinearOrder.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (Min.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toMin.{u1} α _inst_1) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)
Case conversion may be inaccurate. Consider using '#align tsub_min tsub_minₓ'. -/
theorem tsub_min : a - min a b = a - b := by
  cases' le_total a b with h h
  · rw [min_eq_left h, tsub_self, tsub_eq_zero_of_le h]
  · rw [min_eq_right h]
#align tsub_min tsub_min

/- warning: tsub_add_min -> tsub_add_min is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (LinearOrder.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1) a b)) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (Min.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toMin.{u1} α _inst_1) a b)) a
Case conversion may be inaccurate. Consider using '#align tsub_add_min tsub_add_minₓ'. -/
theorem tsub_add_min : a - b + min a b = a := by
  rw [← tsub_min, tsub_add_cancel_of_le]
  apply min_le_left
#align tsub_add_min tsub_add_min

end CanonicallyLinearOrderedAddMonoid

