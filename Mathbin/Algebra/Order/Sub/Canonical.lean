/-
Copyright (c) 2021 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn

! This file was ported from Lean 3 source module algebra.order.sub.canonical
! leanprover-community/mathlib commit 448144f7ae193a8990cb7473c9e9a01990f64ac7
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.Monoid.Canonical.Defs
import Mathbin.Algebra.Order.Sub.Defs

/-!
# Lemmas about subtraction in canonically ordered monoids

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
-/


variable {α : Type _}

section ExistsAddOfLE

variable [AddCommSemigroup α] [PartialOrder α] [ExistsAddOfLE α]
  [CovariantClass α α (· + ·) (· ≤ ·)] [Sub α] [OrderedSub α] {a b c d : α}

/- warning: add_tsub_cancel_of_le -> add_tsub_cancel_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.90 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.92 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.90 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.92) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.105 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.107 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.105 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.107)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) b)
Case conversion may be inaccurate. Consider using '#align add_tsub_cancel_of_le add_tsub_cancel_of_leₓ'. -/
@[simp]
theorem add_tsub_cancel_of_le (h : a ≤ b) : a + (b - a) = b :=
  by
  refine' le_antisymm _ le_add_tsub
  obtain ⟨c, rfl⟩ := exists_add_of_le h
  exact add_le_add_left add_tsub_le_left a
#align add_tsub_cancel_of_le add_tsub_cancel_of_le

/- warning: tsub_add_cancel_of_le -> tsub_add_cancel_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a) a) b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.176 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.178 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.176 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.178) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.191 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.193 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.191 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.193)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a) a) b)
Case conversion may be inaccurate. Consider using '#align tsub_add_cancel_of_le tsub_add_cancel_of_leₓ'. -/
theorem tsub_add_cancel_of_le (h : a ≤ b) : b - a + a = b :=
  by
  rw [add_comm]
  exact add_tsub_cancel_of_le h
#align tsub_add_cancel_of_le tsub_add_cancel_of_le

/- warning: add_le_of_le_tsub_right_of_le -> add_le_of_le_tsub_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.281 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.283 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.281 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.283) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.296 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.298 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.296 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.298)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c)
Case conversion may be inaccurate. Consider using '#align add_le_of_le_tsub_right_of_le add_le_of_le_tsub_right_of_leₓ'. -/
theorem add_le_of_le_tsub_right_of_le (h : b ≤ c) (h2 : a ≤ c - b) : a + b ≤ c :=
  (add_le_add_right h2 b).trans_eq <| tsub_add_cancel_of_le h
#align add_le_of_le_tsub_right_of_le add_le_of_le_tsub_right_of_le

/- warning: add_le_of_le_tsub_left_of_le -> add_le_of_le_tsub_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.366 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.368 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.366 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.368) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.381 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.383 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.381 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.383)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c)
Case conversion may be inaccurate. Consider using '#align add_le_of_le_tsub_left_of_le add_le_of_le_tsub_left_of_leₓ'. -/
theorem add_le_of_le_tsub_left_of_le (h : a ≤ c) (h2 : b ≤ c - a) : a + b ≤ c :=
  (add_le_add_left h2 a).trans_eq <| add_tsub_cancel_of_le h
#align add_le_of_le_tsub_left_of_le add_le_of_le_tsub_left_of_le

/- warning: tsub_le_tsub_iff_right -> tsub_le_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.451 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.453 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.451 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.453) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.466 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.468 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.466 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.468)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b))
Case conversion may be inaccurate. Consider using '#align tsub_le_tsub_iff_right tsub_le_tsub_iff_rightₓ'. -/
theorem tsub_le_tsub_iff_right (h : c ≤ b) : a - c ≤ b - c ↔ a ≤ b := by
  rw [tsub_le_iff_right, tsub_add_cancel_of_le h]
#align tsub_le_tsub_iff_right tsub_le_tsub_iff_right

/- warning: tsub_left_inj -> tsub_left_inj is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.559 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.561 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.559 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.561) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.574 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.576 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.574 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.576)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α a b))
Case conversion may be inaccurate. Consider using '#align tsub_left_inj tsub_left_injₓ'. -/
theorem tsub_left_inj (h1 : c ≤ a) (h2 : c ≤ b) : a - c = b - c ↔ a = b := by
  simp_rw [le_antisymm_iff, tsub_le_tsub_iff_right h1, tsub_le_tsub_iff_right h2]
#align tsub_left_inj tsub_left_inj

/- warning: tsub_inj_left -> tsub_inj_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) -> (Eq.{succ u1} α b c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.654 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.656 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.654 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.656) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.669 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.671 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.669 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.671)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) -> (Eq.{succ u1} α b c)
Case conversion may be inaccurate. Consider using '#align tsub_inj_left tsub_inj_leftₓ'. -/
theorem tsub_inj_left (h₁ : a ≤ b) (h₂ : a ≤ c) : b - a = c - a → b = c :=
  (tsub_left_inj h₁ h₂).1
#align tsub_inj_left tsub_inj_left

/- warning: lt_of_tsub_lt_tsub_right_of_le -> lt_of_tsub_lt_tsub_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.741 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.743 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.741 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.743) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.756 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.758 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.756 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.758)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b)
Case conversion may be inaccurate. Consider using '#align lt_of_tsub_lt_tsub_right_of_le lt_of_tsub_lt_tsub_right_of_leₓ'. -/
/-- See `lt_of_tsub_lt_tsub_right` for a stronger statement in a linear order. -/
theorem lt_of_tsub_lt_tsub_right_of_le (h : c ≤ b) (h2 : a - c < b - c) : a < b :=
  by
  refine' ((tsub_le_tsub_iff_right h).mp h2.le).lt_of_ne _
  rintro rfl
  exact h2.false
#align lt_of_tsub_lt_tsub_right_of_le lt_of_tsub_lt_tsub_right_of_le

/- warning: tsub_add_tsub_cancel -> tsub_add_tsub_cancel is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.834 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.836 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.834 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.836) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.849 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.851 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.849 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.851)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
Case conversion may be inaccurate. Consider using '#align tsub_add_tsub_cancel tsub_add_tsub_cancelₓ'. -/
theorem tsub_add_tsub_cancel (hab : b ≤ a) (hcb : c ≤ b) : a - b + (b - c) = a - c :=
  by
  convert tsub_add_cancel_of_le (tsub_le_tsub_right hab c) using 2
  rw [tsub_tsub, add_tsub_cancel_of_le hcb]
#align tsub_add_tsub_cancel tsub_add_tsub_cancel

/- warning: tsub_tsub_tsub_cancel_right -> tsub_tsub_tsub_cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.974 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.976 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.974 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.976) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.989 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.991 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.989 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.991)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b))
Case conversion may be inaccurate. Consider using '#align tsub_tsub_tsub_cancel_right tsub_tsub_tsub_cancel_rightₓ'. -/
theorem tsub_tsub_tsub_cancel_right (h : c ≤ b) : a - c - (b - c) = a - b := by
  rw [tsub_tsub, add_tsub_cancel_of_le h]
#align tsub_tsub_tsub_cancel_right tsub_tsub_tsub_cancel_right

/-! #### Lemmas that assume that an element is `add_le_cancellable`. -/


namespace AddLECancellable

/- warning: add_le_cancellable.eq_tsub_iff_add_eq_of_le -> AddLECancellable.eq_tsub_iff_add_eq_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1081 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1083 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1081 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1083) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1096 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1098 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1096 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1098)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.eq_tsub_iff_add_eq_of_le AddLECancellable.eq_tsub_iff_add_eq_of_leₓ'. -/
protected theorem eq_tsub_iff_add_eq_of_le (hc : AddLECancellable c) (h : c ≤ b) :
    a = b - c ↔ a + c = b :=
  ⟨by
    rintro rfl
    exact tsub_add_cancel_of_le h, hc.eq_tsub_of_add_eq⟩
#align add_le_cancellable.eq_tsub_iff_add_eq_of_le AddLECancellable.eq_tsub_iff_add_eq_of_le

/- warning: add_le_cancellable.tsub_eq_iff_eq_add_of_le -> AddLECancellable.tsub_eq_iff_eq_add_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (Eq.{succ u1} α a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1172 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1174 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1172 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1174) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1187 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1189 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1187 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1189)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (Eq.{succ u1} α a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_eq_iff_eq_add_of_le AddLECancellable.tsub_eq_iff_eq_add_of_leₓ'. -/
protected theorem tsub_eq_iff_eq_add_of_le (hb : AddLECancellable b) (h : b ≤ a) :
    a - b = c ↔ a = c + b := by rw [eq_comm, hb.eq_tsub_iff_add_eq_of_le h, eq_comm]
#align add_le_cancellable.tsub_eq_iff_eq_add_of_le AddLECancellable.tsub_eq_iff_eq_add_of_le

/- warning: add_le_cancellable.add_tsub_assoc_of_le -> AddLECancellable.add_tsub_assoc_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (forall (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1283 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1285 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1283 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1285) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1298 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1300 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1298 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1300)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (forall (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.add_tsub_assoc_of_le AddLECancellable.add_tsub_assoc_of_leₓ'. -/
protected theorem add_tsub_assoc_of_le (hc : AddLECancellable c) (h : c ≤ b) (a : α) :
    a + b - c = a + (b - c) := by
  conv_lhs => rw [← add_tsub_cancel_of_le h, add_comm c, ← add_assoc, hc.add_tsub_cancel_right]
#align add_le_cancellable.add_tsub_assoc_of_le AddLECancellable.add_tsub_assoc_of_le

/- warning: add_le_cancellable.tsub_add_eq_add_tsub -> AddLECancellable.tsub_add_eq_add_tsub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1389 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1391 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1389 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1391) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1404 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1406 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1404 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1406)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_add_eq_add_tsub AddLECancellable.tsub_add_eq_add_tsubₓ'. -/
protected theorem tsub_add_eq_add_tsub (hb : AddLECancellable b) (h : b ≤ a) :
    a - b + c = a + c - b := by rw [add_comm a, hb.add_tsub_assoc_of_le h, add_comm]
#align add_le_cancellable.tsub_add_eq_add_tsub AddLECancellable.tsub_add_eq_add_tsub

/- warning: add_le_cancellable.tsub_tsub_assoc -> AddLECancellable.tsub_tsub_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1498 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1500 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1498 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1500) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1513 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1515 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1513 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1515)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_tsub_assoc AddLECancellable.tsub_tsub_assocₓ'. -/
protected theorem tsub_tsub_assoc (hbc : AddLECancellable (b - c)) (h₁ : b ≤ a) (h₂ : c ≤ b) :
    a - (b - c) = a - b + c :=
  hbc.tsub_eq_of_eq_add <| by rw [add_assoc, add_tsub_cancel_of_le h₂, tsub_add_cancel_of_le h₁]
#align add_le_cancellable.tsub_tsub_assoc AddLECancellable.tsub_tsub_assoc

/- warning: add_le_cancellable.tsub_add_tsub_comm -> AddLECancellable.tsub_add_tsub_comm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} {d : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d c) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c d)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b d)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1621 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1623 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1621 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1623) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1636 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1638 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1636 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1638)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} {d : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d c) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c d)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b d)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_add_tsub_comm AddLECancellable.tsub_add_tsub_commₓ'. -/
protected theorem tsub_add_tsub_comm (hb : AddLECancellable b) (hd : AddLECancellable d)
    (hba : b ≤ a) (hdc : d ≤ c) : a - b + (c - d) = a + c - (b + d) := by
  rw [hb.tsub_add_eq_add_tsub hba, ← hd.add_tsub_assoc_of_le hdc, tsub_tsub, add_comm d]
#align add_le_cancellable.tsub_add_tsub_comm AddLECancellable.tsub_add_tsub_comm

/- warning: add_le_cancellable.le_tsub_iff_left -> AddLECancellable.le_tsub_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1743 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1745 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1743 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1745) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1758 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1760 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1758 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1760)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.le_tsub_iff_left AddLECancellable.le_tsub_iff_leftₓ'. -/
protected theorem le_tsub_iff_left (ha : AddLECancellable a) (h : a ≤ c) : b ≤ c - a ↔ a + b ≤ c :=
  ⟨add_le_of_le_tsub_left_of_le h, ha.le_tsub_of_add_le_left⟩
#align add_le_cancellable.le_tsub_iff_left AddLECancellable.le_tsub_iff_left

/- warning: add_le_cancellable.le_tsub_iff_right -> AddLECancellable.le_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b a) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1828 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1830 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1828 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1830) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1843 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1845 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1843 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1845)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b a) c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.le_tsub_iff_right AddLECancellable.le_tsub_iff_rightₓ'. -/
protected theorem le_tsub_iff_right (ha : AddLECancellable a) (h : a ≤ c) : b ≤ c - a ↔ b + a ≤ c :=
  by
  rw [add_comm]
  exact ha.le_tsub_iff_left h
#align add_le_cancellable.le_tsub_iff_right AddLECancellable.le_tsub_iff_right

/- warning: add_le_cancellable.tsub_lt_iff_left -> AddLECancellable.tsub_lt_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1943 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1945 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1943 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1945) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1958 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1960 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1958 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.1960)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_iff_left AddLECancellable.tsub_lt_iff_leftₓ'. -/
protected theorem tsub_lt_iff_left (hb : AddLECancellable b) (hba : b ≤ a) :
    a - b < c ↔ a < b + c := by
  refine' ⟨hb.lt_add_of_tsub_lt_left, _⟩
  intro h; refine' (tsub_le_iff_left.mpr h.le).lt_of_ne _
  rintro rfl; exact h.ne' (add_tsub_cancel_of_le hba)
#align add_le_cancellable.tsub_lt_iff_left AddLECancellable.tsub_lt_iff_left

/- warning: add_le_cancellable.tsub_lt_iff_right -> AddLECancellable.tsub_lt_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2047 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2049 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2047 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2049) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2062 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2064 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2062 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2064)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_iff_right AddLECancellable.tsub_lt_iff_rightₓ'. -/
protected theorem tsub_lt_iff_right (hb : AddLECancellable b) (hba : b ≤ a) :
    a - b < c ↔ a < c + b := by
  rw [add_comm]
  exact hb.tsub_lt_iff_left hba
#align add_le_cancellable.tsub_lt_iff_right AddLECancellable.tsub_lt_iff_right

/- warning: add_le_cancellable.tsub_lt_iff_tsub_lt -> AddLECancellable.tsub_lt_iff_tsub_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2162 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2164 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2162 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2164) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2177 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2179 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2177 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2179)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_iff_tsub_lt AddLECancellable.tsub_lt_iff_tsub_ltₓ'. -/
protected theorem tsub_lt_iff_tsub_lt (hb : AddLECancellable b) (hc : AddLECancellable c)
    (h₁ : b ≤ a) (h₂ : c ≤ a) : a - b < c ↔ a - c < b := by
  rw [hb.tsub_lt_iff_left h₁, hc.tsub_lt_iff_right h₂]
#align add_le_cancellable.tsub_lt_iff_tsub_lt AddLECancellable.tsub_lt_iff_tsub_lt

/- warning: add_le_cancellable.le_tsub_iff_le_tsub -> AddLECancellable.le_tsub_iff_le_tsub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2280 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2282 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2280 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2282) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2295 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2297 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2295 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2297)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a) -> (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.le_tsub_iff_le_tsub AddLECancellable.le_tsub_iff_le_tsubₓ'. -/
protected theorem le_tsub_iff_le_tsub (ha : AddLECancellable a) (hc : AddLECancellable c)
    (h₁ : a ≤ b) (h₂ : c ≤ b) : a ≤ b - c ↔ c ≤ b - a := by
  rw [ha.le_tsub_iff_left h₁, hc.le_tsub_iff_right h₂]
#align add_le_cancellable.le_tsub_iff_le_tsub AddLECancellable.le_tsub_iff_le_tsub

/- warning: add_le_cancellable.lt_tsub_iff_right_of_le -> AddLECancellable.lt_tsub_iff_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2398 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2400 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2398 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2400) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2413 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2415 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2413 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2415)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.lt_tsub_iff_right_of_le AddLECancellable.lt_tsub_iff_right_of_leₓ'. -/
protected theorem lt_tsub_iff_right_of_le (hc : AddLECancellable c) (h : c ≤ b) :
    a < b - c ↔ a + c < b :=
  by
  refine' ⟨fun h' => (add_le_of_le_tsub_right_of_le h h'.le).lt_of_ne _, hc.lt_tsub_of_add_lt_right⟩
  rintro rfl
  exact h'.ne' hc.add_tsub_cancel_right
#align add_le_cancellable.lt_tsub_iff_right_of_le AddLECancellable.lt_tsub_iff_right_of_le

/- warning: add_le_cancellable.lt_tsub_iff_left_of_le -> AddLECancellable.lt_tsub_iff_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c a) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2500 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2502 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2500 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2502) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2515 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2517 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2515 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2517)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c a) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.lt_tsub_iff_left_of_le AddLECancellable.lt_tsub_iff_left_of_leₓ'. -/
protected theorem lt_tsub_iff_left_of_le (hc : AddLECancellable c) (h : c ≤ b) :
    a < b - c ↔ c + a < b := by
  rw [add_comm]
  exact hc.lt_tsub_iff_right_of_le h
#align add_le_cancellable.lt_tsub_iff_left_of_le AddLECancellable.lt_tsub_iff_left_of_le

/- warning: add_le_cancellable.tsub_inj_right -> AddLECancellable.tsub_inj_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (Eq.{succ u1} α b c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2615 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2617 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2615 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2617) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2630 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2632 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2630 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2632)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (Eq.{succ u1} α b c)
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_inj_right AddLECancellable.tsub_inj_rightₓ'. -/
protected theorem tsub_inj_right (hab : AddLECancellable (a - b)) (h₁ : b ≤ a) (h₂ : c ≤ a)
    (h₃ : a - b = a - c) : b = c := by
  rw [← hab.inj]
  rw [tsub_add_cancel_of_le h₁, h₃, tsub_add_cancel_of_le h₂]
#align add_le_cancellable.tsub_inj_right AddLECancellable.tsub_inj_right

/- warning: add_le_cancellable.lt_of_tsub_lt_tsub_left_of_le -> AddLECancellable.lt_of_tsub_lt_tsub_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2765 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2767 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2765 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2767) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2780 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2782 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2780 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2782)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2809 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2811 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2809 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2811) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2824 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2826 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2824 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2826)], (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b)
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.lt_of_tsub_lt_tsub_left_of_le AddLECancellable.lt_of_tsub_lt_tsub_left_of_leₓ'. -/
protected theorem lt_of_tsub_lt_tsub_left_of_le [ContravariantClass α α (· + ·) (· < ·)]
    (hb : AddLECancellable b) (hca : c ≤ a) (h : a - b < a - c) : c < b :=
  by
  conv_lhs at h => rw [← tsub_add_cancel_of_le hca]
  exact lt_of_add_lt_add_left (hb.lt_add_of_tsub_lt_right h)
#align add_le_cancellable.lt_of_tsub_lt_tsub_left_of_le AddLECancellable.lt_of_tsub_lt_tsub_left_of_le

/- warning: add_le_cancellable.tsub_lt_tsub_left_of_le -> AddLECancellable.tsub_lt_tsub_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2897 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2899 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2897 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2899) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2912 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2914 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2912 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2914)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_tsub_left_of_le AddLECancellable.tsub_lt_tsub_left_of_leₓ'. -/
protected theorem tsub_lt_tsub_left_of_le (hab : AddLECancellable (a - b)) (h₁ : b ≤ a)
    (h : c < b) : a - b < a - c :=
  (tsub_le_tsub_left h.le _).lt_of_ne fun h' => h.ne' <| hab.tsub_inj_right h₁ (h.le.trans h₁) h'
#align add_le_cancellable.tsub_lt_tsub_left_of_le AddLECancellable.tsub_lt_tsub_left_of_le

/- warning: add_le_cancellable.tsub_lt_tsub_right_of_le -> AddLECancellable.tsub_lt_tsub_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2999 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3001 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.2999 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3001) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3014 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3016 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3014 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3016)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_tsub_right_of_le AddLECancellable.tsub_lt_tsub_right_of_leₓ'. -/
protected theorem tsub_lt_tsub_right_of_le (hc : AddLECancellable c) (h : c ≤ a) (h2 : a < b) :
    a - c < b - c := by
  apply hc.lt_tsub_of_add_lt_left
  rwa [add_tsub_cancel_of_le h]
#align add_le_cancellable.tsub_lt_tsub_right_of_le AddLECancellable.tsub_lt_tsub_right_of_le

/- warning: add_le_cancellable.tsub_lt_tsub_iff_left_of_le_of_le -> AddLECancellable.tsub_lt_tsub_iff_left_of_le_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3116 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3118 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3116 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3118) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3131 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3133 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3131 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3133)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3160 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3162 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3160 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3162) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3175 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3177 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3175 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3177)], (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b) -> (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_tsub_iff_left_of_le_of_le AddLECancellable.tsub_lt_tsub_iff_left_of_le_of_leₓ'. -/
protected theorem tsub_lt_tsub_iff_left_of_le_of_le [ContravariantClass α α (· + ·) (· < ·)]
    (hb : AddLECancellable b) (hab : AddLECancellable (a - b)) (h₁ : b ≤ a) (h₂ : c ≤ a) :
    a - b < a - c ↔ c < b :=
  ⟨hb.lt_of_tsub_lt_tsub_left_of_le h₂, hab.tsub_lt_tsub_left_of_le h₁⟩
#align add_le_cancellable.tsub_lt_tsub_iff_left_of_le_of_le AddLECancellable.tsub_lt_tsub_iff_left_of_le_of_le

/- warning: add_le_cancellable.add_tsub_tsub_cancel -> AddLECancellable.add_tsub_tsub_cancel is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3249 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3251 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3249 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3251) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3264 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3266 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3264 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3266)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.add_tsub_tsub_cancel AddLECancellable.add_tsub_tsub_cancelₓ'. -/
@[simp]
protected theorem add_tsub_tsub_cancel (hac : AddLECancellable (a - c)) (h : c ≤ a) :
    a + b - (a - c) = b + c :=
  hac.tsub_eq_of_eq_add <| by rw [add_assoc, add_tsub_cancel_of_le h, add_comm]
#align add_le_cancellable.add_tsub_tsub_cancel AddLECancellable.add_tsub_tsub_cancel

/- warning: add_le_cancellable.tsub_tsub_cancel_of_le -> AddLECancellable.tsub_tsub_cancel_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3366 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3368 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3366 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3368) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3381 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3383 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3381 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3383)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) a)
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_tsub_cancel_of_le AddLECancellable.tsub_tsub_cancel_of_leₓ'. -/
protected theorem tsub_tsub_cancel_of_le (hba : AddLECancellable (b - a)) (h : a ≤ b) :
    b - (b - a) = a :=
  hba.tsub_eq_of_eq_add (add_tsub_cancel_of_le h).symm
#align add_le_cancellable.tsub_tsub_cancel_of_le AddLECancellable.tsub_tsub_cancel_of_le

/- warning: add_le_cancellable.tsub_tsub_tsub_cancel_left -> AddLECancellable.tsub_tsub_tsub_cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3450 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3452 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3450 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3452) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3465 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3467 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3465 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3467)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_tsub_tsub_cancel_left AddLECancellable.tsub_tsub_tsub_cancel_leftₓ'. -/
protected theorem tsub_tsub_tsub_cancel_left (hab : AddLECancellable (a - b)) (h : b ≤ a) :
    a - c - (a - b) = b - c := by rw [tsub_right_comm, hab.tsub_tsub_cancel_of_le h]
#align add_le_cancellable.tsub_tsub_tsub_cancel_left AddLECancellable.tsub_tsub_tsub_cancel_left

end AddLECancellable

section Contra

/-! ### Lemmas where addition is order-reflecting. -/


variable [ContravariantClass α α (· + ·) (· ≤ ·)]

/- warning: eq_tsub_iff_add_eq_of_le -> eq_tsub_iff_add_eq_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3656 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3658 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3656 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3658) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3671 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3673 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3671 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3673)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3700 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3702 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3700 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3702) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3715 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3717 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3715 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3717)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (Eq.{succ u1} α a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align eq_tsub_iff_add_eq_of_le eq_tsub_iff_add_eq_of_leₓ'. -/
theorem eq_tsub_iff_add_eq_of_le (h : c ≤ b) : a = b - c ↔ a + c = b :=
  Contravariant.AddLECancellable.eq_tsub_iff_add_eq_of_le h
#align eq_tsub_iff_add_eq_of_le eq_tsub_iff_add_eq_of_le

/- warning: tsub_eq_iff_eq_add_of_le -> tsub_eq_iff_eq_add_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (Eq.{succ u1} α a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3770 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3772 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3770 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3772) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3785 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3787 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3785 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3787)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3814 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3816 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3814 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3816) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3829 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3831 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3829 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3831)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (Eq.{succ u1} α a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
Case conversion may be inaccurate. Consider using '#align tsub_eq_iff_eq_add_of_le tsub_eq_iff_eq_add_of_leₓ'. -/
theorem tsub_eq_iff_eq_add_of_le (h : b ≤ a) : a - b = c ↔ a = c + b :=
  Contravariant.AddLECancellable.tsub_eq_iff_eq_add_of_le h
#align tsub_eq_iff_eq_add_of_le tsub_eq_iff_eq_add_of_le

/- warning: add_tsub_assoc_of_le -> add_tsub_assoc_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (forall (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3884 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3886 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3884 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3886) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3899 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3901 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3899 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3901)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3928 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3930 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3928 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3930) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3943 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3945 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3943 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3945)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (forall (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)))
Case conversion may be inaccurate. Consider using '#align add_tsub_assoc_of_le add_tsub_assoc_of_leₓ'. -/
/-- See `add_tsub_le_assoc` for an inequality. -/
theorem add_tsub_assoc_of_le (h : c ≤ b) (a : α) : a + b - c = a + (b - c) :=
  Contravariant.AddLECancellable.add_tsub_assoc_of_le h a
#align add_tsub_assoc_of_le add_tsub_assoc_of_le

/- warning: tsub_add_eq_add_tsub -> tsub_add_eq_add_tsub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3996 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3998 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3996 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.3998) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4011 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4013 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4011 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4013)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4040 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4042 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4040 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4042) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4055 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4057 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4055 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4057)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align tsub_add_eq_add_tsub tsub_add_eq_add_tsubₓ'. -/
theorem tsub_add_eq_add_tsub (h : b ≤ a) : a - b + c = a + c - b :=
  Contravariant.AddLECancellable.tsub_add_eq_add_tsub h
#align tsub_add_eq_add_tsub tsub_add_eq_add_tsub

/- warning: tsub_tsub_assoc -> tsub_tsub_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4106 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4108 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4106 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4108) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4121 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4123 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4121 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4123)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4150 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4152 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4150 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4152) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4165 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4167 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4165 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4167)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c))
Case conversion may be inaccurate. Consider using '#align tsub_tsub_assoc tsub_tsub_assocₓ'. -/
theorem tsub_tsub_assoc (h₁ : b ≤ a) (h₂ : c ≤ b) : a - (b - c) = a - b + c :=
  Contravariant.AddLECancellable.tsub_tsub_assoc h₁ h₂
#align tsub_tsub_assoc tsub_tsub_assoc

/- warning: tsub_add_tsub_comm -> tsub_add_tsub_comm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} {d : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d c) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c d)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b d)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4222 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4224 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4222 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4224) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4237 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4239 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4237 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4239)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} {d : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4266 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4268 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4266 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4268) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4281 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4283 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4281 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4283)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) d c) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c d)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b d)))
Case conversion may be inaccurate. Consider using '#align tsub_add_tsub_comm tsub_add_tsub_commₓ'. -/
theorem tsub_add_tsub_comm (hba : b ≤ a) (hdc : d ≤ c) : a - b + (c - d) = a + c - (b + d) :=
  Contravariant.AddLECancellable.tsub_add_tsub_comm Contravariant.AddLECancellable hba hdc
#align tsub_add_tsub_comm tsub_add_tsub_comm

/- warning: le_tsub_iff_left -> le_tsub_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4343 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4345 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4343 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4345) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4358 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4360 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4358 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4360)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4387 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4389 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4387 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4389) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4402 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4404 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4402 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4404)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) c))
Case conversion may be inaccurate. Consider using '#align le_tsub_iff_left le_tsub_iff_leftₓ'. -/
theorem le_tsub_iff_left (h : a ≤ c) : b ≤ c - a ↔ a + b ≤ c :=
  Contravariant.AddLECancellable.le_tsub_iff_left h
#align le_tsub_iff_left le_tsub_iff_left

/- warning: le_tsub_iff_right -> le_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b a) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4457 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4459 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4457 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4459) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4472 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4474 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4472 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4474)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4501 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4503 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4501 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4503) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4516 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4518 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4516 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4518)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a c) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) c a)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b a) c))
Case conversion may be inaccurate. Consider using '#align le_tsub_iff_right le_tsub_iff_rightₓ'. -/
theorem le_tsub_iff_right (h : a ≤ c) : b ≤ c - a ↔ b + a ≤ c :=
  Contravariant.AddLECancellable.le_tsub_iff_right h
#align le_tsub_iff_right le_tsub_iff_right

/- warning: tsub_lt_iff_left -> tsub_lt_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4571 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4573 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4571 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4573) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4586 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4588 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4586 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4588)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4615 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4617 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4615 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4617) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4630 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4632 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4630 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4632)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c)))
Case conversion may be inaccurate. Consider using '#align tsub_lt_iff_left tsub_lt_iff_leftₓ'. -/
theorem tsub_lt_iff_left (hbc : b ≤ a) : a - b < c ↔ a < b + c :=
  Contravariant.AddLECancellable.tsub_lt_iff_left hbc
#align tsub_lt_iff_left tsub_lt_iff_left

/- warning: tsub_lt_iff_right -> tsub_lt_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4685 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4687 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4685 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4687) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4700 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4702 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4700 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4702)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4729 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4731 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4729 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4731) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4744 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4746 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4744 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4746)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c b)))
Case conversion may be inaccurate. Consider using '#align tsub_lt_iff_right tsub_lt_iff_rightₓ'. -/
theorem tsub_lt_iff_right (hbc : b ≤ a) : a - b < c ↔ a < c + b :=
  Contravariant.AddLECancellable.tsub_lt_iff_right hbc
#align tsub_lt_iff_right tsub_lt_iff_right

/- warning: tsub_lt_iff_tsub_lt -> tsub_lt_iff_tsub_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4799 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4801 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4799 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4801) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4814 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4816 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4814 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4816)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4843 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4845 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4843 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4845) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4858 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4860 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4858 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4860)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) c) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) b))
Case conversion may be inaccurate. Consider using '#align tsub_lt_iff_tsub_lt tsub_lt_iff_tsub_ltₓ'. -/
theorem tsub_lt_iff_tsub_lt (h₁ : b ≤ a) (h₂ : c ≤ a) : a - b < c ↔ a - c < b :=
  Contravariant.AddLECancellable.tsub_lt_iff_tsub_lt Contravariant.AddLECancellable h₁ h₂
#align tsub_lt_iff_tsub_lt tsub_lt_iff_tsub_lt

/- warning: le_tsub_iff_le_tsub -> le_tsub_iff_le_tsub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4920 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4922 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4920 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4922) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4935 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4937 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4935 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4937)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4964 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4966 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4964 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4966) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4979 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4981 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4979 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.4981)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)))
Case conversion may be inaccurate. Consider using '#align le_tsub_iff_le_tsub le_tsub_iff_le_tsubₓ'. -/
theorem le_tsub_iff_le_tsub (h₁ : a ≤ b) (h₂ : c ≤ b) : a ≤ b - c ↔ c ≤ b - a :=
  Contravariant.AddLECancellable.le_tsub_iff_le_tsub Contravariant.AddLECancellable h₁ h₂
#align le_tsub_iff_le_tsub le_tsub_iff_le_tsub

/- warning: lt_tsub_iff_right_of_le -> lt_tsub_iff_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5041 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5043 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5041 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5043) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5056 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5058 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5056 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5058)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5085 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5087 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5085 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5087) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5100 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5102 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5100 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5102)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a c) b))
Case conversion may be inaccurate. Consider using '#align lt_tsub_iff_right_of_le lt_tsub_iff_right_of_leₓ'. -/
/-- See `lt_tsub_iff_right` for a stronger statement in a linear order. -/
theorem lt_tsub_iff_right_of_le (h : c ≤ b) : a < b - c ↔ a + c < b :=
  Contravariant.AddLECancellable.lt_tsub_iff_right_of_le h
#align lt_tsub_iff_right_of_le lt_tsub_iff_right_of_le

/- warning: lt_tsub_iff_left_of_le -> lt_tsub_iff_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c a) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5155 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5157 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5155 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5157) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5170 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5172 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5170 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5172)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5199 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5201 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5199 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5201) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5214 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5216 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5214 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5216)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) c a) b))
Case conversion may be inaccurate. Consider using '#align lt_tsub_iff_left_of_le lt_tsub_iff_left_of_leₓ'. -/
/-- See `lt_tsub_iff_left` for a stronger statement in a linear order. -/
theorem lt_tsub_iff_left_of_le (h : c ≤ b) : a < b - c ↔ c + a < b :=
  Contravariant.AddLECancellable.lt_tsub_iff_left_of_le h
#align lt_tsub_iff_left_of_le lt_tsub_iff_left_of_le

/- warning: lt_of_tsub_lt_tsub_left_of_le -> lt_of_tsub_lt_tsub_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_8 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5269 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5271 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5269 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5271) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5284 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5286 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5284 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5286)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5313 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5315 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5313 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5315) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5328 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5330 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5328 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5330)] [_inst_8 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5347 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5349 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5347 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5349) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5362 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5364 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5362 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5364)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b)
Case conversion may be inaccurate. Consider using '#align lt_of_tsub_lt_tsub_left_of_le lt_of_tsub_lt_tsub_left_of_leₓ'. -/
/-- See `lt_of_tsub_lt_tsub_left` for a stronger statement in a linear order. -/
theorem lt_of_tsub_lt_tsub_left_of_le [ContravariantClass α α (· + ·) (· < ·)] (hca : c ≤ a)
    (h : a - b < a - c) : c < b :=
  Contravariant.AddLECancellable.lt_of_tsub_lt_tsub_left_of_le hca h
#align lt_of_tsub_lt_tsub_left_of_le lt_of_tsub_lt_tsub_left_of_le

/- warning: tsub_lt_tsub_left_of_le -> tsub_lt_tsub_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5415 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5417 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5415 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5417) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5430 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5432 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5430 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5432)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5459 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5461 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5459 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5461) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5474 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5476 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5474 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5476)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c))
Case conversion may be inaccurate. Consider using '#align tsub_lt_tsub_left_of_le tsub_lt_tsub_left_of_leₓ'. -/
theorem tsub_lt_tsub_left_of_le : b ≤ a → c < b → a - b < a - c :=
  Contravariant.AddLECancellable.tsub_lt_tsub_left_of_le
#align tsub_lt_tsub_left_of_le tsub_lt_tsub_left_of_le

/- warning: tsub_lt_tsub_right_of_le -> tsub_lt_tsub_right_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5527 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5529 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5527 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5529) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5542 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5544 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5542 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5544)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5571 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5573 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5571 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5573) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5586 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5588 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5586 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5588)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
Case conversion may be inaccurate. Consider using '#align tsub_lt_tsub_right_of_le tsub_lt_tsub_right_of_leₓ'. -/
theorem tsub_lt_tsub_right_of_le (h : c ≤ a) (h2 : a < b) : a - c < b - c :=
  Contravariant.AddLECancellable.tsub_lt_tsub_right_of_le h h2
#align tsub_lt_tsub_right_of_le tsub_lt_tsub_right_of_le

/- warning: tsub_inj_right -> tsub_inj_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (Eq.{succ u1} α b c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5639 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5641 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5639 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5641) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5654 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5656 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5654 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5656)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5683 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5685 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5683 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5685) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5698 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5700 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5698 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5700)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) -> (Eq.{succ u1} α b c)
Case conversion may be inaccurate. Consider using '#align tsub_inj_right tsub_inj_rightₓ'. -/
theorem tsub_inj_right (h₁ : b ≤ a) (h₂ : c ≤ a) (h₃ : a - b = a - c) : b = c :=
  Contravariant.AddLECancellable.tsub_inj_right h₁ h₂ h₃
#align tsub_inj_right tsub_inj_right

/- warning: tsub_lt_tsub_iff_left_of_le_of_le -> tsub_lt_tsub_iff_left_of_le_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_8 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5757 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5759 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5757 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5759) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5772 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5774 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5772 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5774)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5801 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5803 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5801 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5803) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5816 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5818 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5816 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5818)] [_inst_8 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5835 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5837 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5835 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5837) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5850 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5852 : α) => LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5850 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5852)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c b))
Case conversion may be inaccurate. Consider using '#align tsub_lt_tsub_iff_left_of_le_of_le tsub_lt_tsub_iff_left_of_le_of_leₓ'. -/
/-- See `tsub_lt_tsub_iff_left_of_le` for a stronger statement in a linear order. -/
theorem tsub_lt_tsub_iff_left_of_le_of_le [ContravariantClass α α (· + ·) (· < ·)] (h₁ : b ≤ a)
    (h₂ : c ≤ a) : a - b < a - c ↔ c < b :=
  Contravariant.AddLECancellable.tsub_lt_tsub_iff_left_of_le_of_le Contravariant.AddLECancellable h₁
    h₂
#align tsub_lt_tsub_iff_left_of_le_of_le tsub_lt_tsub_iff_left_of_le_of_le

/- warning: add_tsub_tsub_cancel -> add_tsub_tsub_cancel is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5912 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5914 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5912 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5914) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5927 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5929 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5927 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5929)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5956 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5958 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5956 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5958) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5971 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5973 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5971 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.5973)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) c a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) b c))
Case conversion may be inaccurate. Consider using '#align add_tsub_tsub_cancel add_tsub_tsub_cancelₓ'. -/
@[simp]
theorem add_tsub_tsub_cancel (h : c ≤ a) : a + b - (a - c) = b + c :=
  Contravariant.AddLECancellable.add_tsub_tsub_cancel h
#align add_tsub_tsub_cancel add_tsub_tsub_cancel

/- warning: tsub_tsub_cancel_of_le -> tsub_tsub_cancel_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6022 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6024 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6022 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6024) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6037 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6039 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6037 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6039)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6066 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6068 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6066 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6068) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6081 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6083 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6081 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6083)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) a b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b a)) a)
Case conversion may be inaccurate. Consider using '#align tsub_tsub_cancel_of_le tsub_tsub_cancel_of_leₓ'. -/
/-- See `tsub_tsub_le` for an inequality. -/
theorem tsub_tsub_cancel_of_le (h : a ≤ b) : b - (b - a) = a :=
  Contravariant.AddLECancellable.tsub_tsub_cancel_of_le h
#align tsub_tsub_cancel_of_le tsub_tsub_cancel_of_le

/- warning: tsub_tsub_tsub_cancel_left -> tsub_tsub_tsub_cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toHasAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : AddCommSemigroup.{u1} α] [_inst_2 : PartialOrder.{u1} α] [_inst_3 : ExistsAddOfLE.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2))] [_inst_4 : CovariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6128 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6130 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6128 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6130) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6143 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6145 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6143 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6145)] [_inst_5 : Sub.{u1} α] [_inst_6 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1)) _inst_5] {a : α} {b : α} {c : α} [_inst_7 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6172 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6174 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddSemigroup.toAdd.{u1} α (AddCommSemigroup.toAddSemigroup.{u1} α _inst_1))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6172 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6174) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6187 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6189 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6187 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6189)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α _inst_2)) b a) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_5) b c))
Case conversion may be inaccurate. Consider using '#align tsub_tsub_tsub_cancel_left tsub_tsub_tsub_cancel_leftₓ'. -/
theorem tsub_tsub_tsub_cancel_left (h : b ≤ a) : a - c - (a - b) = b - c :=
  Contravariant.AddLECancellable.tsub_tsub_tsub_cancel_left h
#align tsub_tsub_tsub_cancel_left tsub_tsub_tsub_cancel_left

end Contra

end ExistsAddOfLE

/-! ### Lemmas in a canonically ordered monoid. -/


section CanonicallyOrderedAddMonoid

variable [CanonicallyOrderedAddMonoid α] [Sub α] [OrderedSub α] {a b c d : α}

/- warning: add_tsub_cancel_iff_le -> add_tsub_cancel_iff_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a)) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a)) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
Case conversion may be inaccurate. Consider using '#align add_tsub_cancel_iff_le add_tsub_cancel_iff_leₓ'. -/
theorem add_tsub_cancel_iff_le : a + (b - a) = b ↔ a ≤ b :=
  ⟨fun h => le_iff_exists_add.mpr ⟨b - a, h.symm⟩, add_tsub_cancel_of_le⟩
#align add_tsub_cancel_iff_le add_tsub_cancel_iff_le

/- warning: tsub_add_cancel_iff_le -> tsub_add_cancel_iff_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a) a) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a) a) b) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
Case conversion may be inaccurate. Consider using '#align tsub_add_cancel_iff_le tsub_add_cancel_iff_leₓ'. -/
theorem tsub_add_cancel_iff_le : b - a + a = b ↔ a ≤ b :=
  by
  rw [add_comm]
  exact add_tsub_cancel_iff_le
#align tsub_add_cancel_iff_le tsub_add_cancel_iff_le

/- warning: tsub_eq_zero_iff_le -> tsub_eq_zero_iff_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b)
Case conversion may be inaccurate. Consider using '#align tsub_eq_zero_iff_le tsub_eq_zero_iff_leₓ'. -/
@[simp]
theorem tsub_eq_zero_iff_le : a - b = 0 ↔ a ≤ b := by
  rw [← nonpos_iff_eq_zero, tsub_le_iff_left, add_zero]
#align tsub_eq_zero_iff_le tsub_eq_zero_iff_le

/- warning: tsub_eq_zero_of_le -> tsub_eq_zero_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b) -> (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align tsub_eq_zero_of_le tsub_eq_zero_of_leₓ'. -/
alias tsub_eq_zero_iff_le ↔ _ tsub_eq_zero_of_le
#align tsub_eq_zero_of_le tsub_eq_zero_of_le

attribute [simp] tsub_eq_zero_of_le

/- warning: tsub_self -> tsub_self is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a a) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a a) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align tsub_self tsub_selfₓ'. -/
@[simp]
theorem tsub_self (a : α) : a - a = 0 :=
  tsub_eq_zero_of_le le_rfl
#align tsub_self tsub_self

/- warning: tsub_le_self -> tsub_le_self is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a
Case conversion may be inaccurate. Consider using '#align tsub_le_self tsub_le_selfₓ'. -/
@[simp]
theorem tsub_le_self : a - b ≤ a :=
  tsub_le_iff_left.mpr <| le_add_left le_rfl
#align tsub_le_self tsub_le_self

/- warning: zero_tsub -> zero_tsub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))) a) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) a) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align zero_tsub zero_tsubₓ'. -/
@[simp]
theorem zero_tsub (a : α) : 0 - a = 0 :=
  tsub_eq_zero_of_le <| zero_le a
#align zero_tsub zero_tsub

/- warning: tsub_self_add -> tsub_self_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α) (b : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) a b)) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] (a : α) (b : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) a b)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align tsub_self_add tsub_self_addₓ'. -/
theorem tsub_self_add (a b : α) : a - (a + b) = 0 :=
  tsub_eq_zero_of_le <| self_le_add_right _ _
#align tsub_self_add tsub_self_add

/- warning: tsub_pos_iff_not_le -> tsub_pos_iff_not_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)) (Not (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)) (Not (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b))
Case conversion may be inaccurate. Consider using '#align tsub_pos_iff_not_le tsub_pos_iff_not_leₓ'. -/
theorem tsub_pos_iff_not_le : 0 < a - b ↔ ¬a ≤ b := by
  rw [pos_iff_ne_zero, Ne.def, tsub_eq_zero_iff_le]
#align tsub_pos_iff_not_le tsub_pos_iff_not_le

/- warning: tsub_pos_of_lt -> tsub_pos_of_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a))
Case conversion may be inaccurate. Consider using '#align tsub_pos_of_lt tsub_pos_of_ltₓ'. -/
theorem tsub_pos_of_lt (h : a < b) : 0 < b - a :=
  tsub_pos_iff_not_le.mpr h.not_le
#align tsub_pos_of_lt tsub_pos_of_lt

/- warning: tsub_lt_of_lt -> tsub_lt_of_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) b)
Case conversion may be inaccurate. Consider using '#align tsub_lt_of_lt tsub_lt_of_ltₓ'. -/
theorem tsub_lt_of_lt (h : a < b) : a - c < b :=
  lt_of_le_of_lt tsub_le_self h
#align tsub_lt_of_lt tsub_lt_of_lt

namespace AddLECancellable

/- warning: add_le_cancellable.tsub_le_tsub_iff_left -> AddLECancellable.tsub_le_tsub_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_le_tsub_iff_left AddLECancellable.tsub_le_tsub_iff_leftₓ'. -/
protected theorem tsub_le_tsub_iff_left (ha : AddLECancellable a) (hc : AddLECancellable c)
    (h : c ≤ a) : a - b ≤ a - c ↔ c ≤ b :=
  by
  refine' ⟨_, fun h => tsub_le_tsub_left h a⟩
  rw [tsub_le_iff_left, ← hc.add_tsub_assoc_of_le h, hc.le_tsub_iff_right (h.trans le_add_self),
    add_comm b]
  apply ha
#align add_le_cancellable.tsub_le_tsub_iff_left AddLECancellable.tsub_le_tsub_iff_left

/- warning: add_le_cancellable.tsub_right_inj -> AddLECancellable.tsub_right_inj is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b) -> (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (Eq.{succ u1} α b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b) -> (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (Eq.{succ u1} α b c))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_right_inj AddLECancellable.tsub_right_injₓ'. -/
protected theorem tsub_right_inj (ha : AddLECancellable a) (hb : AddLECancellable b)
    (hc : AddLECancellable c) (hba : b ≤ a) (hca : c ≤ a) : a - b = a - c ↔ b = c := by
  simp_rw [le_antisymm_iff, ha.tsub_le_tsub_iff_left hb hba, ha.tsub_le_tsub_iff_left hc hca,
    and_comm']
#align add_le_cancellable.tsub_right_inj AddLECancellable.tsub_right_inj

end AddLECancellable

/-! #### Lemmas where addition is order-reflecting. -/


section Contra

variable [ContravariantClass α α (· + ·) (· ≤ ·)]

/- warning: tsub_le_tsub_iff_left -> tsub_le_tsub_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6900 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6902 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6900 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6902) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6915 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6917 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6915 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6917)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c b))
Case conversion may be inaccurate. Consider using '#align tsub_le_tsub_iff_left tsub_le_tsub_iff_leftₓ'. -/
theorem tsub_le_tsub_iff_left (h : c ≤ a) : a - b ≤ a - c ↔ c ≤ b :=
  Contravariant.AddLECancellable.tsub_le_tsub_iff_left Contravariant.AddLECancellable h
#align tsub_le_tsub_iff_left tsub_le_tsub_iff_left

/- warning: tsub_right_inj -> tsub_right_inj is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (Eq.{succ u1} α b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6975 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6977 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6975 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6977) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6990 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6992 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6990 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.6992)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) b a) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) c a) -> (Iff (Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (Eq.{succ u1} α b c))
Case conversion may be inaccurate. Consider using '#align tsub_right_inj tsub_right_injₓ'. -/
theorem tsub_right_inj (hba : b ≤ a) (hca : c ≤ a) : a - b = a - c ↔ b = c :=
  Contravariant.AddLECancellable.tsub_right_inj Contravariant.AddLECancellable
    Contravariant.AddLECancellable hba hca
#align tsub_right_inj tsub_right_inj

variable (α)

/- warning: canonically_ordered_add_monoid.to_add_cancel_comm_monoid -> CanonicallyOrderedAddMonoid.toAddCancelCommMonoid is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))], AddCancelCommMonoid.{u1} α
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : CanonicallyOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1))))) _inst_2] [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7110 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7112 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7110 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7112) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7125 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7127 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α _inst_1)))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7125 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7127)], AddCancelCommMonoid.{u1} α
Case conversion may be inaccurate. Consider using '#align canonically_ordered_add_monoid.to_add_cancel_comm_monoid CanonicallyOrderedAddMonoid.toAddCancelCommMonoidₓ'. -/
/-- A `canonically_ordered_add_monoid` with ordered subtraction and order-reflecting addition is
cancellative. This is not an instance at it would form a typeclass loop.

See note [reducible non-instances]. -/
@[reducible]
def CanonicallyOrderedAddMonoid.toAddCancelCommMonoid : AddCancelCommMonoid α :=
  { (by infer_instance : AddCommMonoid α) with
    add_left_cancel := fun a b c h => by
      simpa only [add_tsub_cancel_left] using congr_arg (fun x => x - a) h }
#align canonically_ordered_add_monoid.to_add_cancel_comm_monoid CanonicallyOrderedAddMonoid.toAddCancelCommMonoid

end Contra

end CanonicallyOrderedAddMonoid

/-! ### Lemmas in a linearly canonically ordered monoid. -/


section CanonicallyLinearOrderedAddMonoid

variable [CanonicallyLinearOrderedAddMonoid α] [Sub α] [OrderedSub α] {a b c d : α}

/- warning: tsub_pos_iff_lt -> tsub_pos_iff_lt is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a)
Case conversion may be inaccurate. Consider using '#align tsub_pos_iff_lt tsub_pos_iff_ltₓ'. -/
@[simp]
theorem tsub_pos_iff_lt : 0 < a - b ↔ b < a := by rw [tsub_pos_iff_not_le, not_le]
#align tsub_pos_iff_lt tsub_pos_iff_lt

/- warning: tsub_eq_tsub_min -> tsub_eq_tsub_min is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] (a : α) (b : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (LinearOrder.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] (a : α) (b : α), Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (Min.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toMin.{u1} α _inst_1) a b))
Case conversion may be inaccurate. Consider using '#align tsub_eq_tsub_min tsub_eq_tsub_minₓ'. -/
theorem tsub_eq_tsub_min (a b : α) : a - b = a - min a b :=
  by
  cases' le_total a b with h h
  · rw [min_eq_left h, tsub_self, tsub_eq_zero_of_le h]
  · rw [min_eq_right h]
#align tsub_eq_tsub_min tsub_eq_tsub_min

namespace AddLECancellable

/- warning: add_le_cancellable.lt_tsub_iff_right -> AddLECancellable.lt_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a c) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a c) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.lt_tsub_iff_right AddLECancellable.lt_tsub_iff_rightₓ'. -/
protected theorem lt_tsub_iff_right (hc : AddLECancellable c) : a < b - c ↔ a + c < b :=
  ⟨lt_imp_lt_of_le_imp_le tsub_le_iff_right.mpr, hc.lt_tsub_of_add_lt_right⟩
#align add_le_cancellable.lt_tsub_iff_right AddLECancellable.lt_tsub_iff_right

/- warning: add_le_cancellable.lt_tsub_iff_left -> AddLECancellable.lt_tsub_iff_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) c a) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) c a) b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.lt_tsub_iff_left AddLECancellable.lt_tsub_iff_leftₓ'. -/
protected theorem lt_tsub_iff_left (hc : AddLECancellable c) : a < b - c ↔ c + a < b :=
  ⟨lt_imp_lt_of_le_imp_le tsub_le_iff_left.mpr, hc.lt_tsub_of_add_lt_left⟩
#align add_le_cancellable.lt_tsub_iff_left AddLECancellable.lt_tsub_iff_left

/- warning: add_le_cancellable.tsub_lt_tsub_iff_right -> AddLECancellable.tsub_lt_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_tsub_iff_right AddLECancellable.tsub_lt_tsub_iff_rightₓ'. -/
protected theorem tsub_lt_tsub_iff_right (hc : AddLECancellable c) (h : c ≤ a) :
    a - c < b - c ↔ a < b := by rw [hc.lt_tsub_iff_left, add_tsub_cancel_of_le h]
#align add_le_cancellable.tsub_lt_tsub_iff_right AddLECancellable.tsub_lt_tsub_iff_right

/- warning: add_le_cancellable.tsub_lt_self -> AddLECancellable.tsub_lt_self is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a)
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_self AddLECancellable.tsub_lt_selfₓ'. -/
protected theorem tsub_lt_self (ha : AddLECancellable a) (h₁ : 0 < a) (h₂ : 0 < b) : a - b < a :=
  by
  refine' tsub_le_self.lt_of_ne fun h => _
  rw [← h, tsub_pos_iff_lt] at h₁
  exact h₂.not_le (ha.add_le_iff_nonpos_left.1 <| add_le_of_le_tsub_left_of_le h₁.le h.ge)
#align add_le_cancellable.tsub_lt_self AddLECancellable.tsub_lt_self

/- warning: add_le_cancellable.tsub_lt_self_iff -> AddLECancellable.tsub_lt_self_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a) (And (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) a) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a) (And (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) b)))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_self_iff AddLECancellable.tsub_lt_self_iffₓ'. -/
protected theorem tsub_lt_self_iff (ha : AddLECancellable a) : a - b < a ↔ 0 < a ∧ 0 < b :=
  by
  refine'
    ⟨fun h => ⟨(zero_le _).trans_lt h, (zero_le b).lt_of_ne _⟩, fun h => ha.tsub_lt_self h.1 h.2⟩
  rintro rfl
  rw [tsub_zero] at h
  exact h.false
#align add_le_cancellable.tsub_lt_self_iff AddLECancellable.tsub_lt_self_iff

/- warning: add_le_cancellable.tsub_lt_tsub_iff_left_of_le -> AddLECancellable.tsub_lt_tsub_iff_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α}, (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a) -> (AddLECancellable.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c b))
Case conversion may be inaccurate. Consider using '#align add_le_cancellable.tsub_lt_tsub_iff_left_of_le AddLECancellable.tsub_lt_tsub_iff_left_of_leₓ'. -/
/-- See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order. -/
protected theorem tsub_lt_tsub_iff_left_of_le (ha : AddLECancellable a) (hb : AddLECancellable b)
    (h : b ≤ a) : a - b < a - c ↔ c < b :=
  lt_iff_lt_of_le_iff_le <| ha.tsub_le_tsub_iff_left hb h
#align add_le_cancellable.tsub_lt_tsub_iff_left_of_le AddLECancellable.tsub_lt_tsub_iff_left_of_le

end AddLECancellable

section Contra

variable [ContravariantClass α α (· + ·) (· ≤ ·)]

/- warning: tsub_lt_tsub_iff_right -> tsub_lt_tsub_iff_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7842 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7844 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7842 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7844) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7857 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7859 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7857 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7859)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) a b))
Case conversion may be inaccurate. Consider using '#align tsub_lt_tsub_iff_right tsub_lt_tsub_iff_rightₓ'. -/
/-- This lemma also holds for `ennreal`, but we need a different proof for that. -/
theorem tsub_lt_tsub_iff_right (h : c ≤ a) : a - c < b - c ↔ a < b :=
  Contravariant.AddLECancellable.tsub_lt_tsub_iff_right h
#align tsub_lt_tsub_iff_right tsub_lt_tsub_iff_right

/- warning: tsub_lt_self -> tsub_lt_self is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7916 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7918 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7916 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7918) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7931 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7933 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7931 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7933)], (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) b) -> (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a)
Case conversion may be inaccurate. Consider using '#align tsub_lt_self tsub_lt_selfₓ'. -/
theorem tsub_lt_self : 0 < a → 0 < b → a - b < a :=
  Contravariant.AddLECancellable.tsub_lt_self
#align tsub_lt_self tsub_lt_self

/- warning: tsub_lt_self_iff -> tsub_lt_self_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))], Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a) (And (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) a) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))))) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7986 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7988 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7986 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.7988) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8001 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8003 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8001 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8003)], Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) a) (And (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddMonoid.toZero.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) b))
Case conversion may be inaccurate. Consider using '#align tsub_lt_self_iff tsub_lt_self_iffₓ'. -/
theorem tsub_lt_self_iff : a - b < a ↔ 0 < a ∧ 0 < b :=
  Contravariant.AddLECancellable.tsub_lt_self_iff
#align tsub_lt_self_iff tsub_lt_self_iff

/- warning: tsub_lt_tsub_iff_left_of_le -> tsub_lt_tsub_iff_left_of_le is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))))) (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α} {c : α} [_inst_4 : ContravariantClass.{u1, u1} α α (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8060 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8062 : α) => HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8060 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8062) (fun (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8075 : α) (x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8077 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8075 x._@.Mathlib.Algebra.Order.Sub.Canonical._hyg.8077)], (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) b a) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a c)) (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) c b))
Case conversion may be inaccurate. Consider using '#align tsub_lt_tsub_iff_left_of_le tsub_lt_tsub_iff_left_of_leₓ'. -/
/-- See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order. -/
theorem tsub_lt_tsub_iff_left_of_le (h : b ≤ a) : a - b < a - c ↔ c < b :=
  Contravariant.AddLECancellable.tsub_lt_tsub_iff_left_of_le Contravariant.AddLECancellable h
#align tsub_lt_tsub_iff_left_of_le tsub_lt_tsub_iff_left_of_le

end Contra

/-! ### Lemmas about `max` and `min`. -/


/- warning: tsub_add_eq_max -> tsub_add_eq_max is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) b) (LinearOrder.max.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) b) (Max.max.{u1} α (CanonicallyLinearOrderedAddMonoid.toMax.{u1} α _inst_1) a b)
Case conversion may be inaccurate. Consider using '#align tsub_add_eq_max tsub_add_eq_maxₓ'. -/
theorem tsub_add_eq_max : a - b + b = max a b :=
  by
  cases' le_total a b with h h
  · rw [max_eq_right h, tsub_eq_zero_of_le h, zero_add]
  · rw [max_eq_left h, tsub_add_cancel_of_le h]
#align tsub_add_eq_max tsub_add_eq_max

/- warning: add_tsub_eq_max -> add_tsub_eq_max is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a)) (LinearOrder.max.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) a (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) b a)) (Max.max.{u1} α (CanonicallyLinearOrderedAddMonoid.toMax.{u1} α _inst_1) a b)
Case conversion may be inaccurate. Consider using '#align add_tsub_eq_max add_tsub_eq_maxₓ'. -/
theorem add_tsub_eq_max : a + (b - a) = max a b := by rw [add_comm, max_comm, tsub_add_eq_max]
#align add_tsub_eq_max add_tsub_eq_max

/- warning: tsub_min -> tsub_min is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (LinearOrder.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a (Min.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toMin.{u1} α _inst_1) a b)) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b)
Case conversion may be inaccurate. Consider using '#align tsub_min tsub_minₓ'. -/
theorem tsub_min : a - min a b = a - b :=
  by
  cases' le_total a b with h h
  · rw [min_eq_left h, tsub_self, tsub_eq_zero_of_le h]
  · rw [min_eq_right h]
#align tsub_min tsub_min

/- warning: tsub_add_min -> tsub_add_min is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (LinearOrder.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toLinearOrder.{u1} α _inst_1) a b)) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : CanonicallyLinearOrderedAddMonoid.{u1} α] [_inst_2 : Sub.{u1} α] [_inst_3 : OrderedSub.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommMonoid.toPartialOrder.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1)))))) _inst_2] {a : α} {b : α}, Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (OrderedAddCommMonoid.toAddCommMonoid.{u1} α (CanonicallyOrderedAddMonoid.toOrderedAddCommMonoid.{u1} α (CanonicallyLinearOrderedAddMonoid.toCanonicallyOrderedAddMonoid.{u1} α _inst_1))))))) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α _inst_2) a b) (Min.min.{u1} α (CanonicallyLinearOrderedAddMonoid.toMin.{u1} α _inst_1) a b)) a
Case conversion may be inaccurate. Consider using '#align tsub_add_min tsub_add_minₓ'. -/
theorem tsub_add_min : a - b + min a b = a :=
  by
  rw [← tsub_min, tsub_add_cancel_of_le]
  apply min_le_left
#align tsub_add_min tsub_add_min

end CanonicallyLinearOrderedAddMonoid

