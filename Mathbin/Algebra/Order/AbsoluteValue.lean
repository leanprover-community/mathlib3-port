/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Anne Baanen

! This file was ported from Lean 3 source module algebra.order.absolute_value
! leanprover-community/mathlib commit 59694bd07f0a39c5beccba34bd9f413a160782bf
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.GroupWithZero.Units.Lemmas
import Mathbin.Algebra.Order.Field.Defs
import Mathbin.Algebra.Order.Hom.Basic
import Mathbin.Algebra.Order.Ring.Abs
import Mathbin.Algebra.Ring.Commute
import Mathbin.Algebra.Ring.Regular

/-!
# Absolute values

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines a bundled type of absolute values `absolute_value R S`.

## Main definitions

 * `absolute_value R S` is the type of absolute values on `R` mapping to `S`.
 * `absolute_value.abs` is the "standard" absolute value on `S`, mapping negative `x` to `-x`.
 * `absolute_value.to_monoid_with_zero_hom`: absolute values mapping to a
   linear ordered field preserve `0`, `*` and `1`
 * `is_absolute_value`: a type class stating that `f : β → α` satisfies the axioms of an abs val
-/


#print AbsoluteValue /-
/-- `absolute_value R S` is the type of absolute values on `R` mapping to `S`:
the maps that preserve `*`, are nonnegative, positive definite and satisfy the triangle equality. -/
structure AbsoluteValue (R S : Type _) [Semiring R] [OrderedSemiring S] extends R →ₙ* S where
  nonneg' : ∀ x, 0 ≤ to_fun x
  eq_zero' : ∀ x, to_fun x = 0 ↔ x = 0
  add_le' : ∀ x y, to_fun (x + y) ≤ to_fun x + to_fun y
#align absolute_value AbsoluteValue
-/

namespace AbsoluteValue

attribute [nolint doc_blame] AbsoluteValue.toMulHom

initialize_simps_projections AbsoluteValue (to_mul_hom_to_fun → apply)

section OrderedSemiring

section Semiring

variable {R S : Type _} [Semiring R] [OrderedSemiring S] (abv : AbsoluteValue R S)

/- warning: absolute_value.zero_hom_class -> AbsoluteValue.zeroHomClass is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S], ZeroHomClass.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S], ZeroHomClass.{max u2 u1, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (MonoidWithZero.toZero.{u2} S (Semiring.toMonoidWithZero.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align absolute_value.zero_hom_class AbsoluteValue.zeroHomClassₓ'. -/
instance zeroHomClass : ZeroHomClass (AbsoluteValue R S) R S
    where
  coe f := f.toFun
  coe_injective' f g h := by
    obtain ⟨⟨_, _⟩, _⟩ := f
    obtain ⟨⟨_, _⟩, _⟩ := g
    congr
  map_zero f := (f.eq_zero' _).2 rfl
#align absolute_value.zero_hom_class AbsoluteValue.zeroHomClass

/- warning: absolute_value.mul_hom_class -> AbsoluteValue.mulHomClass is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S], MulHomClass.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S], MulHomClass.{max u2 u1, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (NonUnitalNonAssocSemiring.toMul.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))
Case conversion may be inaccurate. Consider using '#align absolute_value.mul_hom_class AbsoluteValue.mulHomClassₓ'. -/
instance mulHomClass : MulHomClass (AbsoluteValue R S) R S :=
  { AbsoluteValue.zeroHomClass with map_mul := fun f => f.map_mul' }
#align absolute_value.mul_hom_class AbsoluteValue.mulHomClass

/- warning: absolute_value.nonneg_hom_class -> AbsoluteValue.nonnegHomClass is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S], NonnegHomClass.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S], NonnegHomClass.{max u2 u1, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (MonoidWithZero.toZero.{u2} S (Semiring.toMonoidWithZero.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align absolute_value.nonneg_hom_class AbsoluteValue.nonnegHomClassₓ'. -/
instance nonnegHomClass : NonnegHomClass (AbsoluteValue R S) R S :=
  { AbsoluteValue.zeroHomClass with map_nonneg := fun f => f.nonneg' }
#align absolute_value.nonneg_hom_class AbsoluteValue.nonnegHomClass

/- warning: absolute_value.subadditive_hom_class -> AbsoluteValue.subadditiveHomClass is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S], SubadditiveHomClass.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S], SubadditiveHomClass.{max u2 u1, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2)))
Case conversion may be inaccurate. Consider using '#align absolute_value.subadditive_hom_class AbsoluteValue.subadditiveHomClassₓ'. -/
instance subadditiveHomClass : SubadditiveHomClass (AbsoluteValue R S) R S :=
  { AbsoluteValue.zeroHomClass with map_add_le_add := fun f => f.add_le' }
#align absolute_value.subadditive_hom_class AbsoluteValue.subadditiveHomClass

/- warning: absolute_value.coe_mk -> AbsoluteValue.coe_mk is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (f : MulHom.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))) {h₁ : forall (x : R), LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2)))) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))))) (MulHom.toFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) f x)} {h₂ : forall (x : R), Iff (Eq.{succ u2} S (MulHom.toFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) f x) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))))))) (Eq.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))} {h₃ : forall (x : R) (y : R), LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2)))) (MulHom.toFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) f (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x y)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))) (MulHom.toFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) f x) (MulHom.toFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) f y))}, Eq.{max (succ u1) (succ u2)} ((fun (_x : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.mk.{u1, u2} R S _inst_1 _inst_2 f h₁ h₂ h₃)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (_x : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (FunLike.hasCoeToFun.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (_x : R) => S) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2)))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2))) (AbsoluteValue.mk.{u1, u2} R S _inst_1 _inst_2 f h₁ h₂ h₃)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MulHom.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))) (fun (_x : MulHom.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))) => R -> S) (MulHom.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))) f)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : OrderedSemiring.{u1} S] (f : MulHom.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2))))) {h₁ : forall (x : R), LE.le.{u1} S (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedSemiring.toPartialOrder.{u1} S _inst_2))) (OfNat.ofNat.{u1} S 0 (Zero.toOfNat0.{u1} S (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2))))) (MulHom.toFun.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2)))) f x)} {h₂ : forall (x : R), Iff (Eq.{succ u1} S (MulHom.toFun.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2)))) f x) (OfNat.ofNat.{u1} S 0 (Zero.toOfNat0.{u1} S (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2)))))) (Eq.{succ u2} R x (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))))} {h₃ : forall (x : R) (y : R), LE.le.{u1} S (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedSemiring.toPartialOrder.{u1} S _inst_2))) (MulHom.toFun.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2)))) f (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) x y)) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2)))))) (MulHom.toFun.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2)))) f x) (MulHom.toFun.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2)))) f y))}, Eq.{max (succ u2) (succ u1)} (forall (a : R), (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) _x) (SubadditiveHomClass.toFunLike.{max u2 u1, u2, u1} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2))))) (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedSemiring.toPartialOrder.{u1} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u2, u1} R S _inst_1 _inst_2)) (AbsoluteValue.mk.{u2, u1} R S _inst_1 _inst_2 f h₁ h₂ h₃)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulHom.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MulHom.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2))))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2)))) (MulHom.mulHomClass.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2)))))) f)
Case conversion may be inaccurate. Consider using '#align absolute_value.coe_mk AbsoluteValue.coe_mkₓ'. -/
@[simp]
theorem coe_mk (f : R →ₙ* S) {h₁ h₂ h₃} : (AbsoluteValue.mk f h₁ h₂ h₃ : R → S) = f :=
  rfl
#align absolute_value.coe_mk AbsoluteValue.coe_mk

/- warning: absolute_value.ext -> AbsoluteValue.ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] {{f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2}} {{g : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2}}, (forall (x : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (_x : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (FunLike.hasCoeToFun.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (_x : R) => S) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2)))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (_x : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (FunLike.hasCoeToFun.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (_x : R) => S) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2)))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2))) g x)) -> (Eq.{max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) f g)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : OrderedSemiring.{u1} S] {{f : AbsoluteValue.{u2, u1} R S _inst_1 _inst_2}} {{g : AbsoluteValue.{u2, u1} R S _inst_1 _inst_2}}, (forall (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) _x) (SubadditiveHomClass.toFunLike.{max u2 u1, u2, u1} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2))))) (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedSemiring.toPartialOrder.{u1} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u2, u1} R S _inst_1 _inst_2)) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) _x) (SubadditiveHomClass.toFunLike.{max u2 u1, u2, u1} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2))))) (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedSemiring.toPartialOrder.{u1} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u2, u1} R S _inst_1 _inst_2)) g x)) -> (Eq.{max (succ u2) (succ u1)} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align absolute_value.ext AbsoluteValue.extₓ'. -/
@[ext]
theorem ext ⦃f g : AbsoluteValue R S⦄ : (∀ x, f x = g x) → f = g :=
  FunLike.ext _ _
#align absolute_value.ext AbsoluteValue.ext

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (AbsoluteValue R S) fun f => R → S :=
  FunLike.hasCoeToFun

/- warning: absolute_value.coe_to_mul_hom -> AbsoluteValue.coe_toMulHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2), Eq.{max (succ u1) (succ u2)} (R -> S) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MulHom.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))) (fun (_x : MulHom.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))) => R -> S) (MulHom.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))) (AbsoluteValue.toMulHom.{u1, u2} R S _inst_1 _inst_2 abv)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : OrderedSemiring.{u1} S] (abv : AbsoluteValue.{u2, u1} R S _inst_1 _inst_2), Eq.{max (succ u2) (succ u1)} (MulHom.{u2, u1} R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2))))) (AbsoluteValue.toMulHom.{u2, u1} R S _inst_1 _inst_2 abv) (MulHomClass.toMulHom.{u2, u1, max u2 u1} R S (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2)))) (AbsoluteValue.mulHomClass.{u2, u1} R S _inst_1 _inst_2) abv)
Case conversion may be inaccurate. Consider using '#align absolute_value.coe_to_mul_hom AbsoluteValue.coe_toMulHomₓ'. -/
@[simp]
theorem coe_toMulHom : ⇑abv.toMulHom = abv :=
  rfl
#align absolute_value.coe_to_mul_hom AbsoluteValue.coe_toMulHom

/- warning: absolute_value.nonneg -> AbsoluteValue.nonneg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (x : R), LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2)))) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv x)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (x : R), LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (OrderedSemiring.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) _inst_2))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (OrderedSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) _inst_2))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2)) abv x)
Case conversion may be inaccurate. Consider using '#align absolute_value.nonneg AbsoluteValue.nonnegₓ'. -/
protected theorem nonneg (x : R) : 0 ≤ abv x :=
  abv.nonneg' x
#align absolute_value.nonneg AbsoluteValue.nonneg

/- warning: absolute_value.eq_zero -> AbsoluteValue.eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) {x : R}, Iff (Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv x) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))))))) (Eq.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) {x : R}, Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2)) abv x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (OrderedSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) _inst_2)))))) (Eq.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align absolute_value.eq_zero AbsoluteValue.eq_zeroₓ'. -/
@[simp]
protected theorem eq_zero {x : R} : abv x = 0 ↔ x = 0 :=
  abv.eq_zero' x
#align absolute_value.eq_zero AbsoluteValue.eq_zero

/- warning: absolute_value.add_le -> AbsoluteValue.add_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (x : R) (y : R), LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x y)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv y))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (x : R) (y : R), LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x y)) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x y)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x y)) (OrderedSemiring.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x y)) _inst_2))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2)) abv (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) x y)) (HAdd.hAdd.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) y) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (instHAdd.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Distrib.toAdd.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (NonUnitalNonAssocSemiring.toDistrib.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (OrderedSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) _inst_2)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2)) abv x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2)) abv y))
Case conversion may be inaccurate. Consider using '#align absolute_value.add_le AbsoluteValue.add_leₓ'. -/
protected theorem add_le (x y : R) : abv (x + y) ≤ abv x + abv y :=
  abv.add_le' x y
#align absolute_value.add_le AbsoluteValue.add_le

/- warning: absolute_value.map_mul clashes with map_mul -> map_mul
warning: absolute_value.map_mul -> map_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u_1}} {S : Type.{u_2}} [_inst_1 : Semiring.{u_1} R] [_inst_2 : OrderedSemiring.{u_2} S] (abv : AbsoluteValue.{u_1, u_2} R S _inst_1 _inst_2) (x : R) (y : R), Eq.{succ u_2} S (coeFn.{max (succ u_1) (succ u_2), max (succ u_1) (succ u_2)} (AbsoluteValue.{u_1, u_2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u_1, u_2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u_1, u_2} R S _inst_1 _inst_2) abv (HMul.hMul.{u_1, u_1, u_1} R R R (instHMul.{u_1} R (Distrib.toHasMul.{u_1} R (NonUnitalNonAssocSemiring.toDistrib.{u_1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} R (Semiring.toNonAssocSemiring.{u_1} R _inst_1))))) x y)) (HMul.hMul.{u_2, u_2, u_2} S S S (instHMul.{u_2} S (Distrib.toHasMul.{u_2} S (NonUnitalNonAssocSemiring.toDistrib.{u_2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_2} S (Semiring.toNonAssocSemiring.{u_2} S (OrderedSemiring.toSemiring.{u_2} S _inst_2)))))) (coeFn.{max (succ u_1) (succ u_2), max (succ u_1) (succ u_2)} (AbsoluteValue.{u_1, u_2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u_1, u_2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u_1, u_2} R S _inst_1 _inst_2) abv x) (coeFn.{max (succ u_1) (succ u_2), max (succ u_1) (succ u_2)} (AbsoluteValue.{u_1, u_2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u_1, u_2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u_1, u_2} R S _inst_1 _inst_2) abv y))
but is expected to have type
  forall {R : Type.{u_2}} {S : Type.{u_3}} {_inst_1 : Type.{u_1}} [_inst_2 : Mul.{u_2} R] [abv : Mul.{u_3} S] [x : MulHomClass.{u_1, u_2, u_3} _inst_1 R S _inst_2 abv] (y : _inst_1) (x_1 : R) (y_1 : R), Eq.{succ u_3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) (HMul.hMul.{u_2, u_2, u_2} R R R (instHMul.{u_2} R _inst_2) x_1 y_1)) (FunLike.coe.{succ u_1, succ u_2, succ u_3} _inst_1 R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) a) (MulHomClass.toFunLike.{u_1, u_2, u_3} _inst_1 R S _inst_2 abv x) y (HMul.hMul.{u_2, u_2, u_2} R R R (instHMul.{u_2} R _inst_2) x_1 y_1)) (HMul.hMul.{u_3, u_3, u_3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) y_1) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x_1) (instHMul.{u_3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) x_1) abv) (FunLike.coe.{succ u_1, succ u_2, succ u_3} _inst_1 R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) a) (MulHomClass.toFunLike.{u_1, u_2, u_3} _inst_1 R S _inst_2 abv x) y x_1) (FunLike.coe.{succ u_1, succ u_2, succ u_3} _inst_1 R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) a) (MulHomClass.toFunLike.{u_1, u_2, u_3} _inst_1 R S _inst_2 abv x) y y_1))
Case conversion may be inaccurate. Consider using '#align absolute_value.map_mul map_mulₓ'. -/
@[simp]
protected theorem map_mul (x y : R) : abv (x * y) = abv x * abv y :=
  abv.map_mul' x y
#align absolute_value.map_mul map_mul

/- warning: absolute_value.ne_zero_iff -> AbsoluteValue.ne_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) {x : R}, Iff (Ne.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv x) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))))))) (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) {x : R}, Iff (Ne.{succ u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2)) abv x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (OrderedSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) _inst_2)))))) (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align absolute_value.ne_zero_iff AbsoluteValue.ne_zero_iffₓ'. -/
protected theorem ne_zero_iff {x : R} : abv x ≠ 0 ↔ x ≠ 0 :=
  abv.eq_zero.Not
#align absolute_value.ne_zero_iff AbsoluteValue.ne_zero_iff

/- warning: absolute_value.pos -> AbsoluteValue.pos is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (LT.lt.{u2} S (Preorder.toLT.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2)))) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv x))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : OrderedSemiring.{u1} S] (abv : AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) {x : R}, (Ne.{succ u2} R x (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))))) -> (LT.lt.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Preorder.toLT.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (PartialOrder.toPreorder.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (OrderedSemiring.toPartialOrder.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) _inst_2))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (OrderedSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) _inst_2))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u2 u1, u2, u1} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2))))) (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedSemiring.toPartialOrder.{u1} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u2, u1} R S _inst_1 _inst_2)) abv x))
Case conversion may be inaccurate. Consider using '#align absolute_value.pos AbsoluteValue.posₓ'. -/
protected theorem pos {x : R} (hx : x ≠ 0) : 0 < abv x :=
  lt_of_le_of_ne (abv.NonNeg x) (Ne.symm <| mt abv.eq_zero.mp hx)
#align absolute_value.pos AbsoluteValue.pos

/- warning: absolute_value.pos_iff -> AbsoluteValue.pos_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) {x : R}, Iff (LT.lt.{u2} S (Preorder.toLT.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2)))) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv x)) (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) {x : R}, Iff (LT.lt.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Preorder.toLT.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (OrderedSemiring.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) _inst_2))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (OrderedSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) _inst_2))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2)) abv x)) (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align absolute_value.pos_iff AbsoluteValue.pos_iffₓ'. -/
@[simp]
protected theorem pos_iff {x : R} : 0 < abv x ↔ x ≠ 0 :=
  ⟨fun h₁ => mt abv.eq_zero.mpr h₁.ne', abv.Pos⟩
#align absolute_value.pos_iff AbsoluteValue.pos_iff

/- warning: absolute_value.ne_zero -> AbsoluteValue.ne_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) {x : R}, (Ne.{succ u1} R x (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) -> (Ne.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv x) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))))))
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : OrderedSemiring.{u1} S] (abv : AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) {x : R}, (Ne.{succ u2} R x (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))))) -> (Ne.{succ u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u2 u1, u2, u1} (AbsoluteValue.{u2, u1} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_2))))) (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedSemiring.toPartialOrder.{u1} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u2, u1} R S _inst_1 _inst_2)) abv x) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) (OrderedSemiring.toSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) x) _inst_2))))))
Case conversion may be inaccurate. Consider using '#align absolute_value.ne_zero AbsoluteValue.ne_zeroₓ'. -/
protected theorem ne_zero {x : R} (hx : x ≠ 0) : abv x ≠ 0 :=
  (abv.Pos hx).ne'
#align absolute_value.ne_zero AbsoluteValue.ne_zero

/- warning: absolute_value.map_one_of_is_regular -> AbsoluteValue.map_one_of_isLeftRegular is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2), (IsLeftRegular.{u2} S (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))) -> (Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 _inst_2) abv (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (OfNat.ofNat.{u2} S 1 (OfNat.mk.{u2} S 1 (One.one.{u2} S (AddMonoidWithOne.toOne.{u2} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} S (NonAssocSemiring.toAddCommMonoidWithOne.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 _inst_2), (IsLeftRegular.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (OrderedSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) _inst_2)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2)) abv (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1))))) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 _inst_2)) abv (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (Semiring.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (OrderedSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) _inst_2)))))
Case conversion may be inaccurate. Consider using '#align absolute_value.map_one_of_is_regular AbsoluteValue.map_one_of_isLeftRegularₓ'. -/
theorem map_one_of_isLeftRegular (h : IsLeftRegular (abv 1)) : abv 1 = 1 :=
  h <| by simp [← abv.map_mul]
#align absolute_value.map_one_of_is_regular AbsoluteValue.map_one_of_isLeftRegular

/- warning: absolute_value.map_zero clashes with map_zero -> map_zero
warning: absolute_value.map_zero -> map_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u_1}} {S : Type.{u_2}} [_inst_1 : Semiring.{u_1} R] [_inst_2 : OrderedSemiring.{u_2} S] (abv : AbsoluteValue.{u_1, u_2} R S _inst_1 _inst_2), Eq.{succ u_2} S (coeFn.{max (succ u_1) (succ u_2), max (succ u_1) (succ u_2)} (AbsoluteValue.{u_1, u_2} R S _inst_1 _inst_2) (fun (f : AbsoluteValue.{u_1, u_2} R S _inst_1 _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u_1, u_2} R S _inst_1 _inst_2) abv (OfNat.ofNat.{u_1} R 0 (OfNat.mk.{u_1} R 0 (Zero.zero.{u_1} R (MulZeroClass.toHasZero.{u_1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u_1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_1} R (Semiring.toNonAssocSemiring.{u_1} R _inst_1)))))))) (OfNat.ofNat.{u_2} S 0 (OfNat.mk.{u_2} S 0 (Zero.zero.{u_2} S (MulZeroClass.toHasZero.{u_2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u_2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_2} S (Semiring.toNonAssocSemiring.{u_2} S (OrderedSemiring.toSemiring.{u_2} S _inst_2))))))))
but is expected to have type
  forall {R : Type.{u_2}} {S : Type.{u_3}} {_inst_1 : Type.{u_1}} [_inst_2 : Zero.{u_2} R] [abv : Zero.{u_3} S] [inst._@.Mathlib.Algebra.Hom.Group._hyg.1380 : ZeroHomClass.{u_1, u_2, u_3} _inst_1 R S _inst_2 abv] (f : _inst_1), Eq.{succ u_3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.1254 : R) => S) (OfNat.ofNat.{u_2} R 0 (Zero.toOfNat0.{u_2} R _inst_2))) (FunLike.coe.{succ u_1, succ u_2, succ u_3} _inst_1 R (fun (a : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.1254 : R) => S) a) (ZeroHomClass.toFunLike.{u_1, u_2, u_3} _inst_1 R S _inst_2 abv inst._@.Mathlib.Algebra.Hom.Group._hyg.1380) f (OfNat.ofNat.{u_2} R 0 (Zero.toOfNat0.{u_2} R _inst_2))) (OfNat.ofNat.{u_3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.1254 : R) => S) (OfNat.ofNat.{u_2} R 0 (Zero.toOfNat0.{u_2} R _inst_2))) 0 (Zero.toOfNat0.{u_3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.1254 : R) => S) (OfNat.ofNat.{u_2} R 0 (Zero.toOfNat0.{u_2} R _inst_2))) abv))
Case conversion may be inaccurate. Consider using '#align absolute_value.map_zero map_zeroₓ'. -/
@[simp]
protected theorem map_zero : abv 0 = 0 :=
  abv.eq_zero.2 rfl
#align absolute_value.map_zero map_zero

end Semiring

section Ring

variable {R S : Type _} [Ring R] [OrderedSemiring S] (abv : AbsoluteValue R S)

/- warning: absolute_value.sub_le -> AbsoluteValue.sub_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) (a : R) (b : R) (c : R), LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommMonoid.toPartialOrder.{u2} S (OrderedSemiring.toOrderedAddCommMonoid.{u2} S _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) a c)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) a b)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) b c)))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) (a : R) (b : R) (c : R), LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a c)) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a c)) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a c)) (OrderedSemiring.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a c)) _inst_2))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2)) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a c)) (HAdd.hAdd.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) b c)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (instHAdd.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (Distrib.toAdd.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (NonUnitalNonAssocSemiring.toDistrib.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (OrderedSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) _inst_2)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2)) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2)) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) b c)))
Case conversion may be inaccurate. Consider using '#align absolute_value.sub_le AbsoluteValue.sub_leₓ'. -/
protected theorem sub_le (a b c : R) : abv (a - c) ≤ abv (a - b) + abv (b - c) := by
  simpa [sub_eq_add_neg, add_assoc] using abv.add_le (a - b) (b - c)
#align absolute_value.sub_le AbsoluteValue.sub_le

/- warning: absolute_value.map_sub_eq_zero_iff -> AbsoluteValue.map_sub_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) (a : R) (b : R), Iff (Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) a b)) (OfNat.ofNat.{u2} S 0 (OfNat.mk.{u2} S 0 (Zero.zero.{u2} S (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))))))) (Eq.{succ u1} R a b)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : OrderedSemiring.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) (a : R) (b : R), Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_2))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_2))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) _inst_2)) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (OrderedSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) _inst_2)))))) (Eq.{succ u1} R a b)
Case conversion may be inaccurate. Consider using '#align absolute_value.map_sub_eq_zero_iff AbsoluteValue.map_sub_eq_zero_iffₓ'. -/
@[simp]
theorem map_sub_eq_zero_iff (a b : R) : abv (a - b) = 0 ↔ a = b :=
  abv.eq_zero.trans sub_eq_zero
#align absolute_value.map_sub_eq_zero_iff AbsoluteValue.map_sub_eq_zero_iff

end Ring

end OrderedSemiring

section OrderedRing

section Semiring

section IsDomain

-- all of these are true for `no_zero_divisors S`; but it doesn't work smoothly with the
-- `is_domain`/`cancel_monoid_with_zero` API
variable {R S : Type _} [Semiring R] [OrderedRing S] (abv : AbsoluteValue R S)

variable [IsDomain S] [Nontrivial R]

/- warning: absolute_value.map_one -> AbsoluteValue.map_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) [_inst_3 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (OrderedRing.toRing.{u2} S _inst_2))] [_inst_4 : Nontrivial.{u1} R], Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) abv (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))) (OfNat.ofNat.{u2} S 1 (OfNat.mk.{u2} S 1 (One.one.{u2} S (AddMonoidWithOne.toOne.{u2} S (AddGroupWithOne.toAddMonoidWithOne.{u2} S (NonAssocRing.toAddGroupWithOne.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S _inst_2))))))))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) [_inst_3 : IsDomain.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedRing.toOrderedSemiring.{u2} S _inst_2))] [_inst_4 : Nontrivial.{u1} R], Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedRing.toOrderedSemiring.{u2} S _inst_2)))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedRing.toOrderedSemiring.{u2} S _inst_2)))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2))) abv (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (NonAssocRing.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (Ring.toNonAssocRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) (OrderedRing.toRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) _inst_2)))))
Case conversion may be inaccurate. Consider using '#align absolute_value.map_one AbsoluteValue.map_oneₓ'. -/
@[simp]
protected theorem map_one : abv 1 = 1 :=
  abv.map_one_of_isLeftRegular (isRegular_of_ne_zero <| abv.NeZero one_ne_zero).left
#align absolute_value.map_one AbsoluteValue.map_one

instance : MonoidWithZeroHomClass (AbsoluteValue R S) R S :=
  { AbsoluteValue.mulHomClass with
    map_zero := fun f => f.map_zero
    map_one := fun f => f.map_one }

#print AbsoluteValue.toMonoidWithZeroHom /-
/-- Absolute values from a nontrivial `R` to a linear ordered ring preserve `*`, `0` and `1`. -/
def toMonoidWithZeroHom : R →*₀ S :=
  abv
#align absolute_value.to_monoid_with_zero_hom AbsoluteValue.toMonoidWithZeroHom
-/

/- warning: absolute_value.coe_to_monoid_with_zero_hom -> AbsoluteValue.coe_toMonoidWithZeroHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) [_inst_3 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (OrderedRing.toRing.{u2} S _inst_2))] [_inst_4 : Nontrivial.{u1} R], Eq.{max (succ u1) (succ u2)} (R -> S) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidWithZeroHom.{u1, u2} R S (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toMulZeroOneClass.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S _inst_2))))) (fun (_x : MonoidWithZeroHom.{u1, u2} R S (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toMulZeroOneClass.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S _inst_2))))) => R -> S) (MonoidWithZeroHom.hasCoeToFun.{u1, u2} R S (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (NonAssocSemiring.toMulZeroOneClass.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S _inst_2))))) (AbsoluteValue.toMonoidWithZeroHom.{u1, u2} R S _inst_1 _inst_2 abv _inst_3 _inst_4)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) abv)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : OrderedRing.{u1} S] (abv : AbsoluteValue.{u2, u1} R S _inst_1 (OrderedRing.toOrderedSemiring.{u1} S _inst_2)) [_inst_3 : IsDomain.{u1} S (OrderedSemiring.toSemiring.{u1} S (OrderedRing.toOrderedSemiring.{u1} S _inst_2))] [_inst_4 : Nontrivial.{u2} R], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidWithZeroHom.{u2, u1} R S (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} R S (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2))))) R S (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (MulOneClass.toMul.{u1} S (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} R S (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2))))) R S (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2))))) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} R S (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2))))) R S (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2)))) (MonoidWithZeroHom.monoidWithZeroHomClass.{u2, u1} R S (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2)))))))) (AbsoluteValue.toMonoidWithZeroHom.{u2, u1} R S _inst_1 _inst_2 abv _inst_3 _inst_4)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AbsoluteValue.{u2, u1} R S _inst_1 (OrderedRing.toOrderedSemiring.{u1} S _inst_2)) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u2 u1, u2, u1} (AbsoluteValue.{u2, u1} R S _inst_1 (OrderedRing.toOrderedSemiring.{u1} S _inst_2)) R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S (OrderedRing.toOrderedSemiring.{u1} S _inst_2)))))) (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedSemiring.toPartialOrder.{u1} S (OrderedRing.toOrderedSemiring.{u1} S _inst_2)))) (AbsoluteValue.subadditiveHomClass.{u2, u1} R S _inst_1 (OrderedRing.toOrderedSemiring.{u1} S _inst_2))) abv)
Case conversion may be inaccurate. Consider using '#align absolute_value.coe_to_monoid_with_zero_hom AbsoluteValue.coe_toMonoidWithZeroHomₓ'. -/
@[simp]
theorem coe_toMonoidWithZeroHom : ⇑abv.toMonoidWithZeroHom = abv :=
  rfl
#align absolute_value.coe_to_monoid_with_zero_hom AbsoluteValue.coe_toMonoidWithZeroHom

#print AbsoluteValue.toMonoidHom /-
/-- Absolute values from a nontrivial `R` to a linear ordered ring preserve `*` and `1`. -/
def toMonoidHom : R →* S :=
  abv
#align absolute_value.to_monoid_hom AbsoluteValue.toMonoidHom
-/

/- warning: absolute_value.coe_to_monoid_hom -> AbsoluteValue.coe_toMonoidHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : OrderedRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) [_inst_3 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (OrderedRing.toRing.{u2} S _inst_2))] [_inst_4 : Nontrivial.{u1} R], Eq.{max (succ u1) (succ u2)} (R -> S) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S _inst_2)))))) (fun (_x : MonoidHom.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S _inst_2)))))) => R -> S) (MonoidHom.hasCoeToFun.{u1, u2} R S (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (MulZeroOneClass.toMulOneClass.{u2} S (NonAssocSemiring.toMulZeroOneClass.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S _inst_2)))))) (AbsoluteValue.toMonoidHom.{u1, u2} R S _inst_1 _inst_2 abv _inst_3 _inst_4)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) (fun (f : AbsoluteValue.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) abv)
but is expected to have type
  forall {R : Type.{u2}} {S : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : OrderedRing.{u1} S] (abv : AbsoluteValue.{u2, u1} R S _inst_1 (OrderedRing.toOrderedSemiring.{u1} S _inst_2)) [_inst_3 : IsDomain.{u1} S (OrderedSemiring.toSemiring.{u1} S (OrderedRing.toOrderedSemiring.{u1} S _inst_2))] [_inst_4 : Nontrivial.{u2} R], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} R S (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2)))))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2)))))) R S (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (MulOneClass.toMul.{u1} S (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2)))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} R S (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2)))))) R S (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2))))) (MonoidHom.monoidHomClass.{u2, u1} R S (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (MulZeroOneClass.toMulOneClass.{u1} S (NonAssocSemiring.toMulZeroOneClass.{u1} S (NonAssocRing.toNonAssocSemiring.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_2)))))))) (AbsoluteValue.toMonoidHom.{u2, u1} R S _inst_1 _inst_2 abv _inst_3 _inst_4)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AbsoluteValue.{u2, u1} R S _inst_1 (OrderedRing.toOrderedSemiring.{u1} S _inst_2)) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u2 u1, u2, u1} (AbsoluteValue.{u2, u1} R S _inst_1 (OrderedRing.toOrderedSemiring.{u1} S _inst_2)) R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S (OrderedRing.toOrderedSemiring.{u1} S _inst_2)))))) (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedSemiring.toPartialOrder.{u1} S (OrderedRing.toOrderedSemiring.{u1} S _inst_2)))) (AbsoluteValue.subadditiveHomClass.{u2, u1} R S _inst_1 (OrderedRing.toOrderedSemiring.{u1} S _inst_2))) abv)
Case conversion may be inaccurate. Consider using '#align absolute_value.coe_to_monoid_hom AbsoluteValue.coe_toMonoidHomₓ'. -/
@[simp]
theorem coe_toMonoidHom : ⇑abv.toMonoidHom = abv :=
  rfl
#align absolute_value.coe_to_monoid_hom AbsoluteValue.coe_toMonoidHom

/- warning: absolute_value.map_pow clashes with map_pow -> map_pow
warning: absolute_value.map_pow -> map_pow is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u_1}} {S : Type.{u_2}} [_inst_1 : Semiring.{u_1} R] [_inst_2 : OrderedRing.{u_2} S] (abv : AbsoluteValue.{u_1, u_2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u_2} S _inst_2)) [_inst_3 : IsDomain.{u_2} S (Ring.toSemiring.{u_2} S (OrderedRing.toRing.{u_2} S _inst_2))] [_inst_4 : Nontrivial.{u_1} R] (a : R) (n : Nat), Eq.{succ u_2} S (coeFn.{max (succ u_1) (succ u_2), max (succ u_1) (succ u_2)} (AbsoluteValue.{u_1, u_2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u_2} S _inst_2)) (fun (f : AbsoluteValue.{u_1, u_2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u_2} S _inst_2)) => R -> S) (AbsoluteValue.hasCoeToFun.{u_1, u_2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u_2} S _inst_2)) abv (HPow.hPow.{u_1, 0, u_1} R Nat R (instHPow.{u_1, 0} R Nat (Monoid.Pow.{u_1} R (MonoidWithZero.toMonoid.{u_1} R (Semiring.toMonoidWithZero.{u_1} R _inst_1)))) a n)) (HPow.hPow.{u_2, 0, u_2} S Nat S (instHPow.{u_2, 0} S Nat (Monoid.Pow.{u_2} S (Ring.toMonoid.{u_2} S (OrderedRing.toRing.{u_2} S _inst_2)))) (coeFn.{max (succ u_1) (succ u_2), max (succ u_1) (succ u_2)} (AbsoluteValue.{u_1, u_2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u_2} S _inst_2)) (fun (f : AbsoluteValue.{u_1, u_2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u_2} S _inst_2)) => R -> S) (AbsoluteValue.hasCoeToFun.{u_1, u_2} R S _inst_1 (OrderedRing.toOrderedSemiring.{u_2} S _inst_2)) abv a) n)
but is expected to have type
  forall {R : Type.{u_1}} {S : Type.{u_2}} {_inst_1 : Type.{u_3}} [_inst_2 : Monoid.{u_1} R] [abv : Monoid.{u_2} S] [_inst_3 : MonoidHomClass.{u_3, u_1, u_2} _inst_1 R S (Monoid.toMulOneClass.{u_1} R _inst_2) (Monoid.toMulOneClass.{u_2} S abv)] (_inst_4 : _inst_1) (a : R) (n : Nat), Eq.{succ u_2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) (HPow.hPow.{u_1, 0, u_1} R Nat R (instHPow.{u_1, 0} R Nat (Monoid.Pow.{u_1} R _inst_2)) a n)) (FunLike.coe.{succ u_3, succ u_1, succ u_2} _inst_1 R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) f) (MulHomClass.toFunLike.{u_3, u_1, u_2} _inst_1 R S (MulOneClass.toMul.{u_1} R (Monoid.toMulOneClass.{u_1} R _inst_2)) (MulOneClass.toMul.{u_2} S (Monoid.toMulOneClass.{u_2} S abv)) (MonoidHomClass.toMulHomClass.{u_3, u_1, u_2} _inst_1 R S (Monoid.toMulOneClass.{u_1} R _inst_2) (Monoid.toMulOneClass.{u_2} S abv) _inst_3)) _inst_4 (HPow.hPow.{u_1, 0, u_1} R Nat R (instHPow.{u_1, 0} R Nat (Monoid.Pow.{u_1} R _inst_2)) a n)) (HPow.hPow.{u_2, 0, u_2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) a) Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) a) (instHPow.{u_2, 0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) a) Nat (Monoid.Pow.{u_2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) a) abv)) (FunLike.coe.{succ u_3, succ u_1, succ u_2} _inst_1 R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : R) => S) f) (MulHomClass.toFunLike.{u_3, u_1, u_2} _inst_1 R S (MulOneClass.toMul.{u_1} R (Monoid.toMulOneClass.{u_1} R _inst_2)) (MulOneClass.toMul.{u_2} S (Monoid.toMulOneClass.{u_2} S abv)) (MonoidHomClass.toMulHomClass.{u_3, u_1, u_2} _inst_1 R S (Monoid.toMulOneClass.{u_1} R _inst_2) (Monoid.toMulOneClass.{u_2} S abv) _inst_3)) _inst_4 a) n)
Case conversion may be inaccurate. Consider using '#align absolute_value.map_pow map_powₓ'. -/
@[simp]
protected theorem map_pow (a : R) (n : ℕ) : abv (a ^ n) = abv a ^ n :=
  abv.toMonoidHom.map_pow a n
#align absolute_value.map_pow map_pow

end IsDomain

end Semiring

section Ring

variable {R S : Type _} [Ring R] [OrderedRing S] (abv : AbsoluteValue R S)

/- warning: absolute_value.le_sub -> AbsoluteValue.le_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : OrderedRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) (a : R) (b : R), LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommGroup.toPartialOrder.{u2} S (OrderedRing.toOrderedAddCommGroup.{u2} S _inst_2)))) (HSub.hSub.{u2, u2, u2} S S S (instHSub.{u2} S (SubNegMonoid.toHasSub.{u2} S (AddGroup.toSubNegMonoid.{u2} S (AddGroupWithOne.toAddGroup.{u2} S (NonAssocRing.toAddGroupWithOne.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S _inst_2))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) abv a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) abv b)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) a b))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : OrderedRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) (a : R) (b : R), LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (OrderedRing.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) _inst_2))) (HSub.hSub.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) b) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (instHSub.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (Ring.toSub.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (OrderedRing.toRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) _inst_2))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedRing.toOrderedSemiring.{u2} S _inst_2)))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedRing.toOrderedSemiring.{u2} S _inst_2)))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2))) abv a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedRing.toOrderedSemiring.{u2} S _inst_2)))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedRing.toOrderedSemiring.{u2} S _inst_2)))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2))) abv b)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2)) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedRing.toOrderedSemiring.{u2} S _inst_2)))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedRing.toOrderedSemiring.{u2} S _inst_2)))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S _inst_2))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b))
Case conversion may be inaccurate. Consider using '#align absolute_value.le_sub AbsoluteValue.le_subₓ'. -/
protected theorem le_sub (a b : R) : abv a - abv b ≤ abv (a - b) :=
  sub_le_iff_le_add.2 <| by simpa using abv.add_le (a - b) b
#align absolute_value.le_sub AbsoluteValue.le_sub

end Ring

end OrderedRing

section OrderedCommRing

variable {R S : Type _} [Ring R] [OrderedCommRing S] (abv : AbsoluteValue R S)

variable [NoZeroDivisors S]

/- warning: absolute_value.map_neg -> AbsoluteValue.map_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : OrderedCommRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) [_inst_3 : NoZeroDivisors.{u2} S (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S (OrderedRing.toRing.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2)))) (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2)))))))] (a : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) abv (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))))) a)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) abv a)
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : OrderedCommRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))) [_inst_3 : NoZeroDivisors.{u2} S (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))))) (CommMonoidWithZero.toZero.{u2} S (CommSemiring.toCommMonoidWithZero.{u2} S (OrderedCommSemiring.toCommSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))))] (a : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_1) a)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2)))) abv (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_1) a)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2)))) abv a)
Case conversion may be inaccurate. Consider using '#align absolute_value.map_neg AbsoluteValue.map_negₓ'. -/
@[simp]
protected theorem map_neg (a : R) : abv (-a) = abv a :=
  by
  by_cases ha : a = 0; · simp [ha]
  refine'
    (mul_self_eq_mul_self_iff.mp (by rw [← abv.map_mul, neg_mul_neg, abv.map_mul])).resolve_right _
  exact ((neg_lt_zero.mpr (abv.pos ha)).trans (abv.pos (neg_ne_zero.mpr ha))).ne'
#align absolute_value.map_neg AbsoluteValue.map_neg

/- warning: absolute_value.map_sub -> AbsoluteValue.map_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : OrderedCommRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) [_inst_3 : NoZeroDivisors.{u2} S (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S (OrderedRing.toRing.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2)))) (MulZeroClass.toHasZero.{u2} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2)))))))] (a : R) (b : R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) a b)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedRing.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) b a))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : OrderedCommRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))) [_inst_3 : NoZeroDivisors.{u2} S (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_2))))) (CommMonoidWithZero.toZero.{u2} S (CommSemiring.toCommMonoidWithZero.{u2} S (OrderedCommSemiring.toCommSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))))] (a : R) (b : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2)))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2))))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_2)))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) b a))
Case conversion may be inaccurate. Consider using '#align absolute_value.map_sub AbsoluteValue.map_subₓ'. -/
protected theorem map_sub (a b : R) : abv (a - b) = abv (b - a) := by rw [← neg_sub, abv.map_neg]
#align absolute_value.map_sub AbsoluteValue.map_sub

end OrderedCommRing

instance {R S : Type _} [Ring R] [OrderedCommRing S] [Nontrivial R] [IsDomain S] :
    MulRingNormClass (AbsoluteValue R S) R S :=
  { AbsoluteValue.subadditiveHomClass,
    AbsoluteValue.monoidWithZeroHomClass with
    map_neg_eq_map := fun f => f.map_neg
    eq_zero_of_map_eq_zero := fun f a => f.eq_zero.1 }

section LinearOrderedRing

variable {R S : Type _} [Semiring R] [LinearOrderedRing S] (abv : AbsoluteValue R S)

#print AbsoluteValue.abs /-
/-- `absolute_value.abs` is `abs` as a bundled `absolute_value`. -/
@[simps]
protected def abs : AbsoluteValue S S where
  toFun := abs
  nonneg' := abs_nonneg
  eq_zero' _ := abs_eq_zero
  add_le' := abs_add
  map_mul' := abs_mul
#align absolute_value.abs AbsoluteValue.abs
-/

instance : Inhabited (AbsoluteValue S S) :=
  ⟨AbsoluteValue.abs⟩

end LinearOrderedRing

section LinearOrderedCommRing

variable {R S : Type _} [Ring R] [LinearOrderedCommRing S] (abv : AbsoluteValue R S)

/- warning: absolute_value.abs_abv_sub_le_abv_sub -> AbsoluteValue.abs_abv_sub_le_abv_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : LinearOrderedCommRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{u2} S (StrictOrderedRing.toStrictOrderedSemiring.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))) (a : R) (b : R), LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedAddCommGroup.toPartialOrder.{u2} S (StrictOrderedRing.toOrderedAddCommGroup.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2)))))) (Abs.abs.{u2} S (Neg.toHasAbs.{u2} S (SubNegMonoid.toHasNeg.{u2} S (AddGroup.toSubNegMonoid.{u2} S (AddGroupWithOne.toAddGroup.{u2} S (NonAssocRing.toAddGroupWithOne.{u2} S (Ring.toNonAssocRing.{u2} S (StrictOrderedRing.toRing.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2)))))))) (SemilatticeSup.toHasSup.{u2} S (Lattice.toSemilatticeSup.{u2} S (LinearOrder.toLattice.{u2} S (LinearOrderedRing.toLinearOrder.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2)))))) (HSub.hSub.{u2, u2, u2} S S S (instHSub.{u2} S (SubNegMonoid.toHasSub.{u2} S (AddGroup.toSubNegMonoid.{u2} S (AddGroupWithOne.toAddGroup.{u2} S (NonAssocRing.toAddGroupWithOne.{u2} S (Ring.toNonAssocRing.{u2} S (StrictOrderedRing.toRing.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{u2} S (StrictOrderedRing.toStrictOrderedSemiring.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{u2} S (StrictOrderedRing.toStrictOrderedSemiring.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{u2} S (StrictOrderedRing.toStrictOrderedSemiring.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))) abv a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{u2} S (StrictOrderedRing.toStrictOrderedSemiring.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{u2} S (StrictOrderedRing.toStrictOrderedSemiring.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{u2} S (StrictOrderedRing.toStrictOrderedSemiring.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))) abv b))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{u2} S (StrictOrderedRing.toStrictOrderedSemiring.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))) (fun (f : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{u2} S (StrictOrderedRing.toStrictOrderedSemiring.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))) => R -> S) (AbsoluteValue.hasCoeToFun.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (StrictOrderedSemiring.toOrderedSemiring.{u2} S (StrictOrderedRing.toStrictOrderedSemiring.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_2))))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (NonAssocRing.toAddGroupWithOne.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1)))))) a b))
but is expected to have type
  forall {R : Type.{u1}} {S : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : LinearOrderedCommRing.{u2} S] (abv : AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))) (a : R) (b : R), LE.le.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (Preorder.toLE.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (PartialOrder.toPreorder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (StrictOrderedRing.toPartialOrder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (LinearOrderedRing.toStrictOrderedRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (LinearOrderedCommRing.toLinearOrderedRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) _inst_2))))) (Abs.abs.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (Neg.toHasAbs.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (Ring.toNeg.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (StrictOrderedRing.toRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (LinearOrderedRing.toStrictOrderedRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (LinearOrderedCommRing.toLinearOrderedRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) _inst_2)))) (SemilatticeSup.toHasSup.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (Lattice.toSemilatticeSup.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (DistribLattice.toLattice.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (instDistribLattice.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (LinearOrderedRing.toLinearOrder.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (LinearOrderedCommRing.toLinearOrderedRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) _inst_2))))))) (HSub.hSub.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) b) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (instHSub.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (Ring.toSub.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (StrictOrderedRing.toRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (LinearOrderedRing.toStrictOrderedRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) (LinearOrderedCommRing.toLinearOrderedRing.{u2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) a) _inst_2))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2)))))) abv a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2)))))) abv b))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u1, u2} (AbsoluteValue.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))) R S (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (OrderedSemiring.toSemiring.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))))))) (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2))))))) (AbsoluteValue.subadditiveHomClass.{u1, u2} R S (Ring.toSemiring.{u1} R _inst_1) (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_2)))))) abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_1)) a b))
Case conversion may be inaccurate. Consider using '#align absolute_value.abs_abv_sub_le_abv_sub AbsoluteValue.abs_abv_sub_le_abv_subₓ'. -/
theorem abs_abv_sub_le_abv_sub (a b : R) : abs (abv a - abv b) ≤ abv (a - b) :=
  abs_sub_le_iff.2 ⟨abv.le_sub _ _, by rw [abv.map_sub] <;> apply abv.le_sub⟩
#align absolute_value.abs_abv_sub_le_abv_sub AbsoluteValue.abs_abv_sub_le_abv_sub

end LinearOrderedCommRing

end AbsoluteValue

#print IsAbsoluteValue /-
/- ./././Mathport/Syntax/Translate/Command.lean:388:30: infer kinds are unsupported in Lean 4: #[`abv_nonneg] [] -/
/- ./././Mathport/Syntax/Translate/Command.lean:388:30: infer kinds are unsupported in Lean 4: #[`abv_eq_zero] [] -/
/- ./././Mathport/Syntax/Translate/Command.lean:388:30: infer kinds are unsupported in Lean 4: #[`abv_add] [] -/
/- ./././Mathport/Syntax/Translate/Command.lean:388:30: infer kinds are unsupported in Lean 4: #[`abv_mul] [] -/
/-- A function `f` is an absolute value if it is nonnegative, zero only at 0, additive, and
multiplicative.

See also the type `absolute_value` which represents a bundled version of absolute values.
-/
class IsAbsoluteValue {S} [OrderedSemiring S] {R} [Semiring R] (f : R → S) : Prop where
  abv_nonneg : ∀ x, 0 ≤ f x
  abv_eq_zero : ∀ {x}, f x = 0 ↔ x = 0
  abv_add : ∀ x y, f (x + y) ≤ f x + f y
  abv_mul : ∀ x y, f (x * y) = f x * f y
#align is_absolute_value IsAbsoluteValue
-/

namespace IsAbsoluteValue

section OrderedSemiring

variable {S : Type _} [OrderedSemiring S]

variable {R : Type _} [Semiring R] (abv : R → S) [IsAbsoluteValue abv]

/- warning: absolute_value.is_absolute_value -> AbsoluteValue.isAbsoluteValue is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : OrderedSemiring.{u1} S] {R : Type.{u2}} [_inst_2 : Semiring.{u2} R] (abv : AbsoluteValue.{u2, u1} R S _inst_2 _inst_1), IsAbsoluteValue.{u1, u2} S _inst_1 R _inst_2 (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (AbsoluteValue.{u2, u1} R S _inst_2 _inst_1) (fun (f : AbsoluteValue.{u2, u1} R S _inst_2 _inst_1) => R -> S) (AbsoluteValue.hasCoeToFun.{u2, u1} R S _inst_2 _inst_1) abv)
but is expected to have type
  forall {S : Type.{u1}} [_inst_1 : OrderedSemiring.{u1} S] {R : Type.{u2}} [_inst_2 : Semiring.{u2} R] (abv : AbsoluteValue.{u2, u1} R S _inst_2 _inst_1), IsAbsoluteValue.{u1, u2} S _inst_1 R _inst_2 (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AbsoluteValue.{u2, u1} R S _inst_2 _inst_1) R (fun (f : R) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.96 : R) => S) f) (SubadditiveHomClass.toFunLike.{max u1 u2, u2, u1} (AbsoluteValue.{u2, u1} R S _inst_2 _inst_1) R S (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Distrib.toAdd.{u1} S (NonUnitalNonAssocSemiring.toDistrib.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_1))))) (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedSemiring.toPartialOrder.{u1} S _inst_1))) (AbsoluteValue.subadditiveHomClass.{u2, u1} R S _inst_2 _inst_1)) abv)
Case conversion may be inaccurate. Consider using '#align absolute_value.is_absolute_value AbsoluteValue.isAbsoluteValueₓ'. -/
/-- A bundled absolute value is an absolute value. -/
instance AbsoluteValue.isAbsoluteValue (abv : AbsoluteValue R S) : IsAbsoluteValue abv
    where
  abv_nonneg := abv.NonNeg
  abv_eq_zero _ := abv.eq_zero
  abv_add := abv.add_le
  abv_mul := abv.map_mul
#align absolute_value.is_absolute_value AbsoluteValue.isAbsoluteValue

#print IsAbsoluteValue.toAbsoluteValue /-
/-- Convert an unbundled `is_absolute_value` to a bundled `absolute_value`. -/
@[simps]
def toAbsoluteValue : AbsoluteValue R S where
  toFun := abv
  add_le' := abv_add abv
  eq_zero' _ := abv_eq_zero abv
  nonneg' := abv_nonneg abv
  map_mul' := abv_mul abv
#align is_absolute_value.to_absolute_value IsAbsoluteValue.toAbsoluteValue
-/

/- warning: is_absolute_value.abv_zero -> IsAbsoluteValue.abv_zero is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : OrderedSemiring.{u1} S] {R : Type.{u2}} [_inst_2 : Semiring.{u2} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u1, u2} S _inst_1 R _inst_2 abv], Eq.{succ u1} S (abv (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))))) (OfNat.ofNat.{u1} S 0 (OfNat.mk.{u1} S 0 (Zero.zero.{u1} S (MulZeroClass.toHasZero.{u1} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_1))))))))
but is expected to have type
  forall {S : Type.{u2}} [_inst_1 : OrderedSemiring.{u2} S] {R : Type.{u1}} [_inst_2 : Semiring.{u1} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u2, u1} S _inst_1 R _inst_2 abv], Eq.{succ u2} S (abv (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_2))))) (OfNat.ofNat.{u2} S 0 (Zero.toOfNat0.{u2} S (MonoidWithZero.toZero.{u2} S (Semiring.toMonoidWithZero.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_1)))))
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abv_zero IsAbsoluteValue.abv_zeroₓ'. -/
theorem abv_zero : abv 0 = 0 :=
  (toAbsoluteValue abv).map_zero
#align is_absolute_value.abv_zero IsAbsoluteValue.abv_zero

/- warning: is_absolute_value.abv_pos -> IsAbsoluteValue.abv_pos is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : OrderedSemiring.{u1} S] {R : Type.{u2}} [_inst_2 : Semiring.{u2} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u1, u2} S _inst_1 R _inst_2 abv] {a : R}, Iff (LT.lt.{u1} S (Preorder.toLT.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedAddCommMonoid.toPartialOrder.{u1} S (OrderedSemiring.toOrderedAddCommMonoid.{u1} S _inst_1)))) (OfNat.ofNat.{u1} S 0 (OfNat.mk.{u1} S 0 (Zero.zero.{u1} S (MulZeroClass.toHasZero.{u1} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (OrderedSemiring.toSemiring.{u1} S _inst_1)))))))) (abv a)) (Ne.{succ u2} R a (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))))))
but is expected to have type
  forall {S : Type.{u2}} [_inst_1 : OrderedSemiring.{u2} S] {R : Type.{u1}} [_inst_2 : Semiring.{u1} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u2, u1} S _inst_1 R _inst_2 abv] {a : R}, Iff (LT.lt.{u2} S (Preorder.toLT.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedSemiring.toPartialOrder.{u2} S _inst_1))) (OfNat.ofNat.{u2} S 0 (Zero.toOfNat0.{u2} S (MonoidWithZero.toZero.{u2} S (Semiring.toMonoidWithZero.{u2} S (OrderedSemiring.toSemiring.{u2} S _inst_1))))) (abv a)) (Ne.{succ u1} R a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_2)))))
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abv_pos IsAbsoluteValue.abv_posₓ'. -/
theorem abv_pos {a : R} : 0 < abv a ↔ a ≠ 0 :=
  (toAbsoluteValue abv).pos_iff
#align is_absolute_value.abv_pos IsAbsoluteValue.abv_pos

end OrderedSemiring

section LinearOrderedRing

variable {S : Type _} [LinearOrderedRing S]

/- warning: is_absolute_value.abs_is_absolute_value -> IsAbsoluteValue.abs_isAbsoluteValue is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} S], IsAbsoluteValue.{u1, u1} S (StrictOrderedSemiring.toOrderedSemiring.{u1} S (StrictOrderedRing.toStrictOrderedSemiring.{u1} S (LinearOrderedRing.toStrictOrderedRing.{u1} S _inst_1))) S (Ring.toSemiring.{u1} S (StrictOrderedRing.toRing.{u1} S (LinearOrderedRing.toStrictOrderedRing.{u1} S _inst_1))) (Abs.abs.{u1} S (Neg.toHasAbs.{u1} S (SubNegMonoid.toHasNeg.{u1} S (AddGroup.toSubNegMonoid.{u1} S (AddGroupWithOne.toAddGroup.{u1} S (NonAssocRing.toAddGroupWithOne.{u1} S (Ring.toNonAssocRing.{u1} S (StrictOrderedRing.toRing.{u1} S (LinearOrderedRing.toStrictOrderedRing.{u1} S _inst_1))))))) (SemilatticeSup.toHasSup.{u1} S (Lattice.toSemilatticeSup.{u1} S (LinearOrder.toLattice.{u1} S (LinearOrderedRing.toLinearOrder.{u1} S _inst_1))))))
but is expected to have type
  forall {S : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} S], IsAbsoluteValue.{u1, u1} S (StrictOrderedSemiring.toOrderedSemiring.{u1} S (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} S (LinearOrderedRing.toLinearOrderedSemiring.{u1} S _inst_1))) S (StrictOrderedSemiring.toSemiring.{u1} S (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} S (LinearOrderedRing.toLinearOrderedSemiring.{u1} S _inst_1))) (Abs.abs.{u1} S (Neg.toHasAbs.{u1} S (Ring.toNeg.{u1} S (StrictOrderedRing.toRing.{u1} S (LinearOrderedRing.toStrictOrderedRing.{u1} S _inst_1))) (SemilatticeSup.toHasSup.{u1} S (Lattice.toSemilatticeSup.{u1} S (DistribLattice.toLattice.{u1} S (instDistribLattice.{u1} S (LinearOrderedRing.toLinearOrder.{u1} S _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abs_is_absolute_value IsAbsoluteValue.abs_isAbsoluteValueₓ'. -/
instance abs_isAbsoluteValue : IsAbsoluteValue (abs : S → S) :=
  AbsoluteValue.abs.IsAbsoluteValue
#align is_absolute_value.abs_is_absolute_value IsAbsoluteValue.abs_isAbsoluteValue

end LinearOrderedRing

section OrderedRing

variable {S : Type _} [OrderedRing S]

section Semiring

variable {R : Type _} [Semiring R] (abv : R → S) [IsAbsoluteValue abv]

variable [IsDomain S]

#print IsAbsoluteValue.abv_one /-
theorem abv_one [Nontrivial R] : abv 1 = 1 :=
  (toAbsoluteValue abv).map_one
#align is_absolute_value.abv_one IsAbsoluteValue.abv_one
-/

#print IsAbsoluteValue.abvHom /-
/-- `abv` as a `monoid_with_zero_hom`. -/
def abvHom [Nontrivial R] : R →*₀ S :=
  (toAbsoluteValue abv).toMonoidWithZeroHom
#align is_absolute_value.abv_hom IsAbsoluteValue.abvHom
-/

/- warning: is_absolute_value.abv_pow -> IsAbsoluteValue.abv_pow is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : OrderedRing.{u1} S] {R : Type.{u2}} [_inst_2 : Semiring.{u2} R] [_inst_4 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (OrderedRing.toRing.{u1} S _inst_1))] [_inst_5 : Nontrivial.{u2} R] (abv : R -> S) [_inst_6 : IsAbsoluteValue.{u1, u2} S (OrderedRing.toOrderedSemiring.{u1} S _inst_1) R _inst_2 abv] (a : R) (n : Nat), Eq.{succ u1} S (abv (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)))) a n)) (HPow.hPow.{u1, 0, u1} S Nat S (instHPow.{u1, 0} S Nat (Monoid.Pow.{u1} S (Ring.toMonoid.{u1} S (OrderedRing.toRing.{u1} S _inst_1)))) (abv a) n)
but is expected to have type
  forall {S : Type.{u1}} [_inst_1 : OrderedRing.{u1} S] {R : Type.{u2}} [_inst_2 : Semiring.{u2} R] [_inst_4 : IsDomain.{u1} S (OrderedSemiring.toSemiring.{u1} S (OrderedRing.toOrderedSemiring.{u1} S _inst_1))] [_inst_5 : Nontrivial.{u2} R] (abv : R -> S) [_inst_6 : IsAbsoluteValue.{u1, u2} S (OrderedRing.toOrderedSemiring.{u1} S _inst_1) R _inst_2 abv] (a : R) (n : Nat), Eq.{succ u1} S (abv (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)))) a n)) (HPow.hPow.{u1, 0, u1} S Nat S (instHPow.{u1, 0} S Nat (Monoid.Pow.{u1} S (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S (OrderedSemiring.toSemiring.{u1} S (OrderedRing.toOrderedSemiring.{u1} S _inst_1)))))) (abv a) n)
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abv_pow IsAbsoluteValue.abv_powₓ'. -/
theorem abv_pow [Nontrivial R] (abv : R → S) [IsAbsoluteValue abv] (a : R) (n : ℕ) :
    abv (a ^ n) = abv a ^ n :=
  (toAbsoluteValue abv).map_pow a n
#align is_absolute_value.abv_pow IsAbsoluteValue.abv_pow

end Semiring

section Ring

variable {R : Type _} [Ring R] (abv : R → S) [IsAbsoluteValue abv]

/- warning: is_absolute_value.abv_sub_le -> IsAbsoluteValue.abv_sub_le is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : OrderedRing.{u1} S] {R : Type.{u2}} [_inst_2 : Ring.{u2} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u1, u2} S (OrderedRing.toOrderedSemiring.{u1} S _inst_1) R (Ring.toSemiring.{u2} R _inst_2) abv] (a : R) (b : R) (c : R), LE.le.{u1} S (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedAddCommGroup.toPartialOrder.{u1} S (OrderedRing.toOrderedAddCommGroup.{u1} S _inst_1)))) (abv (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) a c)) (HAdd.hAdd.{u1, u1, u1} S S S (instHAdd.{u1} S (Distrib.toHasAdd.{u1} S (Ring.toDistrib.{u1} S (OrderedRing.toRing.{u1} S _inst_1)))) (abv (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) a b)) (abv (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) b c)))
but is expected to have type
  forall {S : Type.{u2}} [_inst_1 : OrderedRing.{u2} S] {R : Type.{u1}} [_inst_2 : Ring.{u1} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u2, u1} S (OrderedRing.toOrderedSemiring.{u2} S _inst_1) R (Ring.toSemiring.{u1} R _inst_2) abv] (a : R) (b : R) (c : R), LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedRing.toPartialOrder.{u2} S _inst_1))) (abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_2)) a c)) (HAdd.hAdd.{u2, u2, u2} S S S (instHAdd.{u2} S (Distrib.toAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S _inst_1))))))) (abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_2)) a b)) (abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_2)) b c)))
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abv_sub_le IsAbsoluteValue.abv_sub_leₓ'. -/
theorem abv_sub_le (a b c : R) : abv (a - c) ≤ abv (a - b) + abv (b - c) := by
  simpa [sub_eq_add_neg, add_assoc] using abv_add abv (a - b) (b - c)
#align is_absolute_value.abv_sub_le IsAbsoluteValue.abv_sub_le

/- warning: is_absolute_value.sub_abv_le_abv_sub -> IsAbsoluteValue.sub_abv_le_abv_sub is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : OrderedRing.{u1} S] {R : Type.{u2}} [_inst_2 : Ring.{u2} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u1, u2} S (OrderedRing.toOrderedSemiring.{u1} S _inst_1) R (Ring.toSemiring.{u2} R _inst_2) abv] (a : R) (b : R), LE.le.{u1} S (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedAddCommGroup.toPartialOrder.{u1} S (OrderedRing.toOrderedAddCommGroup.{u1} S _inst_1)))) (HSub.hSub.{u1, u1, u1} S S S (instHSub.{u1} S (SubNegMonoid.toHasSub.{u1} S (AddGroup.toSubNegMonoid.{u1} S (AddGroupWithOne.toAddGroup.{u1} S (NonAssocRing.toAddGroupWithOne.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S _inst_1))))))) (abv a) (abv b)) (abv (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) a b))
but is expected to have type
  forall {S : Type.{u2}} [_inst_1 : OrderedRing.{u2} S] {R : Type.{u1}} [_inst_2 : Ring.{u1} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u2, u1} S (OrderedRing.toOrderedSemiring.{u2} S _inst_1) R (Ring.toSemiring.{u1} R _inst_2) abv] (a : R) (b : R), LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (OrderedRing.toPartialOrder.{u2} S _inst_1))) (HSub.hSub.{u2, u2, u2} S S S (instHSub.{u2} S (Ring.toSub.{u2} S (OrderedRing.toRing.{u2} S _inst_1))) (abv a) (abv b)) (abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_2)) a b))
Case conversion may be inaccurate. Consider using '#align is_absolute_value.sub_abv_le_abv_sub IsAbsoluteValue.sub_abv_le_abv_subₓ'. -/
theorem sub_abv_le_abv_sub (a b : R) : abv a - abv b ≤ abv (a - b) :=
  (toAbsoluteValue abv).le_sub a b
#align is_absolute_value.sub_abv_le_abv_sub IsAbsoluteValue.sub_abv_le_abv_sub

end Ring

end OrderedRing

section OrderedCommRing

variable {S : Type _} [OrderedCommRing S]

section Ring

variable {R : Type _} [Ring R] (abv : R → S) [IsAbsoluteValue abv]

variable [NoZeroDivisors S]

/- warning: is_absolute_value.abv_neg -> IsAbsoluteValue.abv_neg is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : OrderedCommRing.{u1} S] {R : Type.{u2}} [_inst_2 : Ring.{u2} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u1, u2} S (OrderedRing.toOrderedSemiring.{u1} S (OrderedCommRing.toOrderedRing.{u1} S _inst_1)) R (Ring.toSemiring.{u2} R _inst_2) abv] [_inst_4 : NoZeroDivisors.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (OrderedRing.toRing.{u1} S (OrderedCommRing.toOrderedRing.{u1} S _inst_1)))) (MulZeroClass.toHasZero.{u1} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S (OrderedCommRing.toOrderedRing.{u1} S _inst_1)))))))] (a : R), Eq.{succ u1} S (abv (Neg.neg.{u2} R (SubNegMonoid.toHasNeg.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2))))) a)) (abv a)
but is expected to have type
  forall {S : Type.{u2}} [_inst_1 : OrderedCommRing.{u2} S] {R : Type.{u1}} [_inst_2 : Ring.{u1} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u2, u1} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_1)) R (Ring.toSemiring.{u1} R _inst_2) abv] [_inst_4 : NoZeroDivisors.{u2} S (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_1))))) (CommMonoidWithZero.toZero.{u2} S (CommSemiring.toCommMonoidWithZero.{u2} S (OrderedCommSemiring.toCommSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_1))))] (a : R), Eq.{succ u2} S (abv (Neg.neg.{u1} R (Ring.toNeg.{u1} R _inst_2) a)) (abv a)
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abv_neg IsAbsoluteValue.abv_negₓ'. -/
theorem abv_neg (a : R) : abv (-a) = abv a :=
  (toAbsoluteValue abv).map_neg a
#align is_absolute_value.abv_neg IsAbsoluteValue.abv_neg

/- warning: is_absolute_value.abv_sub -> IsAbsoluteValue.abv_sub is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : OrderedCommRing.{u1} S] {R : Type.{u2}} [_inst_2 : Ring.{u2} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u1, u2} S (OrderedRing.toOrderedSemiring.{u1} S (OrderedCommRing.toOrderedRing.{u1} S _inst_1)) R (Ring.toSemiring.{u2} R _inst_2) abv] [_inst_4 : NoZeroDivisors.{u1} S (Distrib.toHasMul.{u1} S (Ring.toDistrib.{u1} S (OrderedRing.toRing.{u1} S (OrderedCommRing.toOrderedRing.{u1} S _inst_1)))) (MulZeroClass.toHasZero.{u1} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (OrderedRing.toRing.{u1} S (OrderedCommRing.toOrderedRing.{u1} S _inst_1)))))))] (a : R) (b : R), Eq.{succ u1} S (abv (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) a b)) (abv (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) b a))
but is expected to have type
  forall {S : Type.{u2}} [_inst_1 : OrderedCommRing.{u2} S] {R : Type.{u1}} [_inst_2 : Ring.{u1} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u2, u1} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_1)) R (Ring.toSemiring.{u1} R _inst_2) abv] [_inst_4 : NoZeroDivisors.{u2} S (NonUnitalNonAssocRing.toMul.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (OrderedRing.toRing.{u2} S (OrderedCommRing.toOrderedRing.{u2} S _inst_1))))) (CommMonoidWithZero.toZero.{u2} S (CommSemiring.toCommMonoidWithZero.{u2} S (OrderedCommSemiring.toCommSemiring.{u2} S (OrderedCommRing.toOrderedCommSemiring.{u2} S _inst_1))))] (a : R) (b : R), Eq.{succ u2} S (abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_2)) a b)) (abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_2)) b a))
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abv_sub IsAbsoluteValue.abv_subₓ'. -/
theorem abv_sub (a b : R) : abv (a - b) = abv (b - a) :=
  (toAbsoluteValue abv).map_sub a b
#align is_absolute_value.abv_sub IsAbsoluteValue.abv_sub

end Ring

end OrderedCommRing

section LinearOrderedCommRing

variable {S : Type _} [LinearOrderedCommRing S]

section Ring

variable {R : Type _} [Ring R] (abv : R → S) [IsAbsoluteValue abv]

/- warning: is_absolute_value.abs_abv_sub_le_abv_sub -> IsAbsoluteValue.abs_abv_sub_le_abv_sub is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : LinearOrderedCommRing.{u1} S] {R : Type.{u2}} [_inst_2 : Ring.{u2} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u1, u2} S (StrictOrderedSemiring.toOrderedSemiring.{u1} S (StrictOrderedRing.toStrictOrderedSemiring.{u1} S (LinearOrderedRing.toStrictOrderedRing.{u1} S (LinearOrderedCommRing.toLinearOrderedRing.{u1} S _inst_1)))) R (Ring.toSemiring.{u2} R _inst_2) abv] (a : R) (b : R), LE.le.{u1} S (Preorder.toLE.{u1} S (PartialOrder.toPreorder.{u1} S (OrderedAddCommGroup.toPartialOrder.{u1} S (StrictOrderedRing.toOrderedAddCommGroup.{u1} S (LinearOrderedRing.toStrictOrderedRing.{u1} S (LinearOrderedCommRing.toLinearOrderedRing.{u1} S _inst_1)))))) (Abs.abs.{u1} S (Neg.toHasAbs.{u1} S (SubNegMonoid.toHasNeg.{u1} S (AddGroup.toSubNegMonoid.{u1} S (AddGroupWithOne.toAddGroup.{u1} S (NonAssocRing.toAddGroupWithOne.{u1} S (Ring.toNonAssocRing.{u1} S (StrictOrderedRing.toRing.{u1} S (LinearOrderedRing.toStrictOrderedRing.{u1} S (LinearOrderedCommRing.toLinearOrderedRing.{u1} S _inst_1)))))))) (SemilatticeSup.toHasSup.{u1} S (Lattice.toSemilatticeSup.{u1} S (LinearOrder.toLattice.{u1} S (LinearOrderedRing.toLinearOrder.{u1} S (LinearOrderedCommRing.toLinearOrderedRing.{u1} S _inst_1)))))) (HSub.hSub.{u1, u1, u1} S S S (instHSub.{u1} S (SubNegMonoid.toHasSub.{u1} S (AddGroup.toSubNegMonoid.{u1} S (AddGroupWithOne.toAddGroup.{u1} S (NonAssocRing.toAddGroupWithOne.{u1} S (Ring.toNonAssocRing.{u1} S (StrictOrderedRing.toRing.{u1} S (LinearOrderedRing.toStrictOrderedRing.{u1} S (LinearOrderedCommRing.toLinearOrderedRing.{u1} S _inst_1))))))))) (abv a) (abv b))) (abv (HSub.hSub.{u2, u2, u2} R R R (instHSub.{u2} R (SubNegMonoid.toHasSub.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (NonAssocRing.toAddGroupWithOne.{u2} R (Ring.toNonAssocRing.{u2} R _inst_2)))))) a b))
but is expected to have type
  forall {S : Type.{u2}} [_inst_1 : LinearOrderedCommRing.{u2} S] {R : Type.{u1}} [_inst_2 : Ring.{u1} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u2, u1} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedCommRing.toLinearOrderedCommSemiring.{u2} S _inst_1)))) R (Ring.toSemiring.{u1} R _inst_2) abv] (a : R) (b : R), LE.le.{u2} S (Preorder.toLE.{u2} S (PartialOrder.toPreorder.{u2} S (StrictOrderedRing.toPartialOrder.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_1))))) (Abs.abs.{u2} S (Neg.toHasAbs.{u2} S (Ring.toNeg.{u2} S (StrictOrderedRing.toRing.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_1)))) (SemilatticeSup.toHasSup.{u2} S (Lattice.toSemilatticeSup.{u2} S (DistribLattice.toLattice.{u2} S (instDistribLattice.{u2} S (LinearOrderedRing.toLinearOrder.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_1))))))) (HSub.hSub.{u2, u2, u2} S S S (instHSub.{u2} S (Ring.toSub.{u2} S (StrictOrderedRing.toRing.{u2} S (LinearOrderedRing.toStrictOrderedRing.{u2} S (LinearOrderedCommRing.toLinearOrderedRing.{u2} S _inst_1))))) (abv a) (abv b))) (abv (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R _inst_2)) a b))
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abs_abv_sub_le_abv_sub IsAbsoluteValue.abs_abv_sub_le_abv_subₓ'. -/
theorem abs_abv_sub_le_abv_sub (a b : R) : abs (abv a - abv b) ≤ abv (a - b) :=
  (toAbsoluteValue abv).abs_abv_sub_le_abv_sub a b
#align is_absolute_value.abs_abv_sub_le_abv_sub IsAbsoluteValue.abs_abv_sub_le_abv_sub

end Ring

end LinearOrderedCommRing

section LinearOrderedField

variable {S : Type _} [LinearOrderedSemifield S]

section Semiring

variable {R : Type _} [Semiring R] [Nontrivial R] (abv : R → S) [IsAbsoluteValue abv]

/- warning: is_absolute_value.abv_one' -> IsAbsoluteValue.abv_one' is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u1} S] {R : Type.{u2}} [_inst_2 : Semiring.{u2} R] [_inst_3 : Nontrivial.{u2} R] (abv : R -> S) [_inst_4 : IsAbsoluteValue.{u1, u2} S (StrictOrderedSemiring.toOrderedSemiring.{u1} S (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} S (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} S (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} S _inst_1)))) R _inst_2 abv], Eq.{succ u1} S (abv (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))))) (OfNat.ofNat.{u1} S 1 (OfNat.mk.{u1} S 1 (One.one.{u1} S (AddMonoidWithOne.toOne.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S (StrictOrderedSemiring.toSemiring.{u1} S (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} S (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} S (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} S _inst_1)))))))))))
but is expected to have type
  forall {S : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u2} S] {R : Type.{u1}} [_inst_2 : Semiring.{u1} R] [_inst_3 : Nontrivial.{u1} R] (abv : R -> S) [_inst_4 : IsAbsoluteValue.{u2, u1} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} S _inst_1)))) R _inst_2 abv], Eq.{succ u2} S (abv (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_2)))) (OfNat.ofNat.{u2} S 1 (One.toOfNat1.{u2} S (Semiring.toOne.{u2} S (StrictOrderedSemiring.toSemiring.{u2} S (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} S (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} S (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} S _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abv_one' IsAbsoluteValue.abv_one'ₓ'. -/
theorem abv_one' : abv 1 = 1 :=
  (toAbsoluteValue abv).map_one_of_isLeftRegular <|
    (isRegular_of_ne_zero <| (toAbsoluteValue abv).NeZero one_ne_zero).left
#align is_absolute_value.abv_one' IsAbsoluteValue.abv_one'

#print IsAbsoluteValue.abvHom' /-
/-- An absolute value as a monoid with zero homomorphism, assuming the target is a semifield. -/
def abvHom' : R →*₀ S :=
  ⟨abv, abv_zero abv, abv_one' abv, abv_mul abv⟩
#align is_absolute_value.abv_hom' IsAbsoluteValue.abvHom'
-/

end Semiring

section DivisionSemiring

variable {R : Type _} [DivisionSemiring R] (abv : R → S) [IsAbsoluteValue abv]

/- warning: is_absolute_value.abv_inv -> IsAbsoluteValue.abv_inv is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u1} S] {R : Type.{u2}} [_inst_2 : DivisionSemiring.{u2} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u1, u2} S (StrictOrderedSemiring.toOrderedSemiring.{u1} S (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} S (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} S (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} S _inst_1)))) R (DivisionSemiring.toSemiring.{u2} R _inst_2) abv] (a : R), Eq.{succ u1} S (abv (Inv.inv.{u2} R (DivInvMonoid.toHasInv.{u2} R (GroupWithZero.toDivInvMonoid.{u2} R (DivisionSemiring.toGroupWithZero.{u2} R _inst_2))) a)) (Inv.inv.{u1} S (DivInvMonoid.toHasInv.{u1} S (GroupWithZero.toDivInvMonoid.{u1} S (DivisionSemiring.toGroupWithZero.{u1} S (Semifield.toDivisionSemiring.{u1} S (LinearOrderedSemifield.toSemifield.{u1} S _inst_1))))) (abv a))
but is expected to have type
  forall {S : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u2} S] {R : Type.{u1}} [_inst_2 : DivisionSemiring.{u1} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u2, u1} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} S _inst_1)))) R (DivisionSemiring.toSemiring.{u1} R _inst_2) abv] (a : R), Eq.{succ u2} S (abv (Inv.inv.{u1} R (DivisionSemiring.toInv.{u1} R _inst_2) a)) (Inv.inv.{u2} S (LinearOrderedSemifield.toInv.{u2} S _inst_1) (abv a))
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abv_inv IsAbsoluteValue.abv_invₓ'. -/
theorem abv_inv (a : R) : abv a⁻¹ = (abv a)⁻¹ :=
  map_inv₀ (abvHom' abv) a
#align is_absolute_value.abv_inv IsAbsoluteValue.abv_inv

/- warning: is_absolute_value.abv_div -> IsAbsoluteValue.abv_div is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u1} S] {R : Type.{u2}} [_inst_2 : DivisionSemiring.{u2} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u1, u2} S (StrictOrderedSemiring.toOrderedSemiring.{u1} S (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} S (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} S (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} S _inst_1)))) R (DivisionSemiring.toSemiring.{u2} R _inst_2) abv] (a : R) (b : R), Eq.{succ u1} S (abv (HDiv.hDiv.{u2, u2, u2} R R R (instHDiv.{u2} R (DivInvMonoid.toHasDiv.{u2} R (GroupWithZero.toDivInvMonoid.{u2} R (DivisionSemiring.toGroupWithZero.{u2} R _inst_2)))) a b)) (HDiv.hDiv.{u1, u1, u1} S S S (instHDiv.{u1} S (DivInvMonoid.toHasDiv.{u1} S (GroupWithZero.toDivInvMonoid.{u1} S (DivisionSemiring.toGroupWithZero.{u1} S (Semifield.toDivisionSemiring.{u1} S (LinearOrderedSemifield.toSemifield.{u1} S _inst_1)))))) (abv a) (abv b))
but is expected to have type
  forall {S : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u2} S] {R : Type.{u1}} [_inst_2 : DivisionSemiring.{u1} R] (abv : R -> S) [_inst_3 : IsAbsoluteValue.{u2, u1} S (OrderedCommSemiring.toOrderedSemiring.{u2} S (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} S (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} S (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} S _inst_1)))) R (DivisionSemiring.toSemiring.{u1} R _inst_2) abv] (a : R) (b : R), Eq.{succ u2} S (abv (HDiv.hDiv.{u1, u1, u1} R R R (instHDiv.{u1} R (DivisionSemiring.toDiv.{u1} R _inst_2)) a b)) (HDiv.hDiv.{u2, u2, u2} S S S (instHDiv.{u2} S (LinearOrderedSemifield.toDiv.{u2} S _inst_1)) (abv a) (abv b))
Case conversion may be inaccurate. Consider using '#align is_absolute_value.abv_div IsAbsoluteValue.abv_divₓ'. -/
theorem abv_div (a b : R) : abv (a / b) = abv a / abv b :=
  map_div₀ (abvHom' abv) a b
#align is_absolute_value.abv_div IsAbsoluteValue.abv_div

end DivisionSemiring

end LinearOrderedField

end IsAbsoluteValue

