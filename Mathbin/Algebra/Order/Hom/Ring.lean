/-
Copyright (c) 2022 Alex J. Best, Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Alex J. Best, Yaël Dillies

! This file was ported from Lean 3 source module algebra.order.hom.ring
! leanprover-community/mathlib commit ee05e9ce1322178f0c12004eb93c00d2c8c00ed2
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Order.Archimedean
import Mathbin.Algebra.Order.Hom.Monoid
import Mathbin.Algebra.Order.Ring.Defs
import Mathbin.Algebra.Ring.Equiv
import Mathbin.Tactic.ByContra
import Mathbin.Tactic.Wlog

/-!
# Ordered ring homomorphisms

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Homomorphisms between ordered (semi)rings that respect the ordering.

## Main definitions

* `order_ring_hom` : Monotone semiring homomorphisms.
* `order_ring_iso` : Monotone semiring isomorphisms.

## Notation

* `→+*o`: Ordered ring homomorphisms.
* `≃+*o`: Ordered ring isomorphisms.

## Tags

ordered ring homomorphism, order homomorphism
-/


open Function

variable {F α β γ δ : Type _}

#print OrderRingHom /-
/-- `order_ring_hom α β` is the type of monotone semiring homomorphisms from `α` to `β`.

When possible, instead of parametrizing results over `(f : order_ring_hom α β)`,
you should parametrize over `(F : Type*) [order_ring_hom_class F α β] (f : F)`.

When you extend this structure, make sure to extend `order_ring_hom_class`. -/
structure OrderRingHom (α β : Type _) [NonAssocSemiring α] [Preorder α] [NonAssocSemiring β]
  [Preorder β] extends α →+* β where
  monotone' : Monotone to_fun
#align order_ring_hom OrderRingHom
-/

/-- Reinterpret an ordered ring homomorphism as a ring homomorphism. -/
add_decl_doc OrderRingHom.toRingHom

-- mathport name: «expr →+*o »
infixl:25 " →+*o " => OrderRingHom

/- warning: order_ring_iso -> OrderRingIso is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β], Sort.{max (succ u1) (succ u2)}
but is expected to have type
  forall (α : Type.{u1}) (β : Type.{u2}) [_inst_1 : Mul.{u1} α] [_inst_2 : Mul.{u2} β] [_inst_3 : Add.{u1} α] [_inst_4 : Add.{u2} β] [_inst_5 : LE.{u1} α] [_inst_6 : LE.{u2} β], Sort.{max (succ u1) (succ u2)}
Case conversion may be inaccurate. Consider using '#align order_ring_iso OrderRingIsoₓ'. -/
/-- `order_ring_hom α β` is the type of order-preserving semiring isomorphisms between `α` and `β`.

When possible, instead of parametrizing results over `(f : order_ring_iso α β)`,
you should parametrize over `(F : Type*) [order_ring_iso_class F α β] (f : F)`.

When you extend this structure, make sure to extend `order_ring_iso_class`. -/
structure OrderRingIso (α β : Type _) [Mul α] [Add α] [LE α] [Mul β] [Add β] [LE β] extends
  α ≃+* β where
  map_le_map_iff' {a b : α} : to_fun a ≤ to_fun b ↔ a ≤ b
#align order_ring_iso OrderRingIso

-- mathport name: «expr ≃+*o »
infixl:25 " ≃+*o " => OrderRingIso

#print OrderRingHomClass /-
/-- `order_ring_hom_class F α β` states that `F` is a type of ordered semiring homomorphisms.
You should extend this typeclass when you extend `order_ring_hom`. -/
class OrderRingHomClass (F : Type _) (α β : outParam <| Type _) [NonAssocSemiring α] [Preorder α]
  [NonAssocSemiring β] [Preorder β] extends RingHomClass F α β where
  Monotone (f : F) : Monotone f
#align order_ring_hom_class OrderRingHomClass
-/

#print OrderRingIsoClass /-
/-- `order_ring_iso_class F α β` states that `F` is a type of ordered semiring isomorphisms.
You should extend this class when you extend `order_ring_iso`. -/
class OrderRingIsoClass (F : Type _) (α β : outParam (Type _)) [Mul α] [Add α] [LE α] [Mul β]
  [Add β] [LE β] extends RingEquivClass F α β where
  map_le_map_iff (f : F) {a b : α} : f a ≤ f b ↔ a ≤ b
#align order_ring_iso_class OrderRingIsoClass
-/

#print OrderRingHomClass.toOrderAddMonoidHomClass /-
-- See note [lower priority instance]
instance (priority := 100) OrderRingHomClass.toOrderAddMonoidHomClass [NonAssocSemiring α]
    [Preorder α] [NonAssocSemiring β] [Preorder β] [OrderRingHomClass F α β] :
    OrderAddMonoidHomClass F α β :=
  { ‹OrderRingHomClass F α β› with }
#align order_ring_hom_class.to_order_add_monoid_hom_class OrderRingHomClass.toOrderAddMonoidHomClass
-/

#print OrderRingHomClass.toOrderMonoidWithZeroHomClass /-
-- See note [lower priority instance]
instance (priority := 100) OrderRingHomClass.toOrderMonoidWithZeroHomClass [NonAssocSemiring α]
    [Preorder α] [NonAssocSemiring β] [Preorder β] [OrderRingHomClass F α β] :
    OrderMonoidWithZeroHomClass F α β :=
  { ‹OrderRingHomClass F α β› with }
#align order_ring_hom_class.to_order_monoid_with_zero_hom_class OrderRingHomClass.toOrderMonoidWithZeroHomClass
-/

#print OrderRingIsoClass.toOrderIsoClass /-
-- See note [lower instance priority]
instance (priority := 100) OrderRingIsoClass.toOrderIsoClass [Mul α] [Add α] [LE α] [Mul β] [Add β]
    [LE β] [OrderRingIsoClass F α β] : OrderIsoClass F α β :=
  { ‹OrderRingIsoClass F α β› with }
#align order_ring_iso_class.to_order_iso_class OrderRingIsoClass.toOrderIsoClass
-/

/- warning: order_ring_iso_class.to_order_ring_hom_class -> OrderRingIsoClass.toOrderRingHomClass is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u3} β] [_inst_4 : Preorder.{u3} β] [_inst_5 : OrderRingIsoClass.{u1, u2, u3} F α β (Distrib.toHasMul.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toHasAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Preorder.toLE.{u2} α _inst_2) (Distrib.toHasMul.{u3} β (NonUnitalNonAssocSemiring.toDistrib.{u3} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β _inst_3))) (Distrib.toHasAdd.{u3} β (NonUnitalNonAssocSemiring.toDistrib.{u3} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β _inst_3))) (Preorder.toLE.{u3} β _inst_4)], OrderRingHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4
but is expected to have type
  forall {F : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} {_inst_1 : NonAssocSemiring.{u2} α} {_inst_2 : Preorder.{u2} α} {_inst_3 : NonAssocSemiring.{u3} β} {_inst_4 : Preorder.{u3} β} [_inst_5 : OrderRingIsoClass.{u1, u2, u3} F α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Preorder.toLE.{u2} α _inst_2) (NonUnitalNonAssocSemiring.toMul.{u3} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β _inst_3)) (Distrib.toAdd.{u3} β (NonUnitalNonAssocSemiring.toDistrib.{u3} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β _inst_3))) (Preorder.toLE.{u3} β _inst_4)], OrderRingHomClass.{u1, u2, u3} F α β _inst_1 _inst_2 _inst_3 _inst_4
Case conversion may be inaccurate. Consider using '#align order_ring_iso_class.to_order_ring_hom_class OrderRingIsoClass.toOrderRingHomClassₓ'. -/
-- See note [lower instance priority]
instance (priority := 100) OrderRingIsoClass.toOrderRingHomClass [NonAssocSemiring α] [Preorder α]
    [NonAssocSemiring β] [Preorder β] [OrderRingIsoClass F α β] : OrderRingHomClass F α β :=
  { ‹OrderRingIsoClass F α β› with Monotone := fun f => OrderHomClass.mono f }
#align order_ring_iso_class.to_order_ring_hom_class OrderRingIsoClass.toOrderRingHomClass

instance [NonAssocSemiring α] [Preorder α] [NonAssocSemiring β] [Preorder β]
    [OrderRingHomClass F α β] : CoeTC F (α →+*o β) :=
  ⟨fun f => ⟨f, OrderHomClass.mono f⟩⟩

instance [Mul α] [Add α] [LE α] [Mul β] [Add β] [LE β] [OrderRingIsoClass F α β] :
    CoeTC F (α ≃+*o β) :=
  ⟨fun f => ⟨f, fun a b => map_le_map_iff f⟩⟩

/-! ### Ordered ring homomorphisms -/


namespace OrderRingHom

variable [NonAssocSemiring α] [Preorder α]

section Preorder

variable [NonAssocSemiring β] [Preorder β] [NonAssocSemiring γ] [Preorder γ] [NonAssocSemiring δ]
  [Preorder δ]

#print OrderRingHom.toOrderAddMonoidHom /-
/-- Reinterpret an ordered ring homomorphism as an ordered additive monoid homomorphism. -/
def toOrderAddMonoidHom (f : α →+*o β) : α →+o β :=
  { f with }
#align order_ring_hom.to_order_add_monoid_hom OrderRingHom.toOrderAddMonoidHom
-/

#print OrderRingHom.toOrderMonoidWithZeroHom /-
/-- Reinterpret an ordered ring homomorphism as an order homomorphism. -/
def toOrderMonoidWithZeroHom (f : α →+*o β) : α →*₀o β :=
  { f with }
#align order_ring_hom.to_order_monoid_with_zero_hom OrderRingHom.toOrderMonoidWithZeroHom
-/

instance : OrderRingHomClass (α →+*o β) α β
    where
  coe f := f.toFun
  coe_injective' f g h := by obtain ⟨⟨_, _⟩, _⟩ := f <;> obtain ⟨⟨_, _⟩, _⟩ := g <;> congr
  map_mul f := f.map_mul'
  map_one f := f.map_one'
  map_add f := f.map_add'
  map_zero f := f.map_zero'
  Monotone f := f.monotone'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (α →+*o β) fun _ => α → β :=
  ⟨fun f => f.toFun⟩

/- warning: order_ring_hom.to_fun_eq_coe -> OrderRingHom.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (α -> β) (RingHom.toFun.{u1, u2} α β _inst_1 _inst_3 (OrderRingHom.toRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (α -> β) (OneHom.toFun.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3))) (MonoidHom.toOneHom.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) (RingHom.toMonoidHom.{u2, u1} α β _inst_1 _inst_3 (OrderRingHom.toRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 f)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (f : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) f) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.to_fun_eq_coe OrderRingHom.toFun_eq_coeₓ'. -/
theorem toFun_eq_coe (f : α →+*o β) : f.toFun = ⇑f :=
  rfl
#align order_ring_hom.to_fun_eq_coe OrderRingHom.toFun_eq_coe

/- warning: order_ring_hom.ext -> OrderRingHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] {f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4} {g : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g a)) -> (Eq.{max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] {f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4} {g : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) g a)) -> (Eq.{max (succ u2) (succ u1)} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) f g)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.ext OrderRingHom.extₓ'. -/
@[ext]
theorem ext {f g : α →+*o β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align order_ring_hom.ext OrderRingHom.ext

/- warning: order_ring_hom.to_ring_hom_eq_coe -> OrderRingHom.toRingHom_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α β _inst_1 _inst_3) (OrderRingHom.toRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (RingHom.{u1, u2} α β _inst_1 _inst_3) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (RingHom.{u1, u2} α β _inst_1 _inst_3) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (RingHom.{u1, u2} α β _inst_1 _inst_3) (RingHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_3 (OrderRingHomClass.toRingHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.orderRingHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} α β _inst_1 _inst_3) (OrderRingHom.toRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 f) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_3 (OrderRingHomClass.toRingHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)) f)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.to_ring_hom_eq_coe OrderRingHom.toRingHom_eq_coeₓ'. -/
@[simp]
theorem toRingHom_eq_coe (f : α →+*o β) : f.toRingHom = f :=
  RingHom.ext fun _ => rfl
#align order_ring_hom.to_ring_hom_eq_coe OrderRingHom.toRingHom_eq_coe

/- warning: order_ring_hom.to_order_add_monoid_hom_eq_coe -> OrderRingHom.toOrderAddMonoidHom_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (OrderRingHom.toOrderAddMonoidHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (OrderAddMonoidHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.orderRingHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (OrderAddMonoidHom.{u2, u1} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3))))) (OrderRingHom.toOrderAddMonoidHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 f) (OrderAddMonoidHomClass.toOrderAddMonoidHom.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)) f)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.to_order_add_monoid_hom_eq_coe OrderRingHom.toOrderAddMonoidHom_eq_coeₓ'. -/
@[simp]
theorem toOrderAddMonoidHom_eq_coe (f : α →+*o β) : f.toOrderAddMonoidHom = f :=
  rfl
#align order_ring_hom.to_order_add_monoid_hom_eq_coe OrderRingHom.toOrderAddMonoidHom_eq_coe

/- warning: order_ring_hom.to_order_monoid_with_zero_hom_eq_coe clashes with order_ring_hom.to_order_monoid_with_zero_hom -> OrderRingHom.toOrderMonoidWithZeroHom
warning: order_ring_hom.to_order_monoid_with_zero_hom_eq_coe -> OrderRingHom.toOrderMonoidWithZeroHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (OrderRingHom.toOrderMonoidWithZeroHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (OrderMonoidWithZeroHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3) (OrderRingHomClass.toOrderMonoidWithZeroHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.orderRingHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))))) f)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β], (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) -> (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3))
Case conversion may be inaccurate. Consider using '#align order_ring_hom.to_order_monoid_with_zero_hom_eq_coe OrderRingHom.toOrderMonoidWithZeroHomₓ'. -/
@[simp]
theorem toOrderMonoidWithZeroHom (f : α →+*o β) : f.toOrderMonoidWithZeroHom = f :=
  rfl
#align order_ring_hom.to_order_monoid_with_zero_hom_eq_coe OrderRingHom.toOrderMonoidWithZeroHom

/- warning: order_ring_hom.coe_coe_ring_hom -> OrderRingHom.coe_coe_ringHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β _inst_1 _inst_3) (fun (_x : RingHom.{u1, u2} α β _inst_1 _inst_3) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_3) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (RingHom.{u1, u2} α β _inst_1 _inst_3) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (RingHom.{u1, u2} α β _inst_1 _inst_3) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (RingHom.{u1, u2} α β _inst_1 _inst_3) (RingHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_3 (OrderRingHomClass.toRingHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.orderRingHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β _inst_1 _inst_3) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β _inst_1 _inst_3) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β _inst_1 _inst_3) α β _inst_1 _inst_3 (RingHom.instRingHomClassRingHom.{u2, u1} α β _inst_1 _inst_3)))) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_3 (OrderRingHomClass.toRingHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_coe_ring_hom OrderRingHom.coe_coe_ringHomₓ'. -/
@[simp]
theorem coe_coe_ringHom (f : α →+*o β) : ⇑(f : α →+* β) = f :=
  rfl
#align order_ring_hom.coe_coe_ring_hom OrderRingHom.coe_coe_ringHom

/- warning: order_ring_hom.coe_coe_order_add_monoid_hom -> OrderRingHom.coe_coe_orderAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (fun (_x : OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) => α -> β) (OrderAddMonoidHom.hasCoeToFun.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (OrderAddMonoidHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.orderRingHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderAddMonoidHom.{u2, u1} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3))))) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderAddMonoidHom.{u2, u1} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3))))) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderAddMonoidHom.{u2, u1} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3))))) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderAddMonoidHom.instOrderAddMonoidHomClassOrderAddMonoidHom.{u2, u1} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3))))))) (OrderAddMonoidHomClass.toOrderAddMonoidHom.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_coe_order_add_monoid_hom OrderRingHom.coe_coe_orderAddMonoidHomₓ'. -/
@[simp]
theorem coe_coe_orderAddMonoidHom (f : α →+*o β) : ⇑(f : α →+o β) = f :=
  rfl
#align order_ring_hom.coe_coe_order_add_monoid_hom OrderRingHom.coe_coe_orderAddMonoidHom

/- warning: order_ring_hom.coe_coe_order_monoid_with_zero_hom -> OrderRingHom.coe_coe_orderMonoidWithZeroHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (fun (_x : OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) => α -> β) (OrderMonoidWithZeroHom.hasCoeToFun.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (OrderMonoidWithZeroHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3) (OrderRingHomClass.toOrderMonoidWithZeroHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.orderRingHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderMonoidWithZeroHom.{u2, u1} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderMonoidWithZeroHom.{u2, u1} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderMonoidWithZeroHom.{u2, u1} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) α β _inst_2 _inst_4 (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) (OrderMonoidWithZeroHomClass.toOrderMonoidHomClass.{max u2 u1, u2, u1} (OrderMonoidWithZeroHom.{u2, u1} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3) (OrderMonoidWithZeroHom.instOrderMonoidWithZeroHomClassOrderMonoidWithZeroHom.{u2, u1} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3))))) (OrderMonoidWithZeroHomClass.toOrderMonoidWithZeroHom.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3) (OrderRingHomClass.toOrderMonoidWithZeroHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_coe_order_monoid_with_zero_hom OrderRingHom.coe_coe_orderMonoidWithZeroHomₓ'. -/
@[simp]
theorem coe_coe_orderMonoidWithZeroHom (f : α →+*o β) : ⇑(f : α →*₀o β) = f :=
  rfl
#align order_ring_hom.coe_coe_order_monoid_with_zero_hom OrderRingHom.coe_coe_orderMonoidWithZeroHom

/- warning: order_ring_hom.coe_ring_hom_apply -> OrderRingHom.coe_ringHom_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β _inst_1 _inst_3) (fun (_x : RingHom.{u1, u2} α β _inst_1 _inst_3) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_3) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (RingHom.{u1, u2} α β _inst_1 _inst_3) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (RingHom.{u1, u2} α β _inst_1 _inst_3) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (RingHom.{u1, u2} α β _inst_1 _inst_3) (RingHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_3 (OrderRingHomClass.toRingHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.orderRingHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))))) f) a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f a)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β _inst_1 _inst_3) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β _inst_1 _inst_3) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β _inst_1 _inst_3) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β _inst_1 _inst_3) α β _inst_1 _inst_3 (RingHom.instRingHomClassRingHom.{u2, u1} α β _inst_1 _inst_3)))) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_3 (OrderRingHomClass.toRingHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)) f) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f a)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_ring_hom_apply OrderRingHom.coe_ringHom_applyₓ'. -/
@[norm_cast]
theorem coe_ringHom_apply (f : α →+*o β) (a : α) : (f : α →+* β) a = f a :=
  rfl
#align order_ring_hom.coe_ring_hom_apply OrderRingHom.coe_ringHom_apply

/- warning: order_ring_hom.coe_order_add_monoid_hom_apply -> OrderRingHom.coe_orderAddMonoidHom_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (fun (_x : OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) => α -> β) (OrderAddMonoidHom.hasCoeToFun.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderAddMonoidHom.{u1, u2} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3))))) (OrderAddMonoidHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.orderRingHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))))) f) a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f a)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderAddMonoidHom.{u2, u1} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3))))) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderAddMonoidHom.{u2, u1} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3))))) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderAddMonoidHom.{u2, u1} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3))))) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderAddMonoidHom.instOrderAddMonoidHomClassOrderAddMonoidHom.{u2, u1} α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3))))))) (OrderAddMonoidHomClass.toOrderAddMonoidHom.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)) f) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f a)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_order_add_monoid_hom_apply OrderRingHom.coe_orderAddMonoidHom_applyₓ'. -/
@[norm_cast]
theorem coe_orderAddMonoidHom_apply (f : α →+*o β) (a : α) : (f : α →+o β) a = f a :=
  rfl
#align order_ring_hom.coe_order_add_monoid_hom_apply OrderRingHom.coe_orderAddMonoidHom_apply

/- warning: order_ring_hom.coe_order_monoid_with_zero_hom_apply -> OrderRingHom.coe_orderMonoidWithZeroHom_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (fun (_x : OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) => α -> β) (OrderMonoidWithZeroHom.hasCoeToFun.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderMonoidWithZeroHom.{u1, u2} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3)) (OrderMonoidWithZeroHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u2} β _inst_3) (OrderRingHomClass.toOrderMonoidWithZeroHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.orderRingHomClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4))))) f) a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f a)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderMonoidWithZeroHom.{u2, u1} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderMonoidWithZeroHom.{u2, u1} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderMonoidWithZeroHom.{u2, u1} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) α β _inst_2 _inst_4 (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) (OrderMonoidWithZeroHomClass.toOrderMonoidHomClass.{max u2 u1, u2, u1} (OrderMonoidWithZeroHom.{u2, u1} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3)) α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3) (OrderMonoidWithZeroHom.instOrderMonoidWithZeroHomClassOrderMonoidWithZeroHom.{u2, u1} α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3))))) (OrderMonoidWithZeroHomClass.toOrderMonoidWithZeroHom.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} β _inst_3) (OrderRingHomClass.toOrderMonoidWithZeroHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)) f) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f a)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_order_monoid_with_zero_hom_apply OrderRingHom.coe_orderMonoidWithZeroHom_applyₓ'. -/
@[norm_cast]
theorem coe_orderMonoidWithZeroHom_apply (f : α →+*o β) (a : α) : (f : α →*₀o β) a = f a :=
  rfl
#align order_ring_hom.coe_order_monoid_with_zero_hom_apply OrderRingHom.coe_orderMonoidWithZeroHom_apply

/- warning: order_ring_hom.copy -> OrderRingHom.copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)) -> (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u2} β (Preorder.toLE.{u2} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f)) -> (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.copy OrderRingHom.copyₓ'. -/
/-- Copy of a `order_ring_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : α →+*o β) (f' : α → β) (h : f' = f) : α →+*o β :=
  { f.toRingHom.copy f' h, f.toOrderAddMonoidHom.copy f' h with }
#align order_ring_hom.copy OrderRingHom.copy

/- warning: order_ring_hom.coe_copy -> OrderRingHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingHom.copy.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (OrderRingHom.copy.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_copy OrderRingHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : α →+*o β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align order_ring_hom.coe_copy OrderRingHom.coe_copy

/- warning: order_ring_hom.copy_eq -> OrderRingHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) f)), Eq.{max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingHom.copy.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) f)), Eq.{max (succ u2) (succ u1)} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingHom.copy.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 f f' h) f
Case conversion may be inaccurate. Consider using '#align order_ring_hom.copy_eq OrderRingHom.copy_eqₓ'. -/
theorem copy_eq (f : α →+*o β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align order_ring_hom.copy_eq OrderRingHom.copy_eq

variable (α)

#print OrderRingHom.id /-
/-- The identity as an ordered ring homomorphism. -/
protected def id : α →+*o α :=
  { RingHom.id _, OrderHom.id with }
#align order_ring_hom.id OrderRingHom.id
-/

instance : Inhabited (α →+*o α) :=
  ⟨OrderRingHom.id α⟩

/- warning: order_ring_hom.coe_id -> OrderRingHom.coe_id is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (fun (_x : OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) => α -> α) (OrderRingHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (OrderRingHom.id.{u1} α _inst_1 _inst_2)) (id.{succ u1} α)
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => α) _x) (RelHomClass.toFunLike.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_2 _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2)))) (OrderRingHom.id.{u1} α _inst_1 _inst_2)) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_id OrderRingHom.coe_idₓ'. -/
@[simp]
theorem coe_id : ⇑(OrderRingHom.id α) = id :=
  rfl
#align order_ring_hom.coe_id OrderRingHom.coe_id

variable {α}

/- warning: order_ring_hom.id_apply -> OrderRingHom.id_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (fun (_x : OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) => α -> α) (OrderRingHom.hasCoeToFun.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (OrderRingHom.id.{u1} α _inst_1 _inst_2) a) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => α) _x) (RelHomClass.toFunLike.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_2 _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2)))) (OrderRingHom.id.{u1} α _inst_1 _inst_2) a) a
Case conversion may be inaccurate. Consider using '#align order_ring_hom.id_apply OrderRingHom.id_applyₓ'. -/
@[simp]
theorem id_apply (a : α) : OrderRingHom.id α a = a :=
  rfl
#align order_ring_hom.id_apply OrderRingHom.id_apply

/- warning: order_ring_hom.coe_ring_hom_id -> OrderRingHom.coe_RingHom_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α], Eq.{succ u1} (RingHom.{u1, u1} α α _inst_1 _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (RingHom.{u1, u1} α α _inst_1 _inst_1) (HasLiftT.mk.{succ u1, succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (RingHom.{u1, u1} α α _inst_1 _inst_1) (CoeTCₓ.coe.{succ u1, succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (RingHom.{u1, u1} α α _inst_1 _inst_1) (RingHom.hasCoeT.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_1 _inst_1 (OrderRingHomClass.toRingHomClass.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingHom.orderRingHomClass.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2))))) (OrderRingHom.id.{u1} α _inst_1 _inst_2)) (RingHom.id.{u1} α _inst_1)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α], Eq.{succ u1} (RingHom.{u1, u1} α α _inst_1 _inst_1) (RingHomClass.toRingHom.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_1 _inst_1 (OrderRingHomClass.toRingHomClass.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2)) (OrderRingHom.id.{u1} α _inst_1 _inst_2)) (RingHom.id.{u1} α _inst_1)
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_ring_hom_id OrderRingHom.coe_RingHom_idₓ'. -/
@[simp]
theorem coe_RingHom_id : (OrderRingHom.id α : α →+* α) = RingHom.id α :=
  rfl
#align order_ring_hom.coe_ring_hom_id OrderRingHom.coe_RingHom_id

/- warning: order_ring_hom.coe_order_add_monoid_hom_id -> OrderRingHom.coe_OrderAddMonoidHom_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α], Eq.{succ u1} (OrderAddMonoidHom.{u1, u1} α α _inst_2 _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (OrderAddMonoidHom.{u1, u1} α α _inst_2 _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1))))) (HasLiftT.mk.{succ u1, succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (OrderAddMonoidHom.{u1, u1} α α _inst_2 _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1))))) (CoeTCₓ.coe.{succ u1, succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (OrderAddMonoidHom.{u1, u1} α α _inst_2 _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1))))) (OrderAddMonoidHom.hasCoeT.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_2 _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingHom.orderRingHomClass.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2))))) (OrderRingHom.id.{u1} α _inst_1 _inst_2)) (OrderAddMonoidHom.id.{u1} α _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α], Eq.{succ u1} (OrderAddMonoidHom.{u1, u1} α α _inst_2 _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1))))) (OrderAddMonoidHomClass.toOrderAddMonoidHom.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_2 _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2)) (OrderRingHom.id.{u1} α _inst_1 _inst_2)) (OrderAddMonoidHom.id.{u1} α _inst_2 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))))
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_order_add_monoid_hom_id OrderRingHom.coe_OrderAddMonoidHom_idₓ'. -/
@[simp]
theorem coe_OrderAddMonoidHom_id : (OrderRingHom.id α : α →+o α) = OrderAddMonoidHom.id α :=
  rfl
#align order_ring_hom.coe_order_add_monoid_hom_id OrderRingHom.coe_OrderAddMonoidHom_id

/- warning: order_ring_hom.coe_order_monoid_with_zero_hom_id -> OrderRingHom.coe_OrderMonoidWithZeroHom_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α], Eq.{succ u1} (OrderMonoidWithZeroHom.{u1, u1} α α _inst_2 _inst_2 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (OrderMonoidWithZeroHom.{u1, u1} α α _inst_2 _inst_2 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (HasLiftT.mk.{succ u1, succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (OrderMonoidWithZeroHom.{u1, u1} α α _inst_2 _inst_2 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (CoeTCₓ.coe.{succ u1, succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (OrderMonoidWithZeroHom.{u1, u1} α α _inst_2 _inst_2 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (OrderMonoidWithZeroHom.hasCoeT.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_2 _inst_2 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (OrderRingHomClass.toOrderMonoidWithZeroHomClass.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingHom.orderRingHomClass.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2))))) (OrderRingHom.id.{u1} α _inst_1 _inst_2)) (OrderMonoidWithZeroHom.id.{u1} α _inst_2 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α], Eq.{succ u1} (OrderMonoidWithZeroHom.{u1, u1} α α _inst_2 _inst_2 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (OrderMonoidWithZeroHomClass.toOrderMonoidWithZeroHom.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_2 _inst_2 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1) (OrderRingHomClass.toOrderMonoidWithZeroHomClass.{u1, u1, u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2)) (OrderRingHom.id.{u1} α _inst_1 _inst_2)) (OrderMonoidWithZeroHom.id.{u1} α _inst_2 (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1))
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_order_monoid_with_zero_hom_id OrderRingHom.coe_OrderMonoidWithZeroHom_idₓ'. -/
@[simp]
theorem coe_OrderMonoidWithZeroHom_id :
    (OrderRingHom.id α : α →*₀o α) = OrderMonoidWithZeroHom.id α :=
  rfl
#align order_ring_hom.coe_order_monoid_with_zero_hom_id OrderRingHom.coe_OrderMonoidWithZeroHom_id

#print OrderRingHom.comp /-
/-- Composition of two `order_ring_hom`s as an `order_ring_hom`. -/
protected def comp (f : β →+*o γ) (g : α →+*o β) : α →+*o γ :=
  { f.toRingHom.comp g.toRingHom, f.toOrderAddMonoidHom.comp g.toOrderAddMonoidHom with }
#align order_ring_hom.comp OrderRingHom.comp
-/

/- warning: order_ring_hom.coe_comp -> OrderRingHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] [_inst_5 : NonAssocSemiring.{u3} γ] [_inst_6 : Preorder.{u3} γ] (f : OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) (g : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u3)} (α -> γ) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderRingHom.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : OrderRingHom.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) => α -> γ) (OrderRingHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (OrderRingHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) => β -> γ) (OrderRingHom.hasCoeToFun.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u3} β] [_inst_4 : Preorder.{u3} β] [_inst_5 : NonAssocSemiring.{u2} γ] [_inst_6 : Preorder.{u2} γ] (f : OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) (g : OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => γ) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (OrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => γ) _x) (RelHomClass.toFunLike.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) α γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : γ) => LE.le.{u2} γ (Preorder.toLE.{u2} γ _inst_6) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) α γ _inst_2 _inst_6 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} γ (AddMonoidWithOne.toAddMonoid.{u2} γ (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} γ (NonAssocSemiring.toAddCommMonoidWithOne.{u2} γ _inst_5)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) α γ _inst_1 _inst_2 _inst_5 _inst_6 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6)))) (OrderRingHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β (fun (_x : β) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : β) => γ) _x) (RelHomClass.toFunLike.{max u3 u2, u3, u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : β) => LE.le.{u3} β (Preorder.toLE.{u3} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : γ) => LE.le.{u2} γ (Preorder.toLE.{u2} γ _inst_6) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u3 u2, u3, u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β γ _inst_4 _inst_6 (AddMonoid.toAddZeroClass.{u3} β (AddMonoidWithOne.toAddMonoid.{u3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u3} β _inst_3)))) (AddMonoid.toAddZeroClass.{u2} γ (AddMonoidWithOne.toAddMonoid.{u2} γ (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} γ (NonAssocSemiring.toAddCommMonoidWithOne.{u2} γ _inst_5)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u3 u2, u3, u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β γ _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6)))) f) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u1 u3, u1, u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u3} β (Preorder.toLE.{u3} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u1 u3, u1, u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u3} β (AddMonoidWithOne.toAddMonoid.{u3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u3} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u1 u3, u1, u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4)))) g))
Case conversion may be inaccurate. Consider using '#align order_ring_hom.coe_comp OrderRingHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (f : β →+*o γ) (g : α →+*o β) : ⇑(f.comp g) = f ∘ g :=
  rfl
#align order_ring_hom.coe_comp OrderRingHom.coe_comp

/- warning: order_ring_hom.comp_apply -> OrderRingHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] [_inst_5 : NonAssocSemiring.{u3} γ] [_inst_6 : Preorder.{u3} γ] (f : OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) (g : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderRingHom.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (fun (_x : OrderRingHom.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) => α -> γ) (OrderRingHom.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (OrderRingHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) => β -> γ) (OrderRingHom.hasCoeToFun.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) f (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g a))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u3} β] [_inst_4 : Preorder.{u3} β] [_inst_5 : NonAssocSemiring.{u2} γ] [_inst_6 : Preorder.{u2} γ] (f : OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) (g : OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) (a : α), Eq.{succ u2} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (OrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => γ) _x) (RelHomClass.toFunLike.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) α γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : γ) => LE.le.{u2} γ (Preorder.toLE.{u2} γ _inst_6) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) α γ _inst_2 _inst_6 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} γ (AddMonoidWithOne.toAddMonoid.{u2} γ (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} γ (NonAssocSemiring.toAddCommMonoidWithOne.{u2} γ _inst_5)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u1 u2, u1, u2} (OrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) α γ _inst_1 _inst_2 _inst_5 _inst_6 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6)))) (OrderRingHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β (fun (_x : β) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : β) => γ) _x) (RelHomClass.toFunLike.{max u3 u2, u3, u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : β) => LE.le.{u3} β (Preorder.toLE.{u3} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : γ) => LE.le.{u2} γ (Preorder.toLE.{u2} γ _inst_6) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u3 u2, u3, u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β γ _inst_4 _inst_6 (AddMonoid.toAddZeroClass.{u3} β (AddMonoidWithOne.toAddMonoid.{u3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u3} β _inst_3)))) (AddMonoid.toAddZeroClass.{u2} γ (AddMonoidWithOne.toAddMonoid.{u2} γ (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} γ (NonAssocSemiring.toAddCommMonoidWithOne.{u2} γ _inst_5)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u3 u2, u3, u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β γ _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6)))) f (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u1 u3, u1, u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u3} β (Preorder.toLE.{u3} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u1 u3, u1, u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u3} β (AddMonoidWithOne.toAddMonoid.{u3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u3} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u1 u3, u1, u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4)))) g a))
Case conversion may be inaccurate. Consider using '#align order_ring_hom.comp_apply OrderRingHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (f : β →+*o γ) (g : α →+*o β) (a : α) : f.comp g a = f (g a) :=
  rfl
#align order_ring_hom.comp_apply OrderRingHom.comp_apply

/- warning: order_ring_hom.comp_assoc -> OrderRingHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} {δ : Type.{u4}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] [_inst_5 : NonAssocSemiring.{u3} γ] [_inst_6 : Preorder.{u3} γ] [_inst_7 : NonAssocSemiring.{u4} δ] [_inst_8 : Preorder.{u4} δ] (f : OrderRingHom.{u3, u4} γ δ _inst_5 _inst_6 _inst_7 _inst_8) (g : OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) (h : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u4)} (OrderRingHom.{u1, u4} α δ _inst_1 _inst_2 _inst_7 _inst_8) (OrderRingHom.comp.{u1, u2, u4} α β δ _inst_1 _inst_2 _inst_3 _inst_4 _inst_7 _inst_8 (OrderRingHom.comp.{u2, u3, u4} β γ δ _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 f g) h) (OrderRingHom.comp.{u1, u3, u4} α γ δ _inst_1 _inst_2 _inst_5 _inst_6 _inst_7 _inst_8 f (OrderRingHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g h))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u4}} {δ : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] [_inst_5 : NonAssocSemiring.{u4} γ] [_inst_6 : Preorder.{u4} γ] [_inst_7 : NonAssocSemiring.{u3} δ] [_inst_8 : Preorder.{u3} δ] (f : OrderRingHom.{u4, u3} γ δ _inst_5 _inst_6 _inst_7 _inst_8) (g : OrderRingHom.{u2, u4} β γ _inst_3 _inst_4 _inst_5 _inst_6) (h : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u3)} (OrderRingHom.{u1, u3} α δ _inst_1 _inst_2 _inst_7 _inst_8) (OrderRingHom.comp.{u1, u2, u3} α β δ _inst_1 _inst_2 _inst_3 _inst_4 _inst_7 _inst_8 (OrderRingHom.comp.{u2, u4, u3} β γ δ _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 f g) h) (OrderRingHom.comp.{u1, u4, u3} α γ δ _inst_1 _inst_2 _inst_5 _inst_6 _inst_7 _inst_8 f (OrderRingHom.comp.{u1, u2, u4} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 g h))
Case conversion may be inaccurate. Consider using '#align order_ring_hom.comp_assoc OrderRingHom.comp_assocₓ'. -/
theorem comp_assoc (f : γ →+*o δ) (g : β →+*o γ) (h : α →+*o β) :
    (f.comp g).comp h = f.comp (g.comp h) :=
  rfl
#align order_ring_hom.comp_assoc OrderRingHom.comp_assoc

/- warning: order_ring_hom.comp_id -> OrderRingHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingHom.comp.{u1, u1, u2} α α β _inst_1 _inst_2 _inst_1 _inst_2 _inst_3 _inst_4 f (OrderRingHom.id.{u1} α _inst_1 _inst_2)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingHom.comp.{u2, u2, u1} α α β _inst_1 _inst_2 _inst_1 _inst_2 _inst_3 _inst_4 f (OrderRingHom.id.{u2} α _inst_1 _inst_2)) f
Case conversion may be inaccurate. Consider using '#align order_ring_hom.comp_id OrderRingHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : α →+*o β) : f.comp (OrderRingHom.id α) = f :=
  ext fun x => rfl
#align order_ring_hom.comp_id OrderRingHom.comp_id

/- warning: order_ring_hom.id_comp -> OrderRingHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingHom.comp.{u1, u2, u2} α β β _inst_1 _inst_2 _inst_3 _inst_4 _inst_3 _inst_4 (OrderRingHom.id.{u2} β _inst_3 _inst_4) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingHom.comp.{u2, u1, u1} α β β _inst_1 _inst_2 _inst_3 _inst_4 _inst_3 _inst_4 (OrderRingHom.id.{u1} β _inst_3 _inst_4) f) f
Case conversion may be inaccurate. Consider using '#align order_ring_hom.id_comp OrderRingHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : α →+*o β) : (OrderRingHom.id β).comp f = f :=
  ext fun x => rfl
#align order_ring_hom.id_comp OrderRingHom.id_comp

/- warning: order_ring_hom.cancel_right -> OrderRingHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] [_inst_5 : NonAssocSemiring.{u3} γ] [_inst_6 : Preorder.{u3} γ] {f₁ : OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6} {f₂ : OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6} {g : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (OrderRingHom.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (OrderRingHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f₁ g) (OrderRingHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f₂ g)) (Eq.{max (succ u2) (succ u3)} (OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u3} β] [_inst_4 : Preorder.{u3} β] [_inst_5 : NonAssocSemiring.{u2} γ] [_inst_6 : Preorder.{u2} γ] {f₁ : OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6} {f₂ : OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6} {g : OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u1 u3, u1, u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u1} α (Preorder.toLE.{u1} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u3} β (Preorder.toLE.{u3} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u1 u3, u1, u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u3} β (AddMonoidWithOne.toAddMonoid.{u3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u3} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u1 u3, u1, u3} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4)))) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (OrderRingHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f₁ g) (OrderRingHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f₂ g)) (Eq.{max (succ u3) (succ u2)} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align order_ring_hom.cancel_right OrderRingHom.cancel_rightₓ'. -/
theorem cancel_right {f₁ f₂ : β →+*o γ} {g : α →+*o β} (hg : Surjective g) :
    f₁.comp g = f₂.comp g ↔ f₁ = f₂ :=
  ⟨fun h => ext <| hg.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align order_ring_hom.cancel_right OrderRingHom.cancel_right

/- warning: order_ring_hom.cancel_left -> OrderRingHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] [_inst_5 : NonAssocSemiring.{u3} γ] [_inst_6 : Preorder.{u3} γ] {f : OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6} {g₁ : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4} {g₂ : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : OrderRingHom.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) => β -> γ) (OrderRingHom.hasCoeToFun.{u2, u3} β γ _inst_3 _inst_4 _inst_5 _inst_6) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (OrderRingHom.{u1, u3} α γ _inst_1 _inst_2 _inst_5 _inst_6) (OrderRingHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g₁) (OrderRingHom.comp.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g₂)) (Eq.{max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u3} β] [_inst_4 : Preorder.{u3} β] [_inst_5 : NonAssocSemiring.{u2} γ] [_inst_6 : Preorder.{u2} γ] {f : OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6} {g₁ : OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4} {g₂ : OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β (fun (_x : β) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : β) => γ) _x) (RelHomClass.toFunLike.{max u3 u2, u3, u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : β) => LE.le.{u3} β (Preorder.toLE.{u3} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : γ) => LE.le.{u2} γ (Preorder.toLE.{u2} γ _inst_6) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u3 u2, u3, u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β γ _inst_4 _inst_6 (AddMonoid.toAddZeroClass.{u3} β (AddMonoidWithOne.toAddMonoid.{u3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u3} β _inst_3)))) (AddMonoid.toAddZeroClass.{u2} γ (AddMonoidWithOne.toAddMonoid.{u2} γ (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} γ (NonAssocSemiring.toAddCommMonoidWithOne.{u2} γ _inst_5)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u3 u2, u3, u2} (OrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6) β γ _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u3, u2} β γ _inst_3 _inst_4 _inst_5 _inst_6)))) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α γ _inst_1 _inst_2 _inst_5 _inst_6) (OrderRingHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g₁) (OrderRingHom.comp.{u1, u3, u2} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f g₂)) (Eq.{max (succ u1) (succ u3)} (OrderRingHom.{u1, u3} α β _inst_1 _inst_2 _inst_3 _inst_4) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align order_ring_hom.cancel_left OrderRingHom.cancel_leftₓ'. -/
theorem cancel_left {f : β →+*o γ} {g₁ g₂ : α →+*o β} (hf : Injective f) :
    f.comp g₁ = f.comp g₂ ↔ g₁ = g₂ :=
  ⟨fun h => ext fun a => hf <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
#align order_ring_hom.cancel_left OrderRingHom.cancel_left

end Preorder

variable [NonAssocSemiring β]

instance [Preorder β] : Preorder (OrderRingHom α β) :=
  Preorder.lift (coeFn : _ → α → β)

instance [PartialOrder β] : PartialOrder (OrderRingHom α β) :=
  PartialOrder.lift _ FunLike.coe_injective

end OrderRingHom

/-! ### Ordered ring isomorphisms -/


namespace OrderRingIso

section LE

variable [Mul α] [Add α] [LE α] [Mul β] [Add β] [LE β] [Mul γ] [Add γ] [LE γ] [Mul δ] [Add δ] [LE δ]

/- warning: order_ring_iso.to_order_iso -> OrderRingIso.toOrderIso is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β], (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) -> (OrderIso.{u1, u2} α β _inst_3 _inst_6)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β], (OrderRingIso.{u1, u2} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) -> (OrderIso.{u1, u2} α β _inst_3 _inst_6)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.to_order_iso OrderRingIso.toOrderIsoₓ'. -/
/-- Reinterpret an ordered ring isomorphism as an order isomorphism. -/
def toOrderIso (f : α ≃+*o β) : α ≃o β :=
  ⟨f.toRingEquiv.toEquiv, fun _ _ => f.map_le_map_iff'⟩
#align order_ring_iso.to_order_iso OrderRingIso.toOrderIso

instance : OrderRingIsoClass (α ≃+*o β) α β
    where
  coe f := f.toFun
  inv f := f.invFun
  coe_injective' f g h₁ h₂ := by
    obtain ⟨⟨_, _⟩, _⟩ := f
    obtain ⟨⟨_, _⟩, _⟩ := g
    congr
  map_add f := f.map_add'
  map_mul f := f.map_mul'
  map_le_map_iff f _ _ := f.map_le_map_iff'
  left_inv f := f.left_inv
  right_inv f := f.right_inv

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (α ≃+*o β) fun _ => α → β :=
  FunLike.hasCoeToFun

/- warning: order_ring_iso.to_fun_eq_coe -> OrderRingIso.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] (f : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (α -> β) (RingEquiv.toFun.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIso.toRingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) => α -> β) (OrderRingIso.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] (f : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6), Eq.{max (succ u2) (succ u1)} (α -> β) (Equiv.toFun.{succ u2, succ u1} α β (RingEquiv.toEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 (OrderRingIso.toRingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 f))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β _inst_6 x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderIsoClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) f)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.to_fun_eq_coe OrderRingIso.toFun_eq_coeₓ'. -/
theorem toFun_eq_coe (f : α ≃+*o β) : f.toFun = f :=
  rfl
#align order_ring_iso.to_fun_eq_coe OrderRingIso.toFun_eq_coe

/- warning: order_ring_iso.ext -> OrderRingIso.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] {f : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6} {g : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6}, (forall (a : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) => α -> β) (OrderRingIso.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) => α -> β) (OrderRingIso.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) g a)) -> (Eq.{max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] {f : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6} {g : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β _inst_6 x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderIsoClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β _inst_6 x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderIsoClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) g a)) -> (Eq.{max (succ u2) (succ u1)} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) f g)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.ext OrderRingIso.extₓ'. -/
@[ext]
theorem ext {f g : α ≃+*o β} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align order_ring_iso.ext OrderRingIso.ext

/- warning: order_ring_iso.coe_mk -> OrderRingIso.coe_mk is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] (e : RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (h : forall {a : α} {b : α}, Iff (LE.le.{u2} β _inst_6 (RingEquiv.toFun.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5 e a) (RingEquiv.toFun.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5 e b)) (LE.le.{u1} α _inst_3 a b)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) => α -> β) (OrderRingIso.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (OrderRingIso.mk.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e h)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (fun (_x : RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) => α -> β) (RingEquiv.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) e)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] (e : RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) (h : forall {a : α} {b : α}, Iff (LE.le.{u1} β _inst_6 (Equiv.toFun.{succ u2, succ u1} α β (RingEquiv.toEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 e) a) (Equiv.toFun.{succ u2, succ u1} α β (RingEquiv.toEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 e) b)) (LE.le.{u2} α _inst_3 a b)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β _inst_6 x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderIsoClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) (OrderRingIso.mk.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 e h)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) α β (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) α β (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) α β _inst_1 _inst_4 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) α β _inst_1 _inst_2 _inst_4 _inst_5 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5))))) e)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.coe_mk OrderRingIso.coe_mkₓ'. -/
@[simp]
theorem coe_mk (e : α ≃+* β) (h) : ⇑(⟨e, h⟩ : α ≃+*o β) = e :=
  rfl
#align order_ring_iso.coe_mk OrderRingIso.coe_mk

/- warning: order_ring_iso.mk_coe -> OrderRingIso.mk_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] (e : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (h : forall {a : α} {b : α}, Iff (LE.le.{u2} β _inst_6 (RingEquiv.toFun.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (RingEquiv.hasCoeT.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIsoClass.toRingEquivClass.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.orderRingIsoClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) e) a) (RingEquiv.toFun.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (RingEquiv.hasCoeT.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIsoClass.toRingEquivClass.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.orderRingIsoClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) e) b)) (LE.le.{u1} α _inst_3 a b)), Eq.{max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (OrderRingIso.mk.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (RingEquiv.hasCoeT.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIsoClass.toRingEquivClass.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.orderRingIsoClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) e) h) e
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] (e : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) (h : forall {a : α} {b : α}, Iff (LE.le.{u1} β _inst_6 (Equiv.toFun.{succ u2, succ u1} α β (RingEquiv.toEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 (RingEquivClass.toRingEquiv.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIsoClass.toRingEquivClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) e)) a) (Equiv.toFun.{succ u2, succ u1} α β (RingEquiv.toEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 (RingEquivClass.toRingEquiv.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIsoClass.toRingEquivClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) e)) b)) (LE.le.{u2} α _inst_3 a b)), Eq.{max (succ u2) (succ u1)} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) (OrderRingIso.mk.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 (RingEquivClass.toRingEquiv.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIsoClass.toRingEquivClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) e) h) e
Case conversion may be inaccurate. Consider using '#align order_ring_iso.mk_coe OrderRingIso.mk_coeₓ'. -/
@[simp]
theorem mk_coe (e : α ≃+*o β) (h) : (⟨e, h⟩ : α ≃+*o β) = e :=
  ext fun _ => rfl
#align order_ring_iso.mk_coe OrderRingIso.mk_coe

/- warning: order_ring_iso.to_ring_equiv_eq_coe -> OrderRingIso.toRingEquiv_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] (f : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (OrderRingIso.toRingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (RingEquiv.hasCoeT.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIsoClass.toRingEquivClass.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.orderRingIsoClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] (f : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6), Eq.{max (succ u2) (succ u1)} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) (OrderRingIso.toRingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6 f) (RingEquivClass.toRingEquiv.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIsoClass.toRingEquivClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.to_ring_equiv_eq_coe OrderRingIso.toRingEquiv_eq_coeₓ'. -/
@[simp]
theorem toRingEquiv_eq_coe (f : α ≃+*o β) : f.toRingEquiv = f :=
  RingEquiv.ext fun _ => rfl
#align order_ring_iso.to_ring_equiv_eq_coe OrderRingIso.toRingEquiv_eq_coe

/- warning: order_ring_iso.to_order_iso_eq_coe -> OrderRingIso.toOrderIso_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] (f : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_3 _inst_6) (OrderRingIso.toOrderIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (OrderIso.{u1, u2} α β _inst_3 _inst_6) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (OrderIso.{u1, u2} α β _inst_3 _inst_6) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (OrderIso.{u1, u2} α β _inst_3 _inst_6) (OrderIso.hasCoeT.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.orderRingIsoClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] (f : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6), Eq.{max (succ u2) (succ u1)} (OrderIso.{u2, u1} α β _inst_3 _inst_6) (OrderRingIso.toOrderIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 f) (OrderIsoClass.toOrderIso.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.to_order_iso_eq_coe OrderRingIso.toOrderIso_eq_coeₓ'. -/
@[simp]
theorem toOrderIso_eq_coe (f : α ≃+*o β) : f.toOrderIso = f :=
  OrderIso.ext rfl
#align order_ring_iso.to_order_iso_eq_coe OrderRingIso.toOrderIso_eq_coe

/- warning: order_ring_iso.coe_to_ring_equiv -> OrderRingIso.coe_toRingEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] (f : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (fun (_x : RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) => α -> β) (RingEquiv.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (RingEquiv.{u1, u2} α β _inst_1 _inst_2 _inst_4 _inst_5) (RingEquiv.hasCoeT.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIsoClass.toRingEquivClass.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.orderRingIsoClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) => α -> β) (OrderRingIso.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] (f : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) α β (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) α β (MulEquivClass.toEquivLike.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) α β _inst_1 _inst_4 (RingEquivClass.toMulEquivClass.{max u2 u1, u2, u1} (RingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5) α β _inst_1 _inst_2 _inst_4 _inst_5 (RingEquiv.instRingEquivClassRingEquiv.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5))))) (RingEquivClass.toRingEquiv.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_4 _inst_5 (OrderRingIsoClass.toRingEquivClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β _inst_6 x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderIsoClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) f)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.coe_to_ring_equiv OrderRingIso.coe_toRingEquivₓ'. -/
@[simp, norm_cast]
theorem coe_toRingEquiv (f : α ≃+*o β) : ⇑(f : α ≃+* β) = f :=
  rfl
#align order_ring_iso.coe_to_ring_equiv OrderRingIso.coe_toRingEquiv

/- warning: order_ring_iso.coe_to_order_iso -> OrderRingIso.coe_toOrderIso is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] (f : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderIso.{u1, u2} α β _inst_3 _inst_6) (fun (_x : RelIso.{u1, u2} α β (LE.le.{u1} α _inst_3) (LE.le.{u2} β _inst_6)) => α -> β) (RelIso.hasCoeToFun.{u1, u2} α β (LE.le.{u1} α _inst_3) (LE.le.{u2} β _inst_6)) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (OrderIso.{u1, u2} α β _inst_3 _inst_6) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (OrderIso.{u1, u2} α β _inst_3 _inst_6) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (OrderIso.{u1, u2} α β _inst_3 _inst_6) (OrderIso.hasCoeT.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.orderRingIsoClass.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) => α -> β) (OrderRingIso.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] (f : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6), Eq.{max (succ u2) (succ u1)} (α -> β) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderIso.{u2, u1} α β _inst_3 _inst_6) α (fun (_x : α) => β) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderIso.{u2, u1} α β _inst_3 _inst_6) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : α) => LE.le.{u2} α _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : β) => LE.le.{u1} β _inst_6 x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298) (RelIso.instRelHomClassRelIso.{u2, u1} α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1281 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1283 : α) => LE.le.{u2} α _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1281 x._@.Mathlib.Order.Hom.Basic._hyg.1283) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1296 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1298 : β) => LE.le.{u1} β _inst_6 x._@.Mathlib.Order.Hom.Basic._hyg.1296 x._@.Mathlib.Order.Hom.Basic._hyg.1298))) (OrderIsoClass.toOrderIso.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β _inst_6 x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderIsoClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) f)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.coe_to_order_iso OrderRingIso.coe_toOrderIsoₓ'. -/
@[simp, norm_cast]
theorem coe_toOrderIso (f : α ≃+*o β) : ⇑(f : α ≃o β) = f :=
  rfl
#align order_ring_iso.coe_to_order_iso OrderRingIso.coe_toOrderIso

variable (α)

/- warning: order_ring_iso.refl -> OrderRingIso.refl is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α], OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α], OrderRingIso.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2 _inst_3 _inst_3
Case conversion may be inaccurate. Consider using '#align order_ring_iso.refl OrderRingIso.reflₓ'. -/
/-- The identity map as an ordered ring isomorphism. -/
@[refl]
protected def refl : α ≃+*o α :=
  ⟨RingEquiv.refl α, fun _ _ => Iff.rfl⟩
#align order_ring_iso.refl OrderRingIso.refl

instance : Inhabited (α ≃+*o α) :=
  ⟨OrderRingIso.refl α⟩

#print OrderRingIso.refl_apply /-
@[simp]
theorem refl_apply (x : α) : OrderRingIso.refl α x = x :=
  rfl
#align order_ring_iso.refl_apply OrderRingIso.refl_apply
-/

/- warning: order_ring_iso.coe_ring_equiv_refl -> OrderRingIso.coe_ringEquiv_refl is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α], Eq.{succ u1} (RingEquiv.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) (RingEquiv.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (HasLiftT.mk.{succ u1, succ u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) (RingEquiv.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) (RingEquiv.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (RingEquiv.hasCoeT.{u1, u1, u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingIsoClass.toRingEquivClass.{u1, u1, u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3 (OrderRingIso.orderRingIsoClass.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3))))) (OrderRingIso.refl.{u1} α _inst_1 _inst_2 _inst_3)) (RingEquiv.refl.{u1} α _inst_1 _inst_2)
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α], Eq.{succ u1} (RingEquiv.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2) (RingEquivClass.toRingEquiv.{u1, u1, u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2 _inst_3 _inst_3) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingIsoClass.toRingEquivClass.{u1, u1, u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2 _inst_3 _inst_3) α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3)) (OrderRingIso.refl.{u1} α _inst_1 _inst_2 _inst_3)) (RingEquiv.refl.{u1} α _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.coe_ring_equiv_refl OrderRingIso.coe_ringEquiv_reflₓ'. -/
@[simp]
theorem coe_ringEquiv_refl : (OrderRingIso.refl α : α ≃+* α) = RingEquiv.refl α :=
  rfl
#align order_ring_iso.coe_ring_equiv_refl OrderRingIso.coe_ringEquiv_refl

/- warning: order_ring_iso.coe_order_iso_refl -> OrderRingIso.coe_orderIso_refl is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α], Eq.{succ u1} (OrderIso.{u1, u1} α α _inst_3 _inst_3) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) (OrderIso.{u1, u1} α α _inst_3 _inst_3) (HasLiftT.mk.{succ u1, succ u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) (OrderIso.{u1, u1} α α _inst_3 _inst_3) (CoeTCₓ.coe.{succ u1, succ u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) (OrderIso.{u1, u1} α α _inst_3 _inst_3) (OrderIso.hasCoeT.{u1, u1, u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) α α _inst_3 _inst_3 (OrderRingIsoClass.toOrderIsoClass.{u1, u1, u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3 (OrderRingIso.orderRingIsoClass.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3))))) (OrderRingIso.refl.{u1} α _inst_1 _inst_2 _inst_3)) (OrderIso.refl.{u1} α _inst_3)
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α], Eq.{succ u1} (OrderIso.{u1, u1} α α _inst_3 _inst_3) (OrderIsoClass.toOrderIso.{u1, u1, u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2 _inst_3 _inst_3) α α _inst_3 _inst_3 (OrderRingIsoClass.toOrderIsoClass.{u1, u1, u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_1 _inst_2 _inst_2 _inst_3 _inst_3) α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3)) (OrderRingIso.refl.{u1} α _inst_1 _inst_2 _inst_3)) (OrderIso.refl.{u1} α _inst_3)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.coe_order_iso_refl OrderRingIso.coe_orderIso_reflₓ'. -/
@[simp]
theorem coe_orderIso_refl : (OrderRingIso.refl α : α ≃o α) = OrderIso.refl α :=
  rfl
#align order_ring_iso.coe_order_iso_refl OrderRingIso.coe_orderIso_refl

variable {α}

/- warning: order_ring_iso.symm -> OrderRingIso.symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β], (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) -> (OrderRingIso.{u2, u1} β α _inst_4 _inst_5 _inst_6 _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β], (OrderRingIso.{u1, u2} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) -> (OrderRingIso.{u2, u1} β α _inst_4 _inst_1 _inst_5 _inst_2 _inst_6 _inst_3)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.symm OrderRingIso.symmₓ'. -/
/-- The inverse of an ordered ring isomorphism as an ordered ring isomorphism. -/
@[symm]
protected def symm (e : α ≃+*o β) : β ≃+*o α :=
  ⟨e.toRingEquiv.symm, fun a b => by
    erw [← map_le_map_iff e, e.1.apply_symm_apply, e.1.apply_symm_apply]⟩
#align order_ring_iso.symm OrderRingIso.symm

/- warning: order_ring_iso.simps.symm_apply -> OrderRingIso.Simps.symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β], (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) -> β -> α
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β], (OrderRingIso.{u1, u2} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) -> β -> α
Case conversion may be inaccurate. Consider using '#align order_ring_iso.simps.symm_apply OrderRingIso.Simps.symm_applyₓ'. -/
/-- See Note [custom simps projection] -/
def Simps.symm_apply (e : α ≃+*o β) : β → α :=
  e.symm
#align order_ring_iso.simps.symm_apply OrderRingIso.Simps.symm_apply

/- warning: order_ring_iso.symm_symm -> OrderRingIso.symm_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] (e : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6), Eq.{max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (OrderRingIso.symm.{u2, u1} β α _inst_4 _inst_5 _inst_6 _inst_1 _inst_2 _inst_3 (OrderRingIso.symm.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e)) e
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] (e : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6), Eq.{max (succ u2) (succ u1)} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) (OrderRingIso.symm.{u1, u2} β α _inst_4 _inst_5 _inst_6 _inst_1 _inst_2 _inst_3 (OrderRingIso.symm.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e)) e
Case conversion may be inaccurate. Consider using '#align order_ring_iso.symm_symm OrderRingIso.symm_symmₓ'. -/
@[simp]
theorem symm_symm (e : α ≃+*o β) : e.symm.symm = e :=
  ext fun _ => rfl
#align order_ring_iso.symm_symm OrderRingIso.symm_symm

/- warning: order_ring_iso.trans -> OrderRingIso.trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] [_inst_7 : Mul.{u3} γ] [_inst_8 : Add.{u3} γ] [_inst_9 : LE.{u3} γ], (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) -> (OrderRingIso.{u2, u3} β γ _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9) -> (OrderRingIso.{u1, u3} α γ _inst_1 _inst_2 _inst_3 _inst_7 _inst_8 _inst_9)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] [_inst_7 : Mul.{u3} γ] [_inst_8 : Add.{u3} γ] [_inst_9 : LE.{u3} γ], (OrderRingIso.{u1, u2} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) -> (OrderRingIso.{u2, u3} β γ _inst_4 _inst_7 _inst_5 _inst_8 _inst_6 _inst_9) -> (OrderRingIso.{u1, u3} α γ _inst_1 _inst_7 _inst_2 _inst_8 _inst_3 _inst_9)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.trans OrderRingIso.transₓ'. -/
/-- Composition of `order_ring_iso`s as an `order_ring_iso`. -/
@[trans, simps]
protected def trans (f : α ≃+*o β) (g : β ≃+*o γ) : α ≃+*o γ :=
  ⟨f.toRingEquiv.trans g.toRingEquiv, fun a b => (map_le_map_iff g).trans (map_le_map_iff f)⟩
#align order_ring_iso.trans OrderRingIso.trans

/- warning: order_ring_iso.trans_apply -> OrderRingIso.trans_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] [_inst_7 : Mul.{u3} γ] [_inst_8 : Add.{u3} γ] [_inst_9 : LE.{u3} γ] (f : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (g : OrderRingIso.{u2, u3} β γ _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9) (a : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (OrderRingIso.{u1, u3} α γ _inst_1 _inst_2 _inst_3 _inst_7 _inst_8 _inst_9) (fun (_x : OrderRingIso.{u1, u3} α γ _inst_1 _inst_2 _inst_3 _inst_7 _inst_8 _inst_9) => α -> γ) (OrderRingIso.hasCoeToFun.{u1, u3} α γ _inst_1 _inst_2 _inst_3 _inst_7 _inst_8 _inst_9) (OrderRingIso.trans.{u1, u2, u3} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 f g) a) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (OrderRingIso.{u2, u3} β γ _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9) (fun (_x : OrderRingIso.{u2, u3} β γ _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9) => β -> γ) (OrderRingIso.hasCoeToFun.{u2, u3} β γ _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (fun (_x : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) => α -> β) (OrderRingIso.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) f a))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [_inst_1 : Mul.{u3} α] [_inst_2 : Add.{u3} α] [_inst_3 : LE.{u3} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] [_inst_7 : Mul.{u1} γ] [_inst_8 : Add.{u1} γ] [_inst_9 : LE.{u1} γ] (f : OrderRingIso.{u3, u2} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) (g : OrderRingIso.{u2, u1} β γ _inst_4 _inst_7 _inst_5 _inst_8 _inst_6 _inst_9) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => γ) a) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (OrderRingIso.{u3, u1} α γ _inst_1 _inst_7 _inst_2 _inst_8 _inst_3 _inst_9) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => γ) _x) (RelHomClass.toFunLike.{max u3 u1, u3, u1} (OrderRingIso.{u3, u1} α γ _inst_1 _inst_7 _inst_2 _inst_8 _inst_3 _inst_9) α γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u3} α _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : γ) => LE.le.{u1} γ _inst_9 x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderIsoClass.toOrderHomClass.{max u3 u1, u3, u1} (OrderRingIso.{u3, u1} α γ _inst_1 _inst_7 _inst_2 _inst_8 _inst_3 _inst_9) α γ _inst_3 _inst_9 (OrderRingIsoClass.toOrderIsoClass.{max u3 u1, u3, u1} (OrderRingIso.{u3, u1} α γ _inst_1 _inst_7 _inst_2 _inst_8 _inst_3 _inst_9) α γ _inst_1 _inst_2 _inst_3 _inst_7 _inst_8 _inst_9 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u3, u1} α γ _inst_1 _inst_2 _inst_3 _inst_7 _inst_8 _inst_9)))) (OrderRingIso.trans.{u3, u2, u1} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 f g) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingIso.{u2, u1} β γ _inst_4 _inst_7 _inst_5 _inst_8 _inst_6 _inst_9) β (fun (_x : β) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : β) => γ) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} β γ _inst_4 _inst_7 _inst_5 _inst_8 _inst_6 _inst_9) β γ (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : β) => LE.le.{u2} β _inst_6 x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : γ) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : γ) => LE.le.{u1} γ _inst_9 x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderIsoClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} β γ _inst_4 _inst_7 _inst_5 _inst_8 _inst_6 _inst_9) β γ _inst_6 _inst_9 (OrderRingIsoClass.toOrderIsoClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} β γ _inst_4 _inst_7 _inst_5 _inst_8 _inst_6 _inst_9) β γ _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} β γ _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9)))) g (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (OrderRingIso.{u3, u2} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u3 u2, u3, u2} (OrderRingIso.{u3, u2} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u3} α _inst_3 x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u2} β _inst_6 x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderIsoClass.toOrderHomClass.{max u3 u2, u3, u2} (OrderRingIso.{u3, u2} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_3 _inst_6 (OrderRingIsoClass.toOrderIsoClass.{max u3 u2, u3, u2} (OrderRingIso.{u3, u2} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u3, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) f a))
Case conversion may be inaccurate. Consider using '#align order_ring_iso.trans_apply OrderRingIso.trans_applyₓ'. -/
@[simp]
theorem trans_apply (f : α ≃+*o β) (g : β ≃+*o γ) (a : α) : f.trans g a = g (f a) :=
  rfl
#align order_ring_iso.trans_apply OrderRingIso.trans_apply

/- warning: order_ring_iso.self_trans_symm -> OrderRingIso.self_trans_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] (e : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6), Eq.{succ u1} (OrderRingIso.{u1, u1} α α _inst_1 _inst_2 _inst_3 _inst_1 _inst_2 _inst_3) (OrderRingIso.trans.{u1, u2, u1} α β α _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_1 _inst_2 _inst_3 e (OrderRingIso.symm.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e)) (OrderRingIso.refl.{u1} α _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] (e : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6), Eq.{succ u2} (OrderRingIso.{u2, u2} α α _inst_1 _inst_1 _inst_2 _inst_2 _inst_3 _inst_3) (OrderRingIso.trans.{u2, u1, u2} α β α _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_1 _inst_2 _inst_3 e (OrderRingIso.symm.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e)) (OrderRingIso.refl.{u2} α _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.self_trans_symm OrderRingIso.self_trans_symmₓ'. -/
@[simp]
theorem self_trans_symm (e : α ≃+*o β) : e.trans e.symm = OrderRingIso.refl α :=
  ext e.left_inv
#align order_ring_iso.self_trans_symm OrderRingIso.self_trans_symm

/- warning: order_ring_iso.symm_trans_self -> OrderRingIso.symm_trans_self is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β] (e : OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6), Eq.{succ u2} (OrderRingIso.{u2, u2} β β _inst_4 _inst_5 _inst_6 _inst_4 _inst_5 _inst_6) (OrderRingIso.trans.{u2, u1, u2} β α β _inst_4 _inst_5 _inst_6 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.symm.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e) e) (OrderRingIso.refl.{u2} β _inst_4 _inst_5 _inst_6)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β] (e : OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6), Eq.{succ u1} (OrderRingIso.{u1, u1} β β _inst_4 _inst_4 _inst_5 _inst_5 _inst_6 _inst_6) (OrderRingIso.trans.{u1, u2, u1} β α β _inst_4 _inst_5 _inst_6 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (OrderRingIso.symm.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 e) e) (OrderRingIso.refl.{u1} β _inst_4 _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.symm_trans_self OrderRingIso.symm_trans_selfₓ'. -/
@[simp]
theorem symm_trans_self (e : α ≃+*o β) : e.symm.trans e = OrderRingIso.refl β :=
  ext e.right_inv
#align order_ring_iso.symm_trans_self OrderRingIso.symm_trans_self

/- warning: order_ring_iso.symm_bijective -> OrderRingIso.symm_bijective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Mul.{u1} α] [_inst_2 : Add.{u1} α] [_inst_3 : LE.{u1} α] [_inst_4 : Mul.{u2} β] [_inst_5 : Add.{u2} β] [_inst_6 : LE.{u2} β], Function.Bijective.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (OrderRingIso.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) (OrderRingIso.{u2, u1} β α _inst_4 _inst_5 _inst_6 _inst_1 _inst_2 _inst_3) (OrderRingIso.symm.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Mul.{u2} α] [_inst_2 : Add.{u2} α] [_inst_3 : LE.{u2} α] [_inst_4 : Mul.{u1} β] [_inst_5 : Add.{u1} β] [_inst_6 : LE.{u1} β], Function.Bijective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderRingIso.{u2, u1} α β _inst_1 _inst_4 _inst_2 _inst_5 _inst_3 _inst_6) (OrderRingIso.{u1, u2} β α _inst_4 _inst_1 _inst_5 _inst_2 _inst_6 _inst_3) (OrderRingIso.symm.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.symm_bijective OrderRingIso.symm_bijectiveₓ'. -/
theorem symm_bijective : Bijective (OrderRingIso.symm : α ≃+*o β → β ≃+*o α) :=
  ⟨fun f g h => f.symm_symm.symm.trans <| (congr_arg OrderRingIso.symm h).trans g.symm_symm,
    fun f => ⟨f.symm, f.symm_symm⟩⟩
#align order_ring_iso.symm_bijective OrderRingIso.symm_bijective

end LE

section NonAssocSemiring

variable [NonAssocSemiring α] [Preorder α] [NonAssocSemiring β] [Preorder β] [NonAssocSemiring γ]
  [Preorder γ]

/- warning: order_ring_iso.to_order_ring_hom -> OrderRingIso.toOrderRingHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β], (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) -> (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β], (OrderRingIso.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3)) (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u1} α _inst_2) (Preorder.toLE.{u2} β _inst_4)) -> (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.to_order_ring_hom OrderRingIso.toOrderRingHomₓ'. -/
/-- Reinterpret an ordered ring isomorphism as an ordered ring homomorphism. -/
def toOrderRingHom (f : α ≃+*o β) : α →+*o β :=
  ⟨f.toRingEquiv.toRingHom, fun a b => (map_le_map_iff f).2⟩
#align order_ring_iso.to_order_ring_hom OrderRingIso.toOrderRingHom

/- warning: order_ring_iso.to_order_ring_hom_eq_coe -> OrderRingIso.toOrderRingHom_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)), Eq.{max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingIso.toOrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4 f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingIsoClass.toOrderRingHomClass.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingIso.orderRingIsoClass.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)))))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)), Eq.{max (succ u2) (succ u1)} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingIso.toOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4 f) (OrderRingHomClass.toOrderRingHom.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingIsoClass.toOrderRingHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Preorder.toLE.{u2} α _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u1} β _inst_4))) f)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.to_order_ring_hom_eq_coe OrderRingIso.toOrderRingHom_eq_coeₓ'. -/
@[simp]
theorem toOrderRingHom_eq_coe (f : α ≃+*o β) : f.toOrderRingHom = f :=
  rfl
#align order_ring_iso.to_order_ring_hom_eq_coe OrderRingIso.toOrderRingHom_eq_coe

/- warning: order_ring_iso.coe_to_order_ring_hom -> OrderRingIso.coe_toOrderRingHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β] (f : OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) => α -> β) (OrderRingHom.hasCoeToFun.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u1) (succ u2)} a b] => self.0) (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingHom.hasCoeT.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingIsoClass.toOrderRingHomClass.{max u1 u2, u1, u2} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingIso.orderRingIsoClass.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)))))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) (fun (_x : OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) => α -> β) (OrderRingIso.hasCoeToFun.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β] (f : OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingHom.instOrderRingHomClassOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)))) (OrderRingHomClass.toOrderRingHom.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingIsoClass.toOrderRingHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Preorder.toLE.{u2} α _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u1} β _inst_4))) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)) α (fun (_x : α) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : α) => β) _x) (RelHomClass.toFunLike.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)) α β (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1896 : α) (x._@.Mathlib.Order.Hom.Basic._hyg.1898 : α) => LE.le.{u2} α (Preorder.toLE.{u2} α _inst_2) x._@.Mathlib.Order.Hom.Basic._hyg.1896 x._@.Mathlib.Order.Hom.Basic._hyg.1898) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.1918 : β) (x._@.Mathlib.Order.Hom.Basic._hyg.1920 : β) => LE.le.{u1} β (Preorder.toLE.{u1} β _inst_4) x._@.Mathlib.Order.Hom.Basic._hyg.1918 x._@.Mathlib.Order.Hom.Basic._hyg.1920) (OrderAddMonoidHomClass.toOrderHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)) α β _inst_2 _inst_4 (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β _inst_3)))) (OrderRingHomClass.toOrderAddMonoidHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingIsoClass.toOrderRingHomClass.{max u2 u1, u2, u1} (OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)) α β _inst_1 _inst_2 _inst_3 _inst_4 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Preorder.toLE.{u2} α _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u1} β _inst_4)))))) f)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.coe_to_order_ring_hom OrderRingIso.coe_toOrderRingHomₓ'. -/
@[simp, norm_cast]
theorem coe_toOrderRingHom (f : α ≃+*o β) : ⇑(f : α →+*o β) = f :=
  rfl
#align order_ring_iso.coe_to_order_ring_hom OrderRingIso.coe_toOrderRingHom

/- warning: order_ring_iso.coe_to_order_ring_hom_refl -> OrderRingIso.coe_toOrderRingHom_refl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α], Eq.{succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (OrderRingIso.{u1, u1} α α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2)) (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (HasLiftT.mk.{succ u1, succ u1} (OrderRingIso.{u1, u1} α α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2)) (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (CoeTCₓ.coe.{succ u1, succ u1} (OrderRingIso.{u1, u1} α α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2)) (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (OrderRingHom.hasCoeT.{u1, u1, u1} (OrderRingIso.{u1, u1} α α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2)) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingIsoClass.toOrderRingHomClass.{u1, u1, u1} (OrderRingIso.{u1, u1} α α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2)) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingIso.orderRingIsoClass.{u1, u1} α α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2)))))) (OrderRingIso.refl.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2))) (OrderRingHom.id.{u1} α _inst_1 _inst_2)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α], Eq.{succ u1} (OrderRingHom.{u1, u1} α α _inst_1 _inst_2 _inst_1 _inst_2) (OrderRingHomClass.toOrderRingHom.{u1, u1, u1} (OrderRingIso.{u1, u1} α α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Preorder.toLE.{u1} α _inst_2)) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingIsoClass.toOrderRingHomClass.{u1, u1, u1} (OrderRingIso.{u1, u1} α α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Preorder.toLE.{u1} α _inst_2)) α α _inst_1 _inst_2 _inst_1 _inst_2 (OrderRingIso.instOrderRingIsoClassOrderRingIso.{u1, u1} α α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2))) (OrderRingIso.refl.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2))) (OrderRingHom.id.{u1} α _inst_1 _inst_2)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.coe_to_order_ring_hom_refl OrderRingIso.coe_toOrderRingHom_reflₓ'. -/
@[simp]
theorem coe_toOrderRingHom_refl : (OrderRingIso.refl α : α →+*o α) = OrderRingHom.id α :=
  rfl
#align order_ring_iso.coe_to_order_ring_hom_refl OrderRingIso.coe_toOrderRingHom_refl

/- warning: order_ring_iso.to_order_ring_hom_injective -> OrderRingIso.toOrderRingHom_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : Preorder.{u1} α] [_inst_3 : NonAssocSemiring.{u2} β] [_inst_4 : Preorder.{u2} β], Function.Injective.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1))) (Preorder.toLE.{u1} α _inst_2) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β _inst_3))) (Preorder.toLE.{u2} β _inst_4)) (OrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingIso.toOrderRingHom.{u1, u2} α β _inst_1 _inst_2 _inst_3 _inst_4)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocSemiring.{u2} α] [_inst_2 : Preorder.{u2} α] [_inst_3 : NonAssocSemiring.{u1} β] [_inst_4 : Preorder.{u1} β], Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (OrderRingIso.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3)) (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_1))) (Distrib.toAdd.{u1} β (NonUnitalNonAssocSemiring.toDistrib.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β _inst_3))) (Preorder.toLE.{u2} α _inst_2) (Preorder.toLE.{u1} β _inst_4)) (OrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4) (OrderRingIso.toOrderRingHom.{u2, u1} α β _inst_1 _inst_2 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align order_ring_iso.to_order_ring_hom_injective OrderRingIso.toOrderRingHom_injectiveₓ'. -/
theorem toOrderRingHom_injective : Injective (toOrderRingHom : α ≃+*o β → α →+*o β) := fun f g h =>
  FunLike.coe_injective <| by convert FunLike.ext'_iff.1 h
#align order_ring_iso.to_order_ring_hom_injective OrderRingIso.toOrderRingHom_injective

end NonAssocSemiring

end OrderRingIso

/-!
### Uniqueness

There is at most one ordered ring homomorphism from a linear ordered field to an archimedean linear
ordered field. Reciprocally, such an ordered ring homomorphism exists when the codomain is further
conditionally complete.
-/


#print OrderRingHom.subsingleton /-
/-- There is at most one ordered ring homomorphism from a linear ordered field to an archimedean
linear ordered field. -/
instance OrderRingHom.subsingleton [LinearOrderedField α] [LinearOrderedField β] [Archimedean β] :
    Subsingleton (α →+*o β) :=
  ⟨fun f g => by
    ext x
    by_contra' h' : f x ≠ g x
    wlog h : f x < g x
    · exact this g f x (Ne.symm h') (h'.lt_or_lt.resolve_left h)
    obtain ⟨q, hf, hg⟩ := exists_rat_btwn h
    rw [← map_ratCast f] at hf
    rw [← map_ratCast g] at hg
    exact
      (lt_asymm ((OrderHomClass.mono g).reflect_lt hg) <|
          (OrderHomClass.mono f).reflect_lt hf).elim⟩
#align order_ring_hom.subsingleton OrderRingHom.subsingleton
-/

/- warning: order_ring_iso.subsingleton_right -> OrderRingIso.subsingleton_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : LinearOrderedField.{u2} β] [_inst_3 : Archimedean.{u2} β (OrderedSemiring.toOrderedAddCommMonoid.{u2} β (StrictOrderedSemiring.toOrderedSemiring.{u2} β (StrictOrderedRing.toStrictOrderedSemiring.{u2} β (LinearOrderedRing.toStrictOrderedRing.{u2} β (LinearOrderedCommRing.toLinearOrderedRing.{u2} β (LinearOrderedField.toLinearOrderedCommRing.{u2} β _inst_2))))))], Subsingleton.{max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))))) (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (StrictOrderedRing.toOrderedAddCommGroup.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))) (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β (LinearOrderedField.toField.{u2} β _inst_2))))) (Distrib.toHasAdd.{u2} β (Ring.toDistrib.{u2} β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β (LinearOrderedField.toField.{u2} β _inst_2))))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (OrderedAddCommGroup.toPartialOrder.{u2} β (StrictOrderedRing.toOrderedAddCommGroup.{u2} β (LinearOrderedRing.toStrictOrderedRing.{u2} β (LinearOrderedCommRing.toLinearOrderedRing.{u2} β (LinearOrderedField.toLinearOrderedCommRing.{u2} β _inst_2))))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : LinearOrderedField.{u2} β] [_inst_3 : Archimedean.{u2} β (OrderedSemiring.toOrderedAddCommMonoid.{u2} β (OrderedCommSemiring.toOrderedSemiring.{u2} β (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} β (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} β (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} β (LinearOrderedField.toLinearOrderedSemifield.{u2} β _inst_2))))))], Subsingleton.{max (succ u2) (succ u1)} (OrderRingIso.{u1, u2} α β (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))) (NonUnitalNonAssocRing.toMul.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β (LinearOrderedField.toField.{u2} β _inst_2)))))) (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (Distrib.toAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β (LinearOrderedField.toField.{u2} β _inst_2)))))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (StrictOrderedRing.toPartialOrder.{u2} β (LinearOrderedRing.toStrictOrderedRing.{u2} β (LinearOrderedCommRing.toLinearOrderedRing.{u2} β (LinearOrderedField.toLinearOrderedCommRing.{u2} β _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align order_ring_iso.subsingleton_right OrderRingIso.subsingleton_rightₓ'. -/
/-- There is at most one ordered ring isomorphism between a linear ordered field and an archimedean
linear ordered field. -/
instance OrderRingIso.subsingleton_right [LinearOrderedField α] [LinearOrderedField β]
    [Archimedean β] : Subsingleton (α ≃+*o β) :=
  OrderRingIso.toOrderRingHom_injective.Subsingleton
#align order_ring_iso.subsingleton_right OrderRingIso.subsingleton_right

/- warning: order_ring_iso.subsingleton_left -> OrderRingIso.subsingleton_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : Archimedean.{u1} α (OrderedSemiring.toOrderedAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedSemiring.{u1} α (StrictOrderedRing.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))] [_inst_3 : LinearOrderedField.{u2} β], Subsingleton.{max (succ u1) (succ u2)} (OrderRingIso.{u1, u2} α β (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))))) (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (OrderedAddCommGroup.toPartialOrder.{u1} α (StrictOrderedRing.toOrderedAddCommGroup.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1))))))) (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β (LinearOrderedField.toField.{u2} β _inst_3))))) (Distrib.toHasAdd.{u2} β (Ring.toDistrib.{u2} β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β (LinearOrderedField.toField.{u2} β _inst_3))))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (OrderedAddCommGroup.toPartialOrder.{u2} β (StrictOrderedRing.toOrderedAddCommGroup.{u2} β (LinearOrderedRing.toStrictOrderedRing.{u2} β (LinearOrderedCommRing.toLinearOrderedRing.{u2} β (LinearOrderedField.toLinearOrderedCommRing.{u2} β _inst_3))))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : LinearOrderedField.{u1} α] [_inst_2 : Archimedean.{u1} α (OrderedSemiring.toOrderedAddCommMonoid.{u1} α (OrderedCommSemiring.toOrderedSemiring.{u1} α (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} α (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} α (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} α (LinearOrderedField.toLinearOrderedSemifield.{u1} α _inst_1))))))] [_inst_3 : LinearOrderedField.{u2} β], Subsingleton.{max (succ u2) (succ u1)} (OrderRingIso.{u1, u2} α β (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))) (NonUnitalNonAssocRing.toMul.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β (LinearOrderedField.toField.{u2} β _inst_3)))))) (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α (Field.toDivisionRing.{u1} α (LinearOrderedField.toField.{u1} α _inst_1)))))))) (Distrib.toAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (DivisionRing.toRing.{u2} β (Field.toDivisionRing.{u2} β (LinearOrderedField.toField.{u2} β _inst_3)))))))) (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α (LinearOrderedCommRing.toLinearOrderedRing.{u1} α (LinearOrderedField.toLinearOrderedCommRing.{u1} α _inst_1)))))) (Preorder.toLE.{u2} β (PartialOrder.toPreorder.{u2} β (StrictOrderedRing.toPartialOrder.{u2} β (LinearOrderedRing.toStrictOrderedRing.{u2} β (LinearOrderedCommRing.toLinearOrderedRing.{u2} β (LinearOrderedField.toLinearOrderedCommRing.{u2} β _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align order_ring_iso.subsingleton_left OrderRingIso.subsingleton_leftₓ'. -/
/-- There is at most one ordered ring isomorphism between an archimedean linear ordered field and a
linear ordered field. -/
instance OrderRingIso.subsingleton_left [LinearOrderedField α] [Archimedean α]
    [LinearOrderedField β] : Subsingleton (α ≃+*o β) :=
  OrderRingIso.symm_bijective.Injective.Subsingleton
#align order_ring_iso.subsingleton_left OrderRingIso.subsingleton_left

