/-
Copyright (c) 2022 Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies
-/
import Mathbin.Algebra.Hom.Group

/-!
# Algebraic order homomorphism classes

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> https://github.com/leanprover-community/mathlib4/pull/627
> Any changes to this file require a corresponding PR to mathlib4.

This file defines hom classes for common properties at the intersection of order theory and algebra.

## Typeclasses

* `nonneg_hom_class`: Homs are nonnegative: `∀ f a, 0 ≤ f a`
* `subadditive_hom_class`: Homs are subadditive: `∀ f a b, f (a + b) ≤ f a + f b`
* `submultiplicative_hom_class`: Homs are submultiplicative: `∀ f a b, f (a * b) ≤ f a * f b`
* `mul_le_add_hom_class`: `∀ f a b, f (a * b) ≤ f a + f b`
* `nonarchimedean_hom_class`: `∀ a b, f (a + b) ≤ max (f a) (f b)`

## TODO

Finitary versions of the current lemmas.
-/


open Function

variable {ι F α β γ δ : Type _}

#print NonNegHomClass /-
/-- `nonneg_hom_class F α β` states that `F` is a type of nonnegative morphisms. -/
class NonNegHomClass (F : Type _) (α β : outParam <| Type _) [Zero β] [LE β] extends
  FunLike F α fun _ => β where
  map_nonneg (f : F) : ∀ a, 0 ≤ f a
#align nonneg_hom_class NonNegHomClass
-/

#print SubAdditiveHomClass /-
/-- `subadditive_hom_class F α β` states that `F` is a type of subadditive morphisms. -/
class SubAdditiveHomClass (F : Type _) (α β : outParam <| Type _) [Add α] [Add β] [LE β] extends
  FunLike F α fun _ => β where
  map_add_le_add (f : F) : ∀ a b, f (a + b) ≤ f a + f b
#align subadditive_hom_class SubAdditiveHomClass
-/

#print SubMultiplicativeHomClass /-
/-- `submultiplicative_hom_class F α β` states that `F` is a type of submultiplicative morphisms. -/
@[to_additive SubAdditiveHomClass]
class SubMultiplicativeHomClass (F : Type _) (α β : outParam <| Type _) [Mul α] [Mul β]
  [LE β] extends FunLike F α fun _ => β where
  map_mul_le_mul (f : F) : ∀ a b, f (a * b) ≤ f a * f b
#align submultiplicative_hom_class SubMultiplicativeHomClass
-/

#print MulLEAddHomClass /-
/-- `mul_le_add_hom_class F α β` states that `F` is a type of subadditive morphisms. -/
@[to_additive SubAdditiveHomClass]
class MulLEAddHomClass (F : Type _) (α β : outParam <| Type _) [Mul α] [Add β] [LE β] extends
  FunLike F α fun _ => β where
  map_mul_le_add (f : F) : ∀ a b, f (a * b) ≤ f a + f b
#align mul_le_add_hom_class MulLEAddHomClass
-/

#print NonArchimedeanHomClass /-
/-- `nonarchimedean_hom_class F α β` states that `F` is a type of non-archimedean morphisms. -/
class NonArchimedeanHomClass (F : Type _) (α β : outParam <| Type _) [Add α] [LinearOrder β] extends
  FunLike F α fun _ => β where
  map_add_le_max (f : F) : ∀ a b, f (a + b) ≤ max (f a) (f b)
#align nonarchimedean_hom_class NonArchimedeanHomClass
-/

export NonNegHomClass (map_nonneg)

export SubAdditiveHomClass (map_add_le_add)

export SubMultiplicativeHomClass (map_mul_le_mul)

export MulLEAddHomClass (map_mul_le_add)

export NonArchimedeanHomClass (map_add_le_max)

attribute [simp] map_nonneg

/- warning: le_map_mul_map_div -> le_map_mul_map_div is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u_2}} {α : Type.{u_3}} {β : Type.{u_4}} [_inst_1 : Group.{u_3} α] [_inst_2 : CommSemigroup.{u_4} β] [_inst_3 : LE.{u_4} β] [_inst_4 : SubMultiplicativeHomClass.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3] (f : F) (a : α) (b : α), LE.le.{u_4} β _inst_3 (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f a) (HMul.hMul.{u_4, u_4, u_4} β β β (instHMul.{u_4} β (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2))) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f b) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a b)))
but is expected to have type
  forall {F : Type.{u_3}} {α : Type.{u_1}} {β : Type.{u_2}} [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.351 : Group.{u_1} α] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.354 : CommSemigroup.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.357 : LE.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.360 : SubMultiplicativeHomClass.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.351)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.354)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.357] (f : F) (a : α) (b : α), LE.le.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) a) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.357 (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.351)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.354)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.357 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.360) f a) (HMul.hMul.{u_2, u_2, u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) b) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.351))) a b)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) b) (instHMul.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) b) (Semigroup.toMul.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) b) (CommSemigroup.toSemigroup.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) b) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.354))) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.351)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.354)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.357 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.360) f b) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.351)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.354)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.357 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.360) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.351))) a b)))
Case conversion may be inaccurate. Consider using '#align le_map_mul_map_div le_map_mul_map_divₓ'. -/
@[to_additive]
theorem le_map_mul_map_div [Group α] [CommSemigroup β] [LE β] [SubMultiplicativeHomClass F α β]
    (f : F) (a b : α) : f a ≤ f b * f (a / b) := by
  simpa only [mul_comm, div_mul_cancel'] using map_mul_le_mul f (a / b) b
#align le_map_mul_map_div le_map_mul_map_div

/- warning: le_map_add_map_div -> le_map_add_map_div is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u_2}} {α : Type.{u_3}} {β : Type.{u_4}} [_inst_1 : Group.{u_3} α] [_inst_2 : AddCommSemigroup.{u_4} β] [_inst_3 : LE.{u_4} β] [_inst_4 : MulLEAddHomClass.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3] (f : F) (a : α) (b : α), LE.le.{u_4} β _inst_3 (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f a) (HAdd.hAdd.{u_4, u_4, u_4} β β β (instHAdd.{u_4} β (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2))) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f b) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a b)))
but is expected to have type
  forall {F : Type.{u_3}} {α : Type.{u_1}} {β : Type.{u_2}} [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.431 : Group.{u_1} α] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.434 : AddCommSemigroup.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.437 : LE.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.440 : MulLEAddHomClass.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.431)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.434)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.437] (f : F) (a : α) (b : α), LE.le.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) a) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.437 (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.431)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.434)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.437 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.440) f a) (HAdd.hAdd.{u_2, u_2, u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) b) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.431))) a b)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) b) (instHAdd.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) b) (AddSemigroup.toAdd.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) b) (AddCommSemigroup.toAddSemigroup.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) b) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.434))) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.431)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.434)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.437 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.440) f b) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.431)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.434)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.437 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.440) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.431))) a b)))
Case conversion may be inaccurate. Consider using '#align le_map_add_map_div le_map_add_map_divₓ'. -/
@[to_additive]
theorem le_map_add_map_div [Group α] [AddCommSemigroup β] [LE β] [MulLEAddHomClass F α β] (f : F)
    (a b : α) : f a ≤ f b + f (a / b) := by
  simpa only [add_comm, div_mul_cancel'] using map_mul_le_add f (a / b) b
#align le_map_add_map_div le_map_add_map_div

/- warning: le_map_div_mul_map_div -> le_map_div_mul_map_div is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u_2}} {α : Type.{u_3}} {β : Type.{u_4}} [_inst_1 : Group.{u_3} α] [_inst_2 : CommSemigroup.{u_4} β] [_inst_3 : LE.{u_4} β] [_inst_4 : SubMultiplicativeHomClass.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3] (f : F) (a : α) (b : α) (c : α), LE.le.{u_4} β _inst_3 (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a c)) (HMul.hMul.{u_4, u_4, u_4} β β β (instHMul.{u_4} β (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2))) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a b)) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) b c)))
but is expected to have type
  forall {F : Type.{u_3}} {α : Type.{u_1}} {β : Type.{u_2}} [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511 : Group.{u_1} α] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.514 : CommSemigroup.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.517 : LE.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.520 : SubMultiplicativeHomClass.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.514)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.517] (f : F) (a : α) (b : α) (c : α), LE.le.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511))) a c)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.517 (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.514)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.517 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.520) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511))) a c)) (HMul.hMul.{u_2, u_2, u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511))) a b)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511))) b c)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511))) a b)) (instHMul.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511))) a b)) (Semigroup.toMul.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511))) a b)) (CommSemigroup.toSemigroup.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511))) a b)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.514))) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.514)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.517 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.520) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511))) a b)) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.167 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.514)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.517 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.520) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.511))) b c)))
Case conversion may be inaccurate. Consider using '#align le_map_div_mul_map_div le_map_div_mul_map_divₓ'. -/
@[to_additive]
theorem le_map_div_mul_map_div [Group α] [CommSemigroup β] [LE β] [SubMultiplicativeHomClass F α β]
    (f : F) (a b c : α) : f (a / c) ≤ f (a / b) * f (b / c) := by
  simpa only [div_mul_div_cancel'] using map_mul_le_mul f (a / b) (b / c)
#align le_map_div_mul_map_div le_map_div_mul_map_div

/- warning: le_map_div_add_map_div -> le_map_div_add_map_div is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u_2}} {α : Type.{u_3}} {β : Type.{u_4}} [_inst_1 : Group.{u_3} α] [_inst_2 : AddCommSemigroup.{u_4} β] [_inst_3 : LE.{u_4} β] [_inst_4 : MulLEAddHomClass.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3] (f : F) (a : α) (b : α) (c : α), LE.le.{u_4} β _inst_3 (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a c)) (HAdd.hAdd.{u_4, u_4, u_4} β β β (instHAdd.{u_4} β (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2))) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a b)) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) b c)))
but is expected to have type
  forall {F : Type.{u_3}} {α : Type.{u_1}} {β : Type.{u_2}} [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610 : Group.{u_1} α] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.613 : AddCommSemigroup.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.616 : LE.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.619 : MulLEAddHomClass.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.613)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.616] (f : F) (a : α) (b : α) (c : α), LE.le.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610))) a c)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.616 (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.613)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.616 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.619) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610))) a c)) (HAdd.hAdd.{u_2, u_2, u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610))) a b)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610))) b c)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610))) a b)) (instHAdd.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610))) a b)) (AddSemigroup.toAdd.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610))) a b)) (AddCommSemigroup.toAddSemigroup.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610))) a b)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.613))) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.613)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.616 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.619) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610))) a b)) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.238 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.613)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.616 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.619) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.610))) b c)))
Case conversion may be inaccurate. Consider using '#align le_map_div_add_map_div le_map_div_add_map_divₓ'. -/
@[to_additive]
theorem le_map_div_add_map_div [Group α] [AddCommSemigroup β] [LE β] [MulLEAddHomClass F α β]
    (f : F) (a b c : α) : f (a / c) ≤ f (a / b) + f (b / c) := by
  simpa only [div_mul_div_cancel'] using map_mul_le_add f (a / b) (b / c)
#align le_map_div_add_map_div le_map_div_add_map_div

