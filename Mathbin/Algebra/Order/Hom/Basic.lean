/-
Copyright (c) 2022 Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies
-/
import Mathbin.Tactic.Positivity

/-!
# Algebraic order homomorphism classes

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> https://github.com/leanprover-community/mathlib4/pull/627
> Any changes to this file require a corresponding PR to mathlib4.

This file defines hom classes for common properties at the intersection of order theory and algebra.

## Typeclasses

* `nonneg_hom_class`: Homs are nonnegative: `∀ f a, 0 ≤ f a`
* `subadditive_hom_class`: Homs are subadditive: `∀ f a b, f (a + b) ≤ f a + f b`
* `submultiplicative_hom_class`: Homs are submultiplicative: `∀ f a b, f (a * b) ≤ f a * f b`
* `mul_le_add_hom_class`: `∀ f a b, f (a * b) ≤ f a + f b`
* `nonarchimedean_hom_class`: `∀ a b, f (a + b) ≤ max (f a) (f b)`

## TODO

Finitary versions of the current lemmas.
-/


open Function

variable {ι F α β γ δ : Type _}

#print NonNegHomClass /-
/-- `nonneg_hom_class F α β` states that `F` is a type of nonnegative morphisms. -/
class NonNegHomClass (F : Type _) (α β : outParam <| Type _) [Zero β] [LE β] extends
  FunLike F α fun _ => β where
  map_nonneg (f : F) : ∀ a, 0 ≤ f a
#align nonneg_hom_class NonNegHomClass
-/

#print SubAdditiveHomClass /-
/-- `subadditive_hom_class F α β` states that `F` is a type of subadditive morphisms. -/
class SubAdditiveHomClass (F : Type _) (α β : outParam <| Type _) [Add α] [Add β] [LE β] extends
  FunLike F α fun _ => β where
  map_add_le_add (f : F) : ∀ a b, f (a + b) ≤ f a + f b
#align subadditive_hom_class SubAdditiveHomClass
-/

#print SubMultiplicativeHomClass /-
/-- `submultiplicative_hom_class F α β` states that `F` is a type of submultiplicative morphisms. -/
@[to_additive SubAdditiveHomClass]
class SubMultiplicativeHomClass (F : Type _) (α β : outParam <| Type _) [Mul α] [Mul β]
  [LE β] extends FunLike F α fun _ => β where
  map_mul_le_mul (f : F) : ∀ a b, f (a * b) ≤ f a * f b
#align submultiplicative_hom_class SubMultiplicativeHomClass
-/

#print MulLEAddHomClass /-
/-- `mul_le_add_hom_class F α β` states that `F` is a type of subadditive morphisms. -/
@[to_additive SubAdditiveHomClass]
class MulLEAddHomClass (F : Type _) (α β : outParam <| Type _) [Mul α] [Add β] [LE β] extends
  FunLike F α fun _ => β where
  map_mul_le_add (f : F) : ∀ a b, f (a * b) ≤ f a + f b
#align mul_le_add_hom_class MulLEAddHomClass
-/

#print NonArchimedeanHomClass /-
/-- `nonarchimedean_hom_class F α β` states that `F` is a type of non-archimedean morphisms. -/
class NonArchimedeanHomClass (F : Type _) (α β : outParam <| Type _) [Add α] [LinearOrder β] extends
  FunLike F α fun _ => β where
  map_add_le_max (f : F) : ∀ a b, f (a + b) ≤ max (f a) (f b)
#align nonarchimedean_hom_class NonArchimedeanHomClass
-/

export NonNegHomClass (map_nonneg)

export SubAdditiveHomClass (map_add_le_add)

export SubMultiplicativeHomClass (map_mul_le_mul)

export MulLEAddHomClass (map_mul_le_add)

export NonArchimedeanHomClass (map_add_le_max)

attribute [simp] map_nonneg

/- warning: le_map_mul_map_div -> le_map_mul_map_div is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u_2}} {α : Type.{u_3}} {β : Type.{u_4}} [_inst_1 : Group.{u_3} α] [_inst_2 : CommSemigroup.{u_4} β] [_inst_3 : LE.{u_4} β] [_inst_4 : SubMultiplicativeHomClass.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3] (f : F) (a : α) (b : α), LE.le.{u_4} β _inst_3 (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f a) (HMul.hMul.{u_4, u_4, u_4} β β β (instHMul.{u_4} β (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2))) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f b) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a b)))
but is expected to have type
  forall {F : Type.{u_3}} {α : Type.{u_1}} {β : Type.{u_2}} [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.366 : Group.{u_1} α] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.369 : CommSemigroup.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.372 : LE.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.375 : SubMultiplicativeHomClass.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.366)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.369)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.372] (f : F) (a : α) (b : α), LE.le.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) a) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.372 (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.366)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.369)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.372 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.375) f a) (HMul.hMul.{u_2, u_2, u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) b) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.366))) a b)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) b) (instHMul.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) b) (Semigroup.toMul.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) b) (CommSemigroup.toSemigroup.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) b) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.369))) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.366)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.369)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.372 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.375) f b) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.366)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.369)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.372 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.375) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.366))) a b)))
Case conversion may be inaccurate. Consider using '#align le_map_mul_map_div le_map_mul_map_divₓ'. -/
@[to_additive]
theorem le_map_mul_map_div [Group α] [CommSemigroup β] [LE β] [SubMultiplicativeHomClass F α β]
    (f : F) (a b : α) : f a ≤ f b * f (a / b) := by
  simpa only [mul_comm, div_mul_cancel'] using map_mul_le_mul f (a / b) b
#align le_map_mul_map_div le_map_mul_map_div

/- warning: le_map_add_map_div -> le_map_add_map_div is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u_2}} {α : Type.{u_3}} {β : Type.{u_4}} [_inst_1 : Group.{u_3} α] [_inst_2 : AddCommSemigroup.{u_4} β] [_inst_3 : LE.{u_4} β] [_inst_4 : MulLEAddHomClass.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3] (f : F) (a : α) (b : α), LE.le.{u_4} β _inst_3 (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f a) (HAdd.hAdd.{u_4, u_4, u_4} β β β (instHAdd.{u_4} β (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2))) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f b) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a b)))
but is expected to have type
  forall {F : Type.{u_3}} {α : Type.{u_1}} {β : Type.{u_2}} [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.446 : Group.{u_1} α] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.449 : AddCommSemigroup.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.452 : LE.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.455 : MulLEAddHomClass.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.446)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.449)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.452] (f : F) (a : α) (b : α), LE.le.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) a) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.452 (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.446)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.449)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.452 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.455) f a) (HAdd.hAdd.{u_2, u_2, u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) b) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.446))) a b)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) b) (instHAdd.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) b) (AddSemigroup.toAdd.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) b) (AddCommSemigroup.toAddSemigroup.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) b) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.449))) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.446)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.449)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.452 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.455) f b) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.446)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.449)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.452 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.455) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.446))) a b)))
Case conversion may be inaccurate. Consider using '#align le_map_add_map_div le_map_add_map_divₓ'. -/
@[to_additive]
theorem le_map_add_map_div [Group α] [AddCommSemigroup β] [LE β] [MulLEAddHomClass F α β] (f : F)
    (a b : α) : f a ≤ f b + f (a / b) := by
  simpa only [add_comm, div_mul_cancel'] using map_mul_le_add f (a / b) b
#align le_map_add_map_div le_map_add_map_div

/- warning: le_map_div_mul_map_div -> le_map_div_mul_map_div is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u_2}} {α : Type.{u_3}} {β : Type.{u_4}} [_inst_1 : Group.{u_3} α] [_inst_2 : CommSemigroup.{u_4} β] [_inst_3 : LE.{u_4} β] [_inst_4 : SubMultiplicativeHomClass.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3] (f : F) (a : α) (b : α) (c : α), LE.le.{u_4} β _inst_3 (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a c)) (HMul.hMul.{u_4, u_4, u_4} β β β (instHMul.{u_4} β (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2))) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a b)) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (SubMultiplicativeHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (Semigroup.toHasMul.{u_4} β (CommSemigroup.toSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) b c)))
but is expected to have type
  forall {F : Type.{u_3}} {α : Type.{u_1}} {β : Type.{u_2}} [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526 : Group.{u_1} α] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.529 : CommSemigroup.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.532 : LE.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.535 : SubMultiplicativeHomClass.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.529)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.532] (f : F) (a : α) (b : α) (c : α), LE.le.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526))) a c)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.532 (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.529)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.532 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.535) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526))) a c)) (HMul.hMul.{u_2, u_2, u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526))) a b)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526))) b c)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526))) a b)) (instHMul.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526))) a b)) (Semigroup.toMul.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526))) a b)) (CommSemigroup.toSemigroup.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526))) a b)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.529))) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.529)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.532 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.535) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526))) a b)) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.182 : α) => β) a) (SubMultiplicativeHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526)))) (Semigroup.toMul.{u_2} β (CommSemigroup.toSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.529)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.532 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.535) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.526))) b c)))
Case conversion may be inaccurate. Consider using '#align le_map_div_mul_map_div le_map_div_mul_map_divₓ'. -/
@[to_additive]
theorem le_map_div_mul_map_div [Group α] [CommSemigroup β] [LE β] [SubMultiplicativeHomClass F α β]
    (f : F) (a b c : α) : f (a / c) ≤ f (a / b) * f (b / c) := by
  simpa only [div_mul_div_cancel'] using map_mul_le_mul f (a / b) (b / c)
#align le_map_div_mul_map_div le_map_div_mul_map_div

/- warning: le_map_div_add_map_div -> le_map_div_add_map_div is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u_2}} {α : Type.{u_3}} {β : Type.{u_4}} [_inst_1 : Group.{u_3} α] [_inst_2 : AddCommSemigroup.{u_4} β] [_inst_3 : LE.{u_4} β] [_inst_4 : MulLEAddHomClass.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3] (f : F) (a : α) (b : α) (c : α), LE.le.{u_4} β _inst_3 (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a c)) (HAdd.hAdd.{u_4, u_4, u_4} β β β (instHAdd.{u_4} β (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2))) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) a b)) (coeFn.{succ u_2, max (succ u_3) (succ u_4)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_2, succ u_3, succ u_4} F α (fun (_x : α) => β) (MulLEAddHomClass.toFunLike.{u_2, u_3, u_4} F α β (MulOneClass.toHasMul.{u_3} α (Monoid.toMulOneClass.{u_3} α (DivInvMonoid.toMonoid.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1)))) (AddSemigroup.toHasAdd.{u_4} β (AddCommSemigroup.toAddSemigroup.{u_4} β _inst_2)) _inst_3 _inst_4)) f (HDiv.hDiv.{u_3, u_3, u_3} α α α (instHDiv.{u_3} α (DivInvMonoid.toHasDiv.{u_3} α (Group.toDivInvMonoid.{u_3} α _inst_1))) b c)))
but is expected to have type
  forall {F : Type.{u_3}} {α : Type.{u_1}} {β : Type.{u_2}} [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625 : Group.{u_1} α] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.628 : AddCommSemigroup.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.631 : LE.{u_2} β] [inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.634 : MulLEAddHomClass.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.628)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.631] (f : F) (a : α) (b : α) (c : α), LE.le.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625))) a c)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.631 (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.628)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.631 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.634) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625))) a c)) (HAdd.hAdd.{u_2, u_2, u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625))) a b)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625))) b c)) ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625))) a b)) (instHAdd.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625))) a b)) (AddSemigroup.toAdd.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625))) a b)) (AddCommSemigroup.toAddSemigroup.{u_2} ((fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625))) a b)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.628))) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.628)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.631 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.634) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625))) a b)) (FunLike.coe.{succ u_3, succ u_1, succ u_2} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Order.Hom.Basic._hyg.253 : α) => β) a) (MulLEAddHomClass.toFunLike.{u_3, u_1, u_2} F α β (MulOneClass.toMul.{u_1} α (Monoid.toMulOneClass.{u_1} α (DivInvMonoid.toMonoid.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625)))) (AddSemigroup.toAdd.{u_2} β (AddCommSemigroup.toAddSemigroup.{u_2} β inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.628)) inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.631 inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.634) f (HDiv.hDiv.{u_1, u_1, u_1} α α α (instHDiv.{u_1} α (DivInvMonoid.toDiv.{u_1} α (Group.toDivInvMonoid.{u_1} α inst._@.Mathlib.Algebra.Order.Hom.Basic._hyg.625))) b c)))
Case conversion may be inaccurate. Consider using '#align le_map_div_add_map_div le_map_div_add_map_divₓ'. -/
@[to_additive]
theorem le_map_div_add_map_div [Group α] [AddCommSemigroup β] [LE β] [MulLEAddHomClass F α β]
    (f : F) (a b c : α) : f (a / c) ≤ f (a / b) + f (b / c) := by
  simpa only [div_mul_div_cancel'] using map_mul_le_add f (a / b) (b / c)
#align le_map_div_add_map_div le_map_div_add_map_div

namespace Tactic

open Positivity

/-- Extension for the `positivity` tactic: nonnegative maps take nonnegative values. -/
@[positivity]
unsafe def positivity_map : expr → tactic strictness
  | expr.app q(⇑$(f)) q($(a)) => nonnegative <$> mk_app `` map_nonneg [f, a]
  | _ => failed
#align tactic.positivity_map tactic.positivity_map

end Tactic

