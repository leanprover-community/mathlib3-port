/-
Copyright (c) 2020 Frédéric Dupuis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Frédéric Dupuis

! This file was ported from Lean 3 source module algebra.order.smul
! leanprover-community/mathlib commit 1f0096e6caa61e9c849ec2adbd227e960e9dff58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Module.Pi
import Mathbin.Algebra.Module.Prod
import Mathbin.Algebra.Order.Monoid.Prod
import Mathbin.Algebra.Order.Pi
import Mathbin.Data.Set.Pointwise.Smul
import Mathbin.Tactic.Positivity

/-!
# Ordered scalar product

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define

* `ordered_smul R M` : an ordered additive commutative monoid `M` is an `ordered_smul`
  over an `ordered_semiring` `R` if the scalar product respects the order relation on the
  monoid and on the ring. There is a correspondence between this structure and convex cones,
  which is proven in `analysis/convex/cone.lean`.

## Implementation notes

* We choose to define `ordered_smul` as a `Prop`-valued mixin, so that it can be
  used for actions, modules, and algebras
  (the axioms for an "ordered algebra" are exactly that the algebra is ordered as a module).
* To get ordered modules and ordered vector spaces, it suffices to replace the
  `order_add_comm_monoid` and the `ordered_semiring` as desired.

## References

* https://en.wikipedia.org/wiki/Ordered_module

## Tags

ordered module, ordered scalar, ordered smul, ordered action, ordered vector space
-/


open Pointwise

/- warning: ordered_smul -> OrderedSMul is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))], Prop
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))], Prop
Case conversion may be inaccurate. Consider using '#align ordered_smul OrderedSMulₓ'. -/
/-- The ordered scalar product property is when an ordered additive commutative monoid
with a partial order has a scalar multiplication which is compatible with the order.
-/
@[protect_proj]
class OrderedSMul (R M : Type _) [OrderedSemiring R] [OrderedAddCommMonoid M] [SMulWithZero R M] :
  Prop where
  smul_lt_smul_of_pos : ∀ {a b : M}, ∀ {c : R}, a < b → 0 < c → c • a < c • b
  lt_of_smul_lt_smul_of_pos : ∀ {a b : M}, ∀ {c : R}, c • a < c • b → 0 < c → a < b
#align ordered_smul OrderedSMul

variable {ι 𝕜 R M N : Type _}

namespace OrderDual

instance [Zero R] [AddZeroClass M] [h : SMulWithZero R M] : SMulWithZero R Mᵒᵈ :=
  { instSMulOrderDual with
    zero_smul := fun m => OrderDual.rec (zero_smul _) m
    smul_zero := fun r => OrderDual.rec smul_zero r }

instance [Monoid R] [MulAction R M] : MulAction R Mᵒᵈ :=
  { instSMulOrderDual with
    one_smul := fun m => OrderDual.rec (one_smul _) m
    mul_smul := fun r => OrderDual.rec mul_smul r }

instance [MonoidWithZero R] [AddMonoid M] [MulActionWithZero R M] : MulActionWithZero R Mᵒᵈ :=
  { OrderDual.mulAction, OrderDual.smulWithZero with }

instance [MonoidWithZero R] [AddMonoid M] [DistribMulAction R M] : DistribMulAction R Mᵒᵈ
    where
  smul_add k a := OrderDual.rec (fun a' b => OrderDual.rec (smul_add _ _) b) a
  smul_zero r := OrderDual.rec (@smul_zero _ M _ _) r

instance [OrderedSemiring R] [OrderedAddCommMonoid M] [SMulWithZero R M] [OrderedSMul R M] :
    OrderedSMul R Mᵒᵈ
    where
  smul_lt_smul_of_pos a b := @OrderedSMul.smul_lt_smul_of_pos R M _ _ _ _ b a
  lt_of_smul_lt_smul_of_pos a b := @OrderedSMul.lt_of_smul_lt_smul_of_pos R M _ _ _ _ b a

end OrderDual

section OrderedSMul

variable [OrderedSemiring R] [OrderedAddCommMonoid M] [SMulWithZero R M] [OrderedSMul R M]
  {s : Set M} {a b : M} {c : R}

/- warning: smul_lt_smul_of_pos -> smul_lt_smul_of_pos is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {b : M} {c : R}, (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b) -> (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c a) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c b))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {b : M} {c : R}, (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b) -> (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) c) -> (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_3))) c a) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_3))) c b))
Case conversion may be inaccurate. Consider using '#align smul_lt_smul_of_pos smul_lt_smul_of_posₓ'. -/
theorem smul_lt_smul_of_pos : a < b → 0 < c → c • a < c • b :=
  OrderedSMul.smul_lt_smul_of_pos
#align smul_lt_smul_of_pos smul_lt_smul_of_pos

/- warning: smul_le_smul_of_nonneg -> smul_le_smul_of_nonneg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {b : M} {c : R}, (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c a) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c b))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {b : M} {c : R}, (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) c) -> (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_3))) c a) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_3))) c b))
Case conversion may be inaccurate. Consider using '#align smul_le_smul_of_nonneg smul_le_smul_of_nonnegₓ'. -/
theorem smul_le_smul_of_nonneg (h₁ : a ≤ b) (h₂ : 0 ≤ c) : c • a ≤ c • b :=
  by
  rcases h₁.eq_or_lt with (rfl | hab)
  · rfl
  · rcases h₂.eq_or_lt with (rfl | hc)
    · rw [zero_smul, zero_smul]
    · exact (smul_lt_smul_of_pos hab hc).le
#align smul_le_smul_of_nonneg smul_le_smul_of_nonneg

/- warning: smul_nonneg -> smul_nonneg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {c : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))))) a) -> (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c a))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} R] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_3 : SMulWithZero.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} R M _inst_1 _inst_2 _inst_3] {a : M} {c : R}, (LE.le.{u2} R (Preorder.toLE.{u2} R (PartialOrder.toPreorder.{u2} R (OrderedSemiring.toPartialOrder.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))))) c) -> (LE.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))))) a) -> (LE.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3))) c a))
Case conversion may be inaccurate. Consider using '#align smul_nonneg smul_nonnegₓ'. -/
theorem smul_nonneg (hc : 0 ≤ c) (ha : 0 ≤ a) : 0 ≤ c • a :=
  calc
    (0 : M) = c • (0 : M) := (smul_zero c).symm
    _ ≤ c • a := smul_le_smul_of_nonneg ha hc
    
#align smul_nonneg smul_nonneg

/- warning: smul_nonpos_of_nonneg_of_nonpos -> smul_nonpos_of_nonneg_of_nonpos is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {c : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))))))) -> (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c a) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} R] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_3 : SMulWithZero.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} R M _inst_1 _inst_2 _inst_3] {a : M} {c : R}, (LE.le.{u2} R (Preorder.toLE.{u2} R (PartialOrder.toPreorder.{u2} R (OrderedSemiring.toPartialOrder.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))))) c) -> (LE.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) a (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))))) -> (LE.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3))) c a) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))))))
Case conversion may be inaccurate. Consider using '#align smul_nonpos_of_nonneg_of_nonpos smul_nonpos_of_nonneg_of_nonposₓ'. -/
theorem smul_nonpos_of_nonneg_of_nonpos (hc : 0 ≤ c) (ha : a ≤ 0) : c • a ≤ 0 :=
  @smul_nonneg R Mᵒᵈ _ _ _ _ _ _ hc ha
#align smul_nonpos_of_nonneg_of_nonpos smul_nonpos_of_nonneg_of_nonpos

/- warning: eq_of_smul_eq_smul_of_pos_of_le -> eq_of_smul_eq_smul_of_pos_of_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {b : M} {c : R}, (Eq.{succ u2} M (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c a) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c b)) -> (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b) -> (Eq.{succ u2} M a b)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {b : M} {c : R}, (Eq.{succ u2} M (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_3))) c a) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_3))) c b)) -> (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) c) -> (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b) -> (Eq.{succ u2} M a b)
Case conversion may be inaccurate. Consider using '#align eq_of_smul_eq_smul_of_pos_of_le eq_of_smul_eq_smul_of_pos_of_leₓ'. -/
theorem eq_of_smul_eq_smul_of_pos_of_le (h₁ : c • a = c • b) (hc : 0 < c) (hle : a ≤ b) : a = b :=
  hle.lt_or_eq.resolve_left fun hlt => (smul_lt_smul_of_pos hlt hc).Ne h₁
#align eq_of_smul_eq_smul_of_pos_of_le eq_of_smul_eq_smul_of_pos_of_le

/- warning: lt_of_smul_lt_smul_of_nonneg -> lt_of_smul_lt_smul_of_nonneg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {b : M} {c : R}, (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c a) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c b)) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {b : M} {c : R}, (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_3))) c a) (HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_3))) c b)) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) c) -> (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b)
Case conversion may be inaccurate. Consider using '#align lt_of_smul_lt_smul_of_nonneg lt_of_smul_lt_smul_of_nonnegₓ'. -/
theorem lt_of_smul_lt_smul_of_nonneg (h : c • a < c • b) (hc : 0 ≤ c) : a < b :=
  hc.eq_or_lt.elim
    (fun hc => False.elim <| lt_irrefl (0 : M) <| by rwa [← hc, zero_smul, zero_smul] at h)
    (OrderedSMul.lt_of_smul_lt_smul_of_pos h)
#align lt_of_smul_lt_smul_of_nonneg lt_of_smul_lt_smul_of_nonneg

/- warning: smul_lt_smul_iff_of_pos -> smul_lt_smul_iff_of_pos is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {b : M} {c : R}, (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (Iff (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c a) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c b)) (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} R] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_3 : SMulWithZero.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} R M _inst_1 _inst_2 _inst_3] {a : M} {b : M} {c : R}, (LT.lt.{u2} R (Preorder.toLT.{u2} R (PartialOrder.toPreorder.{u2} R (OrderedSemiring.toPartialOrder.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))))) c) -> (Iff (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3))) c a) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3))) c b)) (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) a b))
Case conversion may be inaccurate. Consider using '#align smul_lt_smul_iff_of_pos smul_lt_smul_iff_of_posₓ'. -/
theorem smul_lt_smul_iff_of_pos (hc : 0 < c) : c • a < c • b ↔ a < b :=
  ⟨fun h => lt_of_smul_lt_smul_of_nonneg h hc.le, fun h => smul_lt_smul_of_pos h hc⟩
#align smul_lt_smul_iff_of_pos smul_lt_smul_iff_of_pos

/- warning: smul_pos_iff_of_pos -> smul_pos_iff_of_pos is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {c : R}, (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (Iff (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c a)) (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))))) a))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} R] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_3 : SMulWithZero.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} R M _inst_1 _inst_2 _inst_3] {a : M} {c : R}, (LT.lt.{u2} R (Preorder.toLT.{u2} R (PartialOrder.toPreorder.{u2} R (OrderedSemiring.toPartialOrder.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))))) c) -> (Iff (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3))) c a)) (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))))) a))
Case conversion may be inaccurate. Consider using '#align smul_pos_iff_of_pos smul_pos_iff_of_posₓ'. -/
theorem smul_pos_iff_of_pos (hc : 0 < c) : 0 < c • a ↔ 0 < a :=
  calc
    0 < c • a ↔ c • 0 < c • a := by rw [smul_zero]
    _ ↔ 0 < a := smul_lt_smul_iff_of_pos hc
    
#align smul_pos_iff_of_pos smul_pos_iff_of_pos

/- warning: smul_pos -> smul_pos is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {a : M} {c : R}, (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))))) a) -> (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))))) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c a))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} R] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_3 : SMulWithZero.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} R M _inst_1 _inst_2 _inst_3] {a : M} {c : R}, (LT.lt.{u2} R (Preorder.toLT.{u2} R (PartialOrder.toPreorder.{u2} R (OrderedSemiring.toPartialOrder.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))))) c) -> (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))))) a) -> (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (OfNat.ofNat.{u1} M 0 (Zero.toOfNat0.{u1} M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))))) (HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3))) c a))
Case conversion may be inaccurate. Consider using '#align smul_pos smul_posₓ'. -/
alias smul_pos_iff_of_pos ↔ _ smul_pos
#align smul_pos smul_pos

/- warning: monotone_smul_left -> monotone_smul_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {c : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (Monotone.{u2, u2} M M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} R] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_3 : SMulWithZero.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} R M _inst_1 _inst_2 _inst_3] {c : R}, (LE.le.{u2} R (Preorder.toLE.{u2} R (PartialOrder.toPreorder.{u2} R (OrderedSemiring.toPartialOrder.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))))) c) -> (Monotone.{u1, u1} M M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) (SMul.smul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3)) c))
Case conversion may be inaccurate. Consider using '#align monotone_smul_left monotone_smul_leftₓ'. -/
theorem monotone_smul_left (hc : 0 ≤ c) : Monotone (SMul.smul c : M → M) := fun a b h =>
  smul_le_smul_of_nonneg h hc
#align monotone_smul_left monotone_smul_left

/- warning: strict_mono_smul_left -> strictMono_smul_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {c : R}, (LT.lt.{u1} R (Preorder.toLT.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (StrictMono.{u2, u2} M M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3)) c))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} R] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_3 : SMulWithZero.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} R M _inst_1 _inst_2 _inst_3] {c : R}, (LT.lt.{u2} R (Preorder.toLT.{u2} R (PartialOrder.toPreorder.{u2} R (OrderedSemiring.toPartialOrder.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))))) c) -> (StrictMono.{u1, u1} M M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) (SMul.smul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3)) c))
Case conversion may be inaccurate. Consider using '#align strict_mono_smul_left strictMono_smul_leftₓ'. -/
theorem strictMono_smul_left (hc : 0 < c) : StrictMono (SMul.smul c : M → M) := fun a b h =>
  smul_lt_smul_of_pos h hc
#align strict_mono_smul_left strictMono_smul_left

/- warning: smul_lower_bounds_subset_lower_bounds_smul -> smul_lowerBounds_subset_lowerBounds_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {s : Set.{u2} M} {c : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) (SMul.smul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3))) c (lowerBounds.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) s)) (lowerBounds.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (SMul.smul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3))) c s)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} R] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_3 : SMulWithZero.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} R M _inst_1 _inst_2 _inst_3] {s : Set.{u1} M} {c : R}, (LE.le.{u2} R (Preorder.toLE.{u2} R (PartialOrder.toPreorder.{u2} R (OrderedSemiring.toPartialOrder.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))))) c) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) (HSMul.hSMul.{u2, u1, u1} R (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} R (Set.{u1} M) (Set.smulSet.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3)))) c (lowerBounds.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) s)) (lowerBounds.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) (HSMul.hSMul.{u2, u1, u1} R (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} R (Set.{u1} M) (Set.smulSet.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3)))) c s)))
Case conversion may be inaccurate. Consider using '#align smul_lower_bounds_subset_lower_bounds_smul smul_lowerBounds_subset_lowerBounds_smulₓ'. -/
theorem smul_lowerBounds_subset_lowerBounds_smul (hc : 0 ≤ c) :
    c • lowerBounds s ⊆ lowerBounds (c • s) :=
  (monotone_smul_left hc).image_lower_bounds_subset_lower_bounds_image
#align smul_lower_bounds_subset_lower_bounds_smul smul_lowerBounds_subset_lowerBounds_smul

/- warning: smul_upper_bounds_subset_upper_bounds_smul -> smul_upperBounds_subset_upperBounds_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {s : Set.{u2} M} {c : R}, (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) (SMul.smul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3))) c (upperBounds.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) s)) (upperBounds.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (SMul.smul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3))) c s)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} R] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_3 : SMulWithZero.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} R M _inst_1 _inst_2 _inst_3] {s : Set.{u1} M} {c : R}, (LE.le.{u2} R (Preorder.toLE.{u2} R (PartialOrder.toPreorder.{u2} R (OrderedSemiring.toPartialOrder.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))))) c) -> (HasSubset.Subset.{u1} (Set.{u1} M) (Set.instHasSubsetSet.{u1} M) (HSMul.hSMul.{u2, u1, u1} R (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} R (Set.{u1} M) (Set.smulSet.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3)))) c (upperBounds.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) s)) (upperBounds.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) (HSMul.hSMul.{u2, u1, u1} R (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} R (Set.{u1} M) (Set.smulSet.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (OrderedSemiring.toSemiring.{u2} R _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3)))) c s)))
Case conversion may be inaccurate. Consider using '#align smul_upper_bounds_subset_upper_bounds_smul smul_upperBounds_subset_upperBounds_smulₓ'. -/
theorem smul_upperBounds_subset_upperBounds_smul (hc : 0 ≤ c) :
    c • upperBounds s ⊆ upperBounds (c • s) :=
  (monotone_smul_left hc).image_upper_bounds_subset_upper_bounds_image
#align smul_upper_bounds_subset_upper_bounds_smul smul_upperBounds_subset_upperBounds_smul

/- warning: bdd_below.smul_of_nonneg -> BddBelow.smul_of_nonneg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {s : Set.{u2} M} {c : R}, (BddBelow.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) s) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (BddBelow.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (SMul.smul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3))) c s))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {s : Set.{u2} M} {c : R}, (BddBelow.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) s) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) c) -> (BddBelow.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (HSMul.hSMul.{u1, u2, u2} R (Set.{u2} M) (Set.{u2} M) (instHSMul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_3)))) c s))
Case conversion may be inaccurate. Consider using '#align bdd_below.smul_of_nonneg BddBelow.smul_of_nonnegₓ'. -/
theorem BddBelow.smul_of_nonneg (hs : BddBelow s) (hc : 0 ≤ c) : BddBelow (c • s) :=
  (monotone_smul_left hc).map_bdd_below hs
#align bdd_below.smul_of_nonneg BddBelow.smul_of_nonneg

/- warning: bdd_above.smul_of_nonneg -> BddAbove.smul_of_nonneg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {s : Set.{u2} M} {c : R}, (BddAbove.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) s) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedAddCommMonoid.toPartialOrder.{u1} R (OrderedSemiring.toOrderedAddCommMonoid.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1)))))))) c) -> (BddAbove.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (SMul.smul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_3))) c s))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} R] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))] [_inst_4 : OrderedSMul.{u1, u2} R M _inst_1 _inst_2 _inst_3] {s : Set.{u2} M} {c : R}, (BddAbove.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) s) -> (LE.le.{u1} R (Preorder.toLE.{u1} R (PartialOrder.toPreorder.{u1} R (OrderedSemiring.toPartialOrder.{u1} R _inst_1))) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))))) c) -> (BddAbove.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (HSMul.hSMul.{u1, u2, u2} R (Set.{u2} M) (Set.{u2} M) (instHSMul.{u1, u2} R (Set.{u2} M) (Set.smulSet.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (OrderedSemiring.toSemiring.{u1} R _inst_1))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_3)))) c s))
Case conversion may be inaccurate. Consider using '#align bdd_above.smul_of_nonneg BddAbove.smul_of_nonnegₓ'. -/
theorem BddAbove.smul_of_nonneg (hs : BddAbove s) (hc : 0 ≤ c) : BddAbove (c • s) :=
  (monotone_smul_left hc).map_bdd_above hs
#align bdd_above.smul_of_nonneg BddAbove.smul_of_nonneg

end OrderedSMul

/- warning: ordered_smul.mk'' -> OrderedSMul.mk'' is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : OrderedSemiring.{u1} 𝕜] [_inst_2 : LinearOrderedAddCommMonoid.{u2} M] [_inst_3 : SMulWithZero.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (OrderedSemiring.toSemiring.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2)))))], (forall {{c : 𝕜}}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedAddCommMonoid.toPartialOrder.{u1} 𝕜 (OrderedSemiring.toOrderedAddCommMonoid.{u1} 𝕜 _inst_1)))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (OrderedSemiring.toSemiring.{u1} 𝕜 _inst_1)))))))) c) -> (StrictMono.{u2, u2} M M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2))) (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2))) (fun (a : M) => SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2))))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (OrderedSemiring.toSemiring.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2))))) _inst_3)) c a))) -> (OrderedSMul.{u1, u2} 𝕜 M _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u2} M _inst_2) _inst_3)
but is expected to have type
  forall {𝕜 : Type.{u2}} {M : Type.{u1}} [_inst_1 : OrderedSemiring.{u2} 𝕜] [_inst_2 : LinearOrderedAddCommMonoid.{u1} M] [_inst_3 : SMulWithZero.{u2, u1} 𝕜 M (MonoidWithZero.toZero.{u2} 𝕜 (Semiring.toMonoidWithZero.{u2} 𝕜 (OrderedSemiring.toSemiring.{u2} 𝕜 _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))], (forall {{c : 𝕜}}, (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (OrderedSemiring.toPartialOrder.{u2} 𝕜 _inst_1))) (OfNat.ofNat.{u2} 𝕜 0 (Zero.toOfNat0.{u2} 𝕜 (MonoidWithZero.toZero.{u2} 𝕜 (Semiring.toMonoidWithZero.{u2} 𝕜 (OrderedSemiring.toSemiring.{u2} 𝕜 _inst_1))))) c) -> (StrictMono.{u1, u1} M M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} M _inst_2))) (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} M _inst_2))) (fun (a : M) => HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (MonoidWithZero.toZero.{u2} 𝕜 (Semiring.toMonoidWithZero.{u2} 𝕜 (OrderedSemiring.toSemiring.{u2} 𝕜 _inst_1))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (LinearOrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_3))) c a))) -> (OrderedSMul.{u2, u1} 𝕜 M _inst_1 (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} M _inst_2) _inst_3)
Case conversion may be inaccurate. Consider using '#align ordered_smul.mk'' OrderedSMul.mk''ₓ'. -/
/-- To prove that a linear ordered monoid is an ordered module, it suffices to verify only the first
axiom of `ordered_smul`. -/
theorem OrderedSMul.mk'' [OrderedSemiring 𝕜] [LinearOrderedAddCommMonoid M] [SMulWithZero 𝕜 M]
    (h : ∀ ⦃c : 𝕜⦄, 0 < c → StrictMono fun a : M => c • a) : OrderedSMul 𝕜 M :=
  { smul_lt_smul_of_pos := fun a b c hab hc => h hc hab
    lt_of_smul_lt_smul_of_pos := fun a b c hab hc => (h hc).lt_iff_lt.1 hab }
#align ordered_smul.mk'' OrderedSMul.mk''

/- warning: nat.ordered_smul -> Nat.orderedSMul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : LinearOrderedCancelAddCommMonoid.{u1} M], OrderedSMul.{0, u1} Nat M Nat.orderedSemiring (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u1} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} M _inst_1)) (AddMonoid.natSMulWithZero.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toCancelAddMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} M _inst_1))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : LinearOrderedCancelAddCommMonoid.{u1} M], OrderedSMul.{0, u1} Nat M Nat.orderedSemiring (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} M (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} M _inst_1)) (AddMonoid.natSMulWithZero.{u1} M (AddRightCancelMonoid.toAddMonoid.{u1} M (AddCancelMonoid.toAddRightCancelMonoid.{u1} M (AddCancelCommMonoid.toAddCancelMonoid.{u1} M (OrderedCancelAddCommMonoid.toCancelAddCommMonoid.{u1} M (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} M _inst_1))))))
Case conversion may be inaccurate. Consider using '#align nat.ordered_smul Nat.orderedSMulₓ'. -/
instance Nat.orderedSMul [LinearOrderedCancelAddCommMonoid M] : OrderedSMul ℕ M :=
  OrderedSMul.mk'' fun n hn a b hab => by
    cases n
    · cases hn
    induction' n with n ih
    · simp only [one_nsmul, hab]
    · simp only [succ_nsmul _ n.succ, add_lt_add hab (ih n.succ_pos)]
#align nat.ordered_smul Nat.orderedSMul

#print Int.orderedSMul /-
instance Int.orderedSMul [LinearOrderedAddCommGroup M] : OrderedSMul ℤ M :=
  OrderedSMul.mk'' fun n hn => by
    cases n
    · simp only [Int.ofNat_eq_coe, Int.coe_nat_pos, coe_nat_zsmul] at hn⊢
      exact strictMono_smul_left hn
    · cases (Int.negSucc_not_pos _).1 hn
#align int.ordered_smul Int.orderedSMul
-/

#print LinearOrderedSemiring.toOrderedSMul /-
-- TODO: `linear_ordered_field M → ordered_smul ℚ M`
instance LinearOrderedSemiring.toOrderedSMul {R : Type _} [LinearOrderedSemiring R] :
    OrderedSMul R R :=
  OrderedSMul.mk'' fun c => strictMono_mul_left_of_pos
#align linear_ordered_semiring.to_ordered_smul LinearOrderedSemiring.toOrderedSMul
-/

section LinearOrderedSemifield

variable [LinearOrderedSemifield 𝕜] [OrderedAddCommMonoid M] [OrderedAddCommMonoid N]
  [MulActionWithZero 𝕜 M] [MulActionWithZero 𝕜 N]

/- warning: ordered_smul.mk' -> OrderedSMul.mk' is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))], (forall {{a : M}} {{b : M}} {{c : 𝕜}}, (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b) -> (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) c a) (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) c b))) -> (OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))
but is expected to have type
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))], (forall {{a : M}} {{b : M}} {{c : 𝕜}}, (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b) -> (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))))) (OfNat.ofNat.{u1} 𝕜 0 (Zero.toOfNat0.{u1} 𝕜 (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))) c) -> (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (HSMul.hSMul.{u1, u2, u2} 𝕜 M M (instHSMul.{u1, u2} 𝕜 M (SMulZeroClass.toSMul.{u1, u2} 𝕜 M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 M (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_4)))) c a) (HSMul.hSMul.{u1, u2, u2} 𝕜 M M (instHSMul.{u1, u2} 𝕜 M (SMulZeroClass.toSMul.{u1, u2} 𝕜 M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u1, u2} 𝕜 M (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_4)))) c b))) -> (OrderedSMul.{u1, u2} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_4))
Case conversion may be inaccurate. Consider using '#align ordered_smul.mk' OrderedSMul.mk'ₓ'. -/
/-- To prove that a vector space over a linear ordered field is ordered, it suffices to verify only
the first axiom of `ordered_smul`. -/
theorem OrderedSMul.mk' (h : ∀ ⦃a b : M⦄ ⦃c : 𝕜⦄, a < b → 0 < c → c • a ≤ c • b) :
    OrderedSMul 𝕜 M :=
  by
  have hlt' : ∀ ⦃a b : M⦄ ⦃c : 𝕜⦄, a < b → 0 < c → c • a < c • b :=
    by
    refine' fun a b c hab hc => (h hab hc).lt_of_ne _
    rw [Ne.def, hc.ne'.is_unit.smul_left_cancel]
    exact hab.ne
  refine' { smul_lt_smul_of_pos := hlt'.. }
  intro a b c hab hc
  obtain ⟨c, rfl⟩ := hc.ne'.is_unit
  rw [← inv_smul_smul c a, ← inv_smul_smul c b]
  refine' hlt' hab (pos_of_mul_pos_right _ hc.le)
  simp only [c.mul_inv, zero_lt_one]
#align ordered_smul.mk' OrderedSMul.mk'

instance [OrderedSMul 𝕜 M] [OrderedSMul 𝕜 N] : OrderedSMul 𝕜 (M × N) :=
  OrderedSMul.mk' fun a b c h hc =>
    ⟨smul_le_smul_of_nonneg h.1.1 hc.le, smul_le_smul_of_nonneg h.1.2 hc.le⟩

/- warning: pi.ordered_smul -> Pi.orderedSMul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] {M : ι -> Type.{u3}} [_inst_6 : forall (i : ι), OrderedAddCommMonoid.{u3} (M i)] [_inst_7 : forall (i : ι), MulActionWithZero.{u2, u3} 𝕜 (M i) (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (OrderedAddCommMonoid.toAddCommMonoid.{u3} (M i) (_inst_6 i)))))] [_inst_8 : forall (i : ι), OrderedSMul.{u2, u3} 𝕜 (M i) (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) (_inst_6 i) (MulActionWithZero.toSMulWithZero.{u2, u3} 𝕜 (M i) (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u3} (M i) (AddMonoid.toAddZeroClass.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (OrderedAddCommMonoid.toAddCommMonoid.{u3} (M i) (_inst_6 i))))) (_inst_7 i))], OrderedSMul.{u2, max u1 u3} 𝕜 (forall (i : ι), M i) (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) (Pi.orderedAddCommMonoid.{u1, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_6 i)) (MulActionWithZero.toSMulWithZero.{u2, max u1 u3} 𝕜 (forall (i : ι), M i) (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{max u1 u3} (forall (i : ι), M i) (AddMonoid.toAddZeroClass.{max u1 u3} (forall (i : ι), M i) (AddCommMonoid.toAddMonoid.{max u1 u3} (forall (i : ι), M i) (OrderedAddCommMonoid.toAddCommMonoid.{max u1 u3} (forall (i : ι), M i) (Pi.orderedAddCommMonoid.{u1, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_6 i)))))) (Pi.mulActionWithZero.{u1, u3, u2} ι (fun (i : ι) => M i) 𝕜 (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (fun (_x : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) _x) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) _x) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) _x) ((fun (i : ι) => OrderedAddCommMonoid.toAddCommMonoid.{u3} ((fun (i : ι) => M i) i) ((fun (i : ι) => _inst_6 i) i)) _x)))) (fun (i : ι) => _inst_7 i)))
but is expected to have type
  forall {ι : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] {M : ι -> Type.{u3}} [_inst_6 : forall (i : ι), OrderedAddCommMonoid.{u3} (M i)] [_inst_7 : forall (i : ι), MulActionWithZero.{u2, u3} 𝕜 (M i) (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (OrderedAddCommMonoid.toAddCommMonoid.{u3} (M i) (_inst_6 i))))] [_inst_8 : forall (i : ι), OrderedSMul.{u2, u3} 𝕜 (M i) (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) (_inst_6 i) (MulActionWithZero.toSMulWithZero.{u2, u3} 𝕜 (M i) (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (OrderedAddCommMonoid.toAddCommMonoid.{u3} (M i) (_inst_6 i)))) (_inst_7 i))], OrderedSMul.{u2, max u1 u3} 𝕜 (forall (i : ι), M i) (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) (Pi.orderedAddCommMonoid.{u1, u3} ι (fun (i : ι) => M i) (fun (i : ι) => _inst_6 i)) (Pi.smulWithZero.{u1, u3, u2} ι (fun (i : ι) => M i) 𝕜 (MonoidWithZero.toZero.{u2} 𝕜 (Semiring.toMonoidWithZero.{u2} 𝕜 (OrderedSemiring.toSemiring.{u2} 𝕜 (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))))) (fun (x._@.Mathlib.Data.Pi.Algebra._hyg.111 : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) x._@.Mathlib.Data.Pi.Algebra._hyg.111) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => M i) i) i) i) ((fun (i : ι) => AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (i : ι) => M i) i) i) ((fun (i : ι) => OrderedAddCommMonoid.toAddCommMonoid.{u3} ((fun (i : ι) => M i) i) ((fun (i : ι) => _inst_6 i) i)) i)) i)) x._@.Mathlib.Data.Pi.Algebra._hyg.111)) (fun (i : ι) => MulActionWithZero.toSMulWithZero.{u2, u3} 𝕜 (M i) (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u3} (M i) (AddCommMonoid.toAddMonoid.{u3} (M i) (OrderedAddCommMonoid.toAddCommMonoid.{u3} (M i) (_inst_6 i)))) (_inst_7 i)))
Case conversion may be inaccurate. Consider using '#align pi.ordered_smul Pi.orderedSMulₓ'. -/
instance Pi.orderedSMul {M : ι → Type _} [∀ i, OrderedAddCommMonoid (M i)]
    [∀ i, MulActionWithZero 𝕜 (M i)] [∀ i, OrderedSMul 𝕜 (M i)] : OrderedSMul 𝕜 (∀ i, M i) :=
  OrderedSMul.mk' fun v u c h hc i => smul_le_smul_of_nonneg (h.le i) hc.le
#align pi.ordered_smul Pi.orderedSMul

/- warning: pi.ordered_smul' -> Pi.orderedSMul' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {𝕜 : Type.{u2}} {M : Type.{u3}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u3} M] [_inst_4 : MulActionWithZero.{u2, u3} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (OrderedAddCommMonoid.toAddCommMonoid.{u3} M _inst_2))))] [_inst_6 : OrderedSMul.{u2, u3} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u3} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (OrderedAddCommMonoid.toAddCommMonoid.{u3} M _inst_2)))) _inst_4)], OrderedSMul.{u2, max u1 u3} 𝕜 (ι -> M) (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) (Pi.orderedAddCommMonoid.{u1, u3} ι (fun (ᾰ : ι) => M) (fun (i : ι) => _inst_2)) (MulActionWithZero.toSMulWithZero.{u2, max u1 u3} 𝕜 (ι -> M) (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{max u1 u3} (ι -> M) (AddMonoid.toAddZeroClass.{max u1 u3} (ι -> M) (AddCommMonoid.toAddMonoid.{max u1 u3} (ι -> M) (OrderedAddCommMonoid.toAddCommMonoid.{max u1 u3} (ι -> M) (Pi.orderedAddCommMonoid.{u1, u3} ι (fun (ᾰ : ι) => M) (fun (i : ι) => _inst_2)))))) (Pi.mulActionWithZero.{u1, u3, u2} ι (fun (ᾰ : ι) => M) 𝕜 (Semiring.toMonoidWithZero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (fun (_x : ι) => AddZeroClass.toHasZero.{u3} ((fun (i : ι) => (fun (ᾰ : ι) => M) i) _x) (AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => (fun (ᾰ : ι) => M) i) _x) (AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (ᾰ : ι) => M) i) _x) ((fun (i : ι) => OrderedAddCommMonoid.toAddCommMonoid.{u3} ((fun (ᾰ : ι) => M) i) ((fun (i : ι) => _inst_2) i)) _x)))) (fun (i : ι) => _inst_4)))
but is expected to have type
  forall {ι : Type.{u1}} {𝕜 : Type.{u2}} {M : Type.{u3}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u3} M] [_inst_4 : MulActionWithZero.{u2, u3} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (OrderedAddCommMonoid.toAddCommMonoid.{u3} M _inst_2)))] [_inst_6 : OrderedSMul.{u2, u3} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u3} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (OrderedAddCommMonoid.toAddCommMonoid.{u3} M _inst_2))) _inst_4)], OrderedSMul.{u2, max u1 u3} 𝕜 (ι -> M) (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) (Pi.orderedAddCommMonoid.{u1, u3} ι (fun (ᾰ : ι) => M) (fun (i : ι) => _inst_2)) (Pi.smulWithZero.{u1, u3, u2} ι (fun (a._@.Mathlib.Algebra.Order.SMul._hyg.2070 : ι) => M) 𝕜 (MonoidWithZero.toZero.{u2} 𝕜 (Semiring.toMonoidWithZero.{u2} 𝕜 (OrderedSemiring.toSemiring.{u2} 𝕜 (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))))) (fun (x._@.Mathlib.Data.Pi.Algebra._hyg.111 : ι) => AddZeroClass.toZero.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (i : ι) => (fun (a._@.Mathlib.Algebra.Order.SMul._hyg.2070 : ι) => M) i) i) i) x._@.Mathlib.Data.Pi.Algebra._hyg.111) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u3} ((fun (i : ι) => (fun (i : ι) => (fun (a._@.Mathlib.Algebra.Order.SMul._hyg.2070 : ι) => M) i) i) i) ((fun (i : ι) => AddCommMonoid.toAddMonoid.{u3} ((fun (i : ι) => (fun (a._@.Mathlib.Algebra.Order.SMul._hyg.2070 : ι) => M) i) i) ((fun (i : ι) => OrderedAddCommMonoid.toAddCommMonoid.{u3} ((fun (a._@.Mathlib.Algebra.Order.SMul._hyg.2070 : ι) => M) i) ((fun (i : ι) => _inst_2) i)) i)) i)) x._@.Mathlib.Data.Pi.Algebra._hyg.111)) (fun (i : ι) => MulActionWithZero.toSMulWithZero.{u2, u3} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M (OrderedAddCommMonoid.toAddCommMonoid.{u3} M _inst_2))) _inst_4))
Case conversion may be inaccurate. Consider using '#align pi.ordered_smul' Pi.orderedSMul'ₓ'. -/
/- Sometimes Lean fails to apply the dependent version to non-dependent functions, so we define
another instance. -/
instance Pi.orderedSMul' [OrderedSMul 𝕜 M] : OrderedSMul 𝕜 (ι → M) :=
  Pi.orderedSMul
#align pi.ordered_smul' Pi.orderedSMul'

/- warning: pi.ordered_smul'' -> Pi.orderedSMul'' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜], OrderedSMul.{u2, max u1 u2} 𝕜 (ι -> 𝕜) (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) (Pi.orderedAddCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => 𝕜) (fun (i : ι) => OrderedSemiring.toOrderedAddCommMonoid.{u2} 𝕜 (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (Pi.smulWithZero.{u1, u2, u2} ι (fun (ᾰ : ι) => 𝕜) 𝕜 (MulZeroClass.toHasZero.{u2} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜 (Semiring.toNonAssocSemiring.{u2} 𝕜 (OrderedSemiring.toSemiring.{u2} 𝕜 (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))))))) (fun (_x : ι) => AddZeroClass.toHasZero.{u2} ((fun (i : ι) => (fun (ᾰ : ι) => 𝕜) i) _x) (AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => (fun (ᾰ : ι) => 𝕜) i) _x) (AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (ᾰ : ι) => 𝕜) i) _x) ((fun (i : ι) => OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (ᾰ : ι) => 𝕜) i) ((fun (i : ι) => OrderedSemiring.toOrderedAddCommMonoid.{u2} 𝕜 (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) i)) _x)))) (fun (i : ι) => MulZeroClass.toSMulWithZero.{u2} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜 (Semiring.toNonAssocSemiring.{u2} 𝕜 (OrderedSemiring.toSemiring.{u2} 𝕜 (StrictOrderedSemiring.toOrderedSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))))))))
but is expected to have type
  forall {ι : Type.{u1}} {𝕜 : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜], OrderedSMul.{u2, max u1 u2} 𝕜 (ι -> 𝕜) (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) (Pi.orderedAddCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => 𝕜) (fun (i : ι) => OrderedSemiring.toOrderedAddCommMonoid.{u2} 𝕜 (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (Pi.smulWithZero.{u1, u2, u2} ι (fun (ᾰ : ι) => 𝕜) 𝕜 (MonoidWithZero.toZero.{u2} 𝕜 (Semiring.toMonoidWithZero.{u2} 𝕜 (OrderedSemiring.toSemiring.{u2} 𝕜 (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))))) (fun (_x : ι) => AddZeroClass.toZero.{u2} ((fun (i : ι) => (fun (ᾰ : ι) => (fun (i : ι) => (fun (a._@.Mathlib.Algebra.Order.SMul._hyg.2106 : ι) => 𝕜) i) ᾰ) i) _x) ((fun (i : ι) => AddMonoid.toAddZeroClass.{u2} ((fun (i : ι) => (fun (i : ι) => (fun (a._@.Mathlib.Algebra.Order.SMul._hyg.2106 : ι) => 𝕜) i) i) i) ((fun (i : ι) => AddCommMonoid.toAddMonoid.{u2} ((fun (i : ι) => (fun (a._@.Mathlib.Algebra.Order.SMul._hyg.2106 : ι) => 𝕜) i) i) ((fun (i : ι) => OrderedAddCommMonoid.toAddCommMonoid.{u2} ((fun (a._@.Mathlib.Algebra.Order.SMul._hyg.2106 : ι) => 𝕜) i) ((fun (i : ι) => OrderedSemiring.toOrderedAddCommMonoid.{u2} 𝕜 (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) i)) i)) i)) _x)) (fun (i : ι) => MulZeroClass.toSMulWithZero.{u2} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} 𝕜 (Semiring.toNonAssocSemiring.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))))))
Case conversion may be inaccurate. Consider using '#align pi.ordered_smul'' Pi.orderedSMul''ₓ'. -/
-- Sometimes Lean fails to unify the module with the scalars, so we define another instance.
instance Pi.orderedSMul'' : OrderedSMul 𝕜 (ι → 𝕜) :=
  @Pi.orderedSMul' ι 𝕜 𝕜 _ _ _ _
#align pi.ordered_smul'' Pi.orderedSMul''

variable [OrderedSMul 𝕜 M] {s : Set M} {a b : M} {c : 𝕜}

/- warning: smul_le_smul_iff_of_pos -> smul_le_smul_iff_of_pos is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)] {a : M} {b : M} {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (Iff (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) c a) (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) c b)) (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a b))
but is expected to have type
  forall {𝕜 : Type.{u2}} {M : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_4 : MulActionWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_6 : OrderedSMul.{u2, u1} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)] {a : M} {b : M} {c : 𝕜}, (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (OfNat.ofNat.{u2} 𝕜 0 (Zero.toOfNat0.{u2} 𝕜 (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))))) c) -> (Iff (LE.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)))) c a) (HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)))) c b)) (LE.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) a b))
Case conversion may be inaccurate. Consider using '#align smul_le_smul_iff_of_pos smul_le_smul_iff_of_posₓ'. -/
theorem smul_le_smul_iff_of_pos (hc : 0 < c) : c • a ≤ c • b ↔ a ≤ b :=
  ⟨fun h =>
    inv_smul_smul₀ hc.ne' a ▸
      inv_smul_smul₀ hc.ne' b ▸ smul_le_smul_of_nonneg h (inv_nonneg.2 hc.le),
    fun h => smul_le_smul_of_nonneg h hc.le⟩
#align smul_le_smul_iff_of_pos smul_le_smul_iff_of_pos

/- warning: inv_smul_le_iff -> inv_smul_le_iff is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)] {a : M} {b : M} {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (Iff (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) (Inv.inv.{u1} 𝕜 (DivInvMonoid.toHasInv.{u1} 𝕜 (GroupWithZero.toDivInvMonoid.{u1} 𝕜 (DivisionSemiring.toGroupWithZero.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))) c) a) b) (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) c b)))
but is expected to have type
  forall {𝕜 : Type.{u2}} {M : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_4 : MulActionWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_6 : OrderedSMul.{u2, u1} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)] {a : M} {b : M} {c : 𝕜}, (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (OfNat.ofNat.{u2} 𝕜 0 (Zero.toOfNat0.{u2} 𝕜 (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))))) c) -> (Iff (LE.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)))) (Inv.inv.{u2} 𝕜 (LinearOrderedSemifield.toInv.{u2} 𝕜 _inst_1) c) a) b) (LE.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) a (HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)))) c b)))
Case conversion may be inaccurate. Consider using '#align inv_smul_le_iff inv_smul_le_iffₓ'. -/
theorem inv_smul_le_iff (h : 0 < c) : c⁻¹ • a ≤ b ↔ a ≤ c • b :=
  by
  rw [← smul_le_smul_iff_of_pos h, smul_inv_smul₀ h.ne']
  infer_instance
#align inv_smul_le_iff inv_smul_le_iff

/- warning: inv_smul_lt_iff -> inv_smul_lt_iff is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)] {a : M} {b : M} {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (Iff (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) (Inv.inv.{u1} 𝕜 (DivInvMonoid.toHasInv.{u1} 𝕜 (GroupWithZero.toDivInvMonoid.{u1} 𝕜 (DivisionSemiring.toGroupWithZero.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))) c) a) b) (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) c b)))
but is expected to have type
  forall {𝕜 : Type.{u2}} {M : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_4 : MulActionWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_6 : OrderedSMul.{u2, u1} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)] {a : M} {b : M} {c : 𝕜}, (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (OfNat.ofNat.{u2} 𝕜 0 (Zero.toOfNat0.{u2} 𝕜 (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))))) c) -> (Iff (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)))) (Inv.inv.{u2} 𝕜 (LinearOrderedSemifield.toInv.{u2} 𝕜 _inst_1) c) a) b) (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) a (HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)))) c b)))
Case conversion may be inaccurate. Consider using '#align inv_smul_lt_iff inv_smul_lt_iffₓ'. -/
theorem inv_smul_lt_iff (h : 0 < c) : c⁻¹ • a < b ↔ a < c • b :=
  by
  rw [← smul_lt_smul_iff_of_pos h, smul_inv_smul₀ h.ne']
  infer_instance
#align inv_smul_lt_iff inv_smul_lt_iff

/- warning: le_inv_smul_iff -> le_inv_smul_iff is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)] {a : M} {b : M} {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (Iff (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) (Inv.inv.{u1} 𝕜 (DivInvMonoid.toHasInv.{u1} 𝕜 (GroupWithZero.toDivInvMonoid.{u1} 𝕜 (DivisionSemiring.toGroupWithZero.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))) c) b)) (LE.le.{u2} M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) c a) b))
but is expected to have type
  forall {𝕜 : Type.{u2}} {M : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_4 : MulActionWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_6 : OrderedSMul.{u2, u1} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)] {a : M} {b : M} {c : 𝕜}, (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (OfNat.ofNat.{u2} 𝕜 0 (Zero.toOfNat0.{u2} 𝕜 (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))))) c) -> (Iff (LE.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) a (HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)))) (Inv.inv.{u2} 𝕜 (LinearOrderedSemifield.toInv.{u2} 𝕜 _inst_1) c) b)) (LE.le.{u1} M (Preorder.toLE.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)))) c a) b))
Case conversion may be inaccurate. Consider using '#align le_inv_smul_iff le_inv_smul_iffₓ'. -/
theorem le_inv_smul_iff (h : 0 < c) : a ≤ c⁻¹ • b ↔ c • a ≤ b :=
  by
  rw [← smul_le_smul_iff_of_pos h, smul_inv_smul₀ h.ne']
  infer_instance
#align le_inv_smul_iff le_inv_smul_iff

/- warning: lt_inv_smul_iff -> lt_inv_smul_iff is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)] {a : M} {b : M} {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (Iff (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) a (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) (Inv.inv.{u1} 𝕜 (DivInvMonoid.toHasInv.{u1} 𝕜 (GroupWithZero.toDivInvMonoid.{u1} 𝕜 (DivisionSemiring.toGroupWithZero.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))) c) b)) (LT.lt.{u2} M (Preorder.toLT.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (SMul.smul.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4))) c a) b))
but is expected to have type
  forall {𝕜 : Type.{u2}} {M : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_4 : MulActionWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_6 : OrderedSMul.{u2, u1} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)] {a : M} {b : M} {c : 𝕜}, (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (OfNat.ofNat.{u2} 𝕜 0 (Zero.toOfNat0.{u2} 𝕜 (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))))) c) -> (Iff (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) a (HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)))) (Inv.inv.{u2} 𝕜 (LinearOrderedSemifield.toInv.{u2} 𝕜 _inst_1) c) b)) (LT.lt.{u1} M (Preorder.toLT.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2))) (HSMul.hSMul.{u2, u1, u1} 𝕜 M M (instHSMul.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)))) c a) b))
Case conversion may be inaccurate. Consider using '#align lt_inv_smul_iff lt_inv_smul_iffₓ'. -/
theorem lt_inv_smul_iff (h : 0 < c) : a < c⁻¹ • b ↔ c • a < b :=
  by
  rw [← smul_lt_smul_iff_of_pos h, smul_inv_smul₀ h.ne']
  infer_instance
#align lt_inv_smul_iff lt_inv_smul_iff

variable (M)

/- warning: order_iso.smul_left -> OrderIso.smulLeft is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} (M : Type.{u2}) [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)] {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (OrderIso.{u2, u2} M M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))))
but is expected to have type
  forall {𝕜 : Type.{u1}} (M : Type.{u2}) [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u1} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (StrictOrderedSemiring.toSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))) _inst_4)] {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))))) (OfNat.ofNat.{u1} 𝕜 0 (Zero.toOfNat0.{u1} 𝕜 (CommMonoidWithZero.toZero.{u1} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u1} 𝕜 (Semifield.toCommGroupWithZero.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))) c) -> (OrderIso.{u2, u2} M M (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))) (Preorder.toLE.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2))))
Case conversion may be inaccurate. Consider using '#align order_iso.smul_left OrderIso.smulLeftₓ'. -/
/-- Left scalar multiplication as an order isomorphism. -/
@[simps]
def OrderIso.smulLeft (hc : 0 < c) : M ≃o M
    where
  toFun b := c • b
  invFun b := c⁻¹ • b
  left_inv := inv_smul_smul₀ hc.ne'
  right_inv := smul_inv_smul₀ hc.ne'
  map_rel_iff' b₁ b₂ := smul_le_smul_iff_of_pos hc
#align order_iso.smul_left OrderIso.smulLeft

variable {M}

/- warning: lower_bounds_smul_of_pos -> lowerBounds_smul_of_pos is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)] {s : Set.{u2} M} {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (Eq.{succ u2} (Set.{u2} M) (lowerBounds.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (SMul.smul.{u1, u2} 𝕜 (Set.{u2} M) (Set.smulSet.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)))) c s)) (SMul.smul.{u1, u2} 𝕜 (Set.{u2} M) (Set.smulSet.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)))) c (lowerBounds.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) s)))
but is expected to have type
  forall {𝕜 : Type.{u2}} {M : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_4 : MulActionWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_6 : OrderedSMul.{u2, u1} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)] {s : Set.{u1} M} {c : 𝕜}, (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (OfNat.ofNat.{u2} 𝕜 0 (Zero.toOfNat0.{u2} 𝕜 (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))))) c) -> (Eq.{succ u1} (Set.{u1} M) (lowerBounds.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) (HSMul.hSMul.{u2, u1, u1} 𝕜 (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} 𝕜 (Set.{u1} M) (Set.smulSet.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4))))) c s)) (HSMul.hSMul.{u2, u1, u1} 𝕜 (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} 𝕜 (Set.{u1} M) (Set.smulSet.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4))))) c (lowerBounds.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) s)))
Case conversion may be inaccurate. Consider using '#align lower_bounds_smul_of_pos lowerBounds_smul_of_posₓ'. -/
@[simp]
theorem lowerBounds_smul_of_pos (hc : 0 < c) : lowerBounds (c • s) = c • lowerBounds s :=
  (OrderIso.smulLeft _ hc).lower_bounds_image
#align lower_bounds_smul_of_pos lowerBounds_smul_of_pos

/- warning: upper_bounds_smul_of_pos -> upperBounds_smul_of_pos is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)] {s : Set.{u2} M} {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (Eq.{succ u2} (Set.{u2} M) (upperBounds.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (SMul.smul.{u1, u2} 𝕜 (Set.{u2} M) (Set.smulSet.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)))) c s)) (SMul.smul.{u1, u2} 𝕜 (Set.{u2} M) (Set.smulSet.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)))) c (upperBounds.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) s)))
but is expected to have type
  forall {𝕜 : Type.{u2}} {M : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_4 : MulActionWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_6 : OrderedSMul.{u2, u1} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)] {s : Set.{u1} M} {c : 𝕜}, (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (OfNat.ofNat.{u2} 𝕜 0 (Zero.toOfNat0.{u2} 𝕜 (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))))) c) -> (Eq.{succ u1} (Set.{u1} M) (upperBounds.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) (HSMul.hSMul.{u2, u1, u1} 𝕜 (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} 𝕜 (Set.{u1} M) (Set.smulSet.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4))))) c s)) (HSMul.hSMul.{u2, u1, u1} 𝕜 (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} 𝕜 (Set.{u1} M) (Set.smulSet.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4))))) c (upperBounds.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) s)))
Case conversion may be inaccurate. Consider using '#align upper_bounds_smul_of_pos upperBounds_smul_of_posₓ'. -/
@[simp]
theorem upperBounds_smul_of_pos (hc : 0 < c) : upperBounds (c • s) = c • upperBounds s :=
  (OrderIso.smulLeft _ hc).upper_bounds_image
#align upper_bounds_smul_of_pos upperBounds_smul_of_pos

/- warning: bdd_below_smul_iff_of_pos -> bddBelow_smul_iff_of_pos is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)] {s : Set.{u2} M} {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (Iff (BddBelow.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (SMul.smul.{u1, u2} 𝕜 (Set.{u2} M) (Set.smulSet.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)))) c s)) (BddBelow.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) s))
but is expected to have type
  forall {𝕜 : Type.{u2}} {M : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_4 : MulActionWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_6 : OrderedSMul.{u2, u1} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)] {s : Set.{u1} M} {c : 𝕜}, (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (OfNat.ofNat.{u2} 𝕜 0 (Zero.toOfNat0.{u2} 𝕜 (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))))) c) -> (Iff (BddBelow.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) (HSMul.hSMul.{u2, u1, u1} 𝕜 (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} 𝕜 (Set.{u1} M) (Set.smulSet.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4))))) c s)) (BddBelow.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) s))
Case conversion may be inaccurate. Consider using '#align bdd_below_smul_iff_of_pos bddBelow_smul_iff_of_posₓ'. -/
@[simp]
theorem bddBelow_smul_iff_of_pos (hc : 0 < c) : BddBelow (c • s) ↔ BddBelow s :=
  (OrderIso.smulLeft _ hc).bdd_below_image
#align bdd_below_smul_iff_of_pos bddBelow_smul_iff_of_pos

/- warning: bdd_above_smul_iff_of_pos -> bddAbove_smul_iff_of_pos is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {M : Type.{u2}} [_inst_1 : LinearOrderedSemifield.{u1} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u2} M] [_inst_4 : MulActionWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2))))] [_inst_6 : OrderedSMul.{u1, u2} 𝕜 M (StrictOrderedSemiring.toOrderedSemiring.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)] {s : Set.{u2} M} {c : 𝕜}, (LT.lt.{u1} 𝕜 (Preorder.toLT.{u1} 𝕜 (PartialOrder.toPreorder.{u1} 𝕜 (OrderedCancelAddCommMonoid.toPartialOrder.{u1} 𝕜 (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} 𝕜 _inst_1))))))) (OfNat.ofNat.{u1} 𝕜 0 (OfNat.mk.{u1} 𝕜 0 (Zero.zero.{u1} 𝕜 (MulZeroClass.toHasZero.{u1} 𝕜 (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} 𝕜 (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} 𝕜 (Semiring.toNonAssocSemiring.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))))))))) c) -> (Iff (BddAbove.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) (SMul.smul.{u1, u2} 𝕜 (Set.{u2} M) (Set.smulSet.{u1, u2} 𝕜 M (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 M (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1))))))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 M (Semiring.toMonoidWithZero.{u1} 𝕜 (DivisionSemiring.toSemiring.{u1} 𝕜 (Semifield.toDivisionSemiring.{u1} 𝕜 (LinearOrderedSemifield.toSemifield.{u1} 𝕜 _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M (OrderedAddCommMonoid.toAddCommMonoid.{u2} M _inst_2)))) _inst_4)))) c s)) (BddAbove.{u2} M (PartialOrder.toPreorder.{u2} M (OrderedAddCommMonoid.toPartialOrder.{u2} M _inst_2)) s))
but is expected to have type
  forall {𝕜 : Type.{u2}} {M : Type.{u1}} [_inst_1 : LinearOrderedSemifield.{u2} 𝕜] [_inst_2 : OrderedAddCommMonoid.{u1} M] [_inst_4 : MulActionWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2)))] [_inst_6 : OrderedSMul.{u2, u1} 𝕜 M (OrderedCommSemiring.toOrderedSemiring.{u2} 𝕜 (StrictOrderedCommSemiring.toOrderedCommSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toStrictOrderedCommSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))) _inst_2 (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4)] {s : Set.{u1} M} {c : 𝕜}, (LT.lt.{u2} 𝕜 (Preorder.toLT.{u2} 𝕜 (PartialOrder.toPreorder.{u2} 𝕜 (StrictOrderedSemiring.toPartialOrder.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1)))))) (OfNat.ofNat.{u2} 𝕜 0 (Zero.toOfNat0.{u2} 𝕜 (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))))) c) -> (Iff (BddAbove.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) (HSMul.hSMul.{u2, u1, u1} 𝕜 (Set.{u1} M) (Set.{u1} M) (instHSMul.{u2, u1} 𝕜 (Set.{u1} M) (Set.smulSet.{u2, u1} 𝕜 M (SMulZeroClass.toSMul.{u2, u1} 𝕜 M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (SMulWithZero.toSMulZeroClass.{u2, u1} 𝕜 M (CommMonoidWithZero.toZero.{u2} 𝕜 (CommGroupWithZero.toCommMonoidWithZero.{u2} 𝕜 (Semifield.toCommGroupWithZero.{u2} 𝕜 (LinearOrderedSemifield.toSemifield.{u2} 𝕜 _inst_1)))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} 𝕜 M (Semiring.toMonoidWithZero.{u2} 𝕜 (StrictOrderedSemiring.toSemiring.{u2} 𝕜 (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} 𝕜 (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u2} 𝕜 (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u2} 𝕜 _inst_1))))) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M (OrderedAddCommMonoid.toAddCommMonoid.{u1} M _inst_2))) _inst_4))))) c s)) (BddAbove.{u1} M (PartialOrder.toPreorder.{u1} M (OrderedAddCommMonoid.toPartialOrder.{u1} M _inst_2)) s))
Case conversion may be inaccurate. Consider using '#align bdd_above_smul_iff_of_pos bddAbove_smul_iff_of_posₓ'. -/
@[simp]
theorem bddAbove_smul_iff_of_pos (hc : 0 < c) : BddAbove (c • s) ↔ BddAbove s :=
  (OrderIso.smulLeft _ hc).bdd_above_image
#align bdd_above_smul_iff_of_pos bddAbove_smul_iff_of_pos

end LinearOrderedSemifield

namespace Tactic

section OrderedSMul

variable [OrderedSemiring R] [OrderedAddCommMonoid M] [SMulWithZero R M] [OrderedSMul R M] {a : R}
  {b : M}

private theorem smul_nonneg_of_pos_of_nonneg (ha : 0 < a) (hb : 0 ≤ b) : 0 ≤ a • b :=
  smul_nonneg ha.le hb
#align tactic.smul_nonneg_of_pos_of_nonneg tactic.smul_nonneg_of_pos_of_nonneg

private theorem smul_nonneg_of_nonneg_of_pos (ha : 0 ≤ a) (hb : 0 < b) : 0 ≤ a • b :=
  smul_nonneg ha hb.le
#align tactic.smul_nonneg_of_nonneg_of_pos tactic.smul_nonneg_of_nonneg_of_pos

end OrderedSMul

section NoZeroSMulDivisors

variable [Zero R] [Zero M] [SMul R M] [NoZeroSMulDivisors R M] {a : R} {b : M}

private theorem smul_ne_zero_of_pos_of_ne_zero [Preorder R] (ha : 0 < a) (hb : b ≠ 0) : a • b ≠ 0 :=
  smul_ne_zero ha.ne' hb
#align tactic.smul_ne_zero_of_pos_of_ne_zero tactic.smul_ne_zero_of_pos_of_ne_zero

private theorem smul_ne_zero_of_ne_zero_of_pos [Preorder M] (ha : a ≠ 0) (hb : 0 < b) : a • b ≠ 0 :=
  smul_ne_zero ha hb.ne'
#align tactic.smul_ne_zero_of_ne_zero_of_pos tactic.smul_ne_zero_of_ne_zero_of_pos

end NoZeroSMulDivisors

open Positivity

-- failed to format: unknown constant 'term.pseudo.antiquot'
/--
      Extension for the `positivity` tactic: scalar multiplication is nonnegative/positive/nonzero if
      both sides are. -/
    @[ positivity ]
    unsafe
  def
    positivity_smul
    : expr → tactic strictness
    |
        e @ q( $ ( a ) • $ ( b ) )
        =>
        do
          let strictness_a ← core a
            let strictness_b ← core b
            match
              strictness_a , strictness_b
              with
              | positive pa , positive pb => positive <$> mk_app ` ` smul_pos [ pa , pb ]
                |
                  positive pa , nonnegative pb
                  =>
                  nonnegative <$> mk_app ` ` smul_nonneg_of_pos_of_nonneg [ pa , pb ]
                |
                  nonnegative pa , positive pb
                  =>
                  nonnegative <$> mk_app ` ` smul_nonneg_of_nonneg_of_pos [ pa , pb ]
                |
                  nonnegative pa , nonnegative pb
                  =>
                  nonnegative <$> mk_app ` ` smul_nonneg [ pa , pb ]
                |
                  positive pa , nonzero pb
                  =>
                  nonzero <$> to_expr ` `( smul_ne_zero_of_pos_of_ne_zero $ ( pa ) $ ( pb ) )
                |
                  nonzero pa , positive pb
                  =>
                  nonzero <$> to_expr ` `( smul_ne_zero_of_ne_zero_of_pos $ ( pa ) $ ( pb ) )
                |
                  nonzero pa , nonzero pb
                  =>
                  nonzero <$> to_expr ` `( smul_ne_zero $ ( pa ) $ ( pb ) )
                | sa @ _ , sb @ _ => positivity_fail e a b sa sb
      | e => pp e >>= fail ∘ format.bracket "The expression `" "` isn't of the form `a • b`"
#align tactic.positivity_smul tactic.positivity_smul

end Tactic

