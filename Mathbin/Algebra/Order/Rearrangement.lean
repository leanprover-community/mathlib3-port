/-
Copyright (c) 2022 Mantas Bakšys. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mantas Bakšys

! This file was ported from Lean 3 source module algebra.order.rearrangement
! leanprover-community/mathlib commit 25a9423c6b2c8626e91c688bfd6c1d0a986a3e6e
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.BigOperators.Basic
import Mathbin.Algebra.Order.Module
import Mathbin.Data.Prod.Lex
import Mathbin.GroupTheory.Perm.Support
import Mathbin.Order.Monotone.Monovary
import Mathbin.Tactic.Abel

/-!
# Rearrangement inequality

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file proves the rearrangement inequality and deduces the conditions for equality and strict
inequality.

The rearrangement inequality tells you that for two functions `f g : ι → α`, the sum
`∑ i, f i * g (σ i)` is maximized over all `σ : perm ι` when `g ∘ σ` monovaries with `f` and
minimized when `g ∘ σ` antivaries with `f`.

The inequality also tells you that `∑ i, f i * g (σ i) = ∑ i, f i * g i` if and only if `g ∘ σ`
monovaries with `f` when `g` monovaries with `f`. The above equality also holds if and only if
`g ∘ σ` antivaries with `f` when `g` antivaries with `f`.

From the above two statements, we deduce that the inequality is strict if and only if `g ∘ σ` does
not monovary with `f` when `g` monovaries with `f`. Analogously, the inequality is strict if and
only if `g ∘ σ` does not antivary with `f` when `g` antivaries with `f`.

## Implementation notes

In fact, we don't need much compatibility between the addition and multiplication of `α`, so we can
actually decouple them by replacing multiplication with scalar multiplication and making `f` and `g`
land in different types.
As a bonus, this makes the dual statement trivial. The multiplication versions are provided for
convenience.

The case for `monotone`/`antitone` pairs of functions over a `linear_order` is not deduced in this
file because it is easily deducible from the `monovary` API.
-/


open Equiv Equiv.Perm Finset Function OrderDual

open BigOperators

variable {ι α β : Type _}

/-! ### Scalar multiplication versions -/


section Smul

variable [LinearOrderedRing α] [LinearOrderedAddCommGroup β] [Module α β] [OrderedSMul α β]
  {s : Finset ι} {σ : Perm ι} {f : ι → α} {g : ι → β}

/- warning: monovary_on.sum_smul_comp_perm_le_sum_smul -> MonovaryOn.sum_smul_comp_perm_le_sum_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (LE.le.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_smul_comp_perm_le_sum_smul MonovaryOn.sum_smul_comp_perm_le_sum_smulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when
`f` and `g` monovary together. Stated by permuting the entries of `g`. -/
theorem MonovaryOn.sum_smul_comp_perm_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i in s, f i • g (σ i)) ≤ ∑ i in s, f i • g i := by
  classical
    revert hσ σ hfg
    apply Finset.induction_on_max_value (fun i => toLex (g i, f i)) s
    · simp only [le_rfl, Finset.sum_empty, imp_true_iff]
    intro a s has hamax hind σ hfg hσ
    set τ : perm ι := σ.trans (swap a (σ a)) with hτ
    have hτs : { x | τ x ≠ x } ⊆ s := by
      intro x hx
      simp only [Ne.def, Set.mem_setOf_eq, Equiv.coe_trans, Equiv.swap_comp_apply] at hx
      split_ifs  at hx with h₁ h₂ h₃
      · obtain rfl | hax := eq_or_ne x a
        · contradiction
        · exact mem_of_mem_insert_of_ne (hσ fun h => hax <| h.symm.trans h₁) hax
      · exact (hx <| σ.injective h₂.symm).elim
      · exact mem_of_mem_insert_of_ne (hσ hx) (ne_of_apply_ne _ h₂)
    specialize hind (hfg.subset <| subset_insert _ _) hτs
    simp_rw [sum_insert has]
    refine' le_trans _ (add_le_add_left hind _)
    obtain hσa | hσa := eq_or_ne a (σ a)
    · rw [hτ, ← hσa, swap_self, trans_refl]
    have h1s : σ⁻¹ a ∈ s := by
      rw [Ne.def, ← inv_eq_iff_eq] at hσa
      refine' mem_of_mem_insert_of_ne (hσ fun h => hσa _) hσa
      rwa [apply_inv_self, eq_comm] at h
    simp only [← s.sum_erase_add _ h1s, add_comm]
    rw [← add_assoc, ← add_assoc]
    simp only [hτ, swap_apply_left, Function.comp_apply, Equiv.coe_trans, apply_inv_self]
    refine' add_le_add (smul_add_smul_le_smul_add_smul' _ _) (sum_congr rfl fun x hx => _).le
    · specialize hamax (σ⁻¹ a) h1s
      rw [Prod.Lex.le_iff] at hamax
      cases hamax
      · exact hfg (mem_insert_of_mem h1s) (mem_insert_self _ _) hamax
      · exact hamax.2
    · specialize hamax (σ a) (mem_of_mem_insert_of_ne (hσ <| σ.injective.ne hσa.symm) hσa.symm)
      rw [Prod.Lex.le_iff] at hamax
      cases hamax
      · exact hamax.le
      · exact hamax.1.le
    · rw [mem_erase, Ne.def, eq_inv_iff_eq] at hx
      rw [swap_apply_of_ne_of_ne hx.1 (σ.injective.ne _)]
      rintro rfl
      exact has hx.2
#align monovary_on.sum_smul_comp_perm_le_sum_smul MonovaryOn.sum_smul_comp_perm_le_sum_smul

/- warning: monovary_on.sum_smul_comp_perm_eq_sum_smul_iff -> MonovaryOn.sum_smul_comp_perm_eq_sum_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (Eq.{succ u3} β (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (MonovaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f (Function.comp.{succ u1, succ u1, succ u3} ι ι β g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (Iff (Eq.{succ u1} β (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (MonovaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f (Function.comp.{succ u3, succ u3, succ u1} ι ι β g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) (Finset.toSet.{u3} ι s)))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_smul_comp_perm_eq_sum_smul_iff MonovaryOn.sum_smul_comp_perm_eq_sum_smul_iffₓ'. -/
/-- **Equality case of Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g`,
which monovary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` monovary
together. Stated by permuting the entries of `g`. -/
theorem MonovaryOn.sum_smul_comp_perm_eq_sum_smul_iff (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f i • g (σ i)) = ∑ i in s, f i • g i) ↔ MonovaryOn f (g ∘ σ) s := by
  classical
    refine' ⟨not_imp_not.1 fun h => _, fun h => (hfg.sum_smul_comp_perm_le_sum_smul hσ).antisymm _⟩
    · rw [MonovaryOn] at h
      push_neg  at h
      obtain ⟨x, hx, y, hy, hgxy, hfxy⟩ := h
      set τ : perm ι := (swap x y).trans σ
      have hτs : { x | τ x ≠ x } ⊆ s :=
        by
        refine' (set_support_mul_subset σ <| swap x y).trans (Set.union_subset hσ fun z hz => _)
        obtain ⟨_, rfl | rfl⟩ := swap_apply_ne_self_iff.1 hz <;> assumption
      refine' ((hfg.sum_smul_comp_perm_le_sum_smul hτs).trans_lt' _).Ne
      obtain rfl | hxy := eq_or_ne x y
      · cases lt_irrefl _ hfxy
      simp only [← s.sum_erase_add _ hx, ← (s.erase x).sum_erase_add _ (mem_erase.2 ⟨hxy.symm, hy⟩),
        add_assoc, Equiv.coe_trans, Function.comp_apply, swap_apply_right, swap_apply_left]
      refine'
        add_lt_add_of_le_of_lt (Finset.sum_congr rfl fun z hz => _).le
          (smul_add_smul_lt_smul_add_smul hfxy hgxy)
      simp_rw [mem_erase] at hz
      rw [swap_apply_of_ne_of_ne hz.2.1 hz.1]
    · convert h.sum_smul_comp_perm_le_sum_smul ((set_support_inv_eq _).Subset.trans hσ) using 1
      simp_rw [Function.comp_apply, apply_inv_self]
#align monovary_on.sum_smul_comp_perm_eq_sum_smul_iff MonovaryOn.sum_smul_comp_perm_eq_sum_smul_iff

/- warning: monovary_on.sum_smul_comp_perm_lt_sum_smul_iff -> MonovaryOn.sum_smul_comp_perm_lt_sum_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (LT.lt.{u3} β (Preorder.toLT.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (Not (MonovaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f (Function.comp.{succ u1, succ u1, succ u3} ι ι β g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (Iff (LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (Not (MonovaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f (Function.comp.{succ u3, succ u3, succ u1} ι ι β g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) (Finset.toSet.{u3} ι s))))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_smul_comp_perm_lt_sum_smul_iff MonovaryOn.sum_smul_comp_perm_lt_sum_smul_iffₓ'. -/
/-- **Strict inequality case of Rearrangement Inequality**: Pointwise scalar multiplication of
`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if
`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. -/
theorem MonovaryOn.sum_smul_comp_perm_lt_sum_smul_iff (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f i • g (σ i)) < ∑ i in s, f i • g i) ↔ ¬MonovaryOn f (g ∘ σ) s := by
  simp [← hfg.sum_smul_comp_perm_eq_sum_smul_iff hσ, lt_iff_le_and_ne,
    hfg.sum_smul_comp_perm_le_sum_smul hσ]
#align monovary_on.sum_smul_comp_perm_lt_sum_smul_iff MonovaryOn.sum_smul_comp_perm_lt_sum_smul_iff

/- warning: monovary_on.sum_comp_perm_smul_le_sum_smul -> MonovaryOn.sum_comp_perm_smul_le_sum_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (LE.le.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_comp_perm_smul_le_sum_smul MonovaryOn.sum_comp_perm_smul_le_sum_smulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when
`f` and `g` monovary together. Stated by permuting the entries of `f`. -/
theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i in s, f (σ i) • g i) ≤ ∑ i in s, f i • g i :=
  by
  convert hfg.sum_smul_comp_perm_le_sum_smul
      (show { x | σ⁻¹ x ≠ x } ⊆ s by simp only [set_support_inv_eq, hσ]) using
    1
  exact σ.sum_comp' s (fun i j => f i • g j) hσ
#align monovary_on.sum_comp_perm_smul_le_sum_smul MonovaryOn.sum_comp_perm_smul_le_sum_smul

/- warning: monovary_on.sum_comp_perm_smul_eq_sum_smul_iff -> MonovaryOn.sum_comp_perm_smul_eq_sum_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (Eq.{succ u3} β (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (MonovaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (Iff (Eq.{succ u1} β (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (MonovaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) (Function.comp.{succ u3, succ u3, succ u2} ι ι α f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) g (Finset.toSet.{u3} ι s)))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_comp_perm_smul_eq_sum_smul_iff MonovaryOn.sum_comp_perm_smul_eq_sum_smul_iffₓ'. -/
/-- **Equality case of Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g`,
which monovary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` monovary
together. Stated by permuting the entries of `f`. -/
theorem MonovaryOn.sum_comp_perm_smul_eq_sum_smul_iff (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f (σ i) • g i) = ∑ i in s, f i • g i) ↔ MonovaryOn (f ∘ σ) g s :=
  by
  have hσinv : { x | σ⁻¹ x ≠ x } ⊆ s := (set_support_inv_eq _).Subset.trans hσ
  refine'
    (Iff.trans _ <| hfg.sum_smul_comp_perm_eq_sum_smul_iff hσinv).trans ⟨fun h => _, fun h => _⟩
  · simpa only [σ.sum_comp' s (fun i j => f i • g j) hσ]
  · convert h.comp_right σ
    · rw [comp.assoc, inv_def, symm_comp_self, comp.right_id]
    · rw [σ.eq_preimage_iff_image_eq, Set.image_perm hσ]
  · convert h.comp_right σ.symm
    · rw [comp.assoc, self_comp_symm, comp.right_id]
    · rw [σ.symm.eq_preimage_iff_image_eq]
      exact Set.image_perm hσinv
#align monovary_on.sum_comp_perm_smul_eq_sum_smul_iff MonovaryOn.sum_comp_perm_smul_eq_sum_smul_iff

/- warning: monovary_on.sum_comp_perm_smul_lt_sum_smul_iff -> MonovaryOn.sum_comp_perm_smul_lt_sum_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (LT.lt.{u3} β (Preorder.toLT.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (Not (MonovaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (MonovaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (Iff (LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (Not (MonovaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) (Function.comp.{succ u3, succ u3, succ u2} ι ι α f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) g (Finset.toSet.{u3} ι s))))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_comp_perm_smul_lt_sum_smul_iff MonovaryOn.sum_comp_perm_smul_lt_sum_smul_iffₓ'. -/
/-- **Strict inequality case of Rearrangement Inequality**: Pointwise scalar multiplication of
`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if
`f ∘ σ` and `g` do not monovary together. Stated by permuting the entries of `f`. -/
theorem MonovaryOn.sum_comp_perm_smul_lt_sum_smul_iff (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f (σ i) • g i) < ∑ i in s, f i • g i) ↔ ¬MonovaryOn (f ∘ σ) g s := by
  simp [← hfg.sum_comp_perm_smul_eq_sum_smul_iff hσ, lt_iff_le_and_ne,
    hfg.sum_comp_perm_smul_le_sum_smul hσ]
#align monovary_on.sum_comp_perm_smul_lt_sum_smul_iff MonovaryOn.sum_comp_perm_smul_lt_sum_smul_iff

/- warning: antivary_on.sum_smul_le_sum_smul_comp_perm -> AntivaryOn.sum_smul_le_sum_smul_comp_perm is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (LE.le.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)))))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_smul_le_sum_smul_comp_perm AntivaryOn.sum_smul_le_sum_smul_comp_permₓ'. -/
/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when
`f` and `g` antivary together. Stated by permuting the entries of `g`. -/
theorem AntivaryOn.sum_smul_le_sum_smul_comp_perm (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i in s, f i • g i) ≤ ∑ i in s, f i • g (σ i) :=
  hfg.dual_right.sum_smul_comp_perm_le_sum_smul hσ
#align antivary_on.sum_smul_le_sum_smul_comp_perm AntivaryOn.sum_smul_le_sum_smul_comp_perm

/- warning: antivary_on.sum_smul_eq_sum_smul_comp_perm_iff -> AntivaryOn.sum_smul_eq_sum_smul_comp_perm_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (Eq.{succ u3} β (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (AntivaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f (Function.comp.{succ u1, succ u1, succ u3} ι ι β g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (Iff (Eq.{succ u1} β (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (AntivaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f (Function.comp.{succ u3, succ u3, succ u1} ι ι β g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) (Finset.toSet.{u3} ι s)))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_smul_eq_sum_smul_comp_perm_iff AntivaryOn.sum_smul_eq_sum_smul_comp_perm_iffₓ'. -/
/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and
`g`, which antivary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` antivary
together. Stated by permuting the entries of `g`. -/
theorem AntivaryOn.sum_smul_eq_sum_smul_comp_perm_iff (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f i • g (σ i)) = ∑ i in s, f i • g i) ↔ AntivaryOn f (g ∘ σ) s :=
  (hfg.dual_right.sum_smul_comp_perm_eq_sum_smul_iff hσ).trans monovaryOn_toDual_right
#align antivary_on.sum_smul_eq_sum_smul_comp_perm_iff AntivaryOn.sum_smul_eq_sum_smul_comp_perm_iff

/- warning: antivary_on.sum_smul_lt_sum_smul_comp_perm_iff -> AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (LT.lt.{u3} β (Preorder.toLT.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i))))) (Not (AntivaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f (Function.comp.{succ u1, succ u1, succ u3} ι ι β g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (Iff (LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i))))) (Not (AntivaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f (Function.comp.{succ u3, succ u3, succ u1} ι ι β g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) (Finset.toSet.{u3} ι s))))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_smul_lt_sum_smul_comp_perm_iff AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iffₓ'. -/
/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of
`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if
`f` and `g ∘ σ` do not antivary together. Stated by permuting the entries of `g`. -/
theorem AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iff (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f i • g i) < ∑ i in s, f i • g (σ i)) ↔ ¬AntivaryOn f (g ∘ σ) s := by
  simp [← hfg.sum_smul_eq_sum_smul_comp_perm_iff hσ, lt_iff_le_and_ne, eq_comm,
    hfg.sum_smul_le_sum_smul_comp_perm hσ]
#align antivary_on.sum_smul_lt_sum_smul_comp_perm_iff AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iff

/- warning: antivary_on.sum_smul_le_sum_comp_perm_smul -> AntivaryOn.sum_smul_le_sum_comp_perm_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (LE.le.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i))))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_smul_le_sum_comp_perm_smul AntivaryOn.sum_smul_le_sum_comp_perm_smulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when
`f` and `g` antivary together. Stated by permuting the entries of `f`. -/
theorem AntivaryOn.sum_smul_le_sum_comp_perm_smul (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i in s, f i • g i) ≤ ∑ i in s, f (σ i) • g i :=
  hfg.dual_right.sum_comp_perm_smul_le_sum_smul hσ
#align antivary_on.sum_smul_le_sum_comp_perm_smul AntivaryOn.sum_smul_le_sum_comp_perm_smul

/- warning: antivary_on.sum_smul_eq_sum_comp_perm_smul_iff -> AntivaryOn.sum_smul_eq_sum_comp_perm_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (Eq.{succ u3} β (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (AntivaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (Iff (Eq.{succ u1} β (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (AntivaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) (Function.comp.{succ u3, succ u3, succ u2} ι ι α f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) g (Finset.toSet.{u3} ι s)))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_smul_eq_sum_comp_perm_smul_iff AntivaryOn.sum_smul_eq_sum_comp_perm_smul_iffₓ'. -/
/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and
`g`, which antivary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` antivary
together. Stated by permuting the entries of `f`. -/
theorem AntivaryOn.sum_smul_eq_sum_comp_perm_smul_iff (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f (σ i) • g i) = ∑ i in s, f i • g i) ↔ AntivaryOn (f ∘ σ) g s :=
  (hfg.dual_right.sum_comp_perm_smul_eq_sum_smul_iff hσ).trans monovaryOn_toDual_right
#align antivary_on.sum_smul_eq_sum_comp_perm_smul_iff AntivaryOn.sum_smul_eq_sum_comp_perm_smul_iff

/- warning: antivary_on.sum_smul_lt_sum_comp_perm_smul_iff -> AntivaryOn.sum_smul_lt_sum_comp_perm_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (LT.lt.{u3} β (Preorder.toLT.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) s (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i)))) (Not (AntivaryOn.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {s : Finset.{u3} ι} {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β}, (AntivaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g (Finset.toSet.{u3} ι s)) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (setOf.{u3} ι (fun (x : ι) => Ne.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ x) x)) (Finset.toSet.{u3} ι s)) -> (Iff (LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i)))) (Not (AntivaryOn.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) (Function.comp.{succ u3, succ u3, succ u2} ι ι α f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) g (Finset.toSet.{u3} ι s))))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_smul_lt_sum_comp_perm_smul_iff AntivaryOn.sum_smul_lt_sum_comp_perm_smul_iffₓ'. -/
/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of
`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if
`f ∘ σ` and `g` do not antivary together. Stated by permuting the entries of `f`. -/
theorem AntivaryOn.sum_smul_lt_sum_comp_perm_smul_iff (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f i • g i) < ∑ i in s, f (σ i) • g i) ↔ ¬AntivaryOn (f ∘ σ) g s := by
  simp [← hfg.sum_smul_eq_sum_comp_perm_smul_iff hσ, eq_comm, lt_iff_le_and_ne,
    hfg.sum_smul_le_sum_comp_perm_smul hσ]
#align antivary_on.sum_smul_lt_sum_comp_perm_smul_iff AntivaryOn.sum_smul_lt_sum_comp_perm_smul_iff

variable [Fintype ι]

/- warning: monovary.sum_smul_comp_perm_le_sum_smul -> Monovary.sum_smul_comp_perm_le_sum_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Monovary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (LE.le.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Monovary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))))
Case conversion may be inaccurate. Consider using '#align monovary.sum_smul_comp_perm_le_sum_smul Monovary.sum_smul_comp_perm_le_sum_smulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when
`f` and `g` monovary together. Stated by permuting the entries of `g`. -/
theorem Monovary.sum_smul_comp_perm_le_sum_smul (hfg : Monovary f g) :
    (∑ i, f i • g (σ i)) ≤ ∑ i, f i • g i :=
  (hfg.MonovaryOn _).sum_smul_comp_perm_le_sum_smul fun i _ => mem_univ _
#align monovary.sum_smul_comp_perm_le_sum_smul Monovary.sum_smul_comp_perm_le_sum_smul

/- warning: monovary.sum_smul_comp_perm_eq_sum_smul_iff -> Monovary.sum_smul_comp_perm_eq_sum_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Monovary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (Iff (Eq.{succ u3} β (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (Monovary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f (Function.comp.{succ u1, succ u1, succ u3} ι ι β g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Monovary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (Iff (Eq.{succ u1} β (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (Monovary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f (Function.comp.{succ u3, succ u3, succ u1} ι ι β g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ))))
Case conversion may be inaccurate. Consider using '#align monovary.sum_smul_comp_perm_eq_sum_smul_iff Monovary.sum_smul_comp_perm_eq_sum_smul_iffₓ'. -/
/-- **Equality case of Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g`,
which monovary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` monovary
together. Stated by permuting the entries of `g`. -/
theorem Monovary.sum_smul_comp_perm_eq_sum_smul_iff (hfg : Monovary f g) :
    ((∑ i, f i • g (σ i)) = ∑ i, f i • g i) ↔ Monovary f (g ∘ σ) := by
  simp [(hfg.monovary_on _).sum_smul_comp_perm_eq_sum_smul_iff fun i _ => mem_univ _]
#align monovary.sum_smul_comp_perm_eq_sum_smul_iff Monovary.sum_smul_comp_perm_eq_sum_smul_iff

/- warning: monovary.sum_smul_comp_perm_lt_sum_smul_iff -> Monovary.sum_smul_comp_perm_lt_sum_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Monovary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (Iff (LT.lt.{u3} β (Preorder.toLT.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (Not (Monovary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f (Function.comp.{succ u1, succ u1, succ u3} ι ι β g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Monovary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (Iff (LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (Not (Monovary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f (Function.comp.{succ u3, succ u3, succ u1} ι ι β g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)))))
Case conversion may be inaccurate. Consider using '#align monovary.sum_smul_comp_perm_lt_sum_smul_iff Monovary.sum_smul_comp_perm_lt_sum_smul_iffₓ'. -/
/-- **Strict inequality case of Rearrangement Inequality**: Pointwise scalar multiplication of
`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if
`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. -/
theorem Monovary.sum_smul_comp_perm_lt_sum_smul_iff (hfg : Monovary f g) :
    ((∑ i, f i • g (σ i)) < ∑ i, f i • g i) ↔ ¬Monovary f (g ∘ σ) := by
  simp [(hfg.monovary_on _).sum_smul_comp_perm_lt_sum_smul_iff fun i _ => mem_univ _]
#align monovary.sum_smul_comp_perm_lt_sum_smul_iff Monovary.sum_smul_comp_perm_lt_sum_smul_iff

/- warning: monovary.sum_comp_perm_smul_le_sum_smul -> Monovary.sum_comp_perm_smul_le_sum_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Monovary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (LE.le.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Monovary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))))
Case conversion may be inaccurate. Consider using '#align monovary.sum_comp_perm_smul_le_sum_smul Monovary.sum_comp_perm_smul_le_sum_smulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when
`f` and `g` monovary together. Stated by permuting the entries of `f`. -/
theorem Monovary.sum_comp_perm_smul_le_sum_smul (hfg : Monovary f g) :
    (∑ i, f (σ i) • g i) ≤ ∑ i, f i • g i :=
  (hfg.MonovaryOn _).sum_comp_perm_smul_le_sum_smul fun i _ => mem_univ _
#align monovary.sum_comp_perm_smul_le_sum_smul Monovary.sum_comp_perm_smul_le_sum_smul

/- warning: monovary.sum_comp_perm_smul_eq_sum_smul_iff -> Monovary.sum_comp_perm_smul_eq_sum_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Monovary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (Iff (Eq.{succ u3} β (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (Monovary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Monovary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (Iff (Eq.{succ u1} β (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (Monovary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) (Function.comp.{succ u3, succ u3, succ u2} ι ι α f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) g))
Case conversion may be inaccurate. Consider using '#align monovary.sum_comp_perm_smul_eq_sum_smul_iff Monovary.sum_comp_perm_smul_eq_sum_smul_iffₓ'. -/
/-- **Equality case of Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g`,
which monovary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` monovary
together. Stated by permuting the entries of `g`. -/
theorem Monovary.sum_comp_perm_smul_eq_sum_smul_iff (hfg : Monovary f g) :
    ((∑ i, f (σ i) • g i) = ∑ i, f i • g i) ↔ Monovary (f ∘ σ) g := by
  simp [(hfg.monovary_on _).sum_comp_perm_smul_eq_sum_smul_iff fun i _ => mem_univ _]
#align monovary.sum_comp_perm_smul_eq_sum_smul_iff Monovary.sum_comp_perm_smul_eq_sum_smul_iff

/- warning: monovary.sum_comp_perm_smul_lt_sum_smul_iff -> Monovary.sum_comp_perm_smul_lt_sum_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Monovary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (Iff (LT.lt.{u3} β (Preorder.toLT.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (Not (Monovary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g)))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Monovary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (Iff (LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (Not (Monovary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) (Function.comp.{succ u3, succ u3, succ u2} ι ι α f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) g)))
Case conversion may be inaccurate. Consider using '#align monovary.sum_comp_perm_smul_lt_sum_smul_iff Monovary.sum_comp_perm_smul_lt_sum_smul_iffₓ'. -/
/-- **Strict inequality case of Rearrangement Inequality**: Pointwise scalar multiplication of
`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if
`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. -/
theorem Monovary.sum_comp_perm_smul_lt_sum_smul_iff (hfg : Monovary f g) :
    ((∑ i, f (σ i) • g i) < ∑ i, f i • g i) ↔ ¬Monovary (f ∘ σ) g := by
  simp [(hfg.monovary_on _).sum_comp_perm_smul_lt_sum_smul_iff fun i _ => mem_univ _]
#align monovary.sum_comp_perm_smul_lt_sum_smul_iff Monovary.sum_comp_perm_smul_lt_sum_smul_iff

/- warning: antivary.sum_smul_le_sum_smul_comp_perm -> Antivary.sum_smul_le_sum_smul_comp_perm is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Antivary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (LE.le.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Antivary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)))))
Case conversion may be inaccurate. Consider using '#align antivary.sum_smul_le_sum_smul_comp_perm Antivary.sum_smul_le_sum_smul_comp_permₓ'. -/
/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when
`f` and `g` antivary together. Stated by permuting the entries of `g`. -/
theorem Antivary.sum_smul_le_sum_smul_comp_perm (hfg : Antivary f g) :
    (∑ i, f i • g i) ≤ ∑ i, f i • g (σ i) :=
  (hfg.AntivaryOn _).sum_smul_le_sum_smul_comp_perm fun i _ => mem_univ _
#align antivary.sum_smul_le_sum_smul_comp_perm Antivary.sum_smul_le_sum_smul_comp_perm

/- warning: antivary.sum_smul_eq_sum_smul_comp_perm_iff -> Antivary.sum_smul_eq_sum_smul_comp_perm_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Antivary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (Iff (Eq.{succ u3} β (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (Antivary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f (Function.comp.{succ u1, succ u1, succ u3} ι ι β g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Antivary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (Iff (Eq.{succ u1} β (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (Antivary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f (Function.comp.{succ u3, succ u3, succ u1} ι ι β g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ))))
Case conversion may be inaccurate. Consider using '#align antivary.sum_smul_eq_sum_smul_comp_perm_iff Antivary.sum_smul_eq_sum_smul_comp_perm_iffₓ'. -/
/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and
`g`, which antivary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` antivary
together. Stated by permuting the entries of `g`. -/
theorem Antivary.sum_smul_eq_sum_smul_comp_perm_iff (hfg : Antivary f g) :
    ((∑ i, f i • g (σ i)) = ∑ i, f i • g i) ↔ Antivary f (g ∘ σ) := by
  simp [(hfg.antivary_on _).sum_smul_eq_sum_smul_comp_perm_iff fun i _ => mem_univ _]
#align antivary.sum_smul_eq_sum_smul_comp_perm_iff Antivary.sum_smul_eq_sum_smul_comp_perm_iff

/- warning: antivary.sum_smul_lt_sum_smul_comp_perm_iff -> Antivary.sum_smul_lt_sum_smul_comp_perm_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Antivary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (Iff (LT.lt.{u3} β (Preorder.toLT.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i))))) (Not (Antivary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f (Function.comp.{succ u1, succ u1, succ u3} ι ι β g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Antivary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (Iff (LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i))))) (Not (Antivary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f (Function.comp.{succ u3, succ u3, succ u1} ι ι β g (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)))))
Case conversion may be inaccurate. Consider using '#align antivary.sum_smul_lt_sum_smul_comp_perm_iff Antivary.sum_smul_lt_sum_smul_comp_perm_iffₓ'. -/
/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of
`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if
`f` and `g ∘ σ` do not antivary together. Stated by permuting the entries of `g`. -/
theorem Antivary.sum_smul_lt_sum_smul_comp_perm_iff (hfg : Antivary f g) :
    ((∑ i, f i • g i) < ∑ i, f i • g (σ i)) ↔ ¬Antivary f (g ∘ σ) := by
  simp [(hfg.antivary_on _).sum_smul_lt_sum_smul_comp_perm_iff fun i _ => mem_univ _]
#align antivary.sum_smul_lt_sum_smul_comp_perm_iff Antivary.sum_smul_lt_sum_smul_comp_perm_iff

/- warning: antivary.sum_smul_le_sum_comp_perm_smul -> Antivary.sum_smul_le_sum_comp_perm_smul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Antivary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (LE.le.{u3} β (Preorder.toLE.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Antivary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (LE.le.{u1} β (Preorder.toLE.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i))))
Case conversion may be inaccurate. Consider using '#align antivary.sum_smul_le_sum_comp_perm_smul Antivary.sum_smul_le_sum_comp_perm_smulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when
`f` and `g` antivary together. Stated by permuting the entries of `f`. -/
theorem Antivary.sum_smul_le_sum_comp_perm_smul (hfg : Antivary f g) :
    (∑ i, f i • g i) ≤ ∑ i, f (σ i) • g i :=
  (hfg.AntivaryOn _).sum_smul_le_sum_comp_perm_smul fun i _ => mem_univ _
#align antivary.sum_smul_le_sum_comp_perm_smul Antivary.sum_smul_le_sum_comp_perm_smul

/- warning: antivary.sum_smul_eq_sum_comp_perm_smul_iff -> Antivary.sum_smul_eq_sum_comp_perm_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Antivary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (Iff (Eq.{succ u3} β (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i)))) (Antivary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Antivary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (Iff (Eq.{succ u1} β (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i)))) (Antivary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) (Function.comp.{succ u3, succ u3, succ u2} ι ι α f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) g))
Case conversion may be inaccurate. Consider using '#align antivary.sum_smul_eq_sum_comp_perm_smul_iff Antivary.sum_smul_eq_sum_comp_perm_smul_iffₓ'. -/
/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and
`g`, which antivary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` antivary
together. Stated by permuting the entries of `f`. -/
theorem Antivary.sum_smul_eq_sum_comp_perm_smul_iff (hfg : Antivary f g) :
    ((∑ i, f (σ i) • g i) = ∑ i, f i • g i) ↔ Antivary (f ∘ σ) g := by
  simp [(hfg.antivary_on _).sum_smul_eq_sum_comp_perm_smul_iff fun i _ => mem_univ _]
#align antivary.sum_smul_eq_sum_comp_perm_smul_iff Antivary.sum_smul_eq_sum_comp_perm_smul_iff

/- warning: antivary.sum_smul_lt_sum_comp_perm_smul_iff -> Antivary.sum_smul_lt_sum_comp_perm_smul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} {β : Type.{u3}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u3} β] [_inst_3 : Module.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u3} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (StrictOrderedRing.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (OrderedAddCommMonoid.toAddCommMonoid.{u3} β (OrderedCancelAddCommMonoid.toOrderedAddCommMonoid.{u3} β (OrderedAddCommGroup.toOrderedCancelAddCommMonoid.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u1} ι], (Antivary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) f g) -> (Iff (LT.lt.{u3} β (Preorder.toLT.{u3} β (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f i) (g i))) (Finset.sum.{u3, u1} β ι (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Finset.univ.{u1} ι _inst_5) (fun (i : ι) => SMul.smul.{u2, u3} α β (SMulZeroClass.toHasSmul.{u2, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (SMulWithZero.toSmulZeroClass.{u2, u3} α β (MulZeroClass.toHasZero.{u2} α (MulZeroOneClass.toMulZeroClass.{u2} α (MonoidWithZero.toMulZeroOneClass.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (MulActionWithZero.toSMulWithZero.{u2, u3} α β (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u3} α β (Ring.toSemiring.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} β (OrderedAddCommGroup.toAddCommGroup.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) _inst_3)))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i)))) (Not (Antivary.{u1, u2, u3} ι α β (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u3} β (OrderedAddCommGroup.toPartialOrder.{u3} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u3} β _inst_2))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g)))
but is expected to have type
  forall {ι : Type.{u3}} {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : LinearOrderedRing.{u2} α] [_inst_2 : LinearOrderedAddCommGroup.{u1} β] [_inst_3 : Module.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))] [_inst_4 : OrderedSMul.{u2, u1} α β (StrictOrderedSemiring.toOrderedSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (AddMonoid.toZero.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (OrderedAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedAddCommMonoid.toOrderedAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2)))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))] {σ : Equiv.Perm.{succ u3} ι} {f : ι -> α} {g : ι -> β} [_inst_5 : Fintype.{u3} ι], (Antivary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) f g) -> (Iff (LT.lt.{u1} β (Preorder.toLT.{u1} β (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2)))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f i) (g i))) (Finset.sum.{u1, u3} β ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) (Finset.univ.{u3} ι _inst_5) (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} α β β (instHSMul.{u2, u1} α β (SMulZeroClass.toSMul.{u2, u1} α β (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (SMulWithZero.toSMulZeroClass.{u2, u1} α β (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u2, u1} α β (Semiring.toMonoidWithZero.{u2} α (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1)))) (NegZeroClass.toZero.{u1} β (SubNegZeroMonoid.toNegZeroClass.{u1} β (SubtractionMonoid.toSubNegZeroMonoid.{u1} β (SubtractionCommMonoid.toSubtractionMonoid.{u1} β (AddCommGroup.toDivisionAddCommMonoid.{u1} β (OrderedAddCommGroup.toAddCommGroup.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))))))) (Module.toMulActionWithZero.{u2, u1} α β (StrictOrderedSemiring.toSemiring.{u2} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u2} α (LinearOrderedRing.toLinearOrderedSemiring.{u2} α _inst_1))) (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} β (LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid.{u1} β (LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid.{u1} β _inst_2))) _inst_3))))) (f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ i)) (g i)))) (Not (Antivary.{u3, u2, u1} ι α β (PartialOrder.toPreorder.{u2} α (StrictOrderedRing.toPartialOrder.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))) (PartialOrder.toPreorder.{u1} β (OrderedAddCommGroup.toPartialOrder.{u1} β (LinearOrderedAddCommGroup.toOrderedAddCommGroup.{u1} β _inst_2))) (Function.comp.{succ u3, succ u3, succ u2} ι ι α f (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} ι ι) σ)) g)))
Case conversion may be inaccurate. Consider using '#align antivary.sum_smul_lt_sum_comp_perm_smul_iff Antivary.sum_smul_lt_sum_comp_perm_smul_iffₓ'. -/
/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of
`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if
`f ∘ σ` and `g` do not antivary together. Stated by permuting the entries of `f`. -/
theorem Antivary.sum_smul_lt_sum_comp_perm_smul_iff (hfg : Antivary f g) :
    ((∑ i, f i • g i) < ∑ i, f (σ i) • g i) ↔ ¬Antivary (f ∘ σ) g := by
  simp [(hfg.antivary_on _).sum_smul_lt_sum_comp_perm_smul_iff fun i _ => mem_univ _]
#align antivary.sum_smul_lt_sum_comp_perm_smul_iff Antivary.sum_smul_lt_sum_comp_perm_smul_iff

end Smul

/-!
### Multiplication versions

Special cases of the above when scalar multiplication is actually multiplication.
-/


section Mul

variable [LinearOrderedRing α] {s : Finset ι} {σ : Perm ι} {f g : ι → α}

/- warning: monovary_on.sum_mul_comp_perm_le_sum_mul -> MonovaryOn.sum_mul_comp_perm_le_sum_mul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_mul_comp_perm_le_sum_mul MonovaryOn.sum_mul_comp_perm_le_sum_mulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and
`g` monovary together. Stated by permuting the entries of `g`. -/
theorem MonovaryOn.sum_mul_comp_perm_le_sum_mul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i in s, f i * g (σ i)) ≤ ∑ i in s, f i * g i :=
  hfg.sum_smul_comp_perm_le_sum_smul hσ
#align monovary_on.sum_mul_comp_perm_le_sum_mul MonovaryOn.sum_mul_comp_perm_le_sum_mul

/- warning: monovary_on.sum_mul_comp_perm_eq_sum_mul_iff -> MonovaryOn.sum_mul_comp_perm_eq_sum_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (Eq.{succ u2} α (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (MonovaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f (Function.comp.{succ u1, succ u1, succ u2} ι ι α g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (Iff (Eq.{succ u1} α (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (MonovaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f (Function.comp.{succ u2, succ u2, succ u1} ι ι α g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) (Finset.toSet.{u2} ι s)))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_mul_comp_perm_eq_sum_mul_iff MonovaryOn.sum_mul_comp_perm_eq_sum_mul_iffₓ'. -/
/-- **Equality case of Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,
which monovary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` monovary
together. Stated by permuting the entries of `g`. -/
theorem MonovaryOn.sum_mul_comp_perm_eq_sum_mul_iff (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f i * g (σ i)) = ∑ i in s, f i * g i) ↔ MonovaryOn f (g ∘ σ) s :=
  hfg.sum_smul_comp_perm_eq_sum_smul_iff hσ
#align monovary_on.sum_mul_comp_perm_eq_sum_mul_iff MonovaryOn.sum_mul_comp_perm_eq_sum_mul_iff

/- warning: monovary_on.sum_mul_comp_perm_lt_sum_mul_iff -> MonovaryOn.sum_mul_comp_perm_lt_sum_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => SMul.smul.{u2, u2} α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => SMul.smul.{u2, u2} α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (Not (MonovaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f (Function.comp.{succ u1, succ u1, succ u2} ι ι α g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HSMul.hSMul.{u1, u1, u1} α α α (instHSMul.{u1, u1} α α (SMulZeroClass.toSMul.{u1, u1} α α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u1} α α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (MulZeroClass.toSMulWithZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HSMul.hSMul.{u1, u1, u1} α α α (instHSMul.{u1, u1} α α (SMulZeroClass.toSMul.{u1, u1} α α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u1} α α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (MulZeroClass.toSMulWithZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))))))) (f i) (g i)))) (Not (MonovaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f (Function.comp.{succ u2, succ u2, succ u1} ι ι α g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) (Finset.toSet.{u2} ι s))))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_mul_comp_perm_lt_sum_mul_iff MonovaryOn.sum_mul_comp_perm_lt_sum_mul_iffₓ'. -/
/-- **Strict inequality case of Rearrangement Inequality**: Pointwise scalar multiplication of
`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if
`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. -/
theorem MonovaryOn.sum_mul_comp_perm_lt_sum_mul_iff (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f i • g (σ i)) < ∑ i in s, f i • g i) ↔ ¬MonovaryOn f (g ∘ σ) s :=
  hfg.sum_smul_comp_perm_lt_sum_smul_iff hσ
#align monovary_on.sum_mul_comp_perm_lt_sum_mul_iff MonovaryOn.sum_mul_comp_perm_lt_sum_mul_iff

/- warning: monovary_on.sum_comp_perm_mul_le_sum_mul -> MonovaryOn.sum_comp_perm_mul_le_sum_mul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_comp_perm_mul_le_sum_mul MonovaryOn.sum_comp_perm_mul_le_sum_mulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and
`g` monovary together. Stated by permuting the entries of `f`. -/
theorem MonovaryOn.sum_comp_perm_mul_le_sum_mul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i in s, f (σ i) * g i) ≤ ∑ i in s, f i * g i :=
  hfg.sum_comp_perm_smul_le_sum_smul hσ
#align monovary_on.sum_comp_perm_mul_le_sum_mul MonovaryOn.sum_comp_perm_mul_le_sum_mul

/- warning: monovary_on.sum_comp_perm_mul_eq_sum_mul_iff -> MonovaryOn.sum_comp_perm_mul_eq_sum_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (Eq.{succ u2} α (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (MonovaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (Iff (Eq.{succ u1} α (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (MonovaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (Function.comp.{succ u2, succ u2, succ u1} ι ι α f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) g (Finset.toSet.{u2} ι s)))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_comp_perm_mul_eq_sum_mul_iff MonovaryOn.sum_comp_perm_mul_eq_sum_mul_iffₓ'. -/
/-- **Equality case of Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,
which monovary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` monovary
together. Stated by permuting the entries of `f`. -/
theorem MonovaryOn.sum_comp_perm_mul_eq_sum_mul_iff (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f (σ i) * g i) = ∑ i in s, f i * g i) ↔ MonovaryOn (f ∘ σ) g s :=
  hfg.sum_comp_perm_smul_eq_sum_smul_iff hσ
#align monovary_on.sum_comp_perm_mul_eq_sum_mul_iff MonovaryOn.sum_comp_perm_mul_eq_sum_mul_iff

/- warning: monovary_on.sum_comp_perm_mul_lt_sum_mul_iff -> MonovaryOn.sum_comp_perm_mul_lt_sum_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (Not (MonovaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (MonovaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (Not (MonovaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (Function.comp.{succ u2, succ u2, succ u1} ι ι α f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) g (Finset.toSet.{u2} ι s))))
Case conversion may be inaccurate. Consider using '#align monovary_on.sum_comp_perm_mul_lt_sum_mul_iff MonovaryOn.sum_comp_perm_mul_lt_sum_mul_iffₓ'. -/
/-- **Strict inequality case of Rearrangement Inequality**: Pointwise multiplication of
`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if
`f ∘ σ` and `g` do not monovary together. Stated by permuting the entries of `f`. -/
theorem MonovaryOn.sum_comp_perm_mul_lt_sum_mul_iff (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f (σ i) * g i) < ∑ i in s, f i * g i) ↔ ¬MonovaryOn (f ∘ σ) g s :=
  hfg.sum_comp_perm_smul_lt_sum_smul_iff hσ
#align monovary_on.sum_comp_perm_mul_lt_sum_mul_iff MonovaryOn.sum_comp_perm_mul_lt_sum_mul_iff

/- warning: antivary_on.sum_mul_le_sum_mul_comp_perm -> AntivaryOn.sum_mul_le_sum_mul_comp_perm is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)))))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_mul_le_sum_mul_comp_perm AntivaryOn.sum_mul_le_sum_mul_comp_permₓ'. -/
/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and
`g` antivary together. Stated by permuting the entries of `g`. -/
theorem AntivaryOn.sum_mul_le_sum_mul_comp_perm (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i in s, f i * g i) ≤ ∑ i in s, f i * g (σ i) :=
  hfg.sum_smul_le_sum_smul_comp_perm hσ
#align antivary_on.sum_mul_le_sum_mul_comp_perm AntivaryOn.sum_mul_le_sum_mul_comp_perm

/- warning: antivary_on.sum_mul_eq_sum_mul_comp_perm_iff -> AntivaryOn.sum_mul_eq_sum_mul_comp_perm_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (Eq.{succ u2} α (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (AntivaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f (Function.comp.{succ u1, succ u1, succ u2} ι ι α g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (Iff (Eq.{succ u1} α (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (AntivaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f (Function.comp.{succ u2, succ u2, succ u1} ι ι α g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) (Finset.toSet.{u2} ι s)))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_mul_eq_sum_mul_comp_perm_iff AntivaryOn.sum_mul_eq_sum_mul_comp_perm_iffₓ'. -/
/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,
which antivary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` antivary
together. Stated by permuting the entries of `g`. -/
theorem AntivaryOn.sum_mul_eq_sum_mul_comp_perm_iff (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f i * g (σ i)) = ∑ i in s, f i * g i) ↔ AntivaryOn f (g ∘ σ) s :=
  hfg.sum_smul_eq_sum_smul_comp_perm_iff hσ
#align antivary_on.sum_mul_eq_sum_mul_comp_perm_iff AntivaryOn.sum_mul_eq_sum_mul_comp_perm_iff

/- warning: antivary_on.sum_mul_lt_sum_mul_comp_perm_iff -> AntivaryOn.sum_mul_lt_sum_mul_comp_perm_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i))))) (Not (AntivaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f (Function.comp.{succ u1, succ u1, succ u2} ι ι α g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i))))) (Not (AntivaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f (Function.comp.{succ u2, succ u2, succ u1} ι ι α g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) (Finset.toSet.{u2} ι s))))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_mul_lt_sum_mul_comp_perm_iff AntivaryOn.sum_mul_lt_sum_mul_comp_perm_iffₓ'. -/
/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of
`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if
`f` and `g ∘ σ` do not antivary together. Stated by permuting the entries of `g`. -/
theorem AntivaryOn.sum_mul_lt_sum_mul_comp_perm_iff (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f i * g i) < ∑ i in s, f i * g (σ i)) ↔ ¬AntivaryOn f (g ∘ σ) s :=
  hfg.sum_smul_lt_sum_smul_comp_perm_iff hσ
#align antivary_on.sum_mul_lt_sum_mul_comp_perm_iff AntivaryOn.sum_mul_lt_sum_mul_comp_perm_iff

/- warning: antivary_on.sum_mul_le_sum_comp_perm_mul -> AntivaryOn.sum_mul_le_sum_comp_perm_mul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i))))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_mul_le_sum_comp_perm_mul AntivaryOn.sum_mul_le_sum_comp_perm_mulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and
`g` antivary together. Stated by permuting the entries of `f`. -/
theorem AntivaryOn.sum_mul_le_sum_comp_perm_mul (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i in s, f i * g i) ≤ ∑ i in s, f (σ i) * g i :=
  hfg.sum_smul_le_sum_comp_perm_smul hσ
#align antivary_on.sum_mul_le_sum_comp_perm_mul AntivaryOn.sum_mul_le_sum_comp_perm_mul

/- warning: antivary_on.sum_mul_eq_sum_comp_perm_mul_iff -> AntivaryOn.sum_mul_eq_sum_comp_perm_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (Eq.{succ u2} α (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (AntivaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (Iff (Eq.{succ u1} α (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (AntivaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (Function.comp.{succ u2, succ u2, succ u1} ι ι α f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) g (Finset.toSet.{u2} ι s)))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_mul_eq_sum_comp_perm_mul_iff AntivaryOn.sum_mul_eq_sum_comp_perm_mul_iffₓ'. -/
/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,
which antivary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` antivary
together. Stated by permuting the entries of `f`. -/
theorem AntivaryOn.sum_mul_eq_sum_comp_perm_mul_iff (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f (σ i) * g i) = ∑ i in s, f i * g i) ↔ AntivaryOn (f ∘ σ) g s :=
  hfg.sum_smul_eq_sum_comp_perm_smul_iff hσ
#align antivary_on.sum_mul_eq_sum_comp_perm_mul_iff AntivaryOn.sum_mul_eq_sum_comp_perm_mul_iff

/- warning: antivary_on.sum_mul_lt_sum_comp_perm_mul_iff -> AntivaryOn.sum_mul_lt_sum_comp_perm_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {s : Finset.{u1} ι} {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (HasSubset.Subset.{u1} (Set.{u1} ι) (Set.hasSubset.{u1} ι) (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ x) x)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s)) -> (Iff (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i)))) (Not (AntivaryOn.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} ι) (Set.{u1} ι) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} ι) (Set.{u1} ι) (Finset.Set.hasCoeT.{u1} ι))) s))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {s : Finset.{u2} ι} {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α}, (AntivaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g (Finset.toSet.{u2} ι s)) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.instHasSubsetSet.{u2} ι) (setOf.{u2} ι (fun (x : ι) => Ne.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) x) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ x) x)) (Finset.toSet.{u2} ι s)) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) s (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i)))) (Not (AntivaryOn.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (Function.comp.{succ u2, succ u2, succ u1} ι ι α f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) g (Finset.toSet.{u2} ι s))))
Case conversion may be inaccurate. Consider using '#align antivary_on.sum_mul_lt_sum_comp_perm_mul_iff AntivaryOn.sum_mul_lt_sum_comp_perm_mul_iffₓ'. -/
/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of
`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if
`f ∘ σ` and `g` do not antivary together. Stated by permuting the entries of `f`. -/
theorem AntivaryOn.sum_mul_lt_sum_comp_perm_mul_iff (hfg : AntivaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) :
    ((∑ i in s, f i * g i) < ∑ i in s, f (σ i) * g i) ↔ ¬AntivaryOn (f ∘ σ) g s :=
  hfg.sum_smul_lt_sum_comp_perm_smul_iff hσ
#align antivary_on.sum_mul_lt_sum_comp_perm_mul_iff AntivaryOn.sum_mul_lt_sum_comp_perm_mul_iff

variable [Fintype ι]

/- warning: monovary.sum_mul_comp_perm_le_sum_mul -> Monovary.sum_mul_comp_perm_le_sum_mul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Monovary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Monovary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))))
Case conversion may be inaccurate. Consider using '#align monovary.sum_mul_comp_perm_le_sum_mul Monovary.sum_mul_comp_perm_le_sum_mulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and
`g` monovary together. Stated by permuting the entries of `g`. -/
theorem Monovary.sum_mul_comp_perm_le_sum_mul (hfg : Monovary f g) :
    (∑ i, f i * g (σ i)) ≤ ∑ i, f i * g i :=
  hfg.sum_smul_comp_perm_le_sum_smul
#align monovary.sum_mul_comp_perm_le_sum_mul Monovary.sum_mul_comp_perm_le_sum_mul

/- warning: monovary.sum_mul_comp_perm_eq_sum_mul_iff -> Monovary.sum_mul_comp_perm_eq_sum_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Monovary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (Iff (Eq.{succ u2} α (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (Monovary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f (Function.comp.{succ u1, succ u1, succ u2} ι ι α g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Monovary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (Iff (Eq.{succ u1} α (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (Monovary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f (Function.comp.{succ u2, succ u2, succ u1} ι ι α g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ))))
Case conversion may be inaccurate. Consider using '#align monovary.sum_mul_comp_perm_eq_sum_mul_iff Monovary.sum_mul_comp_perm_eq_sum_mul_iffₓ'. -/
/-- **Equality case of Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,
which monovary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` monovary
together. Stated by permuting the entries of `g`. -/
theorem Monovary.sum_mul_comp_perm_eq_sum_mul_iff (hfg : Monovary f g) :
    ((∑ i, f i * g (σ i)) = ∑ i, f i * g i) ↔ Monovary f (g ∘ σ) :=
  hfg.sum_smul_comp_perm_eq_sum_smul_iff
#align monovary.sum_mul_comp_perm_eq_sum_mul_iff Monovary.sum_mul_comp_perm_eq_sum_mul_iff

/- warning: monovary.sum_mul_comp_perm_lt_sum_mul_iff -> Monovary.sum_mul_comp_perm_lt_sum_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Monovary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (Iff (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (Not (Monovary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f (Function.comp.{succ u1, succ u1, succ u2} ι ι α g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Monovary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (Not (Monovary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f (Function.comp.{succ u2, succ u2, succ u1} ι ι α g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)))))
Case conversion may be inaccurate. Consider using '#align monovary.sum_mul_comp_perm_lt_sum_mul_iff Monovary.sum_mul_comp_perm_lt_sum_mul_iffₓ'. -/
/-- **Strict inequality case of Rearrangement Inequality**: Pointwise multiplication of
`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if
`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. -/
theorem Monovary.sum_mul_comp_perm_lt_sum_mul_iff (hfg : Monovary f g) :
    ((∑ i, f i * g (σ i)) < ∑ i, f i * g i) ↔ ¬Monovary f (g ∘ σ) :=
  hfg.sum_smul_comp_perm_lt_sum_smul_iff
#align monovary.sum_mul_comp_perm_lt_sum_mul_iff Monovary.sum_mul_comp_perm_lt_sum_mul_iff

/- warning: monovary.sum_comp_perm_mul_le_sum_mul -> Monovary.sum_comp_perm_mul_le_sum_mul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Monovary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Monovary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))))
Case conversion may be inaccurate. Consider using '#align monovary.sum_comp_perm_mul_le_sum_mul Monovary.sum_comp_perm_mul_le_sum_mulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and
`g` monovary together. Stated by permuting the entries of `f`. -/
theorem Monovary.sum_comp_perm_mul_le_sum_mul (hfg : Monovary f g) :
    (∑ i, f (σ i) * g i) ≤ ∑ i, f i * g i :=
  hfg.sum_comp_perm_smul_le_sum_smul
#align monovary.sum_comp_perm_mul_le_sum_mul Monovary.sum_comp_perm_mul_le_sum_mul

/- warning: monovary.sum_comp_perm_mul_eq_sum_mul_iff -> Monovary.sum_comp_perm_mul_eq_sum_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Monovary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (Iff (Eq.{succ u2} α (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (Monovary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Monovary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (Iff (Eq.{succ u1} α (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (Monovary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (Function.comp.{succ u2, succ u2, succ u1} ι ι α f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) g))
Case conversion may be inaccurate. Consider using '#align monovary.sum_comp_perm_mul_eq_sum_mul_iff Monovary.sum_comp_perm_mul_eq_sum_mul_iffₓ'. -/
/-- **Equality case of Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,
which monovary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` monovary
together. Stated by permuting the entries of `g`. -/
theorem Monovary.sum_comp_perm_mul_eq_sum_mul_iff (hfg : Monovary f g) :
    ((∑ i, f (σ i) * g i) = ∑ i, f i * g i) ↔ Monovary (f ∘ σ) g :=
  hfg.sum_comp_perm_smul_eq_sum_smul_iff
#align monovary.sum_comp_perm_mul_eq_sum_mul_iff Monovary.sum_comp_perm_mul_eq_sum_mul_iff

/- warning: monovary.sum_comp_perm_mul_lt_sum_mul_iff -> Monovary.sum_comp_perm_mul_lt_sum_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Monovary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (Iff (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (Not (Monovary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g)))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Monovary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (Not (Monovary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (Function.comp.{succ u2, succ u2, succ u1} ι ι α f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) g)))
Case conversion may be inaccurate. Consider using '#align monovary.sum_comp_perm_mul_lt_sum_mul_iff Monovary.sum_comp_perm_mul_lt_sum_mul_iffₓ'. -/
/-- **Strict inequality case of Rearrangement Inequality**: Pointwise multiplication of
`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if
`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. -/
theorem Monovary.sum_comp_perm_mul_lt_sum_mul_iff (hfg : Monovary f g) :
    ((∑ i, f (σ i) * g i) < ∑ i, f i * g i) ↔ ¬Monovary (f ∘ σ) g :=
  hfg.sum_comp_perm_smul_lt_sum_smul_iff
#align monovary.sum_comp_perm_mul_lt_sum_mul_iff Monovary.sum_comp_perm_mul_lt_sum_mul_iff

/- warning: antivary.sum_mul_le_sum_mul_comp_perm -> Antivary.sum_mul_le_sum_mul_comp_perm is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Antivary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Antivary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)))))
Case conversion may be inaccurate. Consider using '#align antivary.sum_mul_le_sum_mul_comp_perm Antivary.sum_mul_le_sum_mul_comp_permₓ'. -/
/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and
`g` antivary together. Stated by permuting the entries of `g`. -/
theorem Antivary.sum_mul_le_sum_mul_comp_perm (hfg : Antivary f g) :
    (∑ i, f i * g i) ≤ ∑ i, f i * g (σ i) :=
  hfg.sum_smul_le_sum_smul_comp_perm
#align antivary.sum_mul_le_sum_mul_comp_perm Antivary.sum_mul_le_sum_mul_comp_perm

/- warning: antivary.sum_mul_eq_sum_mul_comp_perm_iff -> Antivary.sum_mul_eq_sum_mul_comp_perm_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Antivary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (Iff (Eq.{succ u2} α (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (Antivary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f (Function.comp.{succ u1, succ u1, succ u2} ι ι α g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Antivary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (Iff (Eq.{succ u1} α (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (Antivary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f (Function.comp.{succ u2, succ u2, succ u1} ι ι α g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ))))
Case conversion may be inaccurate. Consider using '#align antivary.sum_mul_eq_sum_mul_comp_perm_iff Antivary.sum_mul_eq_sum_mul_comp_perm_iffₓ'. -/
/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,
which antivary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` antivary
together. Stated by permuting the entries of `g`. -/
theorem Antivary.sum_mul_eq_sum_mul_comp_perm_iff (hfg : Antivary f g) :
    ((∑ i, f i * g (σ i)) = ∑ i, f i * g i) ↔ Antivary f (g ∘ σ) :=
  hfg.sum_smul_eq_sum_smul_comp_perm_iff
#align antivary.sum_mul_eq_sum_mul_comp_perm_iff Antivary.sum_mul_eq_sum_mul_comp_perm_iff

/- warning: antivary.sum_mul_lt_sum_mul_comp_perm_iff -> Antivary.sum_mul_lt_sum_mul_comp_perm_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Antivary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (Iff (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => SMul.smul.{u2, u2} α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => SMul.smul.{u2, u2} α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i))))) (Not (Antivary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f (Function.comp.{succ u1, succ u1, succ u2} ι ι α g (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Antivary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HSMul.hSMul.{u1, u1, u1} α α α (instHSMul.{u1, u1} α α (SMulZeroClass.toSMul.{u1, u1} α α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u1} α α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (MulZeroClass.toSMulWithZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))))))) (f i) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HSMul.hSMul.{u1, u1, u1} α α α (instHSMul.{u1, u1} α α (SMulZeroClass.toSMul.{u1, u1} α α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (SMulWithZero.toSMulZeroClass.{u1, u1} α α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (StrictOrderedSemiring.toSemiring.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1))))) (MulZeroClass.toSMulWithZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))))))) (f i) (g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i))))) (Not (Antivary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f (Function.comp.{succ u2, succ u2, succ u1} ι ι α g (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)))))
Case conversion may be inaccurate. Consider using '#align antivary.sum_mul_lt_sum_mul_comp_perm_iff Antivary.sum_mul_lt_sum_mul_comp_perm_iffₓ'. -/
/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of
`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if
`f` and `g ∘ σ` do not antivary together. Stated by permuting the entries of `g`. -/
theorem Antivary.sum_mul_lt_sum_mul_comp_perm_iff (hfg : Antivary f g) :
    ((∑ i, f i • g i) < ∑ i, f i • g (σ i)) ↔ ¬Antivary f (g ∘ σ) :=
  hfg.sum_smul_lt_sum_smul_comp_perm_iff
#align antivary.sum_mul_lt_sum_mul_comp_perm_iff Antivary.sum_mul_lt_sum_mul_comp_perm_iff

/- warning: antivary.sum_mul_le_sum_comp_perm_mul -> Antivary.sum_mul_le_sum_comp_perm_mul is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Antivary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Antivary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (LE.le.{u1} α (Preorder.toLE.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i))))
Case conversion may be inaccurate. Consider using '#align antivary.sum_mul_le_sum_comp_perm_mul Antivary.sum_mul_le_sum_comp_perm_mulₓ'. -/
/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and
`g` antivary together. Stated by permuting the entries of `f`. -/
theorem Antivary.sum_mul_le_sum_comp_perm_mul (hfg : Antivary f g) :
    (∑ i, f i * g i) ≤ ∑ i, f (σ i) * g i :=
  hfg.sum_smul_le_sum_comp_perm_smul
#align antivary.sum_mul_le_sum_comp_perm_mul Antivary.sum_mul_le_sum_comp_perm_mul

/- warning: antivary.sum_mul_eq_sum_comp_perm_mul_iff -> Antivary.sum_mul_eq_sum_comp_perm_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Antivary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (Iff (Eq.{succ u2} α (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i)))) (Antivary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Antivary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (Iff (Eq.{succ u1} α (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i)))) (Antivary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (Function.comp.{succ u2, succ u2, succ u1} ι ι α f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) g))
Case conversion may be inaccurate. Consider using '#align antivary.sum_mul_eq_sum_comp_perm_mul_iff Antivary.sum_mul_eq_sum_comp_perm_mul_iffₓ'. -/
/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,
which antivary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` antivary
together. Stated by permuting the entries of `f`. -/
theorem Antivary.sum_mul_eq_sum_comp_perm_mul_iff (hfg : Antivary f g) :
    ((∑ i, f (σ i) * g i) = ∑ i, f i * g i) ↔ Antivary (f ∘ σ) g :=
  hfg.sum_smul_eq_sum_comp_perm_smul_iff
#align antivary.sum_mul_eq_sum_comp_perm_mul_iff Antivary.sum_mul_eq_sum_comp_perm_mul_iff

/- warning: antivary.sum_mul_lt_sum_comp_perm_mul_iff -> Antivary.sum_mul_lt_sum_comp_perm_mul_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {α : Type.{u2}} [_inst_1 : LinearOrderedRing.{u2} α] {σ : Equiv.Perm.{succ u1} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u1} ι], (Antivary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) f g) -> (Iff (LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f i) (g i))) (Finset.sum.{u2, u1} α ι (AddCommGroup.toAddCommMonoid.{u2} α (OrderedAddCommGroup.toAddCommGroup.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Finset.univ.{u1} ι _inst_2) (fun (i : ι) => HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (StrictOrderedRing.toRing.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1))))) (f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ i)) (g i)))) (Not (Antivary.{u1, u2, u2} ι α α (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (PartialOrder.toPreorder.{u2} α (OrderedAddCommGroup.toPartialOrder.{u2} α (StrictOrderedRing.toOrderedAddCommGroup.{u2} α (LinearOrderedRing.toStrictOrderedRing.{u2} α _inst_1)))) (Function.comp.{succ u1, succ u1, succ u2} ι ι α f (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} ι) (fun (_x : Equiv.{succ u1, succ u1} ι ι) => ι -> ι) (Equiv.hasCoeToFun.{succ u1, succ u1} ι ι) σ)) g)))
but is expected to have type
  forall {ι : Type.{u2}} {α : Type.{u1}} [_inst_1 : LinearOrderedRing.{u1} α] {σ : Equiv.Perm.{succ u2} ι} {f : ι -> α} {g : ι -> α} [_inst_2 : Fintype.{u2} ι], (Antivary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) f g) -> (Iff (LT.lt.{u1} α (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f i) (g i))) (Finset.sum.{u1, u2} α ι (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} α (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} α (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} α (LinearOrderedRing.toLinearOrderedSemiring.{u1} α _inst_1)))) (Finset.univ.{u2} ι _inst_2) (fun (i : ι) => HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (StrictOrderedRing.toRing.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1)))))) (f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ i)) (g i)))) (Not (Antivary.{u2, u1, u1} ι α α (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (PartialOrder.toPreorder.{u1} α (StrictOrderedRing.toPartialOrder.{u1} α (LinearOrderedRing.toStrictOrderedRing.{u1} α _inst_1))) (Function.comp.{succ u2, succ u2, succ u1} ι ι α f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.Perm.{succ u2} ι) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => ι) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} ι ι) σ)) g)))
Case conversion may be inaccurate. Consider using '#align antivary.sum_mul_lt_sum_comp_perm_mul_iff Antivary.sum_mul_lt_sum_comp_perm_mul_iffₓ'. -/
/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of
`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if
`f ∘ σ` and `g` do not antivary together. Stated by permuting the entries of `f`. -/
theorem Antivary.sum_mul_lt_sum_comp_perm_mul_iff (hfg : Antivary f g) :
    ((∑ i, f i * g i) < ∑ i, f (σ i) * g i) ↔ ¬Antivary (f ∘ σ) g :=
  hfg.sum_smul_lt_sum_comp_perm_smul_iff
#align antivary.sum_mul_lt_sum_comp_perm_mul_iff Antivary.sum_mul_lt_sum_comp_perm_mul_iff

end Mul

