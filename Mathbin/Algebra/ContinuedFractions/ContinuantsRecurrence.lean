/-
Copyright (c) 2019 Kevin Kappelmann. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Kappelmann

! This file was ported from Lean 3 source module algebra.continued_fractions.continuants_recurrence
! leanprover-community/mathlib commit 5f11361a98ae4acd77f5c1837686f6f0102cdc25
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.ContinuedFractions.Translations

/-!
# Recurrence Lemmas for the `continuants` Function of Continued Fractions.

## Summary

Given a generalized continued fraction `g`, for all `n ≥ 1`, we prove that the `continuants`
function indeed satisfies the following recurrences:
- `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`, and
- `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`.
-/


namespace GeneralizedContinuedFraction

variable {K : Type _} {g : GeneralizedContinuedFraction K} {n : ℕ} [DivisionRing K]

/- warning: generalized_continued_fraction.continuants_aux_recurrence -> GeneralizedContinuedFraction.continuantsAux_recurrence is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {g : GeneralizedContinuedFraction.{u1} K} {n : Nat} [_inst_1 : DivisionRing.{u1} K] {gp : GeneralizedContinuedFraction.Pair.{u1} K} {ppred : GeneralizedContinuedFraction.Pair.{u1} K} {pred : GeneralizedContinuedFraction.Pair.{u1} K}, (Eq.{succ u1} (Option.{u1} (GeneralizedContinuedFraction.Pair.{u1} K)) (Stream'.Seq.get?.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.s.{u1} K g) n) (Option.some.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) gp)) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuantsAux.{u1} K _inst_1 g n) ppred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuantsAux.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) pred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuantsAux.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (GeneralizedContinuedFraction.Pair.mk.{u1} K (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K ppred))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K ppred)))))
but is expected to have type
  forall {K : Type.{u1}} {g : GeneralizedContinuedFraction.{u1} K} {n : Nat} [_inst_1 : DivisionRing.{u1} K] {gp : GeneralizedContinuedFraction.Pair.{u1} K} {ppred : GeneralizedContinuedFraction.Pair.{u1} K} {pred : GeneralizedContinuedFraction.Pair.{u1} K}, (Eq.{succ u1} (Option.{u1} (GeneralizedContinuedFraction.Pair.{u1} K)) (Stream'.Seq.get?.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.s.{u1} K g) n) (Option.some.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) gp)) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuantsAux.{u1} K _inst_1 g n) ppred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuantsAux.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) pred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuantsAux.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (GeneralizedContinuedFraction.Pair.mk.{u1} K (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K ppred))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K ppred)))))
Case conversion may be inaccurate. Consider using '#align generalized_continued_fraction.continuants_aux_recurrence GeneralizedContinuedFraction.continuantsAux_recurrenceₓ'. -/
theorem continuantsAux_recurrence {gp ppred pred : Pair K} (nth_s_eq : g.s.get? n = some gp)
    (nth_conts_aux_eq : g.continuantsAux n = ppred)
    (succ_nth_conts_aux_eq : g.continuantsAux (n + 1) = pred) :
    g.continuantsAux (n + 2) = ⟨gp.b * pred.a + gp.a * ppred.a, gp.b * pred.b + gp.a * ppred.b⟩ :=
  by simp [*, continuants_aux, next_continuants, next_denominator, next_numerator]
#align generalized_continued_fraction.continuants_aux_recurrence GeneralizedContinuedFraction.continuantsAux_recurrence

/- warning: generalized_continued_fraction.continuants_recurrence_aux -> GeneralizedContinuedFraction.continuants_recurrenceAux is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {g : GeneralizedContinuedFraction.{u1} K} {n : Nat} [_inst_1 : DivisionRing.{u1} K] {gp : GeneralizedContinuedFraction.Pair.{u1} K} {ppred : GeneralizedContinuedFraction.Pair.{u1} K} {pred : GeneralizedContinuedFraction.Pair.{u1} K}, (Eq.{succ u1} (Option.{u1} (GeneralizedContinuedFraction.Pair.{u1} K)) (Stream'.Seq.get?.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.s.{u1} K g) n) (Option.some.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) gp)) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuantsAux.{u1} K _inst_1 g n) ppred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuantsAux.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) pred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuants.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (GeneralizedContinuedFraction.Pair.mk.{u1} K (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K ppred))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K ppred)))))
but is expected to have type
  forall {K : Type.{u1}} {g : GeneralizedContinuedFraction.{u1} K} {n : Nat} [_inst_1 : DivisionRing.{u1} K] {gp : GeneralizedContinuedFraction.Pair.{u1} K} {ppred : GeneralizedContinuedFraction.Pair.{u1} K} {pred : GeneralizedContinuedFraction.Pair.{u1} K}, (Eq.{succ u1} (Option.{u1} (GeneralizedContinuedFraction.Pair.{u1} K)) (Stream'.Seq.get?.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.s.{u1} K g) n) (Option.some.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) gp)) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuantsAux.{u1} K _inst_1 g n) ppred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuantsAux.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) pred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuants.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (GeneralizedContinuedFraction.Pair.mk.{u1} K (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K ppred))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K ppred)))))
Case conversion may be inaccurate. Consider using '#align generalized_continued_fraction.continuants_recurrence_aux GeneralizedContinuedFraction.continuants_recurrenceAuxₓ'. -/
theorem continuants_recurrenceAux {gp ppred pred : Pair K} (nth_s_eq : g.s.get? n = some gp)
    (nth_conts_aux_eq : g.continuantsAux n = ppred)
    (succ_nth_conts_aux_eq : g.continuantsAux (n + 1) = pred) :
    g.continuants (n + 1) = ⟨gp.b * pred.a + gp.a * ppred.a, gp.b * pred.b + gp.a * ppred.b⟩ := by
  simp [nth_cont_eq_succ_nth_cont_aux,
    continuants_aux_recurrence nth_s_eq nth_conts_aux_eq succ_nth_conts_aux_eq]
#align generalized_continued_fraction.continuants_recurrence_aux GeneralizedContinuedFraction.continuants_recurrenceAux

/- warning: generalized_continued_fraction.continuants_recurrence -> GeneralizedContinuedFraction.continuants_recurrence is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {g : GeneralizedContinuedFraction.{u1} K} {n : Nat} [_inst_1 : DivisionRing.{u1} K] {gp : GeneralizedContinuedFraction.Pair.{u1} K} {ppred : GeneralizedContinuedFraction.Pair.{u1} K} {pred : GeneralizedContinuedFraction.Pair.{u1} K}, (Eq.{succ u1} (Option.{u1} (GeneralizedContinuedFraction.Pair.{u1} K)) (Stream'.Seq.get?.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.s.{u1} K g) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Option.some.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) gp)) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuants.{u1} K _inst_1 g n) ppred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuants.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) pred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuants.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (GeneralizedContinuedFraction.Pair.mk.{u1} K (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K ppred))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K ppred)))))
but is expected to have type
  forall {K : Type.{u1}} {g : GeneralizedContinuedFraction.{u1} K} {n : Nat} [_inst_1 : DivisionRing.{u1} K] {gp : GeneralizedContinuedFraction.Pair.{u1} K} {ppred : GeneralizedContinuedFraction.Pair.{u1} K} {pred : GeneralizedContinuedFraction.Pair.{u1} K}, (Eq.{succ u1} (Option.{u1} (GeneralizedContinuedFraction.Pair.{u1} K)) (Stream'.Seq.get?.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.s.{u1} K g) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Option.some.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) gp)) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuants.{u1} K _inst_1 g n) ppred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuants.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) pred) -> (Eq.{succ u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.continuants.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (GeneralizedContinuedFraction.Pair.mk.{u1} K (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.a.{u1} K ppred))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K pred)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) (GeneralizedContinuedFraction.Pair.b.{u1} K ppred)))))
Case conversion may be inaccurate. Consider using '#align generalized_continued_fraction.continuants_recurrence GeneralizedContinuedFraction.continuants_recurrenceₓ'. -/
/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/
theorem continuants_recurrence {gp ppred pred : Pair K} (succ_nth_s_eq : g.s.get? (n + 1) = some gp)
    (nth_conts_eq : g.continuants n = ppred) (succ_nth_conts_eq : g.continuants (n + 1) = pred) :
    g.continuants (n + 2) = ⟨gp.b * pred.a + gp.a * ppred.a, gp.b * pred.b + gp.a * ppred.b⟩ :=
  by
  rw [nth_cont_eq_succ_nth_cont_aux] at nth_conts_eq succ_nth_conts_eq
  exact continuants_recurrence_aux succ_nth_s_eq nth_conts_eq succ_nth_conts_eq
#align generalized_continued_fraction.continuants_recurrence GeneralizedContinuedFraction.continuants_recurrence

/- warning: generalized_continued_fraction.numerators_recurrence -> GeneralizedContinuedFraction.numerators_recurrence is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {g : GeneralizedContinuedFraction.{u1} K} {n : Nat} [_inst_1 : DivisionRing.{u1} K] {gp : GeneralizedContinuedFraction.Pair.{u1} K} {ppredA : K} {predA : K}, (Eq.{succ u1} (Option.{u1} (GeneralizedContinuedFraction.Pair.{u1} K)) (Stream'.Seq.get?.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.s.{u1} K g) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Option.some.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) gp)) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.numerators.{u1} K _inst_1 g n) ppredA) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.numerators.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) predA) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.numerators.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) predA) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) ppredA)))
but is expected to have type
  forall {K : Type.{u1}} {g : GeneralizedContinuedFraction.{u1} K} {n : Nat} [_inst_1 : DivisionRing.{u1} K] {gp : GeneralizedContinuedFraction.Pair.{u1} K} {ppredA : K} {predA : K}, (Eq.{succ u1} (Option.{u1} (GeneralizedContinuedFraction.Pair.{u1} K)) (Stream'.Seq.get?.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.s.{u1} K g) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Option.some.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) gp)) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.numerators.{u1} K _inst_1 g n) ppredA) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.numerators.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) predA) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.numerators.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) predA) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) ppredA)))
Case conversion may be inaccurate. Consider using '#align generalized_continued_fraction.numerators_recurrence GeneralizedContinuedFraction.numerators_recurrenceₓ'. -/
/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. -/
theorem numerators_recurrence {gp : Pair K} {ppredA predA : K}
    (succ_nth_s_eq : g.s.get? (n + 1) = some gp) (nth_num_eq : g.numerators n = ppredA)
    (succ_nth_num_eq : g.numerators (n + 1) = predA) :
    g.numerators (n + 2) = gp.b * predA + gp.a * ppredA :=
  by
  obtain ⟨ppredConts, nth_conts_eq, ⟨rfl⟩⟩ : ∃ conts, g.continuants n = conts ∧ conts.a = ppredA
  exact exists_conts_a_of_num nth_num_eq
  obtain ⟨predConts, succ_nth_conts_eq, ⟨rfl⟩⟩ :
    ∃ conts, g.continuants (n + 1) = conts ∧ conts.a = predA
  exact exists_conts_a_of_num succ_nth_num_eq
  rw [num_eq_conts_a, continuants_recurrence succ_nth_s_eq nth_conts_eq succ_nth_conts_eq]
#align generalized_continued_fraction.numerators_recurrence GeneralizedContinuedFraction.numerators_recurrence

/- warning: generalized_continued_fraction.denominators_recurrence -> GeneralizedContinuedFraction.denominators_recurrence is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {g : GeneralizedContinuedFraction.{u1} K} {n : Nat} [_inst_1 : DivisionRing.{u1} K] {gp : GeneralizedContinuedFraction.Pair.{u1} K} {ppredB : K} {predB : K}, (Eq.{succ u1} (Option.{u1} (GeneralizedContinuedFraction.Pair.{u1} K)) (Stream'.Seq.get?.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.s.{u1} K g) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Option.some.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) gp)) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.denominators.{u1} K _inst_1 g n) ppredB) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.denominators.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) predB) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.denominators.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) predB) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) ppredB)))
but is expected to have type
  forall {K : Type.{u1}} {g : GeneralizedContinuedFraction.{u1} K} {n : Nat} [_inst_1 : DivisionRing.{u1} K] {gp : GeneralizedContinuedFraction.Pair.{u1} K} {ppredB : K} {predB : K}, (Eq.{succ u1} (Option.{u1} (GeneralizedContinuedFraction.Pair.{u1} K)) (Stream'.Seq.get?.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) (GeneralizedContinuedFraction.s.{u1} K g) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Option.some.{u1} (GeneralizedContinuedFraction.Pair.{u1} K) gp)) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.denominators.{u1} K _inst_1 g n) ppredB) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.denominators.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) predB) -> (Eq.{succ u1} K (GeneralizedContinuedFraction.denominators.{u1} K _inst_1 g (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.b.{u1} K gp) predB) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (GeneralizedContinuedFraction.Pair.a.{u1} K gp) ppredB)))
Case conversion may be inaccurate. Consider using '#align generalized_continued_fraction.denominators_recurrence GeneralizedContinuedFraction.denominators_recurrenceₓ'. -/
/-- Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/
theorem denominators_recurrence {gp : Pair K} {ppredB predB : K}
    (succ_nth_s_eq : g.s.get? (n + 1) = some gp) (nth_denom_eq : g.denominators n = ppredB)
    (succ_nth_denom_eq : g.denominators (n + 1) = predB) :
    g.denominators (n + 2) = gp.b * predB + gp.a * ppredB :=
  by
  obtain ⟨ppredConts, nth_conts_eq, ⟨rfl⟩⟩ : ∃ conts, g.continuants n = conts ∧ conts.b = ppredB
  exact exists_conts_b_of_denom nth_denom_eq
  obtain ⟨predConts, succ_nth_conts_eq, ⟨rfl⟩⟩ :
    ∃ conts, g.continuants (n + 1) = conts ∧ conts.b = predB
  exact exists_conts_b_of_denom succ_nth_denom_eq
  rw [denom_eq_conts_b, continuants_recurrence succ_nth_s_eq nth_conts_eq succ_nth_conts_eq]
#align generalized_continued_fraction.denominators_recurrence GeneralizedContinuedFraction.denominators_recurrence

end GeneralizedContinuedFraction

