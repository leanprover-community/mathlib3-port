/-
Copyright (c) 2020 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau

! This file was ported from Lean 3 source module algebra.big_operators.finsupp
! leanprover-community/mathlib commit 842328d9df7e96fd90fc424e115679c15fb23a71
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Finsupp.Indicator
import Mathbin.Algebra.BigOperators.Pi
import Mathbin.Algebra.BigOperators.Ring
import Mathbin.Algebra.BigOperators.Order
import Mathbin.GroupTheory.Submonoid.Membership

/-!
# Big operators for finsupps

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file contains theorems relevant to big operators in finitely supported functions.
-/


noncomputable section

open Finset Function

open BigOperators

variable {α ι γ A B C : Type _} [AddCommMonoid A] [AddCommMonoid B] [AddCommMonoid C]

variable {t : ι → A → C} (h0 : ∀ i, t i 0 = 0) (h1 : ∀ i x y, t i (x + y) = t i x + t i y)

variable {s : Finset α} {f : α → ι →₀ A} (i : ι)

variable (g : ι →₀ A) (k : ι → A → γ → B) (x : γ)

variable {β M M' N P G H R S : Type _}

namespace Finsupp

/-!
### Declarations about `sum` and `prod`

In most of this section, the domain `β` is assumed to be an `add_monoid`.
-/


section SumProd

#print Finsupp.prod /-
/-- `prod f g` is the product of `g a (f a)` over the support of `f`. -/
@[to_additive "`sum f g` is the sum of `g a (f a)` over the support of `f`. "]
def prod [Zero M] [CommMonoid N] (f : α →₀ M) (g : α → M → N) : N :=
  ∏ a in f.support, g a (f a)
#align finsupp.prod Finsupp.prod
#align finsupp.sum Finsupp.sum
-/

variable [Zero M] [Zero M'] [CommMonoid N]

/- warning: finsupp.prod_of_support_subset -> Finsupp.prod_of_support_subset is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] (f : Finsupp.{u1, u2} α M _inst_4) {s : Finset.{u1} α}, (HasSubset.Subset.{u1} (Finset.{u1} α) (Finset.hasSubset.{u1} α) (Finsupp.support.{u1, u2} α M _inst_4 f) s) -> (forall (g : α -> M -> N), (forall (i : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) i s) -> (Eq.{succ u3} N (g i (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_4)))) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)))))))) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 f g) (Finset.prod.{u3, u1} N α _inst_6 s (fun (x : α) => g x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_4) (fun (_x : Finsupp.{u1, u2} α M _inst_4) => α -> M) (Finsupp.coeFun.{u1, u2} α M _inst_4) f x)))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u1} N] (f : Finsupp.{u3, u2} α M _inst_4) {s : Finset.{u3} α}, (HasSubset.Subset.{u3} (Finset.{u3} α) (Finset.instHasSubsetFinset.{u3} α) (Finsupp.support.{u3, u2} α M _inst_4 f) s) -> (forall (g : α -> M -> N), (forall (i : α), (Membership.mem.{u3, u3} α (Finset.{u3} α) (Finset.instMembershipFinset.{u3} α) i s) -> (Eq.{succ u1} N (g i (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M _inst_4))) (OfNat.ofNat.{u1} N 1 (One.toOfNat1.{u1} N (Monoid.toOne.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6)))))) -> (Eq.{succ u1} N (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 f g) (Finset.prod.{u1, u3} N α _inst_6 s (fun (x : α) => g x (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M _inst_4) f x)))))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_of_support_subset Finsupp.prod_of_support_subsetₓ'. -/
@[to_additive]
theorem prod_of_support_subset (f : α →₀ M) {s : Finset α} (hs : f.support ⊆ s) (g : α → M → N)
    (h : ∀ i ∈ s, g i 0 = 1) : f.Prod g = ∏ x in s, g x (f x) :=
  Finset.prod_subset hs fun x hxs hx => h x hxs ▸ congr_arg (g x) <| not_mem_support_iff.1 hx
#align finsupp.prod_of_support_subset Finsupp.prod_of_support_subset
#align finsupp.sum_of_support_subset Finsupp.sum_of_support_subset

/- warning: finsupp.prod_fintype -> Finsupp.prod_fintype is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] [_inst_7 : Fintype.{u1} α] (f : Finsupp.{u1, u2} α M _inst_4) (g : α -> M -> N), (forall (i : α), Eq.{succ u3} N (g i (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_4)))) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6))))))) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 f g) (Finset.prod.{u3, u1} N α _inst_6 (Finset.univ.{u1} α _inst_7) (fun (i : α) => g i (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_4) (fun (_x : Finsupp.{u1, u2} α M _inst_4) => α -> M) (Finsupp.coeFun.{u1, u2} α M _inst_4) f i))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u1} N] [_inst_7 : Fintype.{u3} α] (f : Finsupp.{u3, u2} α M _inst_4) (g : α -> M -> N), (forall (i : α), Eq.{succ u1} N (g i (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M _inst_4))) (OfNat.ofNat.{u1} N 1 (One.toOfNat1.{u1} N (Monoid.toOne.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6))))) -> (Eq.{succ u1} N (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 f g) (Finset.prod.{u1, u3} N α _inst_6 (Finset.univ.{u3} α _inst_7) (fun (i : α) => g i (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M _inst_4) f i))))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_fintype Finsupp.prod_fintypeₓ'. -/
@[to_additive]
theorem prod_fintype [Fintype α] (f : α →₀ M) (g : α → M → N) (h : ∀ i, g i 0 = 1) :
    f.Prod g = ∏ i, g i (f i) :=
  f.prod_of_support_subset (subset_univ _) g fun x _ => h x
#align finsupp.prod_fintype Finsupp.prod_fintype
#align finsupp.sum_fintype Finsupp.sum_fintype

/- warning: finsupp.prod_single_index -> Finsupp.prod_single_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] {a : α} {b : M} {h : α -> M -> N}, (Eq.{succ u3} N (h a (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_4)))) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6))))))) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 (Finsupp.single.{u1, u2} α M _inst_4 a b) h) (h a b))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] {a : α} {b : M} {h : α -> M -> N}, (Eq.{succ u3} N (h a (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M _inst_4))) (OfNat.ofNat.{u3} N 1 (One.toOfNat1.{u3} N (Monoid.toOne.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6))))) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 (Finsupp.single.{u1, u2} α M _inst_4 a b) h) (h a b))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_single_index Finsupp.prod_single_indexₓ'. -/
@[simp, to_additive]
theorem prod_single_index {a : α} {b : M} {h : α → M → N} (h_zero : h a 0 = 1) :
    (single a b).Prod h = h a b :=
  calc
    (single a b).Prod h = ∏ x in {a}, h x (single a b x) :=
      prod_of_support_subset _ support_single_subset h fun x hx =>
        (mem_singleton.1 hx).symm ▸ h_zero
    _ = h a b := by simp
    
#align finsupp.prod_single_index Finsupp.prod_single_index
#align finsupp.sum_single_index Finsupp.sum_single_index

/- warning: finsupp.prod_map_range_index -> Finsupp.prod_mapRange_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {M' : Type.{u3}} {N : Type.{u4}} [_inst_4 : Zero.{u2} M] [_inst_5 : Zero.{u3} M'] [_inst_6 : CommMonoid.{u4} N] {f : M -> M'} {hf : Eq.{succ u3} M' (f (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_4)))) (OfNat.ofNat.{u3} M' 0 (OfNat.mk.{u3} M' 0 (Zero.zero.{u3} M' _inst_5)))} {g : Finsupp.{u1, u2} α M _inst_4} {h : α -> M' -> N}, (forall (a : α), Eq.{succ u4} N (h a (OfNat.ofNat.{u3} M' 0 (OfNat.mk.{u3} M' 0 (Zero.zero.{u3} M' _inst_5)))) (OfNat.ofNat.{u4} N 1 (OfNat.mk.{u4} N 1 (One.one.{u4} N (MulOneClass.toHasOne.{u4} N (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_6))))))) -> (Eq.{succ u4} N (Finsupp.prod.{u1, u3, u4} α M' N _inst_5 _inst_6 (Finsupp.mapRange.{u1, u2, u3} α M M' _inst_4 _inst_5 f hf g) h) (Finsupp.prod.{u1, u2, u4} α M N _inst_4 _inst_6 g (fun (a : α) (b : M) => h a (f b))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u3}} {M' : Type.{u4}} {N : Type.{u1}} [_inst_4 : Zero.{u3} M] [_inst_5 : Zero.{u4} M'] [_inst_6 : CommMonoid.{u1} N] {f : M -> M'} {hf : Eq.{succ u4} M' (f (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M _inst_4))) (OfNat.ofNat.{u4} M' 0 (Zero.toOfNat0.{u4} M' _inst_5))} {g : Finsupp.{u2, u3} α M _inst_4} {h : α -> M' -> N}, (forall (a : α), Eq.{succ u1} N (h a (OfNat.ofNat.{u4} M' 0 (Zero.toOfNat0.{u4} M' _inst_5))) (OfNat.ofNat.{u1} N 1 (One.toOfNat1.{u1} N (Monoid.toOne.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6))))) -> (Eq.{succ u1} N (Finsupp.prod.{u2, u4, u1} α M' N _inst_5 _inst_6 (Finsupp.mapRange.{u2, u3, u4} α M M' _inst_4 _inst_5 f hf g) h) (Finsupp.prod.{u2, u3, u1} α M N _inst_4 _inst_6 g (fun (a : α) (b : M) => h a (f b))))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_map_range_index Finsupp.prod_mapRange_indexₓ'. -/
@[to_additive]
theorem prod_mapRange_index {f : M → M'} {hf : f 0 = 0} {g : α →₀ M} {h : α → M' → N}
    (h0 : ∀ a, h a 0 = 1) : (mapRange f hf g).Prod h = g.Prod fun a b => h a (f b) :=
  Finset.prod_subset support_mapRange fun _ _ H => by rw [not_mem_support_iff.1 H, h0]
#align finsupp.prod_map_range_index Finsupp.prod_mapRange_index
#align finsupp.sum_map_range_index Finsupp.sum_mapRange_index

/- warning: finsupp.prod_zero_index -> Finsupp.prod_zero_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] {h : α -> M -> N}, Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 (OfNat.ofNat.{max u1 u2} (Finsupp.{u1, u2} α M _inst_4) 0 (OfNat.mk.{max u1 u2} (Finsupp.{u1, u2} α M _inst_4) 0 (Zero.zero.{max u1 u2} (Finsupp.{u1, u2} α M _inst_4) (Finsupp.zero.{u1, u2} α M _inst_4)))) h) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6))))))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {N : Type.{u3}} [_inst_4 : Zero.{u1} M] [_inst_6 : CommMonoid.{u3} N] {h : α -> M -> N}, Eq.{succ u3} N (Finsupp.prod.{u2, u1, u3} α M N _inst_4 _inst_6 (OfNat.ofNat.{max u2 u1} (Finsupp.{u2, u1} α M _inst_4) 0 (Zero.toOfNat0.{max u2 u1} (Finsupp.{u2, u1} α M _inst_4) (Finsupp.zero.{u2, u1} α M _inst_4))) h) (OfNat.ofNat.{u3} N 1 (One.toOfNat1.{u3} N (Monoid.toOne.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6))))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_zero_index Finsupp.prod_zero_indexₓ'. -/
@[simp, to_additive]
theorem prod_zero_index {h : α → M → N} : (0 : α →₀ M).Prod h = 1 :=
  rfl
#align finsupp.prod_zero_index Finsupp.prod_zero_index
#align finsupp.sum_zero_index Finsupp.sum_zero_index

/- warning: finsupp.prod_comm -> Finsupp.prod_comm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {M' : Type.{u4}} {N : Type.{u5}} [_inst_4 : Zero.{u3} M] [_inst_5 : Zero.{u4} M'] [_inst_6 : CommMonoid.{u5} N] (f : Finsupp.{u1, u3} α M _inst_4) (g : Finsupp.{u2, u4} β M' _inst_5) (h : α -> M -> β -> M' -> N), Eq.{succ u5} N (Finsupp.prod.{u1, u3, u5} α M N _inst_4 _inst_6 f (fun (x : α) (v : M) => Finsupp.prod.{u2, u4, u5} β M' N _inst_5 _inst_6 g (fun (x' : β) (v' : M') => h x v x' v'))) (Finsupp.prod.{u2, u4, u5} β M' N _inst_5 _inst_6 g (fun (x' : β) (v' : M') => Finsupp.prod.{u1, u3, u5} α M N _inst_4 _inst_6 f (fun (x : α) (v : M) => h x v x' v')))
but is expected to have type
  forall {α : Type.{u5}} {β : Type.{u3}} {M : Type.{u4}} {M' : Type.{u2}} {N : Type.{u1}} [_inst_4 : Zero.{u4} M] [_inst_5 : Zero.{u2} M'] [_inst_6 : CommMonoid.{u1} N] (f : Finsupp.{u5, u4} α M _inst_4) (g : Finsupp.{u3, u2} β M' _inst_5) (h : α -> M -> β -> M' -> N), Eq.{succ u1} N (Finsupp.prod.{u5, u4, u1} α M N _inst_4 _inst_6 f (fun (x : α) (v : M) => Finsupp.prod.{u3, u2, u1} β M' N _inst_5 _inst_6 g (fun (x' : β) (v' : M') => h x v x' v'))) (Finsupp.prod.{u3, u2, u1} β M' N _inst_5 _inst_6 g (fun (x' : β) (v' : M') => Finsupp.prod.{u5, u4, u1} α M N _inst_4 _inst_6 f (fun (x : α) (v : M) => h x v x' v')))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_comm Finsupp.prod_commₓ'. -/
@[to_additive]
theorem prod_comm (f : α →₀ M) (g : β →₀ M') (h : α → M → β → M' → N) :
    (f.Prod fun x v => g.Prod fun x' v' => h x v x' v') =
      g.Prod fun x' v' => f.Prod fun x v => h x v x' v' :=
  Finset.prod_comm
#align finsupp.prod_comm Finsupp.prod_comm
#align finsupp.sum_comm Finsupp.sum_comm

/- warning: finsupp.prod_ite_eq -> Finsupp.prod_ite_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] [_inst_7 : DecidableEq.{succ u1} α] (f : Finsupp.{u1, u2} α M _inst_4) (a : α) (b : α -> M -> N), Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 f (fun (x : α) (v : M) => ite.{succ u3} N (Eq.{succ u1} α a x) (_inst_7 a x) (b x v) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)))))))) (ite.{succ u3} N (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Finsupp.support.{u1, u2} α M _inst_4 f)) (Finset.decidableMem.{u1} α (fun (a : α) (b : α) => _inst_7 a b) a (Finsupp.support.{u1, u2} α M _inst_4 f)) (b a (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_4) (fun (_x : Finsupp.{u1, u2} α M _inst_4) => α -> M) (Finsupp.coeFun.{u1, u2} α M _inst_4) f a)) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)))))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u1} N] [_inst_7 : DecidableEq.{succ u3} α] (f : Finsupp.{u3, u2} α M _inst_4) (a : α) (b : α -> M -> N), Eq.{succ u1} N (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 f (fun (x : α) (v : M) => ite.{succ u1} N (Eq.{succ u3} α a x) (_inst_7 a x) (b x v) (OfNat.ofNat.{u1} N 1 (One.toOfNat1.{u1} N (Monoid.toOne.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6)))))) (ite.{succ u1} N (Membership.mem.{u3, u3} α (Finset.{u3} α) (Finset.instMembershipFinset.{u3} α) a (Finsupp.support.{u3, u2} α M _inst_4 f)) (Finset.decidableMem.{u3} α (fun (a : α) (b : α) => _inst_7 a b) a (Finsupp.support.{u3, u2} α M _inst_4 f)) (b a (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M _inst_4) f a)) (OfNat.ofNat.{u1} N 1 (One.toOfNat1.{u1} N (Monoid.toOne.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6)))))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_ite_eq Finsupp.prod_ite_eqₓ'. -/
@[simp, to_additive]
theorem prod_ite_eq [DecidableEq α] (f : α →₀ M) (a : α) (b : α → M → N) :
    (f.Prod fun x v => ite (a = x) (b x v) 1) = ite (a ∈ f.support) (b a (f a)) 1 :=
  by
  dsimp [Finsupp.prod]
  rw [f.support.prod_ite_eq]
#align finsupp.prod_ite_eq Finsupp.prod_ite_eq
#align finsupp.sum_ite_eq Finsupp.sum_ite_eq

/- warning: finsupp.sum_ite_self_eq -> Finsupp.sum_ite_self_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_7 : DecidableEq.{succ u1} α] {N : Type.{u2}} [_inst_8 : AddCommMonoid.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)))) (a : α), Eq.{succ u2} N (Finsupp.sum.{u1, u2, u2} α N N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8))) _inst_8 f (fun (x : α) (v : N) => ite.{succ u2} N (Eq.{succ u1} α a x) (_inst_7 a x) v (OfNat.ofNat.{u2} N 0 (OfNat.mk.{u2} N 0 (Zero.zero.{u2} N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)))) (fun (_x : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)))) => α -> N) (Finsupp.coeFun.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)))) f a)
but is expected to have type
  forall {α : Type.{u2}} [_inst_7 : DecidableEq.{succ u2} α] {N : Type.{u1}} [_inst_8 : AddCommMonoid.{u1} N] (f : Finsupp.{u2, u1} α N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_8))) (a : α), Eq.{succ u1} N (Finsupp.sum.{u2, u1, u1} α N N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_8)) _inst_8 f (fun (x : α) (v : N) => ite.{succ u1} N (Eq.{succ u2} α a x) (_inst_7 a x) v (OfNat.ofNat.{u1} N 0 (Zero.toOfNat0.{u1} N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_8)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_8))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u2, u1} α N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_8))) f a)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_ite_self_eq Finsupp.sum_ite_self_eqₓ'. -/
@[simp]
theorem sum_ite_self_eq [DecidableEq α] {N : Type _} [AddCommMonoid N] (f : α →₀ N) (a : α) :
    (f.Sum fun x v => ite (a = x) v 0) = f a := by
  classical
    convert f.sum_ite_eq a fun x => id
    simp [ite_eq_right_iff.2 Eq.symm]
#align finsupp.sum_ite_self_eq Finsupp.sum_ite_self_eq

/- warning: finsupp.prod_ite_eq' -> Finsupp.prod_ite_eq' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] [_inst_7 : DecidableEq.{succ u1} α] (f : Finsupp.{u1, u2} α M _inst_4) (a : α) (b : α -> M -> N), Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 f (fun (x : α) (v : M) => ite.{succ u3} N (Eq.{succ u1} α x a) (_inst_7 x a) (b x v) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)))))))) (ite.{succ u3} N (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Finsupp.support.{u1, u2} α M _inst_4 f)) (Finset.decidableMem.{u1} α (fun (a : α) (b : α) => _inst_7 a b) a (Finsupp.support.{u1, u2} α M _inst_4 f)) (b a (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_4) (fun (_x : Finsupp.{u1, u2} α M _inst_4) => α -> M) (Finsupp.coeFun.{u1, u2} α M _inst_4) f a)) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)))))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u1} N] [_inst_7 : DecidableEq.{succ u3} α] (f : Finsupp.{u3, u2} α M _inst_4) (a : α) (b : α -> M -> N), Eq.{succ u1} N (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 f (fun (x : α) (v : M) => ite.{succ u1} N (Eq.{succ u3} α x a) (_inst_7 x a) (b x v) (OfNat.ofNat.{u1} N 1 (One.toOfNat1.{u1} N (Monoid.toOne.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6)))))) (ite.{succ u1} N (Membership.mem.{u3, u3} α (Finset.{u3} α) (Finset.instMembershipFinset.{u3} α) a (Finsupp.support.{u3, u2} α M _inst_4 f)) (Finset.decidableMem.{u3} α (fun (a : α) (b : α) => _inst_7 a b) a (Finsupp.support.{u3, u2} α M _inst_4 f)) (b a (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M _inst_4) f a)) (OfNat.ofNat.{u1} N 1 (One.toOfNat1.{u1} N (Monoid.toOne.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6)))))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_ite_eq' Finsupp.prod_ite_eq'ₓ'. -/
/-- A restatement of `prod_ite_eq` with the equality test reversed. -/
@[simp, to_additive "A restatement of `sum_ite_eq` with the equality test reversed."]
theorem prod_ite_eq' [DecidableEq α] (f : α →₀ M) (a : α) (b : α → M → N) :
    (f.Prod fun x v => ite (x = a) (b x v) 1) = ite (a ∈ f.support) (b a (f a)) 1 :=
  by
  dsimp [Finsupp.prod]
  rw [f.support.prod_ite_eq']
#align finsupp.prod_ite_eq' Finsupp.prod_ite_eq'
#align finsupp.sum_ite_eq' Finsupp.sum_ite_eq'

/- warning: finsupp.sum_ite_self_eq' -> Finsupp.sum_ite_self_eq' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_7 : DecidableEq.{succ u1} α] {N : Type.{u2}} [_inst_8 : AddCommMonoid.{u2} N] (f : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)))) (a : α), Eq.{succ u2} N (Finsupp.sum.{u1, u2, u2} α N N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8))) _inst_8 f (fun (x : α) (v : N) => ite.{succ u2} N (Eq.{succ u1} α x a) (_inst_7 x a) v (OfNat.ofNat.{u2} N 0 (OfNat.mk.{u2} N 0 (Zero.zero.{u2} N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)))))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)))) (fun (_x : Finsupp.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)))) => α -> N) (Finsupp.coeFun.{u1, u2} α N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_8)))) f a)
but is expected to have type
  forall {α : Type.{u2}} [_inst_7 : DecidableEq.{succ u2} α] {N : Type.{u1}} [_inst_8 : AddCommMonoid.{u1} N] (f : Finsupp.{u2, u1} α N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_8))) (a : α), Eq.{succ u1} N (Finsupp.sum.{u2, u1, u1} α N N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_8)) _inst_8 f (fun (x : α) (v : N) => ite.{succ u1} N (Eq.{succ u2} α x a) (_inst_7 x a) v (OfNat.ofNat.{u1} N 0 (Zero.toOfNat0.{u1} N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_8)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_8))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u2, u1} α N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_8))) f a)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_ite_self_eq' Finsupp.sum_ite_self_eq'ₓ'. -/
@[simp]
theorem sum_ite_self_eq' [DecidableEq α] {N : Type _} [AddCommMonoid N] (f : α →₀ N) (a : α) :
    (f.Sum fun x v => ite (x = a) v 0) = f a := by
  classical
    convert f.sum_ite_eq' a fun x => id
    simp [ite_eq_right_iff.2 Eq.symm]
#align finsupp.sum_ite_self_eq' Finsupp.sum_ite_self_eq'

/- warning: finsupp.prod_pow -> Finsupp.prod_pow is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {N : Type.{u2}} [_inst_6 : CommMonoid.{u2} N] [_inst_7 : Fintype.{u1} α] (f : Finsupp.{u1, 0} α Nat Nat.hasZero) (g : α -> N), Eq.{succ u2} N (Finsupp.prod.{u1, 0, u2} α Nat N Nat.hasZero _inst_6 f (fun (a : α) (b : Nat) => HPow.hPow.{u2, 0, u2} N Nat N (instHPow.{u2, 0} N Nat (Monoid.Pow.{u2} N (CommMonoid.toMonoid.{u2} N _inst_6))) (g a) b)) (Finset.prod.{u2, u1} N α _inst_6 (Finset.univ.{u1} α _inst_7) (fun (a : α) => HPow.hPow.{u2, 0, u2} N Nat N (instHPow.{u2, 0} N Nat (Monoid.Pow.{u2} N (CommMonoid.toMonoid.{u2} N _inst_6))) (g a) (coeFn.{succ u1, succ u1} (Finsupp.{u1, 0} α Nat Nat.hasZero) (fun (_x : Finsupp.{u1, 0} α Nat Nat.hasZero) => α -> Nat) (Finsupp.coeFun.{u1, 0} α Nat Nat.hasZero) f a)))
but is expected to have type
  forall {α : Type.{u2}} {N : Type.{u1}} [_inst_6 : CommMonoid.{u1} N] [_inst_7 : Fintype.{u2} α] (f : Finsupp.{u2, 0} α Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) (g : α -> N), Eq.{succ u1} N (Finsupp.prod.{u2, 0, u1} α Nat N (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) _inst_6 f (fun (a : α) (b : Nat) => HPow.hPow.{u1, 0, u1} N Nat N (instHPow.{u1, 0} N Nat (Monoid.Pow.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6))) (g a) b)) (Finset.prod.{u1, u2} N α _inst_6 (Finset.univ.{u2} α _inst_7) (fun (a : α) => HPow.hPow.{u1, 0, u1} N ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => Nat) a) N (instHPow.{u1, 0} N ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => Nat) a) (Monoid.Pow.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6))) (g a) (FunLike.coe.{succ u2, succ u2, 1} (Finsupp.{u2, 0} α Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => Nat) _x) (Finsupp.funLike.{u2, 0} α Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) f a)))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_pow Finsupp.prod_powₓ'. -/
@[simp]
theorem prod_pow [Fintype α] (f : α →₀ ℕ) (g : α → N) :
    (f.Prod fun a b => g a ^ b) = ∏ a, g a ^ f a :=
  f.prod_fintype _ fun a => pow_zero _
#align finsupp.prod_pow Finsupp.prod_pow

/- warning: finsupp.on_finset_prod -> Finsupp.onFinset_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] {s : Finset.{u1} α} {f : α -> M} {g : α -> M -> N} (hf : forall (a : α), (Ne.{succ u2} M (f a) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_4)))) -> (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a s)), (forall (a : α), Eq.{succ u3} N (g a (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_4)))) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6))))))) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 (Finsupp.onFinset.{u1, u2} α M _inst_4 s f hf) g) (Finset.prod.{u3, u1} N α _inst_6 s (fun (a : α) => g a (f a))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u1} N] {s : Finset.{u3} α} {f : α -> M} {g : α -> M -> N} (hf : forall (a : α), (Ne.{succ u2} M (f a) (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M _inst_4))) -> (Membership.mem.{u3, u3} α (Finset.{u3} α) (Finset.instMembershipFinset.{u3} α) a s)), (forall (a : α), Eq.{succ u1} N (g a (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M _inst_4))) (OfNat.ofNat.{u1} N 1 (One.toOfNat1.{u1} N (Monoid.toOne.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6))))) -> (Eq.{succ u1} N (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 (Finsupp.onFinset.{u3, u2} α M _inst_4 s f hf) g) (Finset.prod.{u1, u3} N α _inst_6 s (fun (a : α) => g a (f a))))
Case conversion may be inaccurate. Consider using '#align finsupp.on_finset_prod Finsupp.onFinset_prodₓ'. -/
/-- If `g` maps a second argument of 0 to 1, then multiplying it over the
result of `on_finset` is the same as multiplying it over the original
`finset`. -/
@[to_additive
      "If `g` maps a second argument of 0 to 0, summing it over the\nresult of `on_finset` is the same as summing it over the original\n`finset`."]
theorem onFinset_prod {s : Finset α} {f : α → M} {g : α → M → N} (hf : ∀ a, f a ≠ 0 → a ∈ s)
    (hg : ∀ a, g a 0 = 1) : (onFinset s f hf).Prod g = ∏ a in s, g a (f a) :=
  Finset.prod_subset support_onFinset_subset <| by simp (config := { contextual := true }) [*]
#align finsupp.on_finset_prod Finsupp.onFinset_prod
#align finsupp.on_finset_sum Finsupp.onFinset_sum

/- warning: finsupp.mul_prod_erase -> Finsupp.mul_prod_erase is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] (f : Finsupp.{u1, u2} α M _inst_4) (y : α) (g : α -> M -> N), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) y (Finsupp.support.{u1, u2} α M _inst_4 f)) -> (Eq.{succ u3} N (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)))) (g y (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_4) (fun (_x : Finsupp.{u1, u2} α M _inst_4) => α -> M) (Finsupp.coeFun.{u1, u2} α M _inst_4) f y)) (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 (Finsupp.erase.{u1, u2} α M _inst_4 y f) g)) (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 f g))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u1} N] (f : Finsupp.{u3, u2} α M _inst_4) (y : α) (g : α -> M -> N), (Membership.mem.{u3, u3} α (Finset.{u3} α) (Finset.instMembershipFinset.{u3} α) y (Finsupp.support.{u3, u2} α M _inst_4 f)) -> (Eq.{succ u1} N (HMul.hMul.{u1, u1, u1} N N N (instHMul.{u1} N (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6)))) (g y (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M _inst_4) f y)) (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 (Finsupp.erase.{u3, u2} α M _inst_4 y f) g)) (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 f g))
Case conversion may be inaccurate. Consider using '#align finsupp.mul_prod_erase Finsupp.mul_prod_eraseₓ'. -/
/-- Taking a product over `f : α →₀ M` is the same as multiplying the value on a single element
`y ∈ f.support` by the product over `erase y f`. -/
@[to_additive
      " Taking a sum over over `f : α →₀ M` is the same as adding the value on a\nsingle element `y ∈ f.support` to the sum over `erase y f`. "]
theorem mul_prod_erase (f : α →₀ M) (y : α) (g : α → M → N) (hyf : y ∈ f.support) :
    g y (f y) * (erase y f).Prod g = f.Prod g := by
  classical
    rw [Finsupp.prod, Finsupp.prod, ← Finset.mul_prod_erase _ _ hyf, Finsupp.support_erase,
      Finset.prod_congr rfl]
    intro h hx
    rw [Finsupp.erase_ne (ne_of_mem_erase hx)]
#align finsupp.mul_prod_erase Finsupp.mul_prod_erase
#align finsupp.add_sum_erase Finsupp.add_sum_erase

/- warning: finsupp.mul_prod_erase' -> Finsupp.mul_prod_erase' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] (f : Finsupp.{u1, u2} α M _inst_4) (y : α) (g : α -> M -> N), (forall (i : α), Eq.{succ u3} N (g i (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_4)))) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6))))))) -> (Eq.{succ u3} N (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)))) (g y (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_4) (fun (_x : Finsupp.{u1, u2} α M _inst_4) => α -> M) (Finsupp.coeFun.{u1, u2} α M _inst_4) f y)) (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 (Finsupp.erase.{u1, u2} α M _inst_4 y f) g)) (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 f g))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u1} N] (f : Finsupp.{u3, u2} α M _inst_4) (y : α) (g : α -> M -> N), (forall (i : α), Eq.{succ u1} N (g i (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M _inst_4))) (OfNat.ofNat.{u1} N 1 (One.toOfNat1.{u1} N (Monoid.toOne.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6))))) -> (Eq.{succ u1} N (HMul.hMul.{u1, u1, u1} N N N (instHMul.{u1} N (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6)))) (g y (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M _inst_4) f y)) (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 (Finsupp.erase.{u3, u2} α M _inst_4 y f) g)) (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 f g))
Case conversion may be inaccurate. Consider using '#align finsupp.mul_prod_erase' Finsupp.mul_prod_erase'ₓ'. -/
/-- Generalization of `finsupp.mul_prod_erase`: if `g` maps a second argument of 0 to 1,
then its product over `f : α →₀ M` is the same as multiplying the value on any element
`y : α` by the product over `erase y f`. -/
@[to_additive
      " Generalization of `finsupp.add_sum_erase`: if `g` maps a second argument of 0\nto 0, then its sum over `f : α →₀ M` is the same as adding the value on any element\n`y : α` to the sum over `erase y f`. "]
theorem mul_prod_erase' (f : α →₀ M) (y : α) (g : α → M → N) (hg : ∀ i : α, g i 0 = 1) :
    g y (f y) * (erase y f).Prod g = f.Prod g := by
  classical
    by_cases hyf : y ∈ f.support
    · exact Finsupp.mul_prod_erase f y g hyf
    · rw [not_mem_support_iff.mp hyf, hg y, erase_of_not_mem_support hyf, one_mul]
#align finsupp.mul_prod_erase' Finsupp.mul_prod_erase'
#align finsupp.add_sum_erase' Finsupp.add_sum_erase'

/- warning: submonoid_class.finsupp_prod_mem -> SubmonoidClass.finsupp_prod_mem is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] {S : Type.{u4}} [_inst_7 : SetLike.{u4, u3} S N] [_inst_8 : SubmonoidClass.{u4, u3} S N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)) _inst_7] (s : S) (f : Finsupp.{u1, u2} α M _inst_4) (g : α -> M -> N), (forall (c : α), (Ne.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_4) (fun (_x : Finsupp.{u1, u2} α M _inst_4) => α -> M) (Finsupp.coeFun.{u1, u2} α M _inst_4) f c) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_4)))) -> (Membership.Mem.{u3, u4} N S (SetLike.hasMem.{u4, u3} S N _inst_7) (g c (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_4) (fun (_x : Finsupp.{u1, u2} α M _inst_4) => α -> M) (Finsupp.coeFun.{u1, u2} α M _inst_4) f c)) s)) -> (Membership.Mem.{u3, u4} N S (SetLike.hasMem.{u4, u3} S N _inst_7) (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 f g) s)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} {N : Type.{u3}} [_inst_4 : Zero.{u1} M] [_inst_6 : CommMonoid.{u3} N] {S : Type.{u4}} [_inst_7 : SetLike.{u4, u3} S N] [_inst_8 : SubmonoidClass.{u4, u3} S N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)) _inst_7] (s : S) (f : Finsupp.{u2, u1} α M _inst_4) (g : α -> M -> N), (forall (c : α), (Ne.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) c) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_4) f c) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) c) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) c) _inst_4))) -> (Membership.mem.{u3, u4} N S (SetLike.instMembership.{u4, u3} S N _inst_7) (g c (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Finsupp.{u2, u1} α M _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u2, u1} α M _inst_4) f c)) s)) -> (Membership.mem.{u3, u4} N S (SetLike.instMembership.{u4, u3} S N _inst_7) (Finsupp.prod.{u2, u1, u3} α M N _inst_4 _inst_6 f g) s)
Case conversion may be inaccurate. Consider using '#align submonoid_class.finsupp_prod_mem SubmonoidClass.finsupp_prod_memₓ'. -/
@[to_additive]
theorem SubmonoidClass.finsupp_prod_mem {S : Type _} [SetLike S N] [SubmonoidClass S N] (s : S)
    (f : α →₀ M) (g : α → M → N) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ s) : f.Prod g ∈ s :=
  prod_mem fun i hi => h _ (Finsupp.mem_support_iff.mp hi)
#align submonoid_class.finsupp_prod_mem SubmonoidClass.finsupp_prod_mem
#align add_submonoid_class.finsupp_sum_mem AddSubmonoidClass.finsupp_sum_mem

/- warning: finsupp.prod_congr -> Finsupp.prod_congr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u3} N] {f : Finsupp.{u1, u2} α M _inst_4} {g1 : α -> M -> N} {g2 : α -> M -> N}, (forall (x : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x (Finsupp.support.{u1, u2} α M _inst_4 f)) -> (Eq.{succ u3} N (g1 x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_4) (fun (_x : Finsupp.{u1, u2} α M _inst_4) => α -> M) (Finsupp.coeFun.{u1, u2} α M _inst_4) f x)) (g2 x (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M _inst_4) (fun (_x : Finsupp.{u1, u2} α M _inst_4) => α -> M) (Finsupp.coeFun.{u1, u2} α M _inst_4) f x)))) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 f g1) (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_6 f g2))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_4 : Zero.{u2} M] [_inst_6 : CommMonoid.{u1} N] {f : Finsupp.{u3, u2} α M _inst_4} {g1 : α -> M -> N} {g2 : α -> M -> N}, (forall (x : α), (Membership.mem.{u3, u3} α (Finset.{u3} α) (Finset.instMembershipFinset.{u3} α) x (Finsupp.support.{u3, u2} α M _inst_4 f)) -> (Eq.{succ u1} N (g1 x (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M _inst_4) f x)) (g2 x (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M _inst_4) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M _inst_4) f x)))) -> (Eq.{succ u1} N (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 f g1) (Finsupp.prod.{u3, u2, u1} α M N _inst_4 _inst_6 f g2))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_congr Finsupp.prod_congrₓ'. -/
@[to_additive]
theorem prod_congr {f : α →₀ M} {g1 g2 : α → M → N} (h : ∀ x ∈ f.support, g1 x (f x) = g2 x (f x)) :
    f.Prod g1 = f.Prod g2 :=
  Finset.prod_congr rfl h
#align finsupp.prod_congr Finsupp.prod_congr
#align finsupp.sum_congr Finsupp.sum_congr

end SumProd

end Finsupp

/- warning: map_finsupp_prod -> map_finsupp_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_4 : Zero.{u2} M] [_inst_5 : CommMonoid.{u3} N] [_inst_6 : CommMonoid.{u4} P] {H : Type.{u5}} [_inst_7 : MonoidHomClass.{u5, u3, u4} H N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))] (h : H) (f : Finsupp.{u1, u2} α M _inst_4) (g : α -> M -> N), Eq.{succ u4} P (coeFn.{succ u5, max (succ u3) (succ u4)} H (fun (_x : H) => N -> P) (FunLike.hasCoeToFun.{succ u5, succ u3, succ u4} H N (fun (_x : N) => P) (MulHomClass.toFunLike.{u5, u3, u4} H N P (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toHasMul.{u4} P (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (MonoidHomClass.toMulHomClass.{u5, u3, u4} H N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)) _inst_7))) h (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_5 f g)) (Finsupp.prod.{u1, u2, u4} α M P _inst_4 _inst_6 f (fun (a : α) (b : M) => coeFn.{succ u5, max (succ u3) (succ u4)} H (fun (_x : H) => N -> P) (FunLike.hasCoeToFun.{succ u5, succ u3, succ u4} H N (fun (_x : N) => P) (MulHomClass.toFunLike.{u5, u3, u4} H N P (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toHasMul.{u4} P (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (MonoidHomClass.toMulHomClass.{u5, u3, u4} H N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)) _inst_7))) h (g a b)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u5}} {N : Type.{u4}} {P : Type.{u3}} [_inst_4 : Zero.{u5} M] [_inst_5 : CommMonoid.{u4} N] [_inst_6 : CommMonoid.{u3} P] {H : Type.{u2}} [_inst_7 : MonoidHomClass.{u2, u4, u3} H N P (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_5)) (Monoid.toMulOneClass.{u3} P (CommMonoid.toMonoid.{u3} P _inst_6))] (h : H) (f : Finsupp.{u1, u5} α M _inst_4) (g : α -> M -> N), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) (Finsupp.prod.{u1, u5, u4} α M N _inst_4 _inst_5 f g)) (FunLike.coe.{succ u2, succ u4, succ u3} H N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) _x) (MulHomClass.toFunLike.{u2, u4, u3} H N P (MulOneClass.toMul.{u4} N (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_5))) (MulOneClass.toMul.{u3} P (Monoid.toMulOneClass.{u3} P (CommMonoid.toMonoid.{u3} P _inst_6))) (MonoidHomClass.toMulHomClass.{u2, u4, u3} H N P (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_5)) (Monoid.toMulOneClass.{u3} P (CommMonoid.toMonoid.{u3} P _inst_6)) _inst_7)) h (Finsupp.prod.{u1, u5, u4} α M N _inst_4 _inst_5 f g)) (Finsupp.prod.{u1, u5, u3} α M P _inst_4 _inst_6 f (fun (a : α) (b : M) => FunLike.coe.{succ u2, succ u4, succ u3} H N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) _x) (MulHomClass.toFunLike.{u2, u4, u3} H N P (MulOneClass.toMul.{u4} N (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_5))) (MulOneClass.toMul.{u3} P (Monoid.toMulOneClass.{u3} P (CommMonoid.toMonoid.{u3} P _inst_6))) (MonoidHomClass.toMulHomClass.{u2, u4, u3} H N P (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_5)) (Monoid.toMulOneClass.{u3} P (CommMonoid.toMonoid.{u3} P _inst_6)) _inst_7)) h (g a b)))
Case conversion may be inaccurate. Consider using '#align map_finsupp_prod map_finsupp_prodₓ'. -/
@[to_additive]
theorem map_finsupp_prod [Zero M] [CommMonoid N] [CommMonoid P] {H : Type _} [MonoidHomClass H N P]
    (h : H) (f : α →₀ M) (g : α → M → N) : h (f.Prod g) = f.Prod fun a b => h (g a b) :=
  map_prod h _ _
#align map_finsupp_prod map_finsupp_prod
#align map_finsupp_sum map_finsupp_sum

/- warning: mul_equiv.map_finsupp_prod -> MulEquiv.map_finsupp_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_4 : Zero.{u2} M] [_inst_5 : CommMonoid.{u3} N] [_inst_6 : CommMonoid.{u4} P] (h : MulEquiv.{u3, u4} N P (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toHasMul.{u4} P (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)))) (f : Finsupp.{u1, u2} α M _inst_4) (g : α -> M -> N), Eq.{succ u4} P (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (MulEquiv.{u3, u4} N P (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toHasMul.{u4} P (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)))) (fun (_x : MulEquiv.{u3, u4} N P (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toHasMul.{u4} P (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)))) => N -> P) (MulEquiv.hasCoeToFun.{u3, u4} N P (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toHasMul.{u4} P (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)))) h (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_5 f g)) (Finsupp.prod.{u1, u2, u4} α M P _inst_4 _inst_6 f (fun (a : α) (b : M) => coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (MulEquiv.{u3, u4} N P (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toHasMul.{u4} P (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)))) (fun (_x : MulEquiv.{u3, u4} N P (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toHasMul.{u4} P (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)))) => N -> P) (MulEquiv.hasCoeToFun.{u3, u4} N P (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toHasMul.{u4} P (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)))) h (g a b)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {N : Type.{u3}} {P : Type.{u2}} [_inst_4 : Zero.{u4} M] [_inst_5 : CommMonoid.{u3} N] [_inst_6 : CommMonoid.{u2} P] (h : MulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))) (f : Finsupp.{u1, u4} α M _inst_4) (g : α -> M -> N), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) (Finsupp.prod.{u1, u4, u3} α M N _inst_4 _inst_5 f g)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))) N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))) N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)) (MulEquivClass.instMonoidHomClass.{max u3 u2, u3, u2} (MulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))) N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)) (MulEquiv.instMulEquivClassMulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))))))) h (Finsupp.prod.{u1, u4, u3} α M N _inst_4 _inst_5 f g)) (Finsupp.prod.{u1, u4, u2} α M P _inst_4 _inst_6 f (fun (a : α) (b : M) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))) N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))) N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)) (MulEquivClass.instMonoidHomClass.{max u3 u2, u3, u2} (MulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))) N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)) (MulEquiv.instMulEquivClassMulEquiv.{u3, u2} N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))))))) h (g a b)))
Case conversion may be inaccurate. Consider using '#align mul_equiv.map_finsupp_prod MulEquiv.map_finsupp_prodₓ'. -/
/-- Deprecated, use `_root_.map_finsupp_prod` instead. -/
@[to_additive "Deprecated, use `_root_.map_finsupp_sum` instead."]
protected theorem MulEquiv.map_finsupp_prod [Zero M] [CommMonoid N] [CommMonoid P] (h : N ≃* P)
    (f : α →₀ M) (g : α → M → N) : h (f.Prod g) = f.Prod fun a b => h (g a b) :=
  map_finsupp_prod h f g
#align mul_equiv.map_finsupp_prod MulEquiv.map_finsupp_prod
#align add_equiv.map_finsupp_sum AddEquiv.map_finsupp_sum

/- warning: monoid_hom.map_finsupp_prod -> MonoidHom.map_finsupp_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_4 : Zero.{u2} M] [_inst_5 : CommMonoid.{u3} N] [_inst_6 : CommMonoid.{u4} P] (h : MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (f : Finsupp.{u1, u2} α M _inst_4) (g : α -> M -> N), Eq.{succ u4} P (coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (fun (_x : MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) => N -> P) (MonoidHom.hasCoeToFun.{u3, u4} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) h (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_5 f g)) (Finsupp.prod.{u1, u2, u4} α M P _inst_4 _inst_6 f (fun (a : α) (b : M) => coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (fun (_x : MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) => N -> P) (MonoidHom.hasCoeToFun.{u3, u4} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) h (g a b)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {N : Type.{u3}} {P : Type.{u2}} [_inst_4 : Zero.{u4} M] [_inst_5 : CommMonoid.{u3} N] [_inst_6 : CommMonoid.{u2} P] (h : MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) (f : Finsupp.{u1, u4} α M _inst_4) (g : α -> M -> N), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) (Finsupp.prod.{u1, u4, u3} α M N _inst_4 _inst_5 f g)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)) (MonoidHom.monoidHomClass.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))))) h (Finsupp.prod.{u1, u4, u3} α M N _inst_4 _inst_5 f g)) (Finsupp.prod.{u1, u4, u2} α M P _inst_4 _inst_6 f (fun (a : α) (b : M) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)) (MonoidHom.monoidHomClass.{u3, u2} N P (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))))) h (g a b)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.map_finsupp_prod MonoidHom.map_finsupp_prodₓ'. -/
/-- Deprecated, use `_root_.map_finsupp_prod` instead. -/
@[to_additive "Deprecated, use `_root_.map_finsupp_sum` instead."]
protected theorem MonoidHom.map_finsupp_prod [Zero M] [CommMonoid N] [CommMonoid P] (h : N →* P)
    (f : α →₀ M) (g : α → M → N) : h (f.Prod g) = f.Prod fun a b => h (g a b) :=
  map_finsupp_prod h f g
#align monoid_hom.map_finsupp_prod MonoidHom.map_finsupp_prod
#align add_monoid_hom.map_finsupp_sum AddMonoidHom.map_finsupp_sum

/- warning: ring_hom.map_finsupp_sum -> RingHom.map_finsupp_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} {S : Type.{u4}} [_inst_4 : Zero.{u2} M] [_inst_5 : Semiring.{u3} R] [_inst_6 : Semiring.{u4} S] (h : RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u4} S _inst_6)) (f : Finsupp.{u1, u2} α M _inst_4) (g : α -> M -> R), Eq.{succ u4} S (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u4} S _inst_6)) (fun (_x : RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u4} S _inst_6)) => R -> S) (RingHom.hasCoeToFun.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u4} S _inst_6)) h (Finsupp.sum.{u1, u2, u3} α M R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_5))) f g)) (Finsupp.sum.{u1, u2, u4} α M S _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_6))) f (fun (a : α) (b : M) => coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u4} S _inst_6)) (fun (_x : RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u4} S _inst_6)) => R -> S) (RingHom.hasCoeToFun.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u4} S _inst_6)) h (g a b)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {R : Type.{u3}} {S : Type.{u2}} [_inst_4 : Zero.{u4} M] [_inst_5 : Semiring.{u3} R] [_inst_6 : Semiring.{u2} S] (h : RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6)) (f : Finsupp.{u1, u4} α M _inst_4) (g : α -> M -> R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Finsupp.sum.{u1, u4, u3} α M R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_5))) f g)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6)) R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_5))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_6))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_5)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_6)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6)) R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6) (RingHom.instRingHomClassRingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6))))) h (Finsupp.sum.{u1, u4, u3} α M R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_5))) f g)) (Finsupp.sum.{u1, u4, u2} α M S _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_6))) f (fun (a : α) (b : M) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6)) R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_5))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_6))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_5)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S _inst_6)) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6)) R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6) (RingHom.instRingHomClassRingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R _inst_5) (Semiring.toNonAssocSemiring.{u2} S _inst_6))))) h (g a b)))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_finsupp_sum RingHom.map_finsupp_sumₓ'. -/
/-- Deprecated, use `_root_.map_finsupp_sum` instead. -/
protected theorem RingHom.map_finsupp_sum [Zero M] [Semiring R] [Semiring S] (h : R →+* S)
    (f : α →₀ M) (g : α → M → R) : h (f.Sum g) = f.Sum fun a b => h (g a b) :=
  map_finsupp_sum h f g
#align ring_hom.map_finsupp_sum RingHom.map_finsupp_sum

/- warning: ring_hom.map_finsupp_prod -> RingHom.map_finsupp_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} {S : Type.{u4}} [_inst_4 : Zero.{u2} M] [_inst_5 : CommSemiring.{u3} R] [_inst_6 : CommSemiring.{u4} S] (h : RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_6))) (f : Finsupp.{u1, u2} α M _inst_4) (g : α -> M -> R), Eq.{succ u4} S (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_6))) (fun (_x : RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_6))) => R -> S) (RingHom.hasCoeToFun.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_6))) h (Finsupp.prod.{u1, u2, u3} α M R _inst_4 (CommSemiring.toCommMonoid.{u3} R _inst_5) f g)) (Finsupp.prod.{u1, u2, u4} α M S _inst_4 (CommSemiring.toCommMonoid.{u4} S _inst_6) f (fun (a : α) (b : M) => coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_6))) (fun (_x : RingHom.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_6))) => R -> S) (RingHom.hasCoeToFun.{u3, u4} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u4} S (CommSemiring.toSemiring.{u4} S _inst_6))) h (g a b)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {R : Type.{u3}} {S : Type.{u2}} [_inst_4 : Zero.{u4} M] [_inst_5 : CommSemiring.{u3} R] [_inst_6 : CommSemiring.{u2} S] (h : RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) (f : Finsupp.{u1, u4} α M _inst_4) (g : α -> M -> R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Finsupp.prod.{u1, u4, u3} α M R _inst_4 (CommSemiring.toCommMonoid.{u3} R _inst_5) f g)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6)) (RingHom.instRingHomClassRingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6)))))) h (Finsupp.prod.{u1, u4, u3} α M R _inst_4 (CommSemiring.toCommMonoid.{u3} R _inst_5) f g)) (Finsupp.prod.{u1, u4, u2} α M S _inst_4 (CommSemiring.toCommMonoid.{u2} S _inst_6) f (fun (a : α) (b : M) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) R S (NonUnitalNonAssocSemiring.toMul.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)))) (NonUnitalNonAssocSemiring.toMul.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6)))) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6))) R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6)) (RingHom.instRingHomClassRingHom.{u3, u2} R S (Semiring.toNonAssocSemiring.{u3} R (CommSemiring.toSemiring.{u3} R _inst_5)) (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S _inst_6)))))) h (g a b)))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_finsupp_prod RingHom.map_finsupp_prodₓ'. -/
/-- Deprecated, use `_root_.map_finsupp_prod` instead. -/
protected theorem RingHom.map_finsupp_prod [Zero M] [CommSemiring R] [CommSemiring S] (h : R →+* S)
    (f : α →₀ M) (g : α → M → R) : h (f.Prod g) = f.Prod fun a b => h (g a b) :=
  map_finsupp_prod h f g
#align ring_hom.map_finsupp_prod RingHom.map_finsupp_prod

/- warning: monoid_hom.coe_finsupp_prod -> MonoidHom.coe_finsupp_prod is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_4 : Zero.{u2} β] [_inst_5 : Monoid.{u3} N] [_inst_6 : CommMonoid.{u4} P] (f : Finsupp.{u1, u2} α β _inst_4) (g : α -> β -> (MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)))), Eq.{succ (max u3 u4)} (N -> P) (coeFn.{succ (max u4 u3), succ (max u3 u4)} (MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (fun (_x : MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) => N -> P) (MonoidHom.hasCoeToFun.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (Finsupp.prod.{u1, u2, max u4 u3} α β (MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) _inst_4 (MonoidHom.commMonoid.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) _inst_6) f g)) (Finsupp.prod.{u1, u2, max u3 u4} α β (N -> P) _inst_4 (Pi.commMonoid.{u3, u4} N (fun (ᾰ : N) => P) (fun (i : N) => _inst_6)) f (fun (i : α) (fi : β) => coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (fun (_x : MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) => N -> P) (MonoidHom.hasCoeToFun.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (g i fi)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u4}} {N : Type.{u3}} {P : Type.{u2}} [_inst_4 : Zero.{u4} β] [_inst_5 : Monoid.{u3} N] [_inst_6 : CommMonoid.{u2} P] (f : Finsupp.{u1, u4} α β _inst_4) (g : α -> β -> (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))), Eq.{max (succ u3) (succ u2)} (forall (ᾰ : N), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) ᾰ) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N _inst_5)) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)) (MonoidHom.monoidHomClass.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))))) (Finsupp.prod.{u1, u4, max u3 u2} α β (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) _inst_4 (MonoidHom.commMonoid.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) _inst_6) f g)) (Finsupp.prod.{u1, u4, max u3 u2} α β (forall (ᾰ : N), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) ᾰ) _inst_4 (Pi.commMonoid.{u3, u2} N (fun (ᾰ : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) ᾰ) (fun (i : N) => _inst_6)) f (fun (i : α) (fi : β) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N _inst_5)) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)) (MonoidHom.monoidHomClass.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))))) (g i fi)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.coe_finsupp_prod MonoidHom.coe_finsupp_prodₓ'. -/
@[to_additive]
theorem MonoidHom.coe_finsupp_prod [Zero β] [Monoid N] [CommMonoid P] (f : α →₀ β)
    (g : α → β → N →* P) : ⇑(f.Prod g) = f.Prod fun i fi => g i fi :=
  MonoidHom.coe_finset_prod _ _
#align monoid_hom.coe_finsupp_prod MonoidHom.coe_finsupp_prod
#align add_monoid_hom.coe_finsupp_sum AddMonoidHom.coe_finsupp_sum

/- warning: monoid_hom.finsupp_prod_apply -> MonoidHom.finsupp_prod_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_4 : Zero.{u2} β] [_inst_5 : Monoid.{u3} N] [_inst_6 : CommMonoid.{u4} P] (f : Finsupp.{u1, u2} α β _inst_4) (g : α -> β -> (MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6)))) (x : N), Eq.{succ u4} P (coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (fun (_x : MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) => N -> P) (MonoidHom.hasCoeToFun.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (Finsupp.prod.{u1, u2, max u4 u3} α β (MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) _inst_4 (MonoidHom.commMonoid.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) _inst_6) f g) x) (Finsupp.prod.{u1, u2, u4} α β P _inst_4 _inst_6 f (fun (i : α) (fi : β) => coeFn.{max (succ u4) (succ u3), max (succ u3) (succ u4)} (MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (fun (_x : MonoidHom.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) => N -> P) (MonoidHom.hasCoeToFun.{u3, u4} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u4} P (CommMonoid.toMonoid.{u4} P _inst_6))) (g i fi) x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u4}} {N : Type.{u3}} {P : Type.{u2}} [_inst_4 : Zero.{u4} β] [_inst_5 : Monoid.{u3} N] [_inst_6 : CommMonoid.{u2} P] (f : Finsupp.{u1, u4} α β _inst_4) (g : α -> β -> (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)))) (x : N), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N _inst_5)) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)) (MonoidHom.monoidHomClass.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))))) (Finsupp.prod.{u1, u4, max u3 u2} α β (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) _inst_4 (MonoidHom.commMonoid.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) _inst_6) f g) x) (Finsupp.prod.{u1, u4, u2} α β ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) x) _inst_4 _inst_6 f (fun (i : α) (fi : β) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : N) => P) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N _inst_5)) (MulOneClass.toMul.{u2} P (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))) N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6)) (MonoidHom.monoidHomClass.{u3, u2} N P (Monoid.toMulOneClass.{u3} N _inst_5) (Monoid.toMulOneClass.{u2} P (CommMonoid.toMonoid.{u2} P _inst_6))))) (g i fi) x))
Case conversion may be inaccurate. Consider using '#align monoid_hom.finsupp_prod_apply MonoidHom.finsupp_prod_applyₓ'. -/
@[simp, to_additive]
theorem MonoidHom.finsupp_prod_apply [Zero β] [Monoid N] [CommMonoid P] (f : α →₀ β)
    (g : α → β → N →* P) (x : N) : f.Prod g x = f.Prod fun i fi => g i fi x :=
  MonoidHom.finset_prod_apply _ _ _
#align monoid_hom.finsupp_prod_apply MonoidHom.finsupp_prod_apply
#align add_monoid_hom.finsupp_sum_apply AddMonoidHom.finsupp_sum_apply

namespace Finsupp

/- warning: finsupp.single_multiset_sum -> Finsupp.single_multiset_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] (s : Multiset.{u2} M) (a : α), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) a (Multiset.sum.{u2} M _inst_4 s)) (Multiset.sum.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4) (Multiset.map.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) a) s))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] (s : Multiset.{u2} M) (a : α), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.single.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) a (Multiset.sum.{u2} M _inst_4 s)) (Multiset.sum.{max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4) (Multiset.map.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.single.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) a) s))
Case conversion may be inaccurate. Consider using '#align finsupp.single_multiset_sum Finsupp.single_multiset_sumₓ'. -/
theorem single_multiset_sum [AddCommMonoid M] (s : Multiset M) (a : α) :
    single a s.Sum = (s.map (single a)).Sum :=
  Multiset.induction_on s (single_zero _) fun a s ih => by
    rw [Multiset.sum_cons, single_add, ih, Multiset.map_cons, Multiset.sum_cons]
#align finsupp.single_multiset_sum Finsupp.single_multiset_sum

/- warning: finsupp.single_finset_sum -> Finsupp.single_finset_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M] (s : Finset.{u2} ι) (f : ι -> M) (a : α), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) (Finsupp.single.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) a (Finset.sum.{u3, u2} M ι _inst_4 s (fun (b : ι) => f b))) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) ι (Finsupp.addCommMonoid.{u1, u3} α M _inst_4) s (fun (b : ι) => Finsupp.single.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) a (f b)))
but is expected to have type
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M] (s : Finset.{u2} ι) (f : ι -> M) (a : α), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Finsupp.single.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) a (Finset.sum.{u3, u2} M ι _inst_4 s (fun (b : ι) => f b))) (Finset.sum.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) ι (Finsupp.addCommMonoid.{u1, u3} α M _inst_4) s (fun (b : ι) => Finsupp.single.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) a (f b)))
Case conversion may be inaccurate. Consider using '#align finsupp.single_finset_sum Finsupp.single_finset_sumₓ'. -/
theorem single_finset_sum [AddCommMonoid M] (s : Finset ι) (f : ι → M) (a : α) :
    single a (∑ b in s, f b) = ∑ b in s, single a (f b) :=
  by
  trans
  apply single_multiset_sum
  rw [Multiset.map_map]
  rfl
#align finsupp.single_finset_sum Finsupp.single_finset_sum

/- warning: finsupp.single_sum -> Finsupp.single_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_4 : Zero.{u3} M] [_inst_5 : AddCommMonoid.{u4} N] (s : Finsupp.{u2, u3} ι M _inst_4) (f : ι -> M -> N) (a : α), Eq.{max (succ u1) (succ u4)} (Finsupp.{u1, u4} α N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) (Finsupp.single.{u1, u4} α N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))) a (Finsupp.sum.{u2, u3, u4} ι M N _inst_4 _inst_5 s f)) (Finsupp.sum.{u2, u3, max u1 u4} ι M (Finsupp.{u1, u4} α N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) _inst_4 (Finsupp.addCommMonoid.{u1, u4} α N _inst_5) s (fun (d : ι) (c : M) => Finsupp.single.{u1, u4} α N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))) a (f d c)))
but is expected to have type
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u4}} {N : Type.{u3}} [_inst_4 : Zero.{u4} M] [_inst_5 : AddCommMonoid.{u3} N] (s : Finsupp.{u2, u4} ι M _inst_4) (f : ι -> M -> N) (a : α), Eq.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Finsupp.single.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) a (Finsupp.sum.{u2, u4, u3} ι M N _inst_4 _inst_5 s f)) (Finsupp.sum.{u2, u4, max u3 u1} ι M (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) _inst_4 (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) s (fun (d : ι) (c : M) => Finsupp.single.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) a (f d c)))
Case conversion may be inaccurate. Consider using '#align finsupp.single_sum Finsupp.single_sumₓ'. -/
theorem single_sum [Zero M] [AddCommMonoid N] (s : ι →₀ M) (f : ι → M → N) (a : α) :
    single a (s.Sum f) = s.Sum fun d c => single a (f d c) :=
  single_finset_sum _ _ _
#align finsupp.single_sum Finsupp.single_sum

/- warning: finsupp.prod_neg_index -> Finsupp.prod_neg_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_4 : AddGroup.{u3} G] [_inst_5 : CommMonoid.{u2} M] {g : Finsupp.{u1, u3} α G (AddZeroClass.toHasZero.{u3} G (AddMonoid.toAddZeroClass.{u3} G (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G _inst_4))))} {h : α -> G -> M}, (forall (a : α), Eq.{succ u2} M (h a (OfNat.ofNat.{u3} G 0 (OfNat.mk.{u3} G 0 (Zero.zero.{u3} G (AddZeroClass.toHasZero.{u3} G (AddMonoid.toAddZeroClass.{u3} G (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G _inst_4)))))))) (OfNat.ofNat.{u2} M 1 (OfNat.mk.{u2} M 1 (One.one.{u2} M (MulOneClass.toHasOne.{u2} M (Monoid.toMulOneClass.{u2} M (CommMonoid.toMonoid.{u2} M _inst_5))))))) -> (Eq.{succ u2} M (Finsupp.prod.{u1, u3, u2} α G M (AddZeroClass.toHasZero.{u3} G (AddMonoid.toAddZeroClass.{u3} G (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G _inst_4)))) _inst_5 (Neg.neg.{max u1 u3} (Finsupp.{u1, u3} α G (AddZeroClass.toHasZero.{u3} G (AddMonoid.toAddZeroClass.{u3} G (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G _inst_4))))) (Finsupp.neg.{u1, u3} α G (SubNegZeroMonoid.toNegZeroClass.{u3} G (SubtractionMonoid.toSubNegZeroMonoid.{u3} G (AddGroup.toSubtractionMonoid.{u3} G _inst_4)))) g) h) (Finsupp.prod.{u1, u3, u2} α G M (AddZeroClass.toHasZero.{u3} G (AddMonoid.toAddZeroClass.{u3} G (SubNegMonoid.toAddMonoid.{u3} G (AddGroup.toSubNegMonoid.{u3} G _inst_4)))) _inst_5 g (fun (a : α) (b : G) => h a (Neg.neg.{u3} G (SubNegMonoid.toHasNeg.{u3} G (AddGroup.toSubNegMonoid.{u3} G _inst_4)) b))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_4 : AddGroup.{u3} G] [_inst_5 : CommMonoid.{u2} M] {g : Finsupp.{u1, u3} α G (NegZeroClass.toZero.{u3} G (SubNegZeroMonoid.toNegZeroClass.{u3} G (SubtractionMonoid.toSubNegZeroMonoid.{u3} G (AddGroup.toSubtractionMonoid.{u3} G _inst_4))))} {h : α -> G -> M}, (forall (a : α), Eq.{succ u2} M (h a (OfNat.ofNat.{u3} G 0 (Zero.toOfNat0.{u3} G (NegZeroClass.toZero.{u3} G (SubNegZeroMonoid.toNegZeroClass.{u3} G (SubtractionMonoid.toSubNegZeroMonoid.{u3} G (AddGroup.toSubtractionMonoid.{u3} G _inst_4))))))) (OfNat.ofNat.{u2} M 1 (One.toOfNat1.{u2} M (Monoid.toOne.{u2} M (CommMonoid.toMonoid.{u2} M _inst_5))))) -> (Eq.{succ u2} M (Finsupp.prod.{u1, u3, u2} α G M (NegZeroClass.toZero.{u3} G (SubNegZeroMonoid.toNegZeroClass.{u3} G (SubtractionMonoid.toSubNegZeroMonoid.{u3} G (AddGroup.toSubtractionMonoid.{u3} G _inst_4)))) _inst_5 (Neg.neg.{max u1 u3} (Finsupp.{u1, u3} α G (NegZeroClass.toZero.{u3} G (SubNegZeroMonoid.toNegZeroClass.{u3} G (SubtractionMonoid.toSubNegZeroMonoid.{u3} G (AddGroup.toSubtractionMonoid.{u3} G _inst_4))))) (Finsupp.neg.{u1, u3} α G (SubNegZeroMonoid.toNegZeroClass.{u3} G (SubtractionMonoid.toSubNegZeroMonoid.{u3} G (AddGroup.toSubtractionMonoid.{u3} G _inst_4)))) g) h) (Finsupp.prod.{u1, u3, u2} α G M (NegZeroClass.toZero.{u3} G (SubNegZeroMonoid.toNegZeroClass.{u3} G (SubtractionMonoid.toSubNegZeroMonoid.{u3} G (AddGroup.toSubtractionMonoid.{u3} G _inst_4)))) _inst_5 g (fun (a : α) (b : G) => h a (Neg.neg.{u3} G (NegZeroClass.toNeg.{u3} G (SubNegZeroMonoid.toNegZeroClass.{u3} G (SubtractionMonoid.toSubNegZeroMonoid.{u3} G (AddGroup.toSubtractionMonoid.{u3} G _inst_4)))) b))))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_neg_index Finsupp.prod_neg_indexₓ'. -/
@[to_additive]
theorem prod_neg_index [AddGroup G] [CommMonoid M] {g : α →₀ G} {h : α → G → M}
    (h0 : ∀ a, h a 0 = 1) : (-g).Prod h = g.Prod fun a b => h a (-b) :=
  prod_mapRange_index h0
#align finsupp.prod_neg_index Finsupp.prod_neg_index
#align finsupp.sum_neg_index Finsupp.sum_neg_index

end Finsupp

namespace Finsupp

/- warning: finsupp.finset_sum_apply -> Finsupp.finset_sum_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} N] (S : Finset.{u2} ι) (f : ι -> (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))))) (a : α), Eq.{succ u3} N (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) (fun (_x : Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) => α -> N) (Finsupp.coeFun.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) ι (Finsupp.addCommMonoid.{u1, u3} α N _inst_4) S (fun (i : ι) => f i)) a) (Finset.sum.{u3, u2} N ι _inst_4 S (fun (i : ι) => coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) (fun (_x : Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) => α -> N) (Finsupp.coeFun.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) (f i) a))
but is expected to have type
  forall {α : Type.{u1}} {ι : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} N] (S : Finset.{u2} ι) (f : ι -> (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) (a : α), Eq.{succ u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) a) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))) ι (Finsupp.addCommMonoid.{u1, u3} α N _inst_4) S (fun (i : ι) => f i)) a) (Finset.sum.{u3, u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) a) ι _inst_4 S (fun (i : ι) => FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))) (f i) a))
Case conversion may be inaccurate. Consider using '#align finsupp.finset_sum_apply Finsupp.finset_sum_applyₓ'. -/
theorem finset_sum_apply [AddCommMonoid N] (S : Finset ι) (f : ι → α →₀ N) (a : α) :
    (∑ i in S, f i) a = ∑ i in S, f i a :=
  (applyAddHom a : (α →₀ N) →+ _).map_sum _ _
#align finsupp.finset_sum_apply Finsupp.finset_sum_apply

/- warning: finsupp.sum_apply -> Finsupp.sum_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_4 : Zero.{u3} M] [_inst_5 : AddCommMonoid.{u4} N] {f : Finsupp.{u1, u3} α M _inst_4} {g : α -> M -> (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))))} {a₂ : β}, Eq.{succ u4} N (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) (fun (_x : Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) => β -> N) (Finsupp.coeFun.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) (Finsupp.sum.{u1, u3, max u2 u4} α M (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) _inst_4 (Finsupp.addCommMonoid.{u2, u4} β N _inst_5) f g) a₂) (Finsupp.sum.{u1, u3, u4} α M N _inst_4 _inst_5 f (fun (a₁ : α) (b : M) => coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) (fun (_x : Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) => β -> N) (Finsupp.coeFun.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) (g a₁ b) a₂))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {M : Type.{u4}} {N : Type.{u3}} [_inst_4 : Zero.{u4} M] [_inst_5 : AddCommMonoid.{u3} N] {f : Finsupp.{u2, u4} α M _inst_4} {g : α -> M -> (Finsupp.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))} {a₂ : β}, Eq.{succ u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => N) a₂) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => N) _x) (Finsupp.funLike.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Finsupp.sum.{u2, u4, max u1 u3} α M (Finsupp.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) _inst_4 (Finsupp.addCommMonoid.{u1, u3} β N _inst_5) f g) a₂) (Finsupp.sum.{u2, u4, u3} α M ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => N) a₂) _inst_4 _inst_5 f (fun (a₁ : α) (b : M) => FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => N) _x) (Finsupp.funLike.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (g a₁ b) a₂))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_apply Finsupp.sum_applyₓ'. -/
@[simp]
theorem sum_apply [Zero M] [AddCommMonoid N] {f : α →₀ M} {g : α → M → β →₀ N} {a₂ : β} :
    (f.Sum g) a₂ = f.Sum fun a₁ b => g a₁ b a₂ :=
  finset_sum_apply _ _ _
#align finsupp.sum_apply Finsupp.sum_apply

/- warning: finsupp.coe_finset_sum -> Finsupp.coe_finset_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} N] (S : Finset.{u2} ι) (f : ι -> (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))))), Eq.{max (succ u1) (succ u3)} (α -> N) (coeFn.{succ (max u1 u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) (fun (_x : Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) => α -> N) (Finsupp.coeFun.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) ι (Finsupp.addCommMonoid.{u1, u3} α N _inst_4) S (fun (i : ι) => f i))) (Finset.sum.{max u1 u3, u2} (α -> N) ι (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => N) (fun (i : α) => _inst_4)) S (fun (i : ι) => coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) (fun (_x : Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) => α -> N) (Finsupp.coeFun.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))) (f i)))
but is expected to have type
  forall {α : Type.{u1}} {ι : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} N] (S : Finset.{u2} ι) (f : ι -> (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4)))), Eq.{max (succ u1) (succ u3)} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) ᾰ) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))) ι (Finsupp.addCommMonoid.{u1, u3} α N _inst_4) S (fun (i : ι) => f i))) (Finset.sum.{max u1 u3, u2} (forall (ᾰ : α), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) ᾰ) ι (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) ᾰ) (fun (i : α) => _inst_4)) S (fun (i : ι) => FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => N) _x) (Finsupp.funLike.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_4))) (f i)))
Case conversion may be inaccurate. Consider using '#align finsupp.coe_finset_sum Finsupp.coe_finset_sumₓ'. -/
theorem coe_finset_sum [AddCommMonoid N] (S : Finset ι) (f : ι → α →₀ N) :
    ⇑(∑ i in S, f i) = ∑ i in S, f i :=
  (coeFnAddHom : (α →₀ N) →+ _).map_sum _ _
#align finsupp.coe_finset_sum Finsupp.coe_finset_sum

/- warning: finsupp.coe_sum -> Finsupp.coe_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_4 : Zero.{u3} M] [_inst_5 : AddCommMonoid.{u4} N] (f : Finsupp.{u1, u3} α M _inst_4) (g : α -> M -> (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))))), Eq.{succ (max u2 u4)} (β -> N) (coeFn.{succ (max u2 u4), succ (max u2 u4)} (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) (fun (_x : Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) => β -> N) (Finsupp.coeFun.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) (Finsupp.sum.{u1, u3, max u2 u4} α M (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) _inst_4 (Finsupp.addCommMonoid.{u2, u4} β N _inst_5) f g)) (Finsupp.sum.{u1, u3, max u2 u4} α M (β -> N) _inst_4 (Pi.addCommMonoid.{u2, u4} β (fun (ᾰ : β) => N) (fun (i : β) => _inst_5)) f (fun (a₁ : α) (b : M) => coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) (fun (_x : Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) => β -> N) (Finsupp.coeFun.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) (g a₁ b)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {M : Type.{u4}} {N : Type.{u3}} [_inst_4 : Zero.{u4} M] [_inst_5 : AddCommMonoid.{u3} N] (f : Finsupp.{u2, u4} α M _inst_4) (g : α -> M -> (Finsupp.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))), Eq.{max (succ u1) (succ u3)} (forall (ᾰ : β), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => N) ᾰ) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => N) _x) (Finsupp.funLike.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Finsupp.sum.{u2, u4, max u1 u3} α M (Finsupp.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) _inst_4 (Finsupp.addCommMonoid.{u1, u3} β N _inst_5) f g)) (Finsupp.sum.{u2, u4, max u1 u3} α M (forall (ᾰ : β), (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => N) ᾰ) _inst_4 (Pi.addCommMonoid.{u1, u3} β (fun (ᾰ : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => N) ᾰ) (fun (i : β) => _inst_5)) f (fun (a₁ : α) (b : M) => FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => N) _x) (Finsupp.funLike.{u1, u3} β N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (g a₁ b)))
Case conversion may be inaccurate. Consider using '#align finsupp.coe_sum Finsupp.coe_sumₓ'. -/
theorem coe_sum [Zero M] [AddCommMonoid N] (f : α →₀ M) (g : α → M → β →₀ N) :
    ⇑(f.Sum g) = f.Sum fun a₁ b => g a₁ b :=
  coe_finset_sum _ _
#align finsupp.coe_sum Finsupp.coe_sum

/- warning: finsupp.support_sum -> Finsupp.support_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_4 : DecidableEq.{succ u2} β] [_inst_5 : Zero.{u3} M] [_inst_6 : AddCommMonoid.{u4} N] {f : Finsupp.{u1, u3} α M _inst_5} {g : α -> M -> (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_6))))}, HasSubset.Subset.{u2} (Finset.{u2} β) (Finset.hasSubset.{u2} β) (Finsupp.support.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_6))) (Finsupp.sum.{u1, u3, max u2 u4} α M (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_6)))) _inst_5 (Finsupp.addCommMonoid.{u2, u4} β N _inst_6) f g)) (Finset.bunionᵢ.{u1, u2} α β (fun (a : β) (b : β) => _inst_4 a b) (Finsupp.support.{u1, u3} α M _inst_5 f) (fun (a : α) => Finsupp.support.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_6))) (g a (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α M _inst_5) (fun (_x : Finsupp.{u1, u3} α M _inst_5) => α -> M) (Finsupp.coeFun.{u1, u3} α M _inst_5) f a))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u4}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : DecidableEq.{succ u4} β] [_inst_5 : Zero.{u3} M] [_inst_6 : AddCommMonoid.{u2} N] {f : Finsupp.{u1, u3} α M _inst_5} {g : α -> M -> (Finsupp.{u4, u2} β N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_6)))}, HasSubset.Subset.{u4} (Finset.{u4} β) (Finset.instHasSubsetFinset.{u4} β) (Finsupp.support.{u4, u2} β N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_6)) (Finsupp.sum.{u1, u3, max u4 u2} α M (Finsupp.{u4, u2} β N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_6))) _inst_5 (Finsupp.addCommMonoid.{u4, u2} β N _inst_6) f g)) (Finset.bunionᵢ.{u1, u4} α β (fun (a : β) (b : β) => _inst_4 a b) (Finsupp.support.{u1, u3} α M _inst_5 f) (fun (a : α) => Finsupp.support.{u4, u2} β N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_6)) (g a (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α M _inst_5) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u1, u3} α M _inst_5) f a))))
Case conversion may be inaccurate. Consider using '#align finsupp.support_sum Finsupp.support_sumₓ'. -/
theorem support_sum [DecidableEq β] [Zero M] [AddCommMonoid N] {f : α →₀ M} {g : α → M → β →₀ N} :
    (f.Sum g).support ⊆ f.support.bunionᵢ fun a => (g a (f a)).support :=
  by
  have : ∀ c, (f.Sum fun a b => g a b c) ≠ 0 → ∃ a, f a ≠ 0 ∧ ¬(g a (f a)) c = 0 := fun a₁ h =>
    let ⟨a, ha, Ne⟩ := Finset.exists_ne_zero_of_sum_ne_zero h
    ⟨a, mem_support_iff.mp ha, Ne⟩
  simpa only [Finset.subset_iff, mem_support_iff, Finset.mem_bunionᵢ, sum_apply, exists_prop]
#align finsupp.support_sum Finsupp.support_sum

/- warning: finsupp.support_finset_sum -> Finsupp.support_finset_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} [_inst_4 : DecidableEq.{succ u2} β] [_inst_5 : AddCommMonoid.{u3} M] {s : Finset.{u1} α} {f : α -> (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))))}, HasSubset.Subset.{u2} (Finset.{u2} β) (Finset.hasSubset.{u2} β) (Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))) (Finset.sum.{max u2 u3, u1} (Finsupp.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5)))) α (Finsupp.addCommMonoid.{u2, u3} β M _inst_5) s f)) (Finset.bunionᵢ.{u1, u2} α β (fun (a : β) (b : β) => _inst_4 a b) s (fun (x : α) => Finsupp.support.{u2, u3} β M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))) (f x)))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {M : Type.{u2}} [_inst_4 : DecidableEq.{succ u3} β] [_inst_5 : AddCommMonoid.{u2} M] {s : Finset.{u1} α} {f : α -> (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_5)))}, HasSubset.Subset.{u3} (Finset.{u3} β) (Finset.instHasSubsetFinset.{u3} β) (Finsupp.support.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_5)) (Finset.sum.{max u3 u2, u1} (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_5))) α (Finsupp.addCommMonoid.{u3, u2} β M _inst_5) s f)) (Finset.bunionᵢ.{u1, u3} α β (fun (a : β) (b : β) => _inst_4 a b) s (fun (x : α) => Finsupp.support.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_5)) (f x)))
Case conversion may be inaccurate. Consider using '#align finsupp.support_finset_sum Finsupp.support_finset_sumₓ'. -/
theorem support_finset_sum [DecidableEq β] [AddCommMonoid M] {s : Finset α} {f : α → β →₀ M} :
    (Finset.sum s f).support ⊆ s.bunionᵢ fun x => (f x).support :=
  by
  rw [← Finset.sup_eq_bunionᵢ]
  induction' s using Finset.cons_induction_on with a s ha ih
  · rfl
  · rw [Finset.sum_cons, Finset.sup_cons]
    exact support_add.trans (Finset.union_subset_union (Finset.Subset.refl _) ih)
#align finsupp.support_finset_sum Finsupp.support_finset_sum

/- warning: finsupp.sum_zero -> Finsupp.sum_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_5 : AddCommMonoid.{u3} N] {f : Finsupp.{u1, u2} α M _inst_4}, Eq.{succ u3} N (Finsupp.sum.{u1, u2, u3} α M N _inst_4 _inst_5 f (fun (a : α) (b : M) => OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))))))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : Zero.{u3} M] [_inst_5 : AddCommMonoid.{u2} N] {f : Finsupp.{u1, u3} α M _inst_4}, Eq.{succ u2} N (Finsupp.sum.{u1, u3, u2} α M N _inst_4 _inst_5 f (fun (a : α) (b : M) => OfNat.ofNat.{u2} N 0 (Zero.toOfNat0.{u2} N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (OfNat.ofNat.{u2} N 0 (Zero.toOfNat0.{u2} N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_zero Finsupp.sum_zeroₓ'. -/
@[simp]
theorem sum_zero [Zero M] [AddCommMonoid N] {f : α →₀ M} : (f.Sum fun a b => (0 : N)) = 0 :=
  Finset.sum_const_zero
#align finsupp.sum_zero Finsupp.sum_zero

/- warning: finsupp.prod_mul -> Finsupp.prod_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_5 : CommMonoid.{u3} N] {f : Finsupp.{u1, u2} α M _inst_4} {h₁ : α -> M -> N} {h₂ : α -> M -> N}, Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_5 f (fun (a : α) (b : M) => HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)))) (h₁ a b) (h₂ a b))) (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)))) (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_5 f h₁) (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_5 f h₂))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : Zero.{u3} M] [_inst_5 : CommMonoid.{u2} N] {f : Finsupp.{u1, u3} α M _inst_4} {h₁ : α -> M -> N} {h₂ : α -> M -> N}, Eq.{succ u2} N (Finsupp.prod.{u1, u3, u2} α M N _inst_4 _inst_5 f (fun (a : α) (b : M) => HMul.hMul.{u2, u2, u2} N N N (instHMul.{u2} N (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5)))) (h₁ a b) (h₂ a b))) (HMul.hMul.{u2, u2, u2} N N N (instHMul.{u2} N (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5)))) (Finsupp.prod.{u1, u3, u2} α M N _inst_4 _inst_5 f h₁) (Finsupp.prod.{u1, u3, u2} α M N _inst_4 _inst_5 f h₂))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_mul Finsupp.prod_mulₓ'. -/
@[simp, to_additive]
theorem prod_mul [Zero M] [CommMonoid N] {f : α →₀ M} {h₁ h₂ : α → M → N} :
    (f.Prod fun a b => h₁ a b * h₂ a b) = f.Prod h₁ * f.Prod h₂ :=
  Finset.prod_mul_distrib
#align finsupp.prod_mul Finsupp.prod_mul
#align finsupp.sum_add Finsupp.sum_add

/- warning: finsupp.prod_inv -> Finsupp.prod_inv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_5 : CommGroup.{u3} G] {f : Finsupp.{u1, u2} α M _inst_4} {h : α -> M -> G}, Eq.{succ u3} G (Finsupp.prod.{u1, u2, u3} α M G _inst_4 (CommGroup.toCommMonoid.{u3} G _inst_5) f (fun (a : α) (b : M) => Inv.inv.{u3} G (DivInvMonoid.toHasInv.{u3} G (Group.toDivInvMonoid.{u3} G (CommGroup.toGroup.{u3} G _inst_5))) (h a b))) (Inv.inv.{u3} G (DivInvMonoid.toHasInv.{u3} G (Group.toDivInvMonoid.{u3} G (CommGroup.toGroup.{u3} G _inst_5))) (Finsupp.prod.{u1, u2, u3} α M G _inst_4 (CommGroup.toCommMonoid.{u3} G _inst_5) f h))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {G : Type.{u2}} [_inst_4 : Zero.{u3} M] [_inst_5 : CommGroup.{u2} G] {f : Finsupp.{u1, u3} α M _inst_4} {h : α -> M -> G}, Eq.{succ u2} G (Finsupp.prod.{u1, u3, u2} α M G _inst_4 (CommGroup.toCommMonoid.{u2} G _inst_5) f (fun (a : α) (b : M) => Inv.inv.{u2} G (InvOneClass.toInv.{u2} G (DivInvOneMonoid.toInvOneClass.{u2} G (DivisionMonoid.toDivInvOneMonoid.{u2} G (DivisionCommMonoid.toDivisionMonoid.{u2} G (CommGroup.toDivisionCommMonoid.{u2} G _inst_5))))) (h a b))) (Inv.inv.{u2} G (InvOneClass.toInv.{u2} G (DivInvOneMonoid.toInvOneClass.{u2} G (DivisionMonoid.toDivInvOneMonoid.{u2} G (DivisionCommMonoid.toDivisionMonoid.{u2} G (CommGroup.toDivisionCommMonoid.{u2} G _inst_5))))) (Finsupp.prod.{u1, u3, u2} α M G _inst_4 (CommGroup.toCommMonoid.{u2} G _inst_5) f h))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_inv Finsupp.prod_invₓ'. -/
@[simp, to_additive]
theorem prod_inv [Zero M] [CommGroup G] {f : α →₀ M} {h : α → M → G} :
    (f.Prod fun a b => (h a b)⁻¹) = (f.Prod h)⁻¹ :=
  (map_prod (MonoidHom.id G)⁻¹ _ _).symm
#align finsupp.prod_inv Finsupp.prod_inv
#align finsupp.sum_neg Finsupp.sum_neg

/- warning: finsupp.sum_sub -> Finsupp.sum_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {G : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_5 : AddCommGroup.{u3} G] {f : Finsupp.{u1, u2} α M _inst_4} {h₁ : α -> M -> G} {h₂ : α -> M -> G}, Eq.{succ u3} G (Finsupp.sum.{u1, u2, u3} α M G _inst_4 (AddCommGroup.toAddCommMonoid.{u3} G _inst_5) f (fun (a : α) (b : M) => HSub.hSub.{u3, u3, u3} G G G (instHSub.{u3} G (SubNegMonoid.toHasSub.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_5)))) (h₁ a b) (h₂ a b))) (HSub.hSub.{u3, u3, u3} G G G (instHSub.{u3} G (SubNegMonoid.toHasSub.{u3} G (AddGroup.toSubNegMonoid.{u3} G (AddCommGroup.toAddGroup.{u3} G _inst_5)))) (Finsupp.sum.{u1, u2, u3} α M G _inst_4 (AddCommGroup.toAddCommMonoid.{u3} G _inst_5) f h₁) (Finsupp.sum.{u1, u2, u3} α M G _inst_4 (AddCommGroup.toAddCommMonoid.{u3} G _inst_5) f h₂))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {G : Type.{u2}} [_inst_4 : Zero.{u3} M] [_inst_5 : AddCommGroup.{u2} G] {f : Finsupp.{u1, u3} α M _inst_4} {h₁ : α -> M -> G} {h₂ : α -> M -> G}, Eq.{succ u2} G (Finsupp.sum.{u1, u3, u2} α M G _inst_4 (AddCommGroup.toAddCommMonoid.{u2} G _inst_5) f (fun (a : α) (b : M) => HSub.hSub.{u2, u2, u2} G G G (instHSub.{u2} G (SubNegMonoid.toSub.{u2} G (AddGroup.toSubNegMonoid.{u2} G (AddCommGroup.toAddGroup.{u2} G _inst_5)))) (h₁ a b) (h₂ a b))) (HSub.hSub.{u2, u2, u2} G G G (instHSub.{u2} G (SubNegMonoid.toSub.{u2} G (AddGroup.toSubNegMonoid.{u2} G (AddCommGroup.toAddGroup.{u2} G _inst_5)))) (Finsupp.sum.{u1, u3, u2} α M G _inst_4 (AddCommGroup.toAddCommMonoid.{u2} G _inst_5) f h₁) (Finsupp.sum.{u1, u3, u2} α M G _inst_4 (AddCommGroup.toAddCommMonoid.{u2} G _inst_5) f h₂))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_sub Finsupp.sum_subₓ'. -/
@[simp]
theorem sum_sub [Zero M] [AddCommGroup G] {f : α →₀ M} {h₁ h₂ : α → M → G} :
    (f.Sum fun a b => h₁ a b - h₂ a b) = f.Sum h₁ - f.Sum h₂ :=
  Finset.sum_sub_distrib
#align finsupp.sum_sub Finsupp.sum_sub

/- warning: finsupp.prod_add_index -> Finsupp.prod_add_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : DecidableEq.{succ u1} α] [_inst_5 : AddZeroClass.{u2} M] [_inst_6 : CommMonoid.{u3} N] {f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_5)} {g : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_5)} {h : α -> M -> N}, (forall (a : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Union.union.{u1} (Finset.{u1} α) (Finset.hasUnion.{u1} α (fun (a : α) (b : α) => _inst_4 a b)) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_5) f) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_5) g))) -> (Eq.{succ u3} N (h a (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M _inst_5))))) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)))))))) -> (forall (a : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Union.union.{u1} (Finset.{u1} α) (Finset.hasUnion.{u1} α (fun (a : α) (b : α) => _inst_4 a b)) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_5) f) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_5) g))) -> (forall (b₁ : M) (b₂ : M), Eq.{succ u3} N (h a (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M _inst_5)) b₁ b₂)) (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)))) (h a b₁) (h a b₂)))) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_5) _inst_6 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_5)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_5)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_5)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_5)) (Finsupp.add.{u1, u2} α M _inst_5)) f g) h) (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_6)))) (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_5) _inst_6 f h) (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_5) _inst_6 g h)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {N : Type.{u1}} [_inst_4 : DecidableEq.{succ u3} α] [_inst_5 : AddZeroClass.{u2} M] [_inst_6 : CommMonoid.{u1} N] {f : Finsupp.{u3, u2} α M (AddZeroClass.toZero.{u2} M _inst_5)} {g : Finsupp.{u3, u2} α M (AddZeroClass.toZero.{u2} M _inst_5)} {h : α -> M -> N}, (forall (a : α), (Membership.mem.{u3, u3} α (Finset.{u3} α) (Finset.instMembershipFinset.{u3} α) a (Union.union.{u3} (Finset.{u3} α) (Finset.instUnionFinset.{u3} α (fun (a : α) (b : α) => _inst_4 a b)) (Finsupp.support.{u3, u2} α M (AddZeroClass.toZero.{u2} M _inst_5) f) (Finsupp.support.{u3, u2} α M (AddZeroClass.toZero.{u2} M _inst_5) g))) -> (Eq.{succ u1} N (h a (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddZeroClass.toZero.{u2} M _inst_5)))) (OfNat.ofNat.{u1} N 1 (One.toOfNat1.{u1} N (Monoid.toOne.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6)))))) -> (forall (a : α), (Membership.mem.{u3, u3} α (Finset.{u3} α) (Finset.instMembershipFinset.{u3} α) a (Union.union.{u3} (Finset.{u3} α) (Finset.instUnionFinset.{u3} α (fun (a : α) (b : α) => _inst_4 a b)) (Finsupp.support.{u3, u2} α M (AddZeroClass.toZero.{u2} M _inst_5) f) (Finsupp.support.{u3, u2} α M (AddZeroClass.toZero.{u2} M _inst_5) g))) -> (forall (b₁ : M) (b₂ : M), Eq.{succ u1} N (h a (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toAdd.{u2} M _inst_5)) b₁ b₂)) (HMul.hMul.{u1, u1, u1} N N N (instHMul.{u1} N (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6)))) (h a b₁) (h a b₂)))) -> (Eq.{succ u1} N (Finsupp.prod.{u3, u2, u1} α M N (AddZeroClass.toZero.{u2} M _inst_5) _inst_6 (HAdd.hAdd.{max u3 u2, max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddZeroClass.toZero.{u2} M _inst_5)) (Finsupp.{u3, u2} α M (AddZeroClass.toZero.{u2} M _inst_5)) (Finsupp.{u3, u2} α M (AddZeroClass.toZero.{u2} M _inst_5)) (instHAdd.{max u3 u2} (Finsupp.{u3, u2} α M (AddZeroClass.toZero.{u2} M _inst_5)) (Finsupp.add.{u3, u2} α M _inst_5)) f g) h) (HMul.hMul.{u1, u1, u1} N N N (instHMul.{u1} N (MulOneClass.toMul.{u1} N (Monoid.toMulOneClass.{u1} N (CommMonoid.toMonoid.{u1} N _inst_6)))) (Finsupp.prod.{u3, u2, u1} α M N (AddZeroClass.toZero.{u2} M _inst_5) _inst_6 f h) (Finsupp.prod.{u3, u2, u1} α M N (AddZeroClass.toZero.{u2} M _inst_5) _inst_6 g h)))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_add_index Finsupp.prod_add_indexₓ'. -/
/-- Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,
if `h` is an additive-to-multiplicative homomorphism on the support.
This is a more general version of `finsupp.prod_add_index'`; the latter has simpler hypotheses. -/
@[to_additive
      "Taking the product under `h` is an additive homomorphism of finsupps,\nif `h` is an additive homomorphism on the support.\nThis is a more general version of `finsupp.sum_add_index'`; the latter has simpler hypotheses."]
theorem prod_add_index [DecidableEq α] [AddZeroClass M] [CommMonoid N] {f g : α →₀ M}
    {h : α → M → N} (h_zero : ∀ a ∈ f.support ∪ g.support, h a 0 = 1)
    (h_add : ∀ a ∈ f.support ∪ g.support, ∀ (b₁ b₂), h a (b₁ + b₂) = h a b₁ * h a b₂) :
    (f + g).Prod h = f.Prod h * g.Prod h :=
  by
  rw [Finsupp.prod_of_support_subset f (subset_union_left _ g.support) h h_zero,
    Finsupp.prod_of_support_subset g (subset_union_right f.support _) h h_zero, ←
    Finset.prod_mul_distrib, Finsupp.prod_of_support_subset (f + g) Finsupp.support_add h h_zero]
  exact Finset.prod_congr rfl fun x hx => by apply h_add x hx
#align finsupp.prod_add_index Finsupp.prod_add_index
#align finsupp.sum_add_index Finsupp.sum_add_index

/- warning: finsupp.prod_add_index' -> Finsupp.prod_add_index' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddZeroClass.{u2} M] [_inst_5 : CommMonoid.{u3} N] {f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)} {g : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)} {h : α -> M -> N}, (forall (a : α), Eq.{succ u3} N (h a (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M _inst_4))))) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))))))) -> (forall (a : α) (b₁ : M) (b₂ : M), Eq.{succ u3} N (h a (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M _inst_4)) b₁ b₂)) (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)))) (h a b₁) (h a b₂))) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_4) _inst_5 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (Finsupp.add.{u1, u2} α M _inst_4)) f g) h) (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)))) (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_4) _inst_5 f h) (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_4) _inst_5 g h)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : AddZeroClass.{u3} M] [_inst_5 : CommMonoid.{u2} N] {f : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)} {g : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)} {h : α -> M -> N}, (forall (a : α), Eq.{succ u2} N (h a (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddZeroClass.toZero.{u3} M _inst_4)))) (OfNat.ofNat.{u2} N 1 (One.toOfNat1.{u2} N (Monoid.toOne.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))))) -> (forall (a : α) (b₁ : M) (b₂ : M), Eq.{succ u2} N (h a (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toAdd.{u3} M _inst_4)) b₁ b₂)) (HMul.hMul.{u2, u2, u2} N N N (instHMul.{u2} N (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5)))) (h a b₁) (h a b₂))) -> (Eq.{succ u2} N (Finsupp.prod.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M _inst_4) _inst_5 (HAdd.hAdd.{max u1 u3, max u1 u3, max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (instHAdd.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (Finsupp.add.{u1, u3} α M _inst_4)) f g) h) (HMul.hMul.{u2, u2, u2} N N N (instHMul.{u2} N (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5)))) (Finsupp.prod.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M _inst_4) _inst_5 f h) (Finsupp.prod.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M _inst_4) _inst_5 g h)))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_add_index' Finsupp.prod_add_index'ₓ'. -/
/-- Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,
if `h` is an additive-to-multiplicative homomorphism.
This is a more specialized version of `finsupp.prod_add_index` with simpler hypotheses. -/
@[to_additive
      "Taking the sum under `h` is an additive homomorphism of finsupps,\nif `h` is an additive homomorphism.\nThis is a more specific version of `finsupp.sum_add_index` with simpler hypotheses."]
theorem prod_add_index' [AddZeroClass M] [CommMonoid N] {f g : α →₀ M} {h : α → M → N}
    (h_zero : ∀ a, h a 0 = 1) (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) :
    (f + g).Prod h = f.Prod h * g.Prod h := by
  classical exact prod_add_index (fun a ha => h_zero a) fun a ha => h_add a
#align finsupp.prod_add_index' Finsupp.prod_add_index'
#align finsupp.sum_add_index' Finsupp.sum_add_index'

/- warning: finsupp.sum_hom_add_index -> Finsupp.sum_hom_add_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddZeroClass.{u2} M] [_inst_5 : AddCommMonoid.{u3} N] {f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)} {g : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)} (h : α -> (AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))), Eq.{succ u3} N (Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_4) _inst_5 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (Finsupp.add.{u1, u2} α M _inst_4)) f g) (fun (x : α) => coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (_x : AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) => M -> N) (AddMonoidHom.hasCoeToFun.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (h x))) (HAdd.hAdd.{u3, u3, u3} N N N (instHAdd.{u3} N (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_4) _inst_5 f (fun (x : α) => coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (_x : AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) => M -> N) (AddMonoidHom.hasCoeToFun.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (h x))) (Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_4) _inst_5 g (fun (x : α) => coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (_x : AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) => M -> N) (AddMonoidHom.hasCoeToFun.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (h x))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : AddZeroClass.{u3} M] [_inst_5 : AddCommMonoid.{u2} N] {f : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)} {g : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)} (h : α -> (AddMonoidHom.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))), Eq.{succ u2} N (Finsupp.sum.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M _inst_4) _inst_5 (HAdd.hAdd.{max u1 u3, max u1 u3, max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (instHAdd.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (Finsupp.add.{u1, u3} α M _inst_4)) f g) (fun (x : α) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AddMonoidHom.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M) => N) _x) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N (AddZeroClass.toAdd.{u3} M _inst_4) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (h x))) (HAdd.hAdd.{u2, u2, u2} N N N (instHAdd.{u2} N (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Finsupp.sum.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M _inst_4) _inst_5 f (fun (x : α) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AddMonoidHom.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M) => N) _x) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N (AddZeroClass.toAdd.{u3} M _inst_4) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (h x))) (Finsupp.sum.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M _inst_4) _inst_5 g (fun (x : α) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AddMonoidHom.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M) => N) _x) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N (AddZeroClass.toAdd.{u3} M _inst_4) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M N _inst_4 (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (h x))))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_hom_add_index Finsupp.sum_hom_add_indexₓ'. -/
@[simp]
theorem sum_hom_add_index [AddZeroClass M] [AddCommMonoid N] {f g : α →₀ M} (h : α → M →+ N) :
    ((f + g).Sum fun x => h x) = (f.Sum fun x => h x) + g.Sum fun x => h x :=
  sum_add_index' (fun a => (h a).map_zero) fun a => (h a).map_add
#align finsupp.sum_hom_add_index Finsupp.sum_hom_add_index

/- warning: finsupp.prod_hom_add_index -> Finsupp.prod_hom_add_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddZeroClass.{u2} M] [_inst_5 : CommMonoid.{u3} N] {f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)} {g : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)} (h : α -> (MonoidHom.{u2, u3} (Multiplicative.{u2} M) N (Multiplicative.mulOneClass.{u2} M _inst_4) (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)))), Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_4) _inst_5 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) (Finsupp.add.{u1, u2} α M _inst_4)) f g) (fun (a : α) (b : M) => coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidHom.{u2, u3} (Multiplicative.{u2} M) N (Multiplicative.mulOneClass.{u2} M _inst_4) (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (fun (_x : MonoidHom.{u2, u3} (Multiplicative.{u2} M) N (Multiplicative.mulOneClass.{u2} M _inst_4) (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) => (Multiplicative.{u2} M) -> N) (MonoidHom.hasCoeToFun.{u2, u3} (Multiplicative.{u2} M) N (Multiplicative.mulOneClass.{u2} M _inst_4) (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (h a) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} M (Multiplicative.{u2} M)) (fun (_x : Equiv.{succ u2, succ u2} M (Multiplicative.{u2} M)) => M -> (Multiplicative.{u2} M)) (Equiv.hasCoeToFun.{succ u2, succ u2} M (Multiplicative.{u2} M)) (Multiplicative.ofAdd.{u2} M) b))) (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toHasMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)))) (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_4) _inst_5 f (fun (a : α) (b : M) => coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidHom.{u2, u3} (Multiplicative.{u2} M) N (Multiplicative.mulOneClass.{u2} M _inst_4) (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (fun (_x : MonoidHom.{u2, u3} (Multiplicative.{u2} M) N (Multiplicative.mulOneClass.{u2} M _inst_4) (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) => (Multiplicative.{u2} M) -> N) (MonoidHom.hasCoeToFun.{u2, u3} (Multiplicative.{u2} M) N (Multiplicative.mulOneClass.{u2} M _inst_4) (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (h a) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} M (Multiplicative.{u2} M)) (fun (_x : Equiv.{succ u2, succ u2} M (Multiplicative.{u2} M)) => M -> (Multiplicative.{u2} M)) (Equiv.hasCoeToFun.{succ u2, succ u2} M (Multiplicative.{u2} M)) (Multiplicative.ofAdd.{u2} M) b))) (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M _inst_4) _inst_5 g (fun (a : α) (b : M) => coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidHom.{u2, u3} (Multiplicative.{u2} M) N (Multiplicative.mulOneClass.{u2} M _inst_4) (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (fun (_x : MonoidHom.{u2, u3} (Multiplicative.{u2} M) N (Multiplicative.mulOneClass.{u2} M _inst_4) (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) => (Multiplicative.{u2} M) -> N) (MonoidHom.hasCoeToFun.{u2, u3} (Multiplicative.{u2} M) N (Multiplicative.mulOneClass.{u2} M _inst_4) (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (h a) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} M (Multiplicative.{u2} M)) (fun (_x : Equiv.{succ u2, succ u2} M (Multiplicative.{u2} M)) => M -> (Multiplicative.{u2} M)) (Equiv.hasCoeToFun.{succ u2, succ u2} M (Multiplicative.{u2} M)) (Multiplicative.ofAdd.{u2} M) b))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : AddZeroClass.{u3} M] [_inst_5 : CommMonoid.{u2} N] {f : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)} {g : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)} (h : α -> (MonoidHom.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5)))), Eq.{succ u2} N (Finsupp.prod.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M _inst_4) _inst_5 (HAdd.hAdd.{max u1 u3, max u1 u3, max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (instHAdd.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M _inst_4)) (Finsupp.add.{u1, u3} α M _inst_4)) f g) (fun (a : α) (b : M) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (Multiplicative.{u3} M) (fun (_x : Multiplicative.{u3} M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{u3} M) => N) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (Multiplicative.{u3} M) N (MulOneClass.toMul.{u3} (Multiplicative.{u3} M) (Multiplicative.mulOneClass.{u3} M _inst_4)) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5)) (MonoidHom.monoidHomClass.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))))) (h a) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.{succ u3, succ u3} M (Multiplicative.{u3} M)) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => Multiplicative.{u3} M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} M (Multiplicative.{u3} M)) (Multiplicative.ofAdd.{u3} M) b))) (HMul.hMul.{u2, u2, u2} N N N (instHMul.{u2} N (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5)))) (Finsupp.prod.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M _inst_4) _inst_5 f (fun (a : α) (b : M) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (Multiplicative.{u3} M) (fun (_x : Multiplicative.{u3} M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{u3} M) => N) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (Multiplicative.{u3} M) N (MulOneClass.toMul.{u3} (Multiplicative.{u3} M) (Multiplicative.mulOneClass.{u3} M _inst_4)) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5)) (MonoidHom.monoidHomClass.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))))) (h a) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.{succ u3, succ u3} M (Multiplicative.{u3} M)) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => Multiplicative.{u3} M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} M (Multiplicative.{u3} M)) (Multiplicative.ofAdd.{u3} M) b))) (Finsupp.prod.{u1, u3, u2} α M N (AddZeroClass.toZero.{u3} M _inst_4) _inst_5 g (fun (a : α) (b : M) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (Multiplicative.{u3} M) (fun (_x : Multiplicative.{u3} M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Multiplicative.{u3} M) => N) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (Multiplicative.{u3} M) N (MulOneClass.toMul.{u3} (Multiplicative.{u3} M) (Multiplicative.mulOneClass.{u3} M _inst_4)) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5)) (MonoidHom.monoidHomClass.{u3, u2} (Multiplicative.{u3} M) N (Multiplicative.mulOneClass.{u3} M _inst_4) (Monoid.toMulOneClass.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))))) (h a) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.{succ u3, succ u3} M (Multiplicative.{u3} M)) M (fun (_x : M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : M) => Multiplicative.{u3} M) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} M (Multiplicative.{u3} M)) (Multiplicative.ofAdd.{u3} M) b))))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_hom_add_index Finsupp.prod_hom_add_indexₓ'. -/
@[simp]
theorem prod_hom_add_index [AddZeroClass M] [CommMonoid N] {f g : α →₀ M}
    (h : α → Multiplicative M →* N) :
    ((f + g).Prod fun a b => h a (Multiplicative.ofAdd b)) =
      (f.Prod fun a b => h a (Multiplicative.ofAdd b)) *
        g.Prod fun a b => h a (Multiplicative.ofAdd b) :=
  prod_add_index' (fun a => (h a).map_one) fun a => (h a).map_mul
#align finsupp.prod_hom_add_index Finsupp.prod_hom_add_index

/- warning: finsupp.lift_add_hom -> Finsupp.liftAddHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddZeroClass.{u2} M] [_inst_5 : AddCommMonoid.{u3} N], AddEquiv.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) N (Finsupp.addZeroClass.{u1, u2} α M _inst_4) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N _inst_4 _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M _inst_4)) N (Finsupp.addZeroClass.{u1, u2} α M _inst_4) _inst_5)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddZeroClass.{u2} M] [_inst_5 : AddCommMonoid.{u3} N], AddEquiv.{max (max u1 u2) u3, max u3 u2 u1} (α -> (AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u2 u1, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_4)) N (Finsupp.addZeroClass.{u1, u2} α M _inst_4) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u2 u3} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N _inst_4 (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u2, u3} M N _inst_4 _inst_5)) (AddMonoidHom.add.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M _inst_4)) N (Finsupp.addZeroClass.{u1, u2} α M _inst_4) _inst_5)
Case conversion may be inaccurate. Consider using '#align finsupp.lift_add_hom Finsupp.liftAddHomₓ'. -/
/-- The canonical isomorphism between families of additive monoid homomorphisms `α → (M →+ N)`
and monoid homomorphisms `(α →₀ M) →+ N`. -/
def liftAddHom [AddZeroClass M] [AddCommMonoid N] : (α → M →+ N) ≃+ ((α →₀ M) →+ N)
    where
  toFun F :=
    { toFun := fun f => f.Sum fun x => F x
      map_zero' := Finset.sum_empty
      map_add' := fun _ _ => sum_add_index' (fun x => (F x).map_zero) fun x => (F x).map_add }
  invFun F x := F.comp <| singleAddHom x
  left_inv F := by
    ext
    simp
  right_inv F := by
    ext
    simp
  map_add' F G := by
    ext
    simp
#align finsupp.lift_add_hom Finsupp.liftAddHom

/- warning: finsupp.lift_add_hom_apply -> Finsupp.liftAddHom_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} N] (F : α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))), Eq.{succ u3} N (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) -> N) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (coeFn.{max (succ (max u1 u3 u2)) (succ (max u3 u1 u2)), max (succ (max u1 u3 u2)) (succ (max u3 u1 u2))} (AddEquiv.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) (fun (_x : AddEquiv.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) => (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) -> (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddEquiv.hasCoeToFun.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) (Finsupp.liftAddHom.{u1, u2, u3} α M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5) F) f) (Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5 f (fun (x : α) => coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (_x : AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) => M -> N) (AddMonoidHom.hasCoeToFun.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (F x)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} N] (F : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (f : Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) => N) f) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (succ u1) (succ u3), succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) F) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) (fun (_x : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) => N) _x) (AddHomClass.toFunLike.{max (max u1 u3) u2, max u1 u3, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) F) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (AddZeroClass.toAdd.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u3) u2, max u1 u3, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) F) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (AddMonoidHom.addMonoidHomClass.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2)} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (fun (_x : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) _x) (AddHomClass.toFunLike.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddZeroClass.toAdd.{max (max u1 u3) u2} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))))) (AddZeroClass.toAdd.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))) (AddEquivClass.instAddMonoidHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))))) (Finsupp.liftAddHom.{u1, u3, u2} α M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5) F) f) (Finsupp.sum.{u1, u3, u2} α M N (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5 f (fun (x : α) => FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M) => N) _x) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (F x)))
Case conversion may be inaccurate. Consider using '#align finsupp.lift_add_hom_apply Finsupp.liftAddHom_applyₓ'. -/
@[simp]
theorem liftAddHom_apply [AddCommMonoid M] [AddCommMonoid N] (F : α → M →+ N) (f : α →₀ M) :
    liftAddHom F f = f.Sum fun x => F x :=
  rfl
#align finsupp.lift_add_hom_apply Finsupp.liftAddHom_apply

/- warning: finsupp.lift_add_hom_symm_apply -> Finsupp.liftAddHom_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} N] (F : AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (x : α), Eq.{max (succ u3) (succ u2)} (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (coeFn.{max (succ (max u3 u1 u2)) (succ (max u1 u3 u2)), max (succ (max u3 u1 u2)) (succ (max u1 u3 u2))} (AddEquiv.{max u3 u1 u2, max u1 u3 u2} (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5))) (fun (_x : AddEquiv.{max u3 u1 u2, max u1 u3 u2} (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5))) => (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) -> α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddEquiv.hasCoeToFun.{max u3 u1 u2, max u1 u3 u2} (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5))) (AddEquiv.symm.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5) (Finsupp.liftAddHom.{u1, u2, u3} α M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) F x) (AddMonoidHom.comp.{u2, max u1 u2, u3} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) F (Finsupp.singleAddHom.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) x))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} N] (F : AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (x : α), Eq.{max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2)} (AddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (_x : AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) => α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) _x) (AddHomClass.toFunLike.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddZeroClass.toAdd.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)))) (AddZeroClass.toAdd.{max (max u1 u3) u2} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))) (AddEquivClass.instAddMonoidHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))))) (AddEquiv.symm.{max (max u1 u3) u2, max (max u1 u3) u2} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Finsupp.liftAddHom.{u1, u3, u2} α M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) F x) (AddMonoidHom.comp.{u3, max u1 u3, u2} M (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) F (Finsupp.singleAddHom.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) x))
Case conversion may be inaccurate. Consider using '#align finsupp.lift_add_hom_symm_apply Finsupp.liftAddHom_symm_applyₓ'. -/
@[simp]
theorem liftAddHom_symm_apply [AddCommMonoid M] [AddCommMonoid N] (F : (α →₀ M) →+ N) (x : α) :
    liftAddHom.symm F x = F.comp (singleAddHom x) :=
  rfl
#align finsupp.lift_add_hom_symm_apply Finsupp.liftAddHom_symm_apply

/- warning: finsupp.lift_add_hom_symm_apply_apply -> Finsupp.liftAddHom_symm_apply_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} N] (F : AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (x : α) (y : M), Eq.{succ u3} N (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (_x : AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) => M -> N) (AddMonoidHom.hasCoeToFun.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (coeFn.{max (succ (max u3 u1 u2)) (succ (max u1 u3 u2)), max (succ (max u3 u1 u2)) (succ (max u1 u3 u2))} (AddEquiv.{max u3 u1 u2, max u1 u3 u2} (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5))) (fun (_x : AddEquiv.{max u3 u1 u2, max u1 u3 u2} (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5))) => (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) -> α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddEquiv.hasCoeToFun.{max u3 u1 u2, max u1 u3 u2} (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5))) (AddEquiv.symm.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5) (Finsupp.liftAddHom.{u1, u2, u3} α M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) F x) y) (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) -> N) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) F (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) x y))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} N] (F : AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (x : α) (y : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M) => N) y) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M) => N) _x) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2)} (AddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (_x : AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) => α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) _x) (AddHomClass.toFunLike.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddZeroClass.toAdd.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)))) (AddZeroClass.toAdd.{max (max u1 u3) u2} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))) (AddEquivClass.instAddMonoidHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))))) (AddEquiv.symm.{max (max u1 u3) u2, max (max u1 u3) u2} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5) (Finsupp.liftAddHom.{u1, u3, u2} α M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) F x) y) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (succ u1) (succ u3), succ u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (fun (_x : Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) => N) _x) (AddHomClass.toFunLike.{max (max u1 u3) u2, max u1 u3, u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) N (AddZeroClass.toAdd.{max u1 u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u3) u2, max u1 u3, u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (AddMonoidHom.addMonoidHomClass.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) F (Finsupp.single.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) x y))
Case conversion may be inaccurate. Consider using '#align finsupp.lift_add_hom_symm_apply_apply Finsupp.liftAddHom_symm_apply_applyₓ'. -/
theorem liftAddHom_symm_apply_apply [AddCommMonoid M] [AddCommMonoid N] (F : (α →₀ M) →+ N) (x : α)
    (y : M) : liftAddHom.symm F x y = F (single x y) :=
  rfl
#align finsupp.lift_add_hom_symm_apply_apply Finsupp.liftAddHom_symm_apply_apply

/- warning: finsupp.lift_add_hom_single_add_hom -> Finsupp.liftAddHom_singleAddHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M], Eq.{succ (max u1 u2)} (AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (AddEquiv.{max u1 u2, max u1 u2} (α -> (AddMonoidHom.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Pi.instAdd.{u1, max u1 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (AddMonoidHom.hasAdd.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (fun (_x : AddEquiv.{max u1 u2, max u1 u2} (α -> (AddMonoidHom.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Pi.instAdd.{u1, max u1 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (AddMonoidHom.hasAdd.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) => (α -> (AddMonoidHom.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) -> (AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddEquiv.hasCoeToFun.{max u1 u2, max u1 u2} (α -> (AddMonoidHom.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Pi.instAdd.{u1, max u1 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (AddMonoidHom.hasAdd.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (Finsupp.liftAddHom.{u1, u2, max u1 u2} α M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)) (Finsupp.singleAddHom.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoidHom.id.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M], Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) => AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Finsupp.singleAddHom.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (AddEquiv.{max (max u1 u2) u2 u1, max u2 u1} (α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Pi.instAdd.{u1, max u2 u1} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoidHom.add.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (AddMonoidHom.add.{max u1 u2, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (fun (_x : α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) => AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) _x) (AddHomClass.toFunLike.{max u1 u2, max u1 u2, max u1 u2} (AddEquiv.{max (max u1 u2) u2 u1, max u2 u1} (α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Pi.instAdd.{u1, max u2 u1} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoidHom.add.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (AddMonoidHom.add.{max u1 u2, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddZeroClass.toAdd.{max u1 u2} (α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (Pi.addZeroClass.{u1, max u1 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddMonoidHom.addCommMonoid.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))))) (AddZeroClass.toAdd.{max u1 u2} (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddMonoidHom.addCommMonoid.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, max u1 u2, max u1 u2} (AddEquiv.{max (max u1 u2) u2 u1, max u2 u1} (α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Pi.instAdd.{u1, max u2 u1} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoidHom.add.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (AddMonoidHom.add.{max u1 u2, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Pi.addZeroClass.{u1, max u1 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddMonoidHom.addCommMonoid.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddMonoidHom.addCommMonoid.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddEquivClass.instAddMonoidHomClass.{max u1 u2, max u1 u2, max u1 u2} (AddEquiv.{max (max u1 u2) u2 u1, max u2 u1} (α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Pi.instAdd.{u1, max u2 u1} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoidHom.add.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (AddMonoidHom.add.{max u1 u2, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Pi.addZeroClass.{u1, max u1 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddMonoidHom.addCommMonoid.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoid.toAddZeroClass.{max u1 u2} (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddMonoidHom.addCommMonoid.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (AddEquiv.instAddEquivClassAddEquiv.{max u1 u2, max u1 u2} (α -> (AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))))) (AddMonoidHom.{max u2 u1, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (Pi.instAdd.{u1, max u2 u1} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))) (fun (i : α) => AddMonoidHom.add.{u2, max u2 u1} M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4))) (AddMonoidHom.add.{max u1 u2, max u2 u1} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)))))) (Finsupp.liftAddHom.{u1, u2, max u2 u1} α M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4)) (Finsupp.singleAddHom.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddMonoidHom.id.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))))
Case conversion may be inaccurate. Consider using '#align finsupp.lift_add_hom_single_add_hom Finsupp.liftAddHom_singleAddHomₓ'. -/
@[simp]
theorem liftAddHom_singleAddHom [AddCommMonoid M] :
    liftAddHom (singleAddHom : α → M →+ α →₀ M) = AddMonoidHom.id _ :=
  liftAddHom.toEquiv.apply_eq_iff_eq_symm_apply.2 rfl
#align finsupp.lift_add_hom_single_add_hom Finsupp.liftAddHom_singleAddHom

/- warning: finsupp.sum_single -> Finsupp.sum_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] (f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))), Eq.{succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.sum.{u1, u2, max u1 u2} α M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4) f (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))))) f
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] (f : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.sum.{u1, u2, max u1 u2} α M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4) f (Finsupp.single.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) f
Case conversion may be inaccurate. Consider using '#align finsupp.sum_single Finsupp.sum_singleₓ'. -/
@[simp]
theorem sum_single [AddCommMonoid M] (f : α →₀ M) : f.Sum single = f :=
  AddMonoidHom.congr_fun liftAddHom_singleAddHom f
#align finsupp.sum_single Finsupp.sum_single

/- warning: finsupp.sum_univ_single -> Finsupp.sum_univ_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : Fintype.{u1} α] (i : α) (m : M), Eq.{succ u2} M (Finset.sum.{u2, u1} M α _inst_4 (Finset.univ.{u1} α _inst_5) (fun (j : α) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) => α -> M) (Finsupp.coeFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) i m) j)) m
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : Fintype.{u1} α] (i : α) (m : M), Eq.{succ u2} M (Finset.sum.{u2, u1} M α _inst_4 (Finset.univ.{u1} α _inst_5) (fun (j : α) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.single.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) i m) j)) m
Case conversion may be inaccurate. Consider using '#align finsupp.sum_univ_single Finsupp.sum_univ_singleₓ'. -/
@[simp]
theorem sum_univ_single [AddCommMonoid M] [Fintype α] (i : α) (m : M) :
    (∑ j : α, (single i m) j) = m := by simp [single]
#align finsupp.sum_univ_single Finsupp.sum_univ_single

/- warning: finsupp.sum_univ_single' -> Finsupp.sum_univ_single' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : Fintype.{u1} α] (i : α) (m : M), Eq.{succ u2} M (Finset.sum.{u2, u1} M α _inst_4 (Finset.univ.{u1} α _inst_5) (fun (j : α) => coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) => α -> M) (Finsupp.coeFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) j m) i)) m
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : Fintype.{u1} α] (i : α) (m : M), Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) i) (Finset.sum.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) i) α _inst_4 (Finset.univ.{u1} α _inst_5) (fun (j : α) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.single.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) j m) i)) m
Case conversion may be inaccurate. Consider using '#align finsupp.sum_univ_single' Finsupp.sum_univ_single'ₓ'. -/
@[simp]
theorem sum_univ_single' [AddCommMonoid M] [Fintype α] (i : α) (m : M) :
    (∑ j : α, (single j m) i) = m := by simp [single]
#align finsupp.sum_univ_single' Finsupp.sum_univ_single'

/- warning: finsupp.lift_add_hom_apply_single -> Finsupp.liftAddHom_apply_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} N] (f : α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (a : α) (b : M), Eq.{succ u3} N (coeFn.{max (succ u3) (succ (max u1 u2)), max (succ (max u1 u2)) (succ u3)} (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (_x : AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) -> N) (AddMonoidHom.hasCoeToFun.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (coeFn.{max (succ (max u1 u3 u2)) (succ (max u3 u1 u2)), max (succ (max u1 u3 u2)) (succ (max u3 u1 u2))} (AddEquiv.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) (fun (_x : AddEquiv.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) => (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) -> (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddEquiv.hasCoeToFun.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) (Finsupp.liftAddHom.{u1, u2, u3} α M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5) f) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) a b)) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (_x : AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) => M -> N) (AddMonoidHom.hasCoeToFun.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (f a) b)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} N] (f : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (a : α) (b : M), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) => N) (Finsupp.single.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) a b)) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (succ u1) (succ u3), succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) f) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) (fun (_x : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) => N) _x) (AddHomClass.toFunLike.{max (max u1 u3) u2, max u1 u3, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) f) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (AddZeroClass.toAdd.{max u1 u3} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u3) u2, max u1 u3, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) f) (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (AddMonoidHom.addMonoidHomClass.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2)} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (fun (_x : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) _x) (AddHomClass.toFunLike.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddZeroClass.toAdd.{max (max u1 u3) u2} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))))) (AddZeroClass.toAdd.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))) (AddEquivClass.instAddMonoidHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))))) (Finsupp.liftAddHom.{u1, u3, u2} α M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5) f) (Finsupp.single.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) a b)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : M) => N) _x) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (AddMonoidHom.addMonoidHomClass.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (f a) b)
Case conversion may be inaccurate. Consider using '#align finsupp.lift_add_hom_apply_single Finsupp.liftAddHom_apply_singleₓ'. -/
@[simp]
theorem liftAddHom_apply_single [AddCommMonoid M] [AddCommMonoid N] (f : α → M →+ N) (a : α)
    (b : M) : liftAddHom f (single a b) = f a b :=
  sum_single_index (f a).map_zero
#align finsupp.lift_add_hom_apply_single Finsupp.liftAddHom_apply_single

/- warning: finsupp.lift_add_hom_comp_single -> Finsupp.liftAddHom_comp_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} N] (f : α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (a : α), Eq.{max (succ u3) (succ u2)} (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddMonoidHom.comp.{u2, max u1 u2, u3} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (coeFn.{max (succ (max u1 u3 u2)) (succ (max u3 u1 u2)), max (succ (max u1 u3 u2)) (succ (max u3 u1 u2))} (AddEquiv.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) (fun (_x : AddEquiv.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) => (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) -> (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddEquiv.hasCoeToFun.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) (Finsupp.liftAddHom.{u1, u2, u3} α M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5) f) (Finsupp.singleAddHom.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) a)) (f a)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} N] (f : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (a : α), Eq.{max (succ u3) (succ u2)} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.comp.{u3, max u1 u3, u2} M (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2)} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (fun (_x : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) _x) (AddHomClass.toFunLike.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddZeroClass.toAdd.{max (max u1 u3) u2} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5))))) (AddZeroClass.toAdd.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))) (AddEquivClass.instAddMonoidHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max (max u1 u3) u2} (AddEquiv.{max (max u1 u3) u2, max u2 u3 u1} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.addZeroClass.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u1 u3) u2, max (max u1 u3) u2} (α -> (AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (AddMonoidHom.{max u3 u1, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u3, u2} M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5))))) (Finsupp.liftAddHom.{u1, u3, u2} α M N (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5) f) (Finsupp.singleAddHom.{u1, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) a)) (f a)
Case conversion may be inaccurate. Consider using '#align finsupp.lift_add_hom_comp_single Finsupp.liftAddHom_comp_singleₓ'. -/
@[simp]
theorem liftAddHom_comp_single [AddCommMonoid M] [AddCommMonoid N] (f : α → M →+ N) (a : α) :
    (liftAddHom f).comp (singleAddHom a) = f a :=
  AddMonoidHom.ext fun b => liftAddHom_apply_single f a b
#align finsupp.lift_add_hom_comp_single Finsupp.liftAddHom_comp_single

/- warning: finsupp.comp_lift_add_hom -> Finsupp.comp_liftAddHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : AddCommMonoid.{u4} P] (g : AddMonoidHom.{u3, u4} N P (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6))) (f : α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))), Eq.{max (succ u4) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6))) (AddMonoidHom.comp.{max u1 u2, u3, u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N P (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6)) g (coeFn.{max (succ (max u1 u3 u2)) (succ (max u3 u1 u2)), max (succ (max u1 u3 u2)) (succ (max u3 u1 u2))} (AddEquiv.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) (fun (_x : AddEquiv.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) => (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) -> (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddEquiv.hasCoeToFun.{max u1 u3 u2, max u3 u1 u2} (α -> (AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u3 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u3} M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5)) (AddMonoidHom.hasAdd.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5)) (Finsupp.liftAddHom.{u1, u2, u3} α M N (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_5) f)) (coeFn.{max (succ (max u1 u4 u2)) (succ (max u4 u1 u2)), max (succ (max u1 u4 u2)) (succ (max u4 u1 u2))} (AddEquiv.{max u1 u4 u2, max u4 u1 u2} (α -> (AddMonoidHom.{u2, u4} M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6)))) (AddMonoidHom.{max u1 u2, u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6))) (Pi.instAdd.{u1, max u4 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u4} M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u4} M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_6)) (AddMonoidHom.hasAdd.{max u1 u2, u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_6)) (fun (_x : AddEquiv.{max u1 u4 u2, max u4 u1 u2} (α -> (AddMonoidHom.{u2, u4} M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6)))) (AddMonoidHom.{max u1 u2, u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6))) (Pi.instAdd.{u1, max u4 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u4} M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u4} M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_6)) (AddMonoidHom.hasAdd.{max u1 u2, u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_6)) => (α -> (AddMonoidHom.{u2, u4} M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6)))) -> (AddMonoidHom.{max u1 u2, u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6)))) (AddEquiv.hasCoeToFun.{max u1 u4 u2, max u4 u1 u2} (α -> (AddMonoidHom.{u2, u4} M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6)))) (AddMonoidHom.{max u1 u2, u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6))) (Pi.instAdd.{u1, max u4 u2} α (fun (ᾰ : α) => AddMonoidHom.{u2, u4} M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6))) (fun (i : α) => AddMonoidHom.hasAdd.{u2, u4} M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_6)) (AddMonoidHom.hasAdd.{max u1 u2, u4} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_6)) (Finsupp.liftAddHom.{u1, u2, u4} α M P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) _inst_6) (fun (a : α) => AddMonoidHom.comp.{u2, u3, u4} M N P (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_6)) g (f a)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {N : Type.{u3}} {P : Type.{u2}} [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : AddCommMonoid.{u2} P] (g : AddMonoidHom.{u3, u2} N P (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (f : α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))), Eq.{max (max (succ u1) (succ u4)) (succ u2)} (AddMonoidHom.{max u1 u4, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddMonoidHom.comp.{max u1 u4, u3, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)) g (FunLike.coe.{max (max (succ u1) (succ u4)) (succ u3), max (max (succ u1) (succ u4)) (succ u3), max (max (succ u1) (succ u4)) (succ u3)} (AddEquiv.{max (max u1 u4) u3, max u3 u4 u1} (α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u4 u3} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u4, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (fun (_x : α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) => AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) _x) (AddHomClass.toFunLike.{max (max u1 u4) u3, max (max u1 u4) u3, max (max u1 u4) u3} (AddEquiv.{max (max u1 u4) u3, max u3 u4 u1} (α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u4 u3} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u4, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddZeroClass.toAdd.{max (max u1 u4) u3} (α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Pi.addZeroClass.{u1, max u4 u3} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddMonoidHom.addCommMonoid.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5))))) (AddZeroClass.toAdd.{max (max u1 u4) u3} (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddMonoid.toAddZeroClass.{max (max u1 u4) u3} (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u4) u3} (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u4, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_5)))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u4) u3, max (max u1 u4) u3, max (max u1 u4) u3} (AddEquiv.{max (max u1 u4) u3, max u3 u4 u1} (α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u4 u3} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u4, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.addZeroClass.{u1, max u4 u3} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddMonoidHom.addCommMonoid.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u4) u3} (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u4) u3} (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u4, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_5))) (AddEquivClass.instAddMonoidHomClass.{max (max u1 u4) u3, max (max u1 u4) u3, max (max u1 u4) u3} (AddEquiv.{max (max u1 u4) u3, max u3 u4 u1} (α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u4 u3} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u4, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_5)) (α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.addZeroClass.{u1, max u4 u3} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u4 u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u4 u3} (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddMonoidHom.addCommMonoid.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5)))) (AddMonoid.toAddZeroClass.{max (max u1 u4) u3} (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddCommMonoid.toAddMonoid.{max (max u1 u4) u3} (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (AddMonoidHom.addCommMonoid.{max u1 u4, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_5))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u1 u4) u3, max (max u1 u4) u3} (α -> (AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoidHom.{max u4 u1, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Pi.instAdd.{u1, max u4 u3} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (fun (i : α) => AddMonoidHom.add.{u4, u3} M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5)) (AddMonoidHom.add.{max u1 u4, u3} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) N (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_5))))) (Finsupp.liftAddHom.{u1, u4, u3} α M N (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5) f)) (FunLike.coe.{max (max (succ u1) (succ u4)) (succ u2), max (max (succ u1) (succ u4)) (succ u2), max (max (succ u1) (succ u4)) (succ u2)} (AddEquiv.{max (max u1 u4) u2, max u2 u4 u1} (α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (Pi.instAdd.{u1, max u4 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (fun (i : α) => AddMonoidHom.add.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_6)) (AddMonoidHom.add.{max u1 u4, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_6)) (α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) (fun (_x : α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) => AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) _x) (AddHomClass.toFunLike.{max (max u1 u4) u2, max (max u1 u4) u2, max (max u1 u4) u2} (AddEquiv.{max (max u1 u4) u2, max u2 u4 u1} (α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (Pi.instAdd.{u1, max u4 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (fun (i : α) => AddMonoidHom.add.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_6)) (AddMonoidHom.add.{max u1 u4, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_6)) (α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddZeroClass.toAdd.{max (max u1 u4) u2} (α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) (Pi.addZeroClass.{u1, max u4 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u4 u2} (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddCommMonoid.toAddMonoid.{max u4 u2} (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddMonoidHom.addCommMonoid.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_6))))) (AddZeroClass.toAdd.{max (max u1 u4) u2} (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddMonoid.toAddZeroClass.{max (max u1 u4) u2} (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddCommMonoid.toAddMonoid.{max (max u1 u4) u2} (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddMonoidHom.addCommMonoid.{max u1 u4, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_6)))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u4) u2, max (max u1 u4) u2, max (max u1 u4) u2} (AddEquiv.{max (max u1 u4) u2, max u2 u4 u1} (α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (Pi.instAdd.{u1, max u4 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (fun (i : α) => AddMonoidHom.add.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_6)) (AddMonoidHom.add.{max u1 u4, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_6)) (α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (Pi.addZeroClass.{u1, max u4 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u4 u2} (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddCommMonoid.toAddMonoid.{max u4 u2} (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddMonoidHom.addCommMonoid.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_6)))) (AddMonoid.toAddZeroClass.{max (max u1 u4) u2} (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddCommMonoid.toAddMonoid.{max (max u1 u4) u2} (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddMonoidHom.addCommMonoid.{max u1 u4, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_6))) (AddEquivClass.instAddMonoidHomClass.{max (max u1 u4) u2, max (max u1 u4) u2, max (max u1 u4) u2} (AddEquiv.{max (max u1 u4) u2, max u2 u4 u1} (α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (Pi.instAdd.{u1, max u4 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (fun (i : α) => AddMonoidHom.add.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_6)) (AddMonoidHom.add.{max u1 u4, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_6)) (α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (Pi.addZeroClass.{u1, max u4 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (fun (i : α) => AddMonoid.toAddZeroClass.{max u4 u2} (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddCommMonoid.toAddMonoid.{max u4 u2} (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddMonoidHom.addCommMonoid.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_6)))) (AddMonoid.toAddZeroClass.{max (max u1 u4) u2} (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddCommMonoid.toAddMonoid.{max (max u1 u4) u2} (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (AddMonoidHom.addCommMonoid.{max u1 u4, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_6))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u1 u4) u2, max (max u1 u4) u2} (α -> (AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)))) (AddMonoidHom.{max u4 u1, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (Pi.instAdd.{u1, max u4 u2} α (fun (a._@.Mathlib.Algebra.BigOperators.Finsupp._hyg.7641 : α) => AddMonoidHom.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6))) (fun (i : α) => AddMonoidHom.add.{u4, u2} M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_6)) (AddMonoidHom.add.{max u1 u4, u2} (Finsupp.{u1, u4} α M (AddZeroClass.toZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) P (Finsupp.addZeroClass.{u1, u4} α M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) _inst_6))))) (Finsupp.liftAddHom.{u1, u4, u2} α M P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_6) (fun (a : α) => AddMonoidHom.comp.{u4, u3, u2} M N P (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (AddMonoid.toAddZeroClass.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_6)) g (f a)))
Case conversion may be inaccurate. Consider using '#align finsupp.comp_lift_add_hom Finsupp.comp_liftAddHomₓ'. -/
theorem comp_liftAddHom [AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P] (g : N →+ P)
    (f : α → M →+ N) : g.comp (liftAddHom f) = liftAddHom fun a => g.comp (f a) :=
  liftAddHom.symm_apply_eq.1 <|
    funext fun a => by
      rw [lift_add_hom_symm_apply, AddMonoidHom.comp_assoc, lift_add_hom_comp_single]
#align finsupp.comp_lift_add_hom Finsupp.comp_liftAddHom

/- warning: finsupp.sum_sub_index -> Finsupp.sum_sub_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {γ : Type.{u2}} {β : Type.{u3}} [_inst_4 : AddCommGroup.{u3} β] [_inst_5 : AddCommGroup.{u2} γ] {f : Finsupp.{u1, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (SubNegMonoid.toAddMonoid.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4)))))} {g : Finsupp.{u1, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (SubNegMonoid.toAddMonoid.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4)))))} {h : α -> β -> γ}, (forall (a : α) (b₁ : β) (b₂ : β), Eq.{succ u2} γ (h a (HSub.hSub.{u3, u3, u3} β β β (instHSub.{u3} β (SubNegMonoid.toHasSub.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4)))) b₁ b₂)) (HSub.hSub.{u2, u2, u2} γ γ γ (instHSub.{u2} γ (SubNegMonoid.toHasSub.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_5)))) (h a b₁) (h a b₂))) -> (Eq.{succ u2} γ (Finsupp.sum.{u1, u3, u2} α β γ (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (SubNegMonoid.toAddMonoid.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4))))) (AddCommGroup.toAddCommMonoid.{u2} γ _inst_5) (HSub.hSub.{max u1 u3, max u1 u3, max u1 u3} (Finsupp.{u1, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (SubNegMonoid.toAddMonoid.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4)))))) (Finsupp.{u1, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (SubNegMonoid.toAddMonoid.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4)))))) (Finsupp.{u1, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (SubNegMonoid.toAddMonoid.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4)))))) (instHSub.{max u1 u3} (Finsupp.{u1, u3} α β (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (SubNegMonoid.toAddMonoid.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4)))))) (Finsupp.sub.{u1, u3} α β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (AddGroup.toSubtractionMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4))))) f g) h) (HSub.hSub.{u2, u2, u2} γ γ γ (instHSub.{u2} γ (SubNegMonoid.toHasSub.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_5)))) (Finsupp.sum.{u1, u3, u2} α β γ (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (SubNegMonoid.toAddMonoid.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4))))) (AddCommGroup.toAddCommMonoid.{u2} γ _inst_5) f h) (Finsupp.sum.{u1, u3, u2} α β γ (AddZeroClass.toHasZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (SubNegMonoid.toAddMonoid.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4))))) (AddCommGroup.toAddCommMonoid.{u2} γ _inst_5) g h)))
but is expected to have type
  forall {α : Type.{u1}} {γ : Type.{u2}} {β : Type.{u3}} [_inst_4 : AddCommGroup.{u3} β] [_inst_5 : AddCommGroup.{u2} γ] {f : Finsupp.{u1, u3} α β (NegZeroClass.toZero.{u3} β (SubNegZeroMonoid.toNegZeroClass.{u3} β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (SubtractionCommMonoid.toSubtractionMonoid.{u3} β (AddCommGroup.toDivisionAddCommMonoid.{u3} β _inst_4)))))} {g : Finsupp.{u1, u3} α β (NegZeroClass.toZero.{u3} β (SubNegZeroMonoid.toNegZeroClass.{u3} β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (SubtractionCommMonoid.toSubtractionMonoid.{u3} β (AddCommGroup.toDivisionAddCommMonoid.{u3} β _inst_4)))))} {h : α -> β -> γ}, (forall (a : α) (b₁ : β) (b₂ : β), Eq.{succ u2} γ (h a (HSub.hSub.{u3, u3, u3} β β β (instHSub.{u3} β (SubNegMonoid.toSub.{u3} β (AddGroup.toSubNegMonoid.{u3} β (AddCommGroup.toAddGroup.{u3} β _inst_4)))) b₁ b₂)) (HSub.hSub.{u2, u2, u2} γ γ γ (instHSub.{u2} γ (SubNegMonoid.toSub.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_5)))) (h a b₁) (h a b₂))) -> (Eq.{succ u2} γ (Finsupp.sum.{u1, u3, u2} α β γ (NegZeroClass.toZero.{u3} β (SubNegZeroMonoid.toNegZeroClass.{u3} β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (SubtractionCommMonoid.toSubtractionMonoid.{u3} β (AddCommGroup.toDivisionAddCommMonoid.{u3} β _inst_4))))) (AddCommGroup.toAddCommMonoid.{u2} γ _inst_5) (HSub.hSub.{max u1 u3, max u1 u3, max u1 u3} (Finsupp.{u1, u3} α β (NegZeroClass.toZero.{u3} β (SubNegZeroMonoid.toNegZeroClass.{u3} β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (SubtractionCommMonoid.toSubtractionMonoid.{u3} β (AddCommGroup.toDivisionAddCommMonoid.{u3} β _inst_4)))))) (Finsupp.{u1, u3} α β (NegZeroClass.toZero.{u3} β (SubNegZeroMonoid.toNegZeroClass.{u3} β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (SubtractionCommMonoid.toSubtractionMonoid.{u3} β (AddCommGroup.toDivisionAddCommMonoid.{u3} β _inst_4)))))) (Finsupp.{u1, u3} α β (NegZeroClass.toZero.{u3} β (SubNegZeroMonoid.toNegZeroClass.{u3} β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (SubtractionCommMonoid.toSubtractionMonoid.{u3} β (AddCommGroup.toDivisionAddCommMonoid.{u3} β _inst_4)))))) (instHSub.{max u1 u3} (Finsupp.{u1, u3} α β (NegZeroClass.toZero.{u3} β (SubNegZeroMonoid.toNegZeroClass.{u3} β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (SubtractionCommMonoid.toSubtractionMonoid.{u3} β (AddCommGroup.toDivisionAddCommMonoid.{u3} β _inst_4)))))) (Finsupp.sub.{u1, u3} α β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (SubtractionCommMonoid.toSubtractionMonoid.{u3} β (AddCommGroup.toDivisionAddCommMonoid.{u3} β _inst_4))))) f g) h) (HSub.hSub.{u2, u2, u2} γ γ γ (instHSub.{u2} γ (SubNegMonoid.toSub.{u2} γ (AddGroup.toSubNegMonoid.{u2} γ (AddCommGroup.toAddGroup.{u2} γ _inst_5)))) (Finsupp.sum.{u1, u3, u2} α β γ (NegZeroClass.toZero.{u3} β (SubNegZeroMonoid.toNegZeroClass.{u3} β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (SubtractionCommMonoid.toSubtractionMonoid.{u3} β (AddCommGroup.toDivisionAddCommMonoid.{u3} β _inst_4))))) (AddCommGroup.toAddCommMonoid.{u2} γ _inst_5) f h) (Finsupp.sum.{u1, u3, u2} α β γ (NegZeroClass.toZero.{u3} β (SubNegZeroMonoid.toNegZeroClass.{u3} β (SubtractionMonoid.toSubNegZeroMonoid.{u3} β (SubtractionCommMonoid.toSubtractionMonoid.{u3} β (AddCommGroup.toDivisionAddCommMonoid.{u3} β _inst_4))))) (AddCommGroup.toAddCommMonoid.{u2} γ _inst_5) g h)))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_sub_index Finsupp.sum_sub_indexₓ'. -/
theorem sum_sub_index [AddCommGroup β] [AddCommGroup γ] {f g : α →₀ β} {h : α → β → γ}
    (h_sub : ∀ a b₁ b₂, h a (b₁ - b₂) = h a b₁ - h a b₂) : (f - g).Sum h = f.Sum h - g.Sum h :=
  (liftAddHom fun a => AddMonoidHom.ofMapSub (h a) (h_sub a)).map_sub f g
#align finsupp.sum_sub_index Finsupp.sum_sub_index

/- warning: finsupp.prod_emb_domain -> Finsupp.prod_embDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_4 : Zero.{u3} M] [_inst_5 : CommMonoid.{u4} N] {v : Finsupp.{u1, u3} α M _inst_4} {f : Function.Embedding.{succ u1, succ u2} α β} {g : β -> M -> N}, Eq.{succ u4} N (Finsupp.prod.{u2, u3, u4} β M N _inst_4 _inst_5 (Finsupp.embDomain.{u1, u2, u3} α β M _inst_4 f v) g) (Finsupp.prod.{u1, u3, u4} α M N _inst_4 _inst_5 v (fun (a : α) (b : M) => g (coeFn.{max 1 (succ u1) (succ u2), max (succ u1) (succ u2)} (Function.Embedding.{succ u1, succ u2} α β) (fun (_x : Function.Embedding.{succ u1, succ u2} α β) => α -> β) (Function.Embedding.hasCoeToFun.{succ u1, succ u2} α β) f a) b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {M : Type.{u4}} {N : Type.{u3}} [_inst_4 : Zero.{u4} M] [_inst_5 : CommMonoid.{u3} N] {v : Finsupp.{u2, u4} α M _inst_4} {f : Function.Embedding.{succ u2, succ u1} α β} {g : β -> M -> N}, Eq.{succ u3} N (Finsupp.prod.{u1, u4, u3} β M N _inst_4 _inst_5 (Finsupp.embDomain.{u2, u1, u4} α β M _inst_4 f v) g) (Finsupp.prod.{u2, u4, u3} α M N _inst_4 _inst_5 v (fun (a : α) (b : M) => g (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => β) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (Function.Embedding.{succ u2, succ u1} α β) α β (Function.instEmbeddingLikeEmbedding.{succ u2, succ u1} α β)) f a) b))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_emb_domain Finsupp.prod_embDomainₓ'. -/
@[to_additive]
theorem prod_embDomain [Zero M] [CommMonoid N] {v : α →₀ M} {f : α ↪ β} {g : β → M → N} :
    (v.embDomain f).Prod g = v.Prod fun a b => g (f a) b :=
  by
  rw [Prod, Prod, support_emb_domain, Finset.prod_map]
  simp_rw [emb_domain_apply]
#align finsupp.prod_emb_domain Finsupp.prod_embDomain
#align finsupp.sum_emb_domain Finsupp.sum_embDomain

/- warning: finsupp.prod_finset_sum_index -> Finsupp.prod_finset_sum_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : CommMonoid.{u4} N] {s : Finset.{u2} ι} {g : ι -> (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))))} {h : α -> M -> N}, (forall (a : α), Eq.{succ u4} N (h a (OfNat.ofNat.{u3} M 0 (OfNat.mk.{u3} M 0 (Zero.zero.{u3} M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))))))) (OfNat.ofNat.{u4} N 1 (OfNat.mk.{u4} N 1 (One.one.{u4} N (MulOneClass.toHasOne.{u4} N (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_5))))))) -> (forall (a : α) (b₁ : M) (b₂ : M), Eq.{succ u4} N (h a (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toHasAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) b₁ b₂)) (HMul.hMul.{u4, u4, u4} N N N (instHMul.{u4} N (MulOneClass.toHasMul.{u4} N (Monoid.toMulOneClass.{u4} N (CommMonoid.toMonoid.{u4} N _inst_5)))) (h a b₁) (h a b₂))) -> (Eq.{succ u4} N (Finset.prod.{u4, u2} N ι _inst_5 s (fun (i : ι) => Finsupp.prod.{u1, u3, u4} α M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5 (g i) h)) (Finsupp.prod.{u1, u3, u4} α M N (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_5 (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) ι (Finsupp.addCommMonoid.{u1, u3} α M _inst_4) s (fun (i : ι) => g i)) h))
but is expected to have type
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u4}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u4} M] [_inst_5 : CommMonoid.{u3} N] {s : Finset.{u2} ι} {g : ι -> (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))} {h : α -> M -> N}, (forall (a : α), Eq.{succ u3} N (h a (OfNat.ofNat.{u4} M 0 (Zero.toOfNat0.{u4} M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))))) (OfNat.ofNat.{u3} N 1 (One.toOfNat1.{u3} N (Monoid.toOne.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))))) -> (forall (a : α) (b₁ : M) (b₂ : M), Eq.{succ u3} N (h a (HAdd.hAdd.{u4, u4, u4} M M M (instHAdd.{u4} M (AddZeroClass.toAdd.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)))) b₁ b₂)) (HMul.hMul.{u3, u3, u3} N N N (instHMul.{u3} N (MulOneClass.toMul.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)))) (h a b₁) (h a b₂))) -> (Eq.{succ u3} N (Finset.prod.{u3, u2} N ι _inst_5 s (fun (i : ι) => Finsupp.prod.{u1, u4, u3} α M N (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5 (g i) h)) (Finsupp.prod.{u1, u4, u3} α M N (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4)) _inst_5 (Finset.sum.{max u1 u4, u2} (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_4))) ι (Finsupp.addCommMonoid.{u1, u4} α M _inst_4) s (fun (i : ι) => g i)) h))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_finset_sum_index Finsupp.prod_finset_sum_indexₓ'. -/
@[to_additive]
theorem prod_finset_sum_index [AddCommMonoid M] [CommMonoid N] {s : Finset ι} {g : ι → α →₀ M}
    {h : α → M → N} (h_zero : ∀ a, h a 0 = 1) (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) :
    (∏ i in s, (g i).Prod h) = (∑ i in s, g i).Prod h :=
  Finset.cons_induction_on s rfl fun a s has ih => by
    rw [prod_cons, ih, sum_cons, prod_add_index' h_zero h_add]
#align finsupp.prod_finset_sum_index Finsupp.prod_finset_sum_index
#align finsupp.sum_finset_sum_index Finsupp.sum_finset_sum_index

/- warning: finsupp.prod_sum_index -> Finsupp.prod_sum_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {M : Type.{u3}} {N : Type.{u4}} {P : Type.{u5}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u4} N] [_inst_6 : CommMonoid.{u5} P] {f : Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))} {g : α -> M -> (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))))} {h : β -> N -> P}, (forall (a : β), Eq.{succ u5} P (h a (OfNat.ofNat.{u4} N 0 (OfNat.mk.{u4} N 0 (Zero.zero.{u4} N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))))))) (OfNat.ofNat.{u5} P 1 (OfNat.mk.{u5} P 1 (One.one.{u5} P (MulOneClass.toHasOne.{u5} P (Monoid.toMulOneClass.{u5} P (CommMonoid.toMonoid.{u5} P _inst_6))))))) -> (forall (a : β) (b₁ : N) (b₂ : N), Eq.{succ u5} P (h a (HAdd.hAdd.{u4, u4, u4} N N N (instHAdd.{u4} N (AddZeroClass.toHasAdd.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) b₁ b₂)) (HMul.hMul.{u5, u5, u5} P P P (instHMul.{u5} P (MulOneClass.toHasMul.{u5} P (Monoid.toMulOneClass.{u5} P (CommMonoid.toMonoid.{u5} P _inst_6)))) (h a b₁) (h a b₂))) -> (Eq.{succ u5} P (Finsupp.prod.{u2, u4, u5} β N P (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))) _inst_6 (Finsupp.sum.{u1, u3, max u2 u4} α M (Finsupp.{u2, u4} β N (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Finsupp.addCommMonoid.{u2, u4} β N _inst_5) f g) h) (Finsupp.prod.{u1, u3, u5} α M P (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) _inst_6 f (fun (a : α) (b : M) => Finsupp.prod.{u2, u4, u5} β N P (AddZeroClass.toHasZero.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))) _inst_6 (g a b) h)))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {M : Type.{u5}} {N : Type.{u4}} {P : Type.{u3}} [_inst_4 : AddCommMonoid.{u5} M] [_inst_5 : AddCommMonoid.{u4} N] [_inst_6 : CommMonoid.{u3} P] {f : Finsupp.{u2, u5} α M (AddMonoid.toZero.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_4))} {g : α -> M -> (Finsupp.{u1, u4} β N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))} {h : β -> N -> P}, (forall (a : β), Eq.{succ u3} P (h a (OfNat.ofNat.{u4} N 0 (Zero.toOfNat0.{u4} N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))))) (OfNat.ofNat.{u3} P 1 (One.toOfNat1.{u3} P (Monoid.toOne.{u3} P (CommMonoid.toMonoid.{u3} P _inst_6))))) -> (forall (a : β) (b₁ : N) (b₂ : N), Eq.{succ u3} P (h a (HAdd.hAdd.{u4, u4, u4} N N N (instHAdd.{u4} N (AddZeroClass.toAdd.{u4} N (AddMonoid.toAddZeroClass.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)))) b₁ b₂)) (HMul.hMul.{u3, u3, u3} P P P (instHMul.{u3} P (MulOneClass.toMul.{u3} P (Monoid.toMulOneClass.{u3} P (CommMonoid.toMonoid.{u3} P _inst_6)))) (h a b₁) (h a b₂))) -> (Eq.{succ u3} P (Finsupp.prod.{u1, u4, u3} β N P (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)) _inst_6 (Finsupp.sum.{u2, u5, max u1 u4} α M (Finsupp.{u1, u4} β N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))) (AddMonoid.toZero.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_4)) (Finsupp.addCommMonoid.{u1, u4} β N _inst_5) f g) h) (Finsupp.prod.{u2, u5, u3} α M P (AddMonoid.toZero.{u5} M (AddCommMonoid.toAddMonoid.{u5} M _inst_4)) _inst_6 f (fun (a : α) (b : M) => Finsupp.prod.{u1, u4, u3} β N P (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5)) _inst_6 (g a b) h)))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_sum_index Finsupp.prod_sum_indexₓ'. -/
@[to_additive]
theorem prod_sum_index [AddCommMonoid M] [AddCommMonoid N] [CommMonoid P] {f : α →₀ M}
    {g : α → M → β →₀ N} {h : β → N → P} (h_zero : ∀ a, h a 0 = 1)
    (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ * h a b₂) :
    (f.Sum g).Prod h = f.Prod fun a b => (g a b).Prod h :=
  (prod_finset_sum_index h_zero h_add).symm
#align finsupp.prod_sum_index Finsupp.prod_sum_index
#align finsupp.sum_sum_index Finsupp.sum_sum_index

/- warning: finsupp.multiset_sum_sum_index -> Finsupp.multiset_sum_sum_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : AddCommMonoid.{u3} N] (f : Multiset.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))))) (h : α -> M -> N), (forall (a : α), Eq.{succ u3} N (h a (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))))))) (OfNat.ofNat.{u3} N 0 (OfNat.mk.{u3} N 0 (Zero.zero.{u3} N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))))))) -> (forall (a : α) (b₁ : M) (b₂ : M), Eq.{succ u3} N (h a (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) b₁ b₂)) (HAdd.hAdd.{u3, u3, u3} N N N (instHAdd.{u3} N (AddZeroClass.toHasAdd.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (h a b₁) (h a b₂))) -> (Eq.{succ u3} N (Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5 (Multiset.sum.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4) f) h) (Multiset.sum.{u3} N _inst_5 (Multiset.map.{max u1 u2, u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) N (fun (g : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) => Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5 g h) f)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : AddCommMonoid.{u2} N] (f : Multiset.{max u3 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) (h : α -> M -> N), (forall (a : α), Eq.{succ u2} N (h a (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))))) (OfNat.ofNat.{u2} N 0 (Zero.toOfNat0.{u2} N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) -> (forall (a : α) (b₁ : M) (b₂ : M), Eq.{succ u2} N (h a (HAdd.hAdd.{u3, u3, u3} M M M (instHAdd.{u3} M (AddZeroClass.toAdd.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) b₁ b₂)) (HAdd.hAdd.{u2, u2, u2} N N N (instHAdd.{u2} N (AddZeroClass.toAdd.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (h a b₁) (h a b₂))) -> (Eq.{succ u2} N (Finsupp.sum.{u1, u3, u2} α M N (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5 (Multiset.sum.{max u1 u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Finsupp.addCommMonoid.{u1, u3} α M _inst_4) f) h) (Multiset.sum.{u2} N _inst_5 (Multiset.map.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) N (fun (g : Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) => Finsupp.sum.{u1, u3, u2} α M N (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5 g h) f)))
Case conversion may be inaccurate. Consider using '#align finsupp.multiset_sum_sum_index Finsupp.multiset_sum_sum_indexₓ'. -/
theorem multiset_sum_sum_index [AddCommMonoid M] [AddCommMonoid N] (f : Multiset (α →₀ M))
    (h : α → M → N) (h₀ : ∀ a, h a 0 = 0)
    (h₁ : ∀ (a : α) (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ + h a b₂) :
    f.Sum.Sum h = (f.map fun g : α →₀ M => g.Sum h).Sum :=
  Multiset.induction_on f rfl fun a s ih => by
    rw [Multiset.sum_cons, Multiset.map_cons, Multiset.sum_cons, sum_add_index' h₀ h₁, ih]
#align finsupp.multiset_sum_sum_index Finsupp.multiset_sum_sum_index

/- warning: finsupp.support_sum_eq_bUnion -> Finsupp.support_sum_eq_bunionᵢ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {M : Type.{u3}} [_inst_4 : DecidableEq.{succ u1} α] [_inst_5 : AddCommMonoid.{u3} M] {g : ι -> (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))))} (s : Finset.{u2} ι), (forall (i₁ : ι) (i₂ : ι), (Ne.{succ u2} ι i₁ i₂) -> (Disjoint.{u1} (Finset.{u1} α) (Finset.partialOrder.{u1} α) (Finset.orderBot.{u1} α) (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))) (g i₁)) (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))) (g i₂)))) -> (Eq.{succ u1} (Finset.{u1} α) (Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))) (Finset.sum.{max u1 u3, u2} (Finsupp.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5)))) ι (Finsupp.addCommMonoid.{u1, u3} α M _inst_5) s (fun (i : ι) => g i))) (Finset.bunionᵢ.{u2, u1} ι α (fun (a : α) (b : α) => _inst_4 a b) s (fun (i : ι) => Finsupp.support.{u1, u3} α M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_5))) (g i))))
but is expected to have type
  forall {α : Type.{u3}} {ι : Type.{u2}} {M : Type.{u1}} [_inst_4 : DecidableEq.{succ u3} α] [_inst_5 : AddCommMonoid.{u1} M] {g : ι -> (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_5)))} (s : Finset.{u2} ι), (forall (i₁ : ι) (i₂ : ι), (Ne.{succ u2} ι i₁ i₂) -> (Disjoint.{u3} (Finset.{u3} α) (Finset.partialOrder.{u3} α) (Finset.instOrderBotFinsetToLEToPreorderPartialOrder.{u3} α) (Finsupp.support.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_5)) (g i₁)) (Finsupp.support.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_5)) (g i₂)))) -> (Eq.{succ u3} (Finset.{u3} α) (Finsupp.support.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_5)) (Finset.sum.{max u3 u1, u2} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_5))) ι (Finsupp.addCommMonoid.{u3, u1} α M _inst_5) s (fun (i : ι) => g i))) (Finset.bunionᵢ.{u2, u3} ι α (fun (a : α) (b : α) => _inst_4 a b) s (fun (i : ι) => Finsupp.support.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_5)) (g i))))
Case conversion may be inaccurate. Consider using '#align finsupp.support_sum_eq_bUnion Finsupp.support_sum_eq_bunionᵢₓ'. -/
theorem support_sum_eq_bunionᵢ {α : Type _} {ι : Type _} {M : Type _} [DecidableEq α]
    [AddCommMonoid M] {g : ι → α →₀ M} (s : Finset ι)
    (h : ∀ i₁ i₂, i₁ ≠ i₂ → Disjoint (g i₁).support (g i₂).support) :
    (∑ i in s, g i).support = s.bunionᵢ fun i => (g i).support := by
  classical
    apply Finset.induction_on s
    · simp
    · intro i s hi
      simp only [hi, sum_insert, not_false_iff, bUnion_insert]
      intro hs
      rw [Finsupp.support_add_eq, hs]
      rw [hs, Finset.disjoint_bunionᵢ_right]
      intro j hj
      refine' h _ _ (ne_of_mem_of_not_mem hj hi).symm
#align finsupp.support_sum_eq_bUnion Finsupp.support_sum_eq_bunionᵢ

/- warning: finsupp.multiset_map_sum -> Finsupp.multiset_map_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {γ : Type.{u2}} {β : Type.{u3}} {M : Type.{u4}} [_inst_4 : Zero.{u4} M] {f : Finsupp.{u1, u4} α M _inst_4} {m : β -> γ} {h : α -> M -> (Multiset.{u3} β)}, Eq.{succ u2} (Multiset.{u2} γ) (Multiset.map.{u3, u2} β γ m (Finsupp.sum.{u1, u4, u3} α M (Multiset.{u3} β) _inst_4 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u3} (Multiset.{u3} β) (Multiset.orderedCancelAddCommMonoid.{u3} β)) f h)) (Finsupp.sum.{u1, u4, u2} α M (Multiset.{u2} γ) _inst_4 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} (Multiset.{u2} γ) (Multiset.orderedCancelAddCommMonoid.{u2} γ)) f (fun (a : α) (b : M) => Multiset.map.{u3, u2} β γ m (h a b)))
but is expected to have type
  forall {α : Type.{u3}} {γ : Type.{u1}} {β : Type.{u2}} {M : Type.{u4}} [_inst_4 : Zero.{u4} M] {f : Finsupp.{u3, u4} α M _inst_4} {m : β -> γ} {h : α -> M -> (Multiset.{u2} β)}, Eq.{succ u1} (Multiset.{u1} γ) (Multiset.map.{u2, u1} β γ m (Finsupp.sum.{u3, u4, u2} α M (Multiset.{u2} β) _inst_4 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} (Multiset.{u2} β) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} β)) f h)) (Finsupp.sum.{u3, u4, u1} α M (Multiset.{u1} γ) _inst_4 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} (Multiset.{u1} γ) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u1} γ)) f (fun (a : α) (b : M) => Multiset.map.{u2, u1} β γ m (h a b)))
Case conversion may be inaccurate. Consider using '#align finsupp.multiset_map_sum Finsupp.multiset_map_sumₓ'. -/
theorem multiset_map_sum [Zero M] {f : α →₀ M} {m : β → γ} {h : α → M → Multiset β} :
    Multiset.map m (f.Sum h) = f.Sum fun a b => (h a b).map m :=
  (Multiset.mapAddMonoidHom m).map_sum _ f.support
#align finsupp.multiset_map_sum Finsupp.multiset_map_sum

/- warning: finsupp.multiset_sum_sum -> Finsupp.multiset_sum_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_5 : AddCommMonoid.{u3} N] {f : Finsupp.{u1, u2} α M _inst_4} {h : α -> M -> (Multiset.{u3} N)}, Eq.{succ u3} N (Multiset.sum.{u3} N _inst_5 (Finsupp.sum.{u1, u2, u3} α M (Multiset.{u3} N) _inst_4 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u3} (Multiset.{u3} N) (Multiset.orderedCancelAddCommMonoid.{u3} N)) f h)) (Finsupp.sum.{u1, u2, u3} α M N _inst_4 _inst_5 f (fun (a : α) (b : M) => Multiset.sum.{u3} N _inst_5 (h a b)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : Zero.{u3} M] [_inst_5 : AddCommMonoid.{u2} N] {f : Finsupp.{u1, u3} α M _inst_4} {h : α -> M -> (Multiset.{u2} N)}, Eq.{succ u2} N (Multiset.sum.{u2} N _inst_5 (Finsupp.sum.{u1, u3, u2} α M (Multiset.{u2} N) _inst_4 (OrderedCancelAddCommMonoid.toAddCommMonoid.{u2} (Multiset.{u2} N) (Multiset.instOrderedCancelAddCommMonoidMultiset.{u2} N)) f h)) (Finsupp.sum.{u1, u3, u2} α M N _inst_4 _inst_5 f (fun (a : α) (b : M) => Multiset.sum.{u2} N _inst_5 (h a b)))
Case conversion may be inaccurate. Consider using '#align finsupp.multiset_sum_sum Finsupp.multiset_sum_sumₓ'. -/
theorem multiset_sum_sum [Zero M] [AddCommMonoid N] {f : α →₀ M} {h : α → M → Multiset N} :
    Multiset.sum (f.Sum h) = f.Sum fun a b => Multiset.sum (h a b) :=
  (Multiset.sumAddMonoidHom : Multiset N →+ N).map_sum _ f.support
#align finsupp.multiset_sum_sum Finsupp.multiset_sum_sum

/- warning: finsupp.prod_add_index_of_disjoint -> Finsupp.prod_add_index_of_disjoint is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] {f1 : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))} {f2 : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))}, (Disjoint.{u1} (Finset.{u1} α) (Finset.partialOrder.{u1} α) (Finset.orderBot.{u1} α) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) f1) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) f2)) -> (forall {β : Type.{u3}} [_inst_5 : CommMonoid.{u3} β] (g : α -> M -> β), Eq.{succ u3} β (Finsupp.prod.{u1, u2, u3} α M β (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5 (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (instHAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.add.{u1, u2} α M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) f1 f2) g) (HMul.hMul.{u3, u3, u3} β β β (instHMul.{u3} β (MulOneClass.toHasMul.{u3} β (Monoid.toMulOneClass.{u3} β (CommMonoid.toMonoid.{u3} β _inst_5)))) (Finsupp.prod.{u1, u2, u3} α M β (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5 f1 g) (Finsupp.prod.{u1, u2, u3} α M β (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5 f2 g)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u3}} [_inst_4 : AddCommMonoid.{u3} M] {f1 : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))} {f2 : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))}, (Disjoint.{u2} (Finset.{u2} α) (Finset.partialOrder.{u2} α) (Finset.instOrderBotFinsetToLEToPreorderPartialOrder.{u2} α) (Finsupp.support.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) f1) (Finsupp.support.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) f2)) -> (forall {β : Type.{u1}} [_inst_5 : CommMonoid.{u1} β] (g : α -> M -> β), Eq.{succ u1} β (Finsupp.prod.{u2, u3, u1} α M β (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5 (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (instHAdd.{max u2 u3} (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) (Finsupp.add.{u2, u3} α M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)))) f1 f2) g) (HMul.hMul.{u1, u1, u1} β β β (instHMul.{u1} β (MulOneClass.toMul.{u1} β (Monoid.toMulOneClass.{u1} β (CommMonoid.toMonoid.{u1} β _inst_5)))) (Finsupp.prod.{u2, u3, u1} α M β (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5 f1 g) (Finsupp.prod.{u2, u3, u1} α M β (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5 f2 g)))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_add_index_of_disjoint Finsupp.prod_add_index_of_disjointₓ'. -/
/-- For disjoint `f1` and `f2`, and function `g`, the product of the products of `g`
over `f1` and `f2` equals the product of `g` over `f1 + f2` -/
@[to_additive
      "For disjoint `f1` and `f2`, and function `g`, the sum of the sums of `g`\nover `f1` and `f2` equals the sum of `g` over `f1 + f2`"]
theorem prod_add_index_of_disjoint [AddCommMonoid M] {f1 f2 : α →₀ M}
    (hd : Disjoint f1.support f2.support) {β : Type _} [CommMonoid β] (g : α → M → β) :
    (f1 + f2).Prod g = f1.Prod g * f2.Prod g :=
  by
  have :
    ∀ {f1 f2 : α →₀ M},
      Disjoint f1.support f2.support → (∏ x in f1.support, g x (f1 x + f2 x)) = f1.Prod g :=
    fun f1 f2 hd =>
    Finset.prod_congr rfl fun x hx => by
      simp only [not_mem_support_iff.mp (disjoint_left.mp hd hx), add_zero]
  classical simp_rw [← this hd, ← this hd.symm, add_comm (f2 _), Finsupp.prod, support_add_eq hd,
      prod_union hd, add_apply]
#align finsupp.prod_add_index_of_disjoint Finsupp.prod_add_index_of_disjoint
#align finsupp.sum_add_index_of_disjoint Finsupp.sum_add_index_of_disjoint

/- warning: finsupp.prod_dvd_prod_of_subset_of_dvd -> Finsupp.prod_dvd_prod_of_subset_of_dvd is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : AddCommMonoid.{u2} M] [_inst_5 : CommMonoid.{u3} N] {f1 : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))} {f2 : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))} {g1 : α -> M -> N} {g2 : α -> M -> N}, (HasSubset.Subset.{u1} (Finset.{u1} α) (Finset.hasSubset.{u1} α) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) f1) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) f2)) -> (forall (a : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) f1)) -> (Dvd.Dvd.{u3} N (semigroupDvd.{u3} N (Monoid.toSemigroup.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (g1 a (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) => α -> M) (Finsupp.coeFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) f1 a)) (g2 a (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) => α -> M) (Finsupp.coeFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) f2 a)))) -> (Dvd.Dvd.{u3} N (semigroupDvd.{u3} N (Monoid.toSemigroup.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5))) (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5 f1 g1) (Finsupp.prod.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) _inst_5 f2 g2))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : AddCommMonoid.{u3} M] [_inst_5 : CommMonoid.{u2} N] {f1 : Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))} {f2 : Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))} {g1 : α -> M -> N} {g2 : α -> M -> N}, (HasSubset.Subset.{u1} (Finset.{u1} α) (Finset.instHasSubsetFinset.{u1} α) (Finsupp.support.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) f1) (Finsupp.support.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) f2)) -> (forall (a : α), (Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) a (Finsupp.support.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) f1)) -> (Dvd.dvd.{u2} N (semigroupDvd.{u2} N (Monoid.toSemigroup.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (g1 a (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) f1 a)) (g2 a (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4))) f2 a)))) -> (Dvd.dvd.{u2} N (semigroupDvd.{u2} N (Monoid.toSemigroup.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5))) (Finsupp.prod.{u1, u3, u2} α M N (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5 f1 g1) (Finsupp.prod.{u1, u3, u2} α M N (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_4)) _inst_5 f2 g2))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_dvd_prod_of_subset_of_dvd Finsupp.prod_dvd_prod_of_subset_of_dvdₓ'. -/
theorem prod_dvd_prod_of_subset_of_dvd [AddCommMonoid M] [CommMonoid N] {f1 f2 : α →₀ M}
    {g1 g2 : α → M → N} (h1 : f1.support ⊆ f2.support)
    (h2 : ∀ a : α, a ∈ f1.support → g1 a (f1 a) ∣ g2 a (f2 a)) : f1.Prod g1 ∣ f2.Prod g2 := by
  classical
    simp only [Finsupp.prod, Finsupp.prod_mul]
    rw [← sdiff_union_of_subset h1, prod_union sdiff_disjoint]
    apply dvd_mul_of_dvd_right
    apply prod_dvd_prod_of_dvd
    exact h2
#align finsupp.prod_dvd_prod_of_subset_of_dvd Finsupp.prod_dvd_prod_of_subset_of_dvd

/- warning: finsupp.indicator_eq_sum_single -> Finsupp.indicator_eq_sum_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] (s : Finset.{u1} α) (f : forall (a : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a s) -> M), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Finsupp.indicator.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) s f) (Finset.sum.{max u1 u2, u1} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)))) (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4) (Finset.attach.{u1} α s) (fun (x : Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) => Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (coeBase.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (coeSubtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s))))) x) (f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (coeBase.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (coeSubtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s))))) x) (Subtype.property.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s) x))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_4 : AddCommMonoid.{u2} M] (s : Finset.{u1} α) (f : forall (a : α), (Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) a s) -> M), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Finsupp.indicator.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) s f) (Finset.sum.{max u2 u1, u1} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4))) (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_4) (Finset.attach.{u1} α s) (fun (x : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) => Finsupp.single.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_4)) (Subtype.val.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s) x) (f (Subtype.val.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s) x) (Subtype.property.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s) x))))
Case conversion may be inaccurate. Consider using '#align finsupp.indicator_eq_sum_single Finsupp.indicator_eq_sum_singleₓ'. -/
theorem indicator_eq_sum_single [AddCommMonoid M] (s : Finset α) (f : ∀ a ∈ s, M) :
    indicator s f = ∑ x in s.attach, single x (f x x.2) :=
  by
  rw [← sum_single (indicator s f), Sum, sum_subset (support_indicator_subset _ _), ← sum_attach]
  · refine' Finset.sum_congr rfl fun x hx => _
    rw [indicator_of_mem]
  intro i _ hi
  rw [not_mem_support_iff.mp hi, single_zero]
#align finsupp.indicator_eq_sum_single Finsupp.indicator_eq_sum_single

/- warning: finsupp.prod_indicator_index -> Finsupp.prod_indicator_index is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_4 : Zero.{u2} M] [_inst_5 : CommMonoid.{u3} N] {s : Finset.{u1} α} (f : forall (a : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a s) -> M) {h : α -> M -> N}, (forall (a : α), (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a s) -> (Eq.{succ u3} N (h a (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M _inst_4)))) (OfNat.ofNat.{u3} N 1 (OfNat.mk.{u3} N 1 (One.one.{u3} N (MulOneClass.toHasOne.{u3} N (Monoid.toMulOneClass.{u3} N (CommMonoid.toMonoid.{u3} N _inst_5)))))))) -> (Eq.{succ u3} N (Finsupp.prod.{u1, u2, u3} α M N _inst_4 _inst_5 (Finsupp.indicator.{u1, u2} α M _inst_4 s f) h) (Finset.prod.{u3, u1} N (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) _inst_5 (Finset.attach.{u1} α s) (fun (x : Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) => h ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (coeBase.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (coeSubtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s))))) x) (f ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (HasLiftT.mk.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (CoeTCₓ.coe.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (coeBase.{succ u1, succ u1} (Subtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s)) α (coeSubtype.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s))))) x) (Subtype.property.{succ u1} α (fun (x : α) => Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) x s) x)))))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} [_inst_4 : Zero.{u3} M] [_inst_5 : CommMonoid.{u2} N] {s : Finset.{u1} α} (f : forall (a : α), (Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) a s) -> M) {h : α -> M -> N}, (forall (a : α), (Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) a s) -> (Eq.{succ u2} N (h a (OfNat.ofNat.{u3} M 0 (Zero.toOfNat0.{u3} M _inst_4))) (OfNat.ofNat.{u2} N 1 (One.toOfNat1.{u2} N (Monoid.toOne.{u2} N (CommMonoid.toMonoid.{u2} N _inst_5)))))) -> (Eq.{succ u2} N (Finsupp.prod.{u1, u3, u2} α M N _inst_4 _inst_5 (Finsupp.indicator.{u1, u3} α M _inst_4 s f) h) (Finset.prod.{u2, u1} N (Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) _inst_5 (Finset.attach.{u1} α s) (fun (x : Subtype.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s)) => h (Subtype.val.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s) x) (f (Subtype.val.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s) x) (Subtype.property.{succ u1} α (fun (x : α) => Membership.mem.{u1, u1} α (Finset.{u1} α) (Finset.instMembershipFinset.{u1} α) x s) x)))))
Case conversion may be inaccurate. Consider using '#align finsupp.prod_indicator_index Finsupp.prod_indicator_indexₓ'. -/
@[simp, to_additive]
theorem prod_indicator_index [Zero M] [CommMonoid N] {s : Finset α} (f : ∀ a ∈ s, M) {h : α → M → N}
    (h_zero : ∀ a ∈ s, h a 0 = 1) : (indicator s f).Prod h = ∏ x in s.attach, h x (f x x.2) :=
  by
  rw [prod_of_support_subset _ (support_indicator_subset _ _) h h_zero, ← prod_attach]
  refine' Finset.prod_congr rfl fun x hx => _
  rw [indicator_of_mem]
#align finsupp.prod_indicator_index Finsupp.prod_indicator_index
#align finsupp.sum_indicator_index Finsupp.sum_indicator_index

end Finsupp

/- warning: finset.sum_apply' -> Finset.sum_apply' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {A : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} A] {s : Finset.{u1} α} {f : α -> (Finsupp.{u2, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))))} (i : ι), Eq.{succ u3} A (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))) (fun (_x : Finsupp.{u2, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))) => ι -> A) (Finsupp.coeFun.{u2, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))) (Finset.sum.{max u2 u3, u1} (Finsupp.{u2, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))) α (Finsupp.addCommMonoid.{u2, u3} ι A _inst_1) s (fun (k : α) => f k)) i) (Finset.sum.{u3, u1} A α _inst_1 s (fun (k : α) => coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (Finsupp.{u2, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))) (fun (_x : Finsupp.{u2, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))) => ι -> A) (Finsupp.coeFun.{u2, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))) (f k) i))
but is expected to have type
  forall {α : Type.{u1}} {ι : Type.{u2}} {A : Type.{u3}} [_inst_1 : AddCommMonoid.{u3} A] {s : Finset.{u1} α} {f : α -> (Finsupp.{u2, u3} ι A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))} (i : ι), Eq.{succ u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => A) i) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Finsupp.{u2, u3} ι A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => A) _x) (Finsupp.funLike.{u2, u3} ι A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))) (Finset.sum.{max u2 u3, u1} (Finsupp.{u2, u3} ι A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))) α (Finsupp.addCommMonoid.{u2, u3} ι A _inst_1) s (fun (k : α) => f k)) i) (Finset.sum.{u3, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => A) i) α _inst_1 s (fun (k : α) => FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (Finsupp.{u2, u3} ι A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => A) _x) (Finsupp.funLike.{u2, u3} ι A (AddMonoid.toZero.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))) (f k) i))
Case conversion may be inaccurate. Consider using '#align finset.sum_apply' Finset.sum_apply'ₓ'. -/
theorem Finset.sum_apply' : (∑ k in s, f k) i = ∑ k in s, f k i :=
  (Finsupp.applyAddHom i : (ι →₀ A) →+ A).map_sum f s
#align finset.sum_apply' Finset.sum_apply'

/- warning: finsupp.sum_apply' -> Finsupp.sum_apply' is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {γ : Type.{u2}} {A : Type.{u3}} {B : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} A] [_inst_2 : AddCommMonoid.{u4} B] (g : Finsupp.{u1, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))) (k : ι -> A -> γ -> B) (x : γ), Eq.{succ u4} B (Finsupp.sum.{u1, u3, max u2 u4} ι A (γ -> B) (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))) (Pi.addCommMonoid.{u2, u4} γ (fun (ᾰ : γ) => B) (fun (i : γ) => _inst_2)) g k x) (Finsupp.sum.{u1, u3, u4} ι A B (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))) _inst_2 g (fun (i : ι) (b : A) => k i b x))
but is expected to have type
  forall {ι : Type.{u3}} {γ : Type.{u1}} {A : Type.{u2}} {B : Type.{u4}} [_inst_1 : AddCommMonoid.{u2} A] [_inst_2 : AddCommMonoid.{u4} B] (g : Finsupp.{u3, u2} ι A (AddMonoid.toZero.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_1))) (k : ι -> A -> γ -> B) (x : γ), Eq.{succ u4} B (Finsupp.sum.{u3, u2, max u1 u4} ι A (γ -> B) (AddMonoid.toZero.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_1)) (Pi.addCommMonoid.{u1, u4} γ (fun (ᾰ : γ) => B) (fun (i : γ) => _inst_2)) g k x) (Finsupp.sum.{u3, u2, u4} ι A B (AddMonoid.toZero.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_1)) _inst_2 g (fun (i : ι) (b : A) => k i b x))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_apply' Finsupp.sum_apply'ₓ'. -/
theorem Finsupp.sum_apply' : g.Sum k x = g.Sum fun i b => k i b x :=
  Finset.sum_apply _ _ _
#align finsupp.sum_apply' Finsupp.sum_apply'

section

include h0 h1

open Classical

/- warning: finsupp.sum_sum_index' -> Finsupp.sum_sum_index' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {ι : Type.{u2}} {A : Type.{u3}} {C : Type.{u4}} [_inst_1 : AddCommMonoid.{u3} A] [_inst_3 : AddCommMonoid.{u4} C] {t : ι -> A -> C}, (forall (i : ι), Eq.{succ u4} C (t i (OfNat.ofNat.{u3} A 0 (OfNat.mk.{u3} A 0 (Zero.zero.{u3} A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))))))) (OfNat.ofNat.{u4} C 0 (OfNat.mk.{u4} C 0 (Zero.zero.{u4} C (AddZeroClass.toHasZero.{u4} C (AddMonoid.toAddZeroClass.{u4} C (AddCommMonoid.toAddMonoid.{u4} C _inst_3))))))) -> (forall (i : ι) (x : A) (y : A), Eq.{succ u4} C (t i (HAdd.hAdd.{u3, u3, u3} A A A (instHAdd.{u3} A (AddZeroClass.toHasAdd.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))) x y)) (HAdd.hAdd.{u4, u4, u4} C C C (instHAdd.{u4} C (AddZeroClass.toHasAdd.{u4} C (AddMonoid.toAddZeroClass.{u4} C (AddCommMonoid.toAddMonoid.{u4} C _inst_3)))) (t i x) (t i y))) -> (forall {s : Finset.{u1} α} {f : α -> (Finsupp.{u2, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))))}, Eq.{succ u4} C (Finsupp.sum.{u2, u3, u4} ι A C (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))) _inst_3 (Finset.sum.{max u2 u3, u1} (Finsupp.{u2, u3} ι A (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1)))) α (Finsupp.addCommMonoid.{u2, u3} ι A _inst_1) s (fun (x : α) => f x)) t) (Finset.sum.{u4, u1} C α _inst_3 s (fun (x : α) => Finsupp.sum.{u2, u3, u4} ι A C (AddZeroClass.toHasZero.{u3} A (AddMonoid.toAddZeroClass.{u3} A (AddCommMonoid.toAddMonoid.{u3} A _inst_1))) _inst_3 (f x) t)))
but is expected to have type
  forall {α : Type.{u1}} {ι : Type.{u3}} {A : Type.{u2}} {C : Type.{u4}} [_inst_1 : AddCommMonoid.{u2} A] [_inst_3 : AddCommMonoid.{u4} C] {t : ι -> A -> C}, (forall (i : ι), Eq.{succ u4} C (t i (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_1))))) (OfNat.ofNat.{u4} C 0 (Zero.toOfNat0.{u4} C (AddMonoid.toZero.{u4} C (AddCommMonoid.toAddMonoid.{u4} C _inst_3))))) -> (forall (i : ι) (x : A) (y : A), Eq.{succ u4} C (t i (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_1)))) x y)) (HAdd.hAdd.{u4, u4, u4} C C C (instHAdd.{u4} C (AddZeroClass.toAdd.{u4} C (AddMonoid.toAddZeroClass.{u4} C (AddCommMonoid.toAddMonoid.{u4} C _inst_3)))) (t i x) (t i y))) -> (forall {s : Finset.{u1} α} {f : α -> (Finsupp.{u3, u2} ι A (AddMonoid.toZero.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_1)))}, Eq.{succ u4} C (Finsupp.sum.{u3, u2, u4} ι A C (AddMonoid.toZero.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_1)) _inst_3 (Finset.sum.{max u3 u2, u1} (Finsupp.{u3, u2} ι A (AddMonoid.toZero.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_1))) α (Finsupp.addCommMonoid.{u3, u2} ι A _inst_1) s (fun (x : α) => f x)) t) (Finset.sum.{u4, u1} C α _inst_3 s (fun (x : α) => Finsupp.sum.{u3, u2, u4} ι A C (AddMonoid.toZero.{u2} A (AddCommMonoid.toAddMonoid.{u2} A _inst_1)) _inst_3 (f x) t)))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_sum_index' Finsupp.sum_sum_index'ₓ'. -/
theorem Finsupp.sum_sum_index' : (∑ x in s, f x).Sum t = ∑ x in s, (f x).Sum t :=
  Finset.induction_on s rfl fun a s has ih => by
    simp_rw [Finset.sum_insert has, Finsupp.sum_add_index' h0 h1, ih]
#align finsupp.sum_sum_index' Finsupp.sum_sum_index'

end

section

variable [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S]

/- warning: finsupp.sum_mul -> Finsupp.sum_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_4 : NonUnitalNonAssocSemiring.{u2} R] [_inst_5 : NonUnitalNonAssocSemiring.{u3} S] (b : S) (s : Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4))) {f : α -> R -> S}, Eq.{succ u3} S (HMul.hMul.{u3, u3, u3} S S S (instHMul.{u3} S (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_5))) (Finsupp.sum.{u1, u2, u3} α R S (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S _inst_5) s f) b) (Finsupp.sum.{u1, u2, u3} α R S (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S _inst_5) s (fun (a : α) (c : R) => HMul.hMul.{u3, u3, u3} S S S (instHMul.{u3} S (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_5))) (f a c) b))
but is expected to have type
  forall {α : Type.{u3}} {R : Type.{u2}} {S : Type.{u1}} [_inst_4 : NonUnitalNonAssocSemiring.{u2} R] [_inst_5 : NonUnitalNonAssocSemiring.{u1} S] (b : S) (s : Finsupp.{u3, u2} α R (MulZeroClass.toZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4))) {f : α -> R -> S}, Eq.{succ u1} S (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5)) (Finsupp.sum.{u3, u2, u1} α R S (MulZeroClass.toZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S _inst_5) s f) b) (Finsupp.sum.{u3, u2, u1} α R S (MulZeroClass.toZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S _inst_5) s (fun (a : α) (c : R) => HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5)) (f a c) b))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_mul Finsupp.sum_mulₓ'. -/
theorem Finsupp.sum_mul (b : S) (s : α →₀ R) {f : α → R → S} :
    s.Sum f * b = s.Sum fun a c => f a c * b := by simp only [Finsupp.sum, Finset.sum_mul]
#align finsupp.sum_mul Finsupp.sum_mul

/- warning: finsupp.mul_sum -> Finsupp.mul_sum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_4 : NonUnitalNonAssocSemiring.{u2} R] [_inst_5 : NonUnitalNonAssocSemiring.{u3} S] (b : S) (s : Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4))) {f : α -> R -> S}, Eq.{succ u3} S (HMul.hMul.{u3, u3, u3} S S S (instHMul.{u3} S (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_5))) b (Finsupp.sum.{u1, u2, u3} α R S (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S _inst_5) s f)) (Finsupp.sum.{u1, u2, u3} α R S (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S _inst_5) s (fun (a : α) (c : R) => HMul.hMul.{u3, u3, u3} S S S (instHMul.{u3} S (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S _inst_5))) b (f a c)))
but is expected to have type
  forall {α : Type.{u3}} {R : Type.{u2}} {S : Type.{u1}} [_inst_4 : NonUnitalNonAssocSemiring.{u2} R] [_inst_5 : NonUnitalNonAssocSemiring.{u1} S] (b : S) (s : Finsupp.{u3, u2} α R (MulZeroClass.toZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4))) {f : α -> R -> S}, Eq.{succ u1} S (HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5)) b (Finsupp.sum.{u3, u2, u1} α R S (MulZeroClass.toZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S _inst_5) s f)) (Finsupp.sum.{u3, u2, u1} α R S (MulZeroClass.toZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S _inst_5) s (fun (a : α) (c : R) => HMul.hMul.{u1, u1, u1} S S S (instHMul.{u1} S (NonUnitalNonAssocSemiring.toMul.{u1} S _inst_5)) b (f a c)))
Case conversion may be inaccurate. Consider using '#align finsupp.mul_sum Finsupp.mul_sumₓ'. -/
theorem Finsupp.mul_sum (b : S) (s : α →₀ R) {f : α → R → S} :
    b * s.Sum f = s.Sum fun a c => b * f a c := by simp only [Finsupp.sum, Finset.mul_sum]
#align finsupp.mul_sum Finsupp.mul_sum

end

namespace Nat

#print Nat.prod_pow_pos_of_zero_not_mem_support /-
/-- If `0 : ℕ` is not in the support of `f : ℕ →₀ ℕ` then `0 < ∏ x in f.support, x ^ (f x)`. -/
theorem prod_pow_pos_of_zero_not_mem_support {f : ℕ →₀ ℕ} (hf : 0 ∉ f.support) : 0 < f.Prod pow :=
  Finset.prod_pos fun a ha =>
    pos_iff_ne_zero.mpr
      (pow_ne_zero _ fun H => by
        subst H
        exact hf ha)
#align nat.prod_pow_pos_of_zero_not_mem_support Nat.prod_pow_pos_of_zero_not_mem_support
-/

end Nat

