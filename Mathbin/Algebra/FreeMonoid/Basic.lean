/-
Copyright (c) 2019 Simon Hudon. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Simon Hudon, Yury Kudryashov

! This file was ported from Lean 3 source module algebra.free_monoid.basic
! leanprover-community/mathlib commit 0ebfdb71919ac6ca5d7fbc61a082fa2519556818
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.List.BigOperators.Basic

/-!
# Free monoid over a given alphabet

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main definitions

* `free_monoid α`: free monoid over alphabet `α`; defined as a synonym for `list α`
  with multiplication given by `(++)`.
* `free_monoid.of`: embedding `α → free_monoid α` sending each element `x` to `[x]`;
* `free_monoid.lift`: natural equivalence between `α → M` and `free_monoid α →* M`
* `free_monoid.map`: embedding of `α → β` into `free_monoid α →* free_monoid β` given by `list.map`.
-/


variable {α : Type _} {β : Type _} {γ : Type _} {M : Type _} [Monoid M] {N : Type _} [Monoid N]

#print FreeMonoid /-
/-- Free monoid over a given alphabet. -/
@[to_additive "Free nonabelian additive monoid over a given alphabet"]
def FreeMonoid (α) :=
  List α
#align free_monoid FreeMonoid
#align free_add_monoid FreeAddMonoid
-/

namespace FreeMonoid

@[to_additive]
instance [DecidableEq α] : DecidableEq (FreeMonoid α) :=
  List.decidableEq

#print FreeMonoid.toList /-
/-- The identity equivalence between `free_monoid α` and `list α`. -/
@[to_additive "The identity equivalence between `free_add_monoid α` and `list α`."]
def toList : FreeMonoid α ≃ List α :=
  Equiv.refl _
#align free_monoid.to_list FreeMonoid.toList
#align free_add_monoid.to_list FreeAddMonoid.toList
-/

#print FreeMonoid.ofList /-
/-- The identity equivalence between `list α` and `free_monoid α`. -/
@[to_additive "The identity equivalence between `list α` and `free_add_monoid α`."]
def ofList : List α ≃ FreeMonoid α :=
  Equiv.refl _
#align free_monoid.of_list FreeMonoid.ofList
#align free_add_monoid.of_list FreeAddMonoid.ofList
-/

#print FreeMonoid.toList_symm /-
@[simp, to_additive]
theorem toList_symm : (@toList α).symm = ofList :=
  rfl
#align free_monoid.to_list_symm FreeMonoid.toList_symm
#align free_add_monoid.to_list_symm FreeAddMonoid.toList_symm
-/

#print FreeMonoid.ofList_symm /-
@[simp, to_additive]
theorem ofList_symm : (@ofList α).symm = toList :=
  rfl
#align free_monoid.of_list_symm FreeMonoid.ofList_symm
#align free_add_monoid.of_list_symm FreeAddMonoid.ofList_symm
-/

#print FreeMonoid.toList_ofList /-
@[simp, to_additive]
theorem toList_ofList (l : List α) : toList (ofList l) = l :=
  rfl
#align free_monoid.to_list_of_list FreeMonoid.toList_ofList
#align free_add_monoid.to_list_of_list FreeAddMonoid.toList_ofList
-/

#print FreeMonoid.ofList_toList /-
@[simp, to_additive]
theorem ofList_toList (xs : FreeMonoid α) : ofList (toList xs) = xs :=
  rfl
#align free_monoid.of_list_to_list FreeMonoid.ofList_toList
#align free_add_monoid.of_list_to_list FreeAddMonoid.ofList_toList
-/

#print FreeMonoid.toList_comp_ofList /-
@[simp, to_additive]
theorem toList_comp_ofList : @toList α ∘ ofList = id :=
  rfl
#align free_monoid.to_list_comp_of_list FreeMonoid.toList_comp_ofList
#align free_add_monoid.to_list_comp_of_list FreeAddMonoid.toList_comp_ofList
-/

#print FreeMonoid.ofList_comp_toList /-
@[simp, to_additive]
theorem ofList_comp_toList : @ofList α ∘ toList = id :=
  rfl
#align free_monoid.of_list_comp_to_list FreeMonoid.ofList_comp_toList
#align free_add_monoid.of_list_comp_to_list FreeAddMonoid.ofList_comp_toList
-/

@[to_additive]
instance : CancelMonoid (FreeMonoid α)
    where
  one := ofList []
  mul x y := ofList (x.toList ++ y.toList)
  mul_one := List.append_nil
  one_mul := List.nil_append
  mul_assoc := List.append_assoc
  mul_left_cancel _ _ _ := List.append_left_cancel
  mul_right_cancel _ _ _ := List.append_right_cancel

@[to_additive]
instance : Inhabited (FreeMonoid α) :=
  ⟨1⟩

#print FreeMonoid.toList_one /-
@[simp, to_additive]
theorem toList_one : (1 : FreeMonoid α).toList = [] :=
  rfl
#align free_monoid.to_list_one FreeMonoid.toList_one
#align free_add_monoid.to_list_zero FreeAddMonoid.toList_zero
-/

#print FreeMonoid.ofList_nil /-
@[simp, to_additive]
theorem ofList_nil : ofList ([] : List α) = 1 :=
  rfl
#align free_monoid.of_list_nil FreeMonoid.ofList_nil
#align free_add_monoid.of_list_nil FreeAddMonoid.ofList_nil
-/

#print FreeMonoid.toList_mul /-
@[simp, to_additive]
theorem toList_mul (xs ys : FreeMonoid α) : (xs * ys).toList = xs.toList ++ ys.toList :=
  rfl
#align free_monoid.to_list_mul FreeMonoid.toList_mul
#align free_add_monoid.to_list_add FreeAddMonoid.toList_add
-/

#print FreeMonoid.ofList_append /-
@[simp, to_additive]
theorem ofList_append (xs ys : List α) : ofList (xs ++ ys) = ofList xs * ofList ys :=
  rfl
#align free_monoid.of_list_append FreeMonoid.ofList_append
#align free_add_monoid.of_list_append FreeAddMonoid.ofList_append
-/

#print FreeMonoid.toList_prod /-
@[simp, to_additive]
theorem toList_prod (xs : List (FreeMonoid α)) : toList xs.prod = (xs.map toList).join := by
  induction xs <;> simp [*, List.join]
#align free_monoid.to_list_prod FreeMonoid.toList_prod
#align free_add_monoid.to_list_sum FreeAddMonoid.toList_sum
-/

#print FreeMonoid.ofList_join /-
@[simp, to_additive]
theorem ofList_join (xs : List (List α)) : ofList xs.join = (xs.map ofList).prod :=
  toList.injective <| by simp
#align free_monoid.of_list_join FreeMonoid.ofList_join
#align free_add_monoid.of_list_join FreeAddMonoid.ofList_join
-/

#print FreeMonoid.of /-
/-- Embeds an element of `α` into `free_monoid α` as a singleton list. -/
@[to_additive "Embeds an element of `α` into `free_add_monoid α` as a singleton list."]
def of (x : α) : FreeMonoid α :=
  ofList [x]
#align free_monoid.of FreeMonoid.of
#align free_add_monoid.of FreeAddMonoid.of
-/

#print FreeMonoid.toList_of /-
@[simp, to_additive]
theorem toList_of (x : α) : toList (of x) = [x] :=
  rfl
#align free_monoid.to_list_of FreeMonoid.toList_of
#align free_add_monoid.to_list_of FreeAddMonoid.toList_of
-/

#print FreeMonoid.ofList_singleton /-
@[to_additive]
theorem ofList_singleton (x : α) : ofList [x] = of x :=
  rfl
#align free_monoid.of_list_singleton FreeMonoid.ofList_singleton
#align free_add_monoid.of_list_singleton FreeAddMonoid.ofList_singleton
-/

#print FreeMonoid.ofList_cons /-
@[simp, to_additive]
theorem ofList_cons (x : α) (xs : List α) : ofList (x :: xs) = of x * ofList xs :=
  rfl
#align free_monoid.of_list_cons FreeMonoid.ofList_cons
#align free_add_monoid.of_list_cons FreeAddMonoid.ofList_cons
-/

#print FreeMonoid.toList_of_mul /-
@[to_additive]
theorem toList_of_mul (x : α) (xs : FreeMonoid α) : toList (of x * xs) = x :: xs.toList :=
  rfl
#align free_monoid.to_list_of_mul FreeMonoid.toList_of_mul
#align free_add_monoid.to_list_of_add FreeAddMonoid.toList_of_add
-/

#print FreeMonoid.of_injective /-
@[to_additive]
theorem of_injective : Function.Injective (@of α) :=
  List.singleton_injective
#align free_monoid.of_injective FreeMonoid.of_injective
#align free_add_monoid.of_injective FreeAddMonoid.of_injective
-/

/- warning: free_monoid.rec_on -> FreeMonoid.recOn is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {C : (FreeMonoid.{u1} α) -> Sort.{u2}} (xs : FreeMonoid.{u1} α), (C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (OfNat.mk.{u1} (FreeMonoid.{u1} α) 1 (One.one.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasOne.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))))))))) -> (forall (x : α) (xs : FreeMonoid.{u1} α), (C xs) -> (C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs))) -> (C xs)
but is expected to have type
  forall {α : Type.{u1}} {C : (FreeMonoid.{u1} α) -> Sort.{u2}} (xs : FreeMonoid.{u1} α), (C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (One.toOfNat1.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toOne.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))))) -> (forall (x : α) (xs : FreeMonoid.{u1} α), (C xs) -> (C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs))) -> (C xs)
Case conversion may be inaccurate. Consider using '#align free_monoid.rec_on FreeMonoid.recOnₓ'. -/
/-- Recursor for `free_monoid` using `1` and `free_monoid.of x * xs` instead of `[]` and
`x :: xs`. -/
@[elab_as_elim,
  to_additive
      "Recursor for `free_add_monoid` using `0` and `free_add_monoid.of x + xs` instead of `[]` and\n  `x :: xs`."]
def recOn {C : FreeMonoid α → Sort _} (xs : FreeMonoid α) (h0 : C 1)
    (ih : ∀ x xs, C xs → C (of x * xs)) : C xs :=
  List.recOn xs h0 ih
#align free_monoid.rec_on FreeMonoid.recOn
#align free_add_monoid.rec_on FreeAddMonoid.recOn

/- warning: free_monoid.rec_on_one -> FreeMonoid.recOn_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {C : (FreeMonoid.{u1} α) -> Sort.{u2}} (h0 : C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (OfNat.mk.{u1} (FreeMonoid.{u1} α) 1 (One.one.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasOne.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))))))))) (ih : forall (x : α) (xs : FreeMonoid.{u1} α), (C xs) -> (C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs))), Eq.{u2} (C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (OfNat.mk.{u1} (FreeMonoid.{u1} α) 1 (One.one.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasOne.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))))))))) (FreeMonoid.recOn.{u1, u2} α C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (OfNat.mk.{u1} (FreeMonoid.{u1} α) 1 (One.one.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasOne.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))))) h0 ih) h0
but is expected to have type
  forall {α : Type.{u2}} {C : (FreeMonoid.{u2} α) -> Sort.{u1}} (h0 : C (OfNat.ofNat.{u2} (FreeMonoid.{u2} α) 1 (One.toOfNat1.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toOne.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (ih : forall (x : α) (xs : FreeMonoid.{u2} α), (C xs) -> (C (HMul.hMul.{u2, u2, u2} (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (instHMul.{u2} (FreeMonoid.{u2} α) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (FreeMonoid.of.{u2} α x) xs))), Eq.{u1} (C (OfNat.ofNat.{u2} (FreeMonoid.{u2} α) 1 (One.toOfNat1.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toOne.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (FreeMonoid.recOn.{u2, u1} α C (OfNat.ofNat.{u2} (FreeMonoid.{u2} α) 1 (One.toOfNat1.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toOne.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) h0 ih) h0
Case conversion may be inaccurate. Consider using '#align free_monoid.rec_on_one FreeMonoid.recOn_oneₓ'. -/
@[simp, to_additive]
theorem recOn_one {C : FreeMonoid α → Sort _} (h0 : C 1) (ih : ∀ x xs, C xs → C (of x * xs)) :
    @recOn α C 1 h0 ih = h0 :=
  rfl
#align free_monoid.rec_on_one FreeMonoid.recOn_one
#align free_add_monoid.rec_on_zero FreeAddMonoid.recOn_zero

/- warning: free_monoid.rec_on_of_mul -> FreeMonoid.recOn_of_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {C : (FreeMonoid.{u1} α) -> Sort.{u2}} (x : α) (xs : FreeMonoid.{u1} α) (h0 : C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (OfNat.mk.{u1} (FreeMonoid.{u1} α) 1 (One.one.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasOne.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))))))))) (ih : forall (x : α) (xs : FreeMonoid.{u1} α), (C xs) -> (C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs))), Eq.{u2} (C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs)) (FreeMonoid.recOn.{u1, u2} α C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs) h0 ih) (ih x xs (FreeMonoid.recOn.{u1, u2} α (fun (_x : FreeMonoid.{u1} α) => C _x) xs h0 ih))
but is expected to have type
  forall {α : Type.{u2}} {C : (FreeMonoid.{u2} α) -> Sort.{u1}} (x : α) (xs : FreeMonoid.{u2} α) (h0 : C (OfNat.ofNat.{u2} (FreeMonoid.{u2} α) 1 (One.toOfNat1.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toOne.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (ih : forall (x : α) (xs : FreeMonoid.{u2} α), (C xs) -> (C (HMul.hMul.{u2, u2, u2} (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (instHMul.{u2} (FreeMonoid.{u2} α) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (FreeMonoid.of.{u2} α x) xs))), Eq.{u1} (C (HMul.hMul.{u2, u2, u2} (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (instHMul.{u2} (FreeMonoid.{u2} α) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (FreeMonoid.of.{u2} α x) xs)) (FreeMonoid.recOn.{u2, u1} α C (HMul.hMul.{u2, u2, u2} (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (instHMul.{u2} (FreeMonoid.{u2} α) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (FreeMonoid.of.{u2} α x) xs) h0 ih) (ih x xs (FreeMonoid.recOn.{u2, u1} α (fun (_x : FreeMonoid.{u2} α) => C _x) xs h0 ih))
Case conversion may be inaccurate. Consider using '#align free_monoid.rec_on_of_mul FreeMonoid.recOn_of_mulₓ'. -/
@[simp, to_additive]
theorem recOn_of_mul {C : FreeMonoid α → Sort _} (x : α) (xs : FreeMonoid α) (h0 : C 1)
    (ih : ∀ x xs, C xs → C (of x * xs)) : @recOn α C (of x * xs) h0 ih = ih x xs (recOn xs h0 ih) :=
  rfl
#align free_monoid.rec_on_of_mul FreeMonoid.recOn_of_mul
#align free_add_monoid.rec_on_of_add FreeAddMonoid.recOn_of_add

/- warning: free_monoid.cases_on -> FreeMonoid.casesOn is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {C : (FreeMonoid.{u1} α) -> Sort.{u2}} (xs : FreeMonoid.{u1} α), (C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (OfNat.mk.{u1} (FreeMonoid.{u1} α) 1 (One.one.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasOne.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))))))))) -> (forall (x : α) (xs : FreeMonoid.{u1} α), C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs)) -> (C xs)
but is expected to have type
  forall {α : Type.{u1}} {C : (FreeMonoid.{u1} α) -> Sort.{u2}} (xs : FreeMonoid.{u1} α), (C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (One.toOfNat1.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toOne.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))))) -> (forall (x : α) (xs : FreeMonoid.{u1} α), C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs)) -> (C xs)
Case conversion may be inaccurate. Consider using '#align free_monoid.cases_on FreeMonoid.casesOnₓ'. -/
/-- A version of `list.cases_on` for `free_monoid` using `1` and `free_monoid.of x * xs` instead of
`[]` and `x :: xs`. -/
@[elab_as_elim,
  to_additive
      "A version of `list.cases_on` for `free_add_monoid` using `0` and `free_add_monoid.of x + xs`\n  instead of `[]` and `x :: xs`."]
def casesOn {C : FreeMonoid α → Sort _} (xs : FreeMonoid α) (h0 : C 1)
    (ih : ∀ x xs, C (of x * xs)) : C xs :=
  List.casesOn xs h0 ih
#align free_monoid.cases_on FreeMonoid.casesOn
#align free_add_monoid.cases_on FreeAddMonoid.casesOn

/- warning: free_monoid.cases_on_one -> FreeMonoid.casesOn_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {C : (FreeMonoid.{u1} α) -> Sort.{u2}} (h0 : C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (OfNat.mk.{u1} (FreeMonoid.{u1} α) 1 (One.one.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasOne.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))))))))) (ih : forall (x : α) (xs : FreeMonoid.{u1} α), C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs)), Eq.{u2} (C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (OfNat.mk.{u1} (FreeMonoid.{u1} α) 1 (One.one.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasOne.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))))))))) (FreeMonoid.casesOn.{u1, u2} α C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (OfNat.mk.{u1} (FreeMonoid.{u1} α) 1 (One.one.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasOne.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))))) h0 ih) h0
but is expected to have type
  forall {α : Type.{u2}} {C : (FreeMonoid.{u2} α) -> Sort.{u1}} (h0 : C (OfNat.ofNat.{u2} (FreeMonoid.{u2} α) 1 (One.toOfNat1.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toOne.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (ih : forall (x : α) (xs : FreeMonoid.{u2} α), C (HMul.hMul.{u2, u2, u2} (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (instHMul.{u2} (FreeMonoid.{u2} α) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (FreeMonoid.of.{u2} α x) xs)), Eq.{u1} (C (OfNat.ofNat.{u2} (FreeMonoid.{u2} α) 1 (One.toOfNat1.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toOne.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (FreeMonoid.casesOn.{u2, u1} α C (OfNat.ofNat.{u2} (FreeMonoid.{u2} α) 1 (One.toOfNat1.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toOne.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) h0 ih) h0
Case conversion may be inaccurate. Consider using '#align free_monoid.cases_on_one FreeMonoid.casesOn_oneₓ'. -/
@[simp, to_additive]
theorem casesOn_one {C : FreeMonoid α → Sort _} (h0 : C 1) (ih : ∀ x xs, C (of x * xs)) :
    @casesOn α C 1 h0 ih = h0 :=
  rfl
#align free_monoid.cases_on_one FreeMonoid.casesOn_one
#align free_add_monoid.cases_on_zero FreeAddMonoid.casesOn_zero

/- warning: free_monoid.cases_on_of_mul -> FreeMonoid.casesOn_of_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {C : (FreeMonoid.{u1} α) -> Sort.{u2}} (x : α) (xs : FreeMonoid.{u1} α) (h0 : C (OfNat.ofNat.{u1} (FreeMonoid.{u1} α) 1 (OfNat.mk.{u1} (FreeMonoid.{u1} α) 1 (One.one.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasOne.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))))))))) (ih : forall (x : α) (xs : FreeMonoid.{u1} α), C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs)), Eq.{u2} (C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs)) (FreeMonoid.casesOn.{u1, u2} α C (HMul.hMul.{u1, u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (instHMul.{u1} (FreeMonoid.{u1} α) (MulOneClass.toHasMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))) (FreeMonoid.of.{u1} α x) xs) h0 ih) (ih x xs)
but is expected to have type
  forall {α : Type.{u2}} {C : (FreeMonoid.{u2} α) -> Sort.{u1}} (x : α) (xs : FreeMonoid.{u2} α) (h0 : C (OfNat.ofNat.{u2} (FreeMonoid.{u2} α) 1 (One.toOfNat1.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toOne.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (ih : forall (x : α) (xs : FreeMonoid.{u2} α), C (HMul.hMul.{u2, u2, u2} (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (instHMul.{u2} (FreeMonoid.{u2} α) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (FreeMonoid.of.{u2} α x) xs)), Eq.{u1} (C (HMul.hMul.{u2, u2, u2} (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (instHMul.{u2} (FreeMonoid.{u2} α) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (FreeMonoid.of.{u2} α x) xs)) (FreeMonoid.casesOn.{u2, u1} α C (HMul.hMul.{u2, u2, u2} (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (FreeMonoid.{u2} α) (instHMul.{u2} (FreeMonoid.{u2} α) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))))) (FreeMonoid.of.{u2} α x) xs) h0 ih) (ih x xs)
Case conversion may be inaccurate. Consider using '#align free_monoid.cases_on_of_mul FreeMonoid.casesOn_of_mulₓ'. -/
@[simp, to_additive]
theorem casesOn_of_mul {C : FreeMonoid α → Sort _} (x : α) (xs : FreeMonoid α) (h0 : C 1)
    (ih : ∀ x xs, C (of x * xs)) : @casesOn α C (of x * xs) h0 ih = ih x xs :=
  rfl
#align free_monoid.cases_on_of_mul FreeMonoid.casesOn_of_mul
#align free_add_monoid.cases_on_of_add FreeAddMonoid.casesOn_of_add

/- warning: free_monoid.hom_eq -> FreeMonoid.hom_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] {{f : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)}} {{g : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)}}, (forall (x : α), Eq.{succ u2} M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) => (FreeMonoid.{u1} α) -> M) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) f (FreeMonoid.of.{u1} α x)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) => (FreeMonoid.{u1} α) -> M) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) g (FreeMonoid.of.{u1} α x))) -> (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) f g)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] {{f : MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)}} {{g : MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)}}, (forall (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => M) (FreeMonoid.of.{u2} α x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) M (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)))) f (FreeMonoid.of.{u2} α x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) M (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)))) g (FreeMonoid.of.{u2} α x))) -> (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) f g)
Case conversion may be inaccurate. Consider using '#align free_monoid.hom_eq FreeMonoid.hom_eqₓ'. -/
@[ext, to_additive]
theorem hom_eq ⦃f g : FreeMonoid α →* M⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=
  MonoidHom.ext fun l =>
    recOn l (f.map_one.trans g.map_one.symm) fun x xs hxs => by
      simp only [h, hxs, MonoidHom.map_mul]
#align free_monoid.hom_eq FreeMonoid.hom_eq
#align free_add_monoid.hom_eq FreeAddMonoid.hom_eq

#print FreeMonoid.prodAux /-
/-- A variant of `list.prod` that has `[x].prod = x` true definitionally.

The purpose is to make `free_monoid.lift_eval_of` true by `rfl`. -/
@[to_additive
      "A variant of `list.sum` that has `[x].sum = x` true definitionally.\n\nThe purpose is to make `free_add_monoid.lift_eval_of` true by `rfl`."]
def prodAux {M} [Monoid M] (l : List M) : M :=
  l.recOn 1 fun x xs (_ : M) => List.foldl (· * ·) x xs
#align free_monoid.prod_aux FreeMonoid.prodAux
#align free_add_monoid.sum_aux FreeAddMonoid.sumAux
-/

/- warning: free_monoid.prod_aux_eq -> FreeMonoid.prodAux_eq is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (l : List.{u1} M), Eq.{succ u1} M (FreeMonoid.prodAux.{u1} M _inst_1 l) (List.prod.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MulOneClass.toHasOne.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) l)
but is expected to have type
  forall {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (l : List.{u1} M), Eq.{succ u1} M (FreeMonoid.prodAux.{u1} M _inst_1 l) (List.prod.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Monoid.toOne.{u1} M _inst_1) l)
Case conversion may be inaccurate. Consider using '#align free_monoid.prod_aux_eq FreeMonoid.prodAux_eqₓ'. -/
@[to_additive]
theorem prodAux_eq : ∀ l : List M, FreeMonoid.prodAux l = l.prod
  | [] => rfl
  | x :: xs => congr_arg (fun x => List.foldl (· * ·) x xs) (one_mul _).symm
#align free_monoid.prod_aux_eq FreeMonoid.prodAux_eq
#align free_add_monoid.sum_aux_eq FreeAddMonoid.sumAux_eq

/- warning: free_monoid.lift -> FreeMonoid.lift is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M], Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M], Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))
Case conversion may be inaccurate. Consider using '#align free_monoid.lift FreeMonoid.liftₓ'. -/
/-- Equivalence between maps `α → M` and monoid homomorphisms `free_monoid α →* M`. -/
@[to_additive
      "Equivalence between maps `α → A` and additive monoid homomorphisms\n`free_add_monoid α →+ A`."]
def lift : (α → M) ≃ (FreeMonoid α →* M)
    where
  toFun f :=
    ⟨fun l => FreeMonoid.prodAux (l.toList.map f), rfl, fun l₁ l₂ => by
      simp only [prodAux_eq, toList_mul, List.map_append, List.prod_append]⟩
  invFun f x := f (of x)
  left_inv f := rfl
  right_inv f := hom_eq fun x => rfl
#align free_monoid.lift FreeMonoid.lift
#align free_add_monoid.lift FreeAddMonoid.lift

/- warning: free_monoid.lift_symm_apply -> FreeMonoid.lift_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] (f : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)), Eq.{max (succ u1) (succ u2)} (α -> M) (coeFn.{max 1 (max (max (succ u2) (succ u1)) (succ u1) (succ u2)) (max (succ u1) (succ u2)) (succ u2) (succ u1), max (max (succ u2) (succ u1)) (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (α -> M)) (fun (_x : Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (α -> M)) => (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) -> α -> M) (Equiv.hasCoeToFun.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (α -> M)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (FreeMonoid.lift.{u1, u2} α M _inst_1)) f) (Function.comp.{succ u1, succ u1, succ u2} α (FreeMonoid.{u1} α) M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) => (FreeMonoid.{u1} α) -> M) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) f) (FreeMonoid.of.{u1} α))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (f : MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) => α -> M) f) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (α -> M)) (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (fun (_x : MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) => α -> M) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (α -> M)) (Equiv.symm.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> M) (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.lift.{u2, u1} α M _inst_1)) f) (Function.comp.{succ u2, succ u2, succ u1} α (FreeMonoid.{u2} α) M (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) M (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)))) f) (FreeMonoid.of.{u2} α))
Case conversion may be inaccurate. Consider using '#align free_monoid.lift_symm_apply FreeMonoid.lift_symm_applyₓ'. -/
@[simp, to_additive]
theorem lift_symm_apply (f : FreeMonoid α →* M) : lift.symm f = f ∘ of :=
  rfl
#align free_monoid.lift_symm_apply FreeMonoid.lift_symm_apply
#align free_add_monoid.lift_symm_apply FreeAddMonoid.lift_symm_apply

/- warning: free_monoid.lift_apply -> FreeMonoid.lift_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] (f : α -> M) (l : FreeMonoid.{u1} α), Eq.{succ u2} M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) => (FreeMonoid.{u1} α) -> M) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) => (α -> M) -> (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (FreeMonoid.lift.{u1, u2} α M _inst_1) f) l) (List.prod.{u2} M (MulOneClass.toHasMul.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MulOneClass.toHasOne.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (List.map.{u1, u2} α M f (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (FreeMonoid.{u1} α) (List.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} (FreeMonoid.{u1} α) (List.{u1} α)) => (FreeMonoid.{u1} α) -> (List.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} (FreeMonoid.{u1} α) (List.{u1} α)) (FreeMonoid.toList.{u1} α) l)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (f : α -> M) (l : FreeMonoid.{u2} α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => M) l) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) f) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) f) (FreeMonoid.{u2} α) M (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) f) (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> M) (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1))) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> M) (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1))) (FreeMonoid.lift.{u2, u1} α M _inst_1) f) l) (List.prod.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (Monoid.toOne.{u1} M _inst_1) (List.map.{u2, u1} α M f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} (FreeMonoid.{u2} α) (List.{u2} α)) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : FreeMonoid.{u2} α) => List.{u2} α) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} (FreeMonoid.{u2} α) (List.{u2} α)) (FreeMonoid.toList.{u2} α) l)))
Case conversion may be inaccurate. Consider using '#align free_monoid.lift_apply FreeMonoid.lift_applyₓ'. -/
@[to_additive]
theorem lift_apply (f : α → M) (l : FreeMonoid α) : lift f l = (l.toList.map f).prod :=
  prodAux_eq _
#align free_monoid.lift_apply FreeMonoid.lift_apply
#align free_add_monoid.lift_apply FreeAddMonoid.lift_apply

/- warning: free_monoid.lift_comp_of -> FreeMonoid.lift_comp_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] (f : α -> M), Eq.{max (succ u1) (succ u2)} (α -> M) (Function.comp.{succ u1, succ u1, succ u2} α (FreeMonoid.{u1} α) M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) => (FreeMonoid.{u1} α) -> M) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) => (α -> M) -> (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (FreeMonoid.lift.{u1, u2} α M _inst_1) f)) (FreeMonoid.of.{u1} α)) f
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (f : α -> M), Eq.{max (succ u2) (succ u1)} (α -> M) (Function.comp.{succ u2, succ u2, succ u1} α (FreeMonoid.{u2} α) M (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) f) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) f) (FreeMonoid.{u2} α) M (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) f) (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> M) (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1))) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> M) (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1))) (FreeMonoid.lift.{u2, u1} α M _inst_1) f)) (FreeMonoid.of.{u2} α)) f
Case conversion may be inaccurate. Consider using '#align free_monoid.lift_comp_of FreeMonoid.lift_comp_ofₓ'. -/
@[to_additive]
theorem lift_comp_of (f : α → M) : lift f ∘ of = f :=
  rfl
#align free_monoid.lift_comp_of FreeMonoid.lift_comp_of
#align free_add_monoid.lift_comp_of FreeAddMonoid.lift_comp_of

/- warning: free_monoid.lift_eval_of -> FreeMonoid.lift_eval_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] (f : α -> M) (x : α), Eq.{succ u2} M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) => (FreeMonoid.{u1} α) -> M) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) => (α -> M) -> (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (FreeMonoid.lift.{u1, u2} α M _inst_1) f) (FreeMonoid.of.{u1} α x)) (f x)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] (f : α -> M) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u1} α) => M) (FreeMonoid.of.{u1} α x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) f) (FreeMonoid.{u1} α) (fun (_x : FreeMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u1} α) => M) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) f) (FreeMonoid.{u1} α) M (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (MulOneClass.toMul.{u2} M (Monoid.toMulOneClass.{u2} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) f) (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1) (MonoidHom.monoidHomClass.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (FreeMonoid.lift.{u1, u2} α M _inst_1) f) (FreeMonoid.of.{u1} α x)) (f x)
Case conversion may be inaccurate. Consider using '#align free_monoid.lift_eval_of FreeMonoid.lift_eval_ofₓ'. -/
@[simp, to_additive]
theorem lift_eval_of (f : α → M) (x : α) : lift f (of x) = f x :=
  rfl
#align free_monoid.lift_eval_of FreeMonoid.lift_eval_of
#align free_add_monoid.lift_eval_of FreeAddMonoid.lift_eval_of

/- warning: free_monoid.lift_restrict -> FreeMonoid.lift_restrict is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] (f : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)), Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) => (α -> M) -> (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (FreeMonoid.lift.{u1, u2} α M _inst_1) (Function.comp.{succ u1, succ u1, succ u2} α (FreeMonoid.{u1} α) M (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) => (FreeMonoid.{u1} α) -> M) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) f) (FreeMonoid.of.{u1} α))) f
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} [_inst_1 : Monoid.{u1} M] (f : MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (Function.comp.{succ u2, succ u2, succ u1} α (FreeMonoid.{u2} α) M (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) (fun (a : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => M) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) M (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)))) f) (FreeMonoid.of.{u2} α))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> M) (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1))) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> M) (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1))) (FreeMonoid.lift.{u2, u1} α M _inst_1) (Function.comp.{succ u2, succ u2, succ u1} α (FreeMonoid.{u2} α) M (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => M) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) M (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)) (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1) (MonoidHom.monoidHomClass.{u2, u1} (FreeMonoid.{u2} α) M (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} M _inst_1)))) f) (FreeMonoid.of.{u2} α))) f
Case conversion may be inaccurate. Consider using '#align free_monoid.lift_restrict FreeMonoid.lift_restrictₓ'. -/
@[simp, to_additive]
theorem lift_restrict (f : FreeMonoid α →* M) : lift (f ∘ of) = f :=
  lift.apply_symm_apply f
#align free_monoid.lift_restrict FreeMonoid.lift_restrict
#align free_add_monoid.lift_restrict FreeAddMonoid.lift_restrict

/- warning: free_monoid.comp_lift -> FreeMonoid.comp_lift is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] {N : Type.{u3}} [_inst_2 : Monoid.{u3} N] (g : MonoidHom.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) (f : α -> M), Eq.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2)) (MonoidHom.comp.{u1, u2, u3} (FreeMonoid.{u1} α) M N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2) g (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) => (α -> M) -> (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (FreeMonoid.lift.{u1, u2} α M _inst_1) f)) (coeFn.{max 1 (max (max (succ u1) (succ u3)) (succ u3) (succ u1)) (max (succ u3) (succ u1)) (succ u1) (succ u3), max (max (succ u1) (succ u3)) (succ u3) (succ u1)} (Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> N) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> N) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2))) => (α -> N) -> (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> N) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2))) (FreeMonoid.lift.{u1, u3} α N _inst_2) (Function.comp.{succ u1, succ u2, succ u3} α M N (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidHom.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) (fun (_x : MonoidHom.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) => M -> N) (MonoidHom.hasCoeToFun.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) g) f))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} [_inst_1 : Monoid.{u3} M] {N : Type.{u2}} [_inst_2 : Monoid.{u2} N] (g : MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) (f : α -> M), Eq.{max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2)) (MonoidHom.comp.{u1, u3, u2} (FreeMonoid.{u1} α) M N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2) g (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> M) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1))) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (α -> M) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1))) (FreeMonoid.lift.{u1, u3} α M _inst_1) f)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> N) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2))) (α -> N) (fun (_x : α -> N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> N) => MonoidHom.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (α -> N) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2))) (FreeMonoid.lift.{u1, u2} α N _inst_2) (Function.comp.{succ u1, succ u3, succ u2} α M N (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N _inst_2)) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2) (MonoidHom.monoidHomClass.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)))) g) f))
Case conversion may be inaccurate. Consider using '#align free_monoid.comp_lift FreeMonoid.comp_liftₓ'. -/
@[to_additive]
theorem comp_lift (g : M →* N) (f : α → M) : g.comp (lift f) = lift (g ∘ f) :=
  by
  ext
  simp
#align free_monoid.comp_lift FreeMonoid.comp_lift
#align free_add_monoid.comp_lift FreeAddMonoid.comp_lift

/- warning: free_monoid.hom_map_lift -> FreeMonoid.hom_map_lift is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} [_inst_1 : Monoid.{u2} M] {N : Type.{u3}} [_inst_2 : Monoid.{u3} N] (g : MonoidHom.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) (f : α -> M) (x : FreeMonoid.{u1} α), Eq.{succ u3} N (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidHom.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) (fun (_x : MonoidHom.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) => M -> N) (MonoidHom.hasCoeToFun.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) g (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) => (FreeMonoid.{u1} α) -> M) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1)) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) => (α -> M) -> (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> M) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} M _inst_1))) (FreeMonoid.lift.{u1, u2} α M _inst_1) f) x)) (coeFn.{max (succ u3) (succ u1), max (succ u1) (succ u3)} (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2)) (fun (_x : MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2)) => (FreeMonoid.{u1} α) -> N) (MonoidHom.hasCoeToFun.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2)) (coeFn.{max 1 (max (max (succ u1) (succ u3)) (succ u3) (succ u1)) (max (succ u3) (succ u1)) (succ u1) (succ u3), max (max (succ u1) (succ u3)) (succ u3) (succ u1)} (Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> N) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2))) (fun (_x : Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> N) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2))) => (α -> N) -> (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2))) (Equiv.hasCoeToFun.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> N) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} N _inst_2))) (FreeMonoid.lift.{u1, u3} α N _inst_2) (Function.comp.{succ u1, succ u2, succ u3} α M N (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (MonoidHom.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) (fun (_x : MonoidHom.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) => M -> N) (MonoidHom.hasCoeToFun.{u2, u3} M N (Monoid.toMulOneClass.{u2} M _inst_1) (Monoid.toMulOneClass.{u3} N _inst_2)) g) f)) x)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} [_inst_1 : Monoid.{u3} M] {N : Type.{u2}} [_inst_2 : Monoid.{u2} N] (g : MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) (f : α -> M) (x : FreeMonoid.{u1} α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)) f) (FreeMonoid.{u1} α) (fun (a : FreeMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u1} α) => M) a) (MulHomClass.toFunLike.{max u1 u3, u1, u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)) f) (FreeMonoid.{u1} α) M (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)) f) (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1) (MonoidHom.monoidHomClass.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)))) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> M) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1))) (α -> M) (fun (a : α -> M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)) a) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (α -> M) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1))) (FreeMonoid.lift.{u1, u3} α M _inst_1) f) x)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N _inst_2)) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2) (MonoidHom.monoidHomClass.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)))) g (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)) f) (FreeMonoid.{u1} α) (fun (_x : FreeMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u1} α) => M) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)) f) (FreeMonoid.{u1} α) M (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MonoidHomClass.toMulHomClass.{max u1 u3, u1, u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)) f) (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1) (MonoidHom.monoidHomClass.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)))) (FunLike.coe.{max (succ u3) (succ u1), max (succ u3) (succ u1), max (succ u3) (succ u1)} (Equiv.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (α -> M) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1))) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> M) => MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1)) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (α -> M) (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) M (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} M _inst_1))) (FreeMonoid.lift.{u1, u3} α M _inst_1) f) x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> N) => MonoidHom.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2)) (Function.comp.{succ u1, succ u3, succ u2} α M N (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M (fun (a : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N _inst_2)) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2) (MonoidHom.monoidHomClass.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)))) g) f)) (FreeMonoid.{u1} α) (fun (_x : FreeMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u1} α) => N) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> N) => MonoidHom.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2)) (Function.comp.{succ u1, succ u3, succ u2} α M N (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M (fun (a : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N _inst_2)) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2) (MonoidHom.monoidHomClass.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)))) g) f)) (FreeMonoid.{u1} α) N (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N _inst_2)) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> N) => MonoidHom.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2)) (Function.comp.{succ u1, succ u3, succ u2} α M N (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M (fun (a : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N _inst_2)) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2) (MonoidHom.monoidHomClass.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)))) g) f)) (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2) (MonoidHom.monoidHomClass.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> N) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2))) (α -> N) (fun (_x : α -> N) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> N) => MonoidHom.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (α -> N) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) N (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} N _inst_2))) (FreeMonoid.lift.{u1, u2} α N _inst_2) (Function.comp.{succ u1, succ u3, succ u2} α M N (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => N) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (MulOneClass.toMul.{u3} M (Monoid.toMulOneClass.{u3} M _inst_1)) (MulOneClass.toMul.{u2} N (Monoid.toMulOneClass.{u2} N _inst_2)) (MonoidHomClass.toMulHomClass.{max u3 u2, u3, u2} (MonoidHom.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)) M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2) (MonoidHom.monoidHomClass.{u3, u2} M N (Monoid.toMulOneClass.{u3} M _inst_1) (Monoid.toMulOneClass.{u2} N _inst_2)))) g) f)) x)
Case conversion may be inaccurate. Consider using '#align free_monoid.hom_map_lift FreeMonoid.hom_map_liftₓ'. -/
@[to_additive]
theorem hom_map_lift (g : M →* N) (f : α → M) (x : FreeMonoid α) : g (lift f x) = lift (g ∘ f) x :=
  MonoidHom.ext_iff.1 (comp_lift g f) x
#align free_monoid.hom_map_lift FreeMonoid.hom_map_lift
#align free_add_monoid.hom_map_lift FreeAddMonoid.hom_map_lift

/- warning: free_monoid.mk_mul_action -> FreeMonoid.mkMulAction is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}}, (α -> β -> β) -> (MulAction.{u1, u2} (FreeMonoid.{u1} α) β (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}}, (α -> β -> β) -> (MulAction.{u1, u2} (FreeMonoid.{u1} α) β (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))
Case conversion may be inaccurate. Consider using '#align free_monoid.mk_mul_action FreeMonoid.mkMulActionₓ'. -/
/-- Define a multiplicative action of `free_monoid α` on `β`. -/
@[to_additive "Define an additive action of `free_add_monoid α` on `β`."]
def mkMulAction (f : α → β → β) : MulAction (FreeMonoid α) β
    where
  smul l b := l.toList.foldr f b
  one_smul x := rfl
  mul_smul xs ys b := List.foldr_append _ _ _ _
#align free_monoid.mk_mul_action FreeMonoid.mkMulAction
#align free_add_monoid.mk_add_action FreeAddMonoid.mkAddAction

/- warning: free_monoid.smul_def -> FreeMonoid.smul_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (f : α -> β -> β) (l : FreeMonoid.{u1} α) (b : β), Eq.{succ u2} β (SMul.smul.{u1, u2} (FreeMonoid.{u1} α) β (MulAction.toHasSmul.{u1, u2} (FreeMonoid.{u1} α) β (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))) (FreeMonoid.mkMulAction.{u1, u2} α β f)) l b) (List.foldr.{u1, u2} α β f b (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (FreeMonoid.{u1} α) (List.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} (FreeMonoid.{u1} α) (List.{u1} α)) => (FreeMonoid.{u1} α) -> (List.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} (FreeMonoid.{u1} α) (List.{u1} α)) (FreeMonoid.toList.{u1} α) l))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} (f : α -> β -> β) (l : FreeMonoid.{u2} α) (b : β), Eq.{succ u1} β (HSMul.hSMul.{u2, u1, u1} (FreeMonoid.{u2} α) β β (instHSMul.{u2, u1} (FreeMonoid.{u2} α) β (MulAction.toSMul.{u2, u1} (FreeMonoid.{u2} α) β (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))) (FreeMonoid.mkMulAction.{u2, u1} α β f))) l b) (List.foldr.{u2, u1} α β f b (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} (FreeMonoid.{u2} α) (List.{u2} α)) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : FreeMonoid.{u2} α) => List.{u2} α) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} (FreeMonoid.{u2} α) (List.{u2} α)) (FreeMonoid.toList.{u2} α) l))
Case conversion may be inaccurate. Consider using '#align free_monoid.smul_def FreeMonoid.smul_defₓ'. -/
@[to_additive]
theorem smul_def (f : α → β → β) (l : FreeMonoid α) (b : β) :
    haveI := mkMulAction f
    l • b = l.to_list.foldr f b :=
  rfl
#align free_monoid.smul_def FreeMonoid.smul_def
#align free_add_monoid.vadd_def FreeAddMonoid.vadd_def

/- warning: free_monoid.of_list_smul -> FreeMonoid.ofList_smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (f : α -> β -> β) (l : List.{u1} α) (b : β), Eq.{succ u2} β (SMul.smul.{u1, u2} (FreeMonoid.{u1} α) β (MulAction.toHasSmul.{u1, u2} (FreeMonoid.{u1} α) β (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))) (FreeMonoid.mkMulAction.{u1, u2} α β f)) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (List.{u1} α) (FreeMonoid.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} (List.{u1} α) (FreeMonoid.{u1} α)) => (List.{u1} α) -> (FreeMonoid.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} (List.{u1} α) (FreeMonoid.{u1} α)) (FreeMonoid.ofList.{u1} α) l) b) (List.foldr.{u1, u2} α β f b l)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} (f : α -> β -> β) (l : List.{u2} α) (b : β), Eq.{succ u1} β (HSMul.hSMul.{u2, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : List.{u2} α) => FreeMonoid.{u2} α) l) β β (instHSMul.{u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : List.{u2} α) => FreeMonoid.{u2} α) l) β (MulAction.toSMul.{u2, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : List.{u2} α) => FreeMonoid.{u2} α) l) β (RightCancelMonoid.toMonoid.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : List.{u2} α) => FreeMonoid.{u2} α) l) (CancelMonoid.toRightCancelMonoid.{u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : List.{u2} α) => FreeMonoid.{u2} α) l) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))) (FreeMonoid.mkMulAction.{u2, u1} α β f))) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} (List.{u2} α) (FreeMonoid.{u2} α)) (List.{u2} α) (fun (_x : List.{u2} α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : List.{u2} α) => FreeMonoid.{u2} α) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} (List.{u2} α) (FreeMonoid.{u2} α)) (FreeMonoid.ofList.{u2} α) l) b) (List.foldr.{u2, u1} α β f b l)
Case conversion may be inaccurate. Consider using '#align free_monoid.of_list_smul FreeMonoid.ofList_smulₓ'. -/
@[to_additive]
theorem ofList_smul (f : α → β → β) (l : List α) (b : β) :
    haveI := mkMulAction f
    ofList l • b = l.foldr f b :=
  rfl
#align free_monoid.of_list_smul FreeMonoid.ofList_smul
#align free_add_monoid.of_list_vadd FreeAddMonoid.ofList_vadd

#print FreeMonoid.of_smul /-
@[simp, to_additive]
theorem of_smul (f : α → β → β) (x : α) (y : β) :
    (haveI := mkMulAction f
      of x • y) =
      f x y :=
  rfl
#align free_monoid.of_smul FreeMonoid.of_smul
#align free_add_monoid.of_vadd FreeAddMonoid.of_vadd
-/

/- warning: free_monoid.map -> FreeMonoid.map is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}}, (α -> β) -> (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β)))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}}, (α -> β) -> (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} β)))))
Case conversion may be inaccurate. Consider using '#align free_monoid.map FreeMonoid.mapₓ'. -/
/-- The unique monoid homomorphism `free_monoid α →* free_monoid β` that sends
each `of x` to `of (f x)`. -/
@[to_additive
      "The unique additive monoid homomorphism `free_add_monoid α →+ free_add_monoid β`\nthat sends each `of x` to `of (f x)`."]
def map (f : α → β) : FreeMonoid α →* FreeMonoid β
    where
  toFun l := ofList <| l.toList.map f
  map_one' := rfl
  map_mul' l₁ l₂ := List.map_append _ _ _
#align free_monoid.map FreeMonoid.map
#align free_add_monoid.map FreeAddMonoid.map

/- warning: free_monoid.map_of -> FreeMonoid.map_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (f : α -> β) (x : α), Eq.{succ u2} (FreeMonoid.{u2} β) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β))))) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β))))) => (FreeMonoid.{u1} α) -> (FreeMonoid.{u2} β)) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β))))) (FreeMonoid.map.{u1, u2} α β f) (FreeMonoid.of.{u1} α x)) (FreeMonoid.of.{u2} β (f x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} (f : α -> β) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u1} α) => FreeMonoid.{u2} β) (FreeMonoid.of.{u1} α x)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} β))))) (FreeMonoid.{u1} α) (fun (_x : FreeMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u1} α) => FreeMonoid.{u2} β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} β))))) (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} β))))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} β))))) (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} β)))) (MonoidHom.monoidHomClass.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} β))))))) (FreeMonoid.map.{u1, u2} α β f) (FreeMonoid.of.{u1} α x)) (FreeMonoid.of.{u2} β (f x))
Case conversion may be inaccurate. Consider using '#align free_monoid.map_of FreeMonoid.map_ofₓ'. -/
@[simp, to_additive]
theorem map_of (f : α → β) (x : α) : map f (of x) = of (f x) :=
  rfl
#align free_monoid.map_of FreeMonoid.map_of
#align free_add_monoid.map_of FreeAddMonoid.map_of

/- warning: free_monoid.to_list_map -> FreeMonoid.toList_map is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (f : α -> β) (xs : FreeMonoid.{u1} α), Eq.{succ u2} (List.{u2} β) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} (FreeMonoid.{u2} β) (List.{u2} β)) (fun (_x : Equiv.{succ u2, succ u2} (FreeMonoid.{u2} β) (List.{u2} β)) => (FreeMonoid.{u2} β) -> (List.{u2} β)) (Equiv.hasCoeToFun.{succ u2, succ u2} (FreeMonoid.{u2} β) (List.{u2} β)) (FreeMonoid.toList.{u2} β) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β))))) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β))))) => (FreeMonoid.{u1} α) -> (FreeMonoid.{u2} β)) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β))))) (FreeMonoid.map.{u1, u2} α β f) xs)) (List.map.{u1, u2} α β f (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (FreeMonoid.{u1} α) (List.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} (FreeMonoid.{u1} α) (List.{u1} α)) => (FreeMonoid.{u1} α) -> (List.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} (FreeMonoid.{u1} α) (List.{u1} α)) (FreeMonoid.toList.{u1} α) xs))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} (f : α -> β) (xs : FreeMonoid.{u2} α), Eq.{succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : FreeMonoid.{u1} β) => List.{u1} β) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (FreeMonoid.{u2} α) (fun (a : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => FreeMonoid.{u1} β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β)))) (MonoidHom.monoidHomClass.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))))) (FreeMonoid.map.{u2, u1} α β f) xs)) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (FreeMonoid.{u1} β) (List.{u1} β)) (FreeMonoid.{u1} β) (fun (_x : FreeMonoid.{u1} β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : FreeMonoid.{u1} β) => List.{u1} β) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (FreeMonoid.{u1} β) (List.{u1} β)) (FreeMonoid.toList.{u1} β) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => FreeMonoid.{u1} β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β)))) (MonoidHom.monoidHomClass.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))))) (FreeMonoid.map.{u2, u1} α β f) xs)) (List.map.{u2, u1} α β f (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} (FreeMonoid.{u2} α) (List.{u2} α)) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : FreeMonoid.{u2} α) => List.{u2} α) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} (FreeMonoid.{u2} α) (List.{u2} α)) (FreeMonoid.toList.{u2} α) xs))
Case conversion may be inaccurate. Consider using '#align free_monoid.to_list_map FreeMonoid.toList_mapₓ'. -/
@[to_additive]
theorem toList_map (f : α → β) (xs : FreeMonoid α) : (map f xs).toList = xs.toList.map f :=
  rfl
#align free_monoid.to_list_map FreeMonoid.toList_map
#align free_add_monoid.to_list_map FreeAddMonoid.toList_map

/- warning: free_monoid.of_list_map -> FreeMonoid.ofList_map is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (f : α -> β) (xs : List.{u1} α), Eq.{succ u2} (FreeMonoid.{u2} β) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} (List.{u2} β) (FreeMonoid.{u2} β)) (fun (_x : Equiv.{succ u2, succ u2} (List.{u2} β) (FreeMonoid.{u2} β)) => (List.{u2} β) -> (FreeMonoid.{u2} β)) (Equiv.hasCoeToFun.{succ u2, succ u2} (List.{u2} β) (FreeMonoid.{u2} β)) (FreeMonoid.ofList.{u2} β) (List.map.{u1, u2} α β f xs)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β))))) (fun (_x : MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β))))) => (FreeMonoid.{u1} α) -> (FreeMonoid.{u2} β)) (MonoidHom.hasCoeToFun.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β))))) (FreeMonoid.map.{u1, u2} α β f) (coeFn.{succ u1, succ u1} (Equiv.{succ u1, succ u1} (List.{u1} α) (FreeMonoid.{u1} α)) (fun (_x : Equiv.{succ u1, succ u1} (List.{u1} α) (FreeMonoid.{u1} α)) => (List.{u1} α) -> (FreeMonoid.{u1} α)) (Equiv.hasCoeToFun.{succ u1, succ u1} (List.{u1} α) (FreeMonoid.{u1} α)) (FreeMonoid.ofList.{u1} α) xs))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} (f : α -> β) (xs : List.{u2} α), Eq.{succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : List.{u1} β) => FreeMonoid.{u1} β) (List.map.{u2, u1} α β f xs)) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (List.{u1} β) (FreeMonoid.{u1} β)) (List.{u1} β) (fun (_x : List.{u1} β) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : List.{u1} β) => FreeMonoid.{u1} β) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (List.{u1} β) (FreeMonoid.{u1} β)) (FreeMonoid.ofList.{u1} β) (List.map.{u2, u1} α β f xs)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (FreeMonoid.{u2} α) (fun (_x : FreeMonoid.{u2} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : FreeMonoid.{u2} α) => FreeMonoid.{u1} β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (MulOneClass.toMul.{u2} (FreeMonoid.{u2} α) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α))))) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β)))) (MonoidHom.monoidHomClass.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))))) (FreeMonoid.map.{u2, u1} α β f) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} (List.{u2} α) (FreeMonoid.{u2} α)) (List.{u2} α) (fun (_x : List.{u2} α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : List.{u2} α) => FreeMonoid.{u2} α) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} (List.{u2} α) (FreeMonoid.{u2} α)) (FreeMonoid.ofList.{u2} α) xs))
Case conversion may be inaccurate. Consider using '#align free_monoid.of_list_map FreeMonoid.ofList_mapₓ'. -/
@[to_additive]
theorem ofList_map (f : α → β) (xs : List α) : ofList (xs.map f) = map f (ofList xs) :=
  rfl
#align free_monoid.of_list_map FreeMonoid.ofList_map
#align free_add_monoid.of_list_map FreeAddMonoid.ofList_map

/- warning: free_monoid.lift_of_comp_eq_map -> FreeMonoid.lift_of_comp_eq_map is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (f : α -> β), Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β))))) (coeFn.{max 1 (max (max (succ u1) (succ u2)) (succ u2) (succ u1)) (max (succ u2) (succ u1)) (succ u1) (succ u2), max (max (succ u1) (succ u2)) (succ u2) (succ u1)} (Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> (FreeMonoid.{u2} β)) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β)))))) (fun (_x : Equiv.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> (FreeMonoid.{u2} β)) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β)))))) => (α -> (FreeMonoid.{u2} β)) -> (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β)))))) (Equiv.hasCoeToFun.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (α -> (FreeMonoid.{u2} β)) (MonoidHom.{u1, u2} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β)))))) (FreeMonoid.lift.{u1, u2} α (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β)))) (fun (x : α) => FreeMonoid.of.{u2} β (f x))) (FreeMonoid.map.{u1, u2} α β f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} (f : α -> β), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> (FreeMonoid.{u1} β)) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) (fun (x : α) => FreeMonoid.of.{u1} β (f x))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (α -> (FreeMonoid.{u1} β)) (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β)))))) (α -> (FreeMonoid.{u1} β)) (fun (_x : α -> (FreeMonoid.{u1} β)) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : α -> (FreeMonoid.{u1} β)) => MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β))))) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (α -> (FreeMonoid.{u1} β)) (MonoidHom.{u2, u1} (FreeMonoid.{u2} α) (FreeMonoid.{u1} β) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} α) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} α) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β)))))) (FreeMonoid.lift.{u2, u1} α (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β)))) (fun (x : α) => FreeMonoid.of.{u1} β (f x))) (FreeMonoid.map.{u2, u1} α β f)
Case conversion may be inaccurate. Consider using '#align free_monoid.lift_of_comp_eq_map FreeMonoid.lift_of_comp_eq_mapₓ'. -/
@[to_additive]
theorem lift_of_comp_eq_map (f : α → β) : (lift fun x => of (f x)) = map f :=
  hom_eq fun x => rfl
#align free_monoid.lift_of_comp_eq_map FreeMonoid.lift_of_comp_eq_map
#align free_add_monoid.lift_of_comp_eq_map FreeAddMonoid.lift_of_comp_eq_map

/- warning: free_monoid.map_comp -> FreeMonoid.map_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} (g : β -> γ) (f : α -> β), Eq.{max (succ u3) (succ u1)} (MonoidHom.{u1, u3} (FreeMonoid.{u1} α) (FreeMonoid.{u3} γ) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u3} (FreeMonoid.{u3} γ) (RightCancelMonoid.toMonoid.{u3} (FreeMonoid.{u3} γ) (CancelMonoid.toRightCancelMonoid.{u3} (FreeMonoid.{u3} γ) (FreeMonoid.cancelMonoid.{u3} γ))))) (FreeMonoid.map.{u1, u3} α γ (Function.comp.{succ u1, succ u2, succ u3} α β γ g f)) (MonoidHom.comp.{u1, u2, u3} (FreeMonoid.{u1} α) (FreeMonoid.{u2} β) (FreeMonoid.{u3} γ) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} β) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} β) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} β) (FreeMonoid.cancelMonoid.{u2} β)))) (Monoid.toMulOneClass.{u3} (FreeMonoid.{u3} γ) (RightCancelMonoid.toMonoid.{u3} (FreeMonoid.{u3} γ) (CancelMonoid.toRightCancelMonoid.{u3} (FreeMonoid.{u3} γ) (FreeMonoid.cancelMonoid.{u3} γ)))) (FreeMonoid.map.{u2, u3} β γ g) (FreeMonoid.map.{u1, u2} α β f))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u1}} {γ : Type.{u2}} (g : β -> γ) (f : α -> β), Eq.{max (succ u3) (succ u2)} (MonoidHom.{u3, u2} (FreeMonoid.{u3} α) (FreeMonoid.{u2} γ) (Monoid.toMulOneClass.{u3} (FreeMonoid.{u3} α) (RightCancelMonoid.toMonoid.{u3} (FreeMonoid.{u3} α) (CancelMonoid.toRightCancelMonoid.{u3} (FreeMonoid.{u3} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u3} α)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} γ) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} γ) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} γ) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} γ))))) (FreeMonoid.map.{u3, u2} α γ (Function.comp.{succ u3, succ u1, succ u2} α β γ g f)) (MonoidHom.comp.{u3, u1, u2} (FreeMonoid.{u3} α) (FreeMonoid.{u1} β) (FreeMonoid.{u2} γ) (Monoid.toMulOneClass.{u3} (FreeMonoid.{u3} α) (RightCancelMonoid.toMonoid.{u3} (FreeMonoid.{u3} α) (CancelMonoid.toRightCancelMonoid.{u3} (FreeMonoid.{u3} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u3} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} β) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} β) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} β) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} β)))) (Monoid.toMulOneClass.{u2} (FreeMonoid.{u2} γ) (RightCancelMonoid.toMonoid.{u2} (FreeMonoid.{u2} γ) (CancelMonoid.toRightCancelMonoid.{u2} (FreeMonoid.{u2} γ) (FreeMonoid.instCancelMonoidFreeMonoid.{u2} γ)))) (FreeMonoid.map.{u1, u2} β γ g) (FreeMonoid.map.{u3, u1} α β f))
Case conversion may be inaccurate. Consider using '#align free_monoid.map_comp FreeMonoid.map_compₓ'. -/
@[to_additive]
theorem map_comp (g : β → γ) (f : α → β) : map (g ∘ f) = (map g).comp (map f) :=
  hom_eq fun x => rfl
#align free_monoid.map_comp FreeMonoid.map_comp
#align free_add_monoid.map_comp FreeAddMonoid.map_comp

/- warning: free_monoid.map_id -> FreeMonoid.map_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}}, Eq.{succ u1} (MonoidHom.{u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α))))) (FreeMonoid.map.{u1, u1} α α (id.{succ u1} α)) (MonoidHom.id.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))))
but is expected to have type
  forall {α : Type.{u1}}, Eq.{succ u1} (MonoidHom.{u1, u1} (FreeMonoid.{u1} α) (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (FreeMonoid.map.{u1, u1} α α (id.{succ u1} α)) (MonoidHom.id.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))))
Case conversion may be inaccurate. Consider using '#align free_monoid.map_id FreeMonoid.map_idₓ'. -/
@[simp, to_additive]
theorem map_id : map (@id α) = MonoidHom.id (FreeMonoid α) :=
  hom_eq fun x => rfl
#align free_monoid.map_id FreeMonoid.map_id
#align free_add_monoid.map_id FreeAddMonoid.map_id

end FreeMonoid

