/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov

! This file was ported from Lean 3 source module algebra.free_monoid.count
! leanprover-community/mathlib commit d6fad0e5bf2d6f48da9175d25c3dc5706b3834ce
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.FreeMonoid.Basic
import Mathbin.Data.List.Count

/-!
# `list.count` as a bundled homomorphism

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define `free_monoid.countp`, `free_monoid.count`, `free_add_monoid.countp`, and
`free_add_monoid.count`. These are `list.countp` and `list.count` bundled as multiplicative and
additive homomorphisms from `free_monoid` and `free_add_monoid`.

We do not use `to_additive` because it can't map `multiplicative ℕ` to `ℕ`.
-/


variable {α : Type _} (p : α → Prop) [DecidablePred p]

namespace FreeAddMonoid

/- warning: free_add_monoid.countp -> FreeAddMonoid.countp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_2 : DecidablePred.{succ u1} α p], AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)
but is expected to have type
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_2 : DecidablePred.{succ u1} α p], AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)
Case conversion may be inaccurate. Consider using '#align free_add_monoid.countp FreeAddMonoid.countpₓ'. -/
/-- `list.countp` as a bundled additive monoid homomorphism. -/
def countp (p : α → Prop) [DecidablePred p] : FreeAddMonoid α →+ ℕ :=
  ⟨List.countp p, List.countp_nil p, List.countp_append _⟩
#align free_add_monoid.countp FreeAddMonoid.countp

/- warning: free_add_monoid.countp_of -> FreeAddMonoid.countp_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_1 : DecidablePred.{succ u1} α p] (x : α), Eq.{1} Nat (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (FreeAddMonoid.{u1} α) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.countp.{u1} α p (fun (a : α) => _inst_1 a)) (FreeAddMonoid.of.{u1} α x)) (ite.{1} Nat (p x) (_inst_1 x) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))
but is expected to have type
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_1 : DecidablePred.{succ u1} α p] (x : α), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) (FreeAddMonoid.of.{u1} α x)) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) (fun (_x : FreeAddMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) Nat (AddZeroClass.toAdd.{u1} (FreeAddMonoid.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (FreeAddMonoid.countp.{u1} α p (fun (a : α) => _inst_1 a)) (FreeAddMonoid.of.{u1} α x)) (ite.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) (FreeAddMonoid.of.{u1} α x)) (Eq.{1} Prop (p x) (Eq.{1} Bool Bool.true Bool.true)) (instDecidableEqProp (p x) (Eq.{1} Bool Bool.true Bool.true) (instDecidableIff (p x) (Eq.{1} Bool Bool.true Bool.true) (_inst_1 x) (instDecidableEqBool Bool.true Bool.true))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) (FreeAddMonoid.of.{u1} α x)) 1 (instOfNatNat 1)) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) (FreeAddMonoid.of.{u1} α x)) 0 (instOfNatNat 0)))
Case conversion may be inaccurate. Consider using '#align free_add_monoid.countp_of FreeAddMonoid.countp_ofₓ'. -/
theorem countp_of (x : α) : countp p (of x) = if p x then 1 else 0 :=
  rfl
#align free_add_monoid.countp_of FreeAddMonoid.countp_of

/- warning: free_add_monoid.countp_apply -> FreeAddMonoid.countp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_1 : DecidablePred.{succ u1} α p] (l : FreeAddMonoid.{u1} α), Eq.{1} Nat (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (FreeAddMonoid.{u1} α) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.countp.{u1} α p (fun (a : α) => _inst_1 a)) l) (List.countp.{u1} α p (fun (a : α) => _inst_1 a) l)
but is expected to have type
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_1 : DecidablePred.{succ u1} α p] (l : FreeAddMonoid.{u1} α), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) l) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) (fun (_x : FreeAddMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) Nat (AddZeroClass.toAdd.{u1} (FreeAddMonoid.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (FreeAddMonoid.countp.{u1} α p (fun (a : α) => _inst_1 a)) l) (List.countp.{u1} α (fun (a : α) => Decidable.decide (p a) ((fun (a : α) => _inst_1 a) a)) l)
Case conversion may be inaccurate. Consider using '#align free_add_monoid.countp_apply FreeAddMonoid.countp_applyₓ'. -/
theorem countp_apply (l : FreeAddMonoid α) : countp p l = List.countp p l :=
  rfl
#align free_add_monoid.countp_apply FreeAddMonoid.countp_apply

/- warning: free_add_monoid.count -> FreeAddMonoid.count is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α], α -> (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))
but is expected to have type
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α], α -> (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))
Case conversion may be inaccurate. Consider using '#align free_add_monoid.count FreeAddMonoid.countₓ'. -/
/-- `list.count` as a bundled additive monoid homomorphism. -/
def count [DecidableEq α] (x : α) : FreeAddMonoid α →+ ℕ :=
  countp (Eq x)
#align free_add_monoid.count FreeAddMonoid.count

/- warning: free_add_monoid.count_of -> FreeAddMonoid.count_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α] (x : α) (y : α), Eq.{1} Nat (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (FreeAddMonoid.{u1} α) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.count.{u1} α (fun (a : α) (b : α) => _inst_2 a b) x) (FreeAddMonoid.of.{u1} α y)) (Pi.single.{u1, 0} α (fun (y : α) => Nat) (fun (a : α) (b : α) => _inst_2 a b) (fun (i : α) => Nat.hasZero) x (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) y)
but is expected to have type
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α] (x : α) (y : α), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) (FreeAddMonoid.of.{u1} α y)) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) (fun (_x : FreeAddMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) Nat (AddZeroClass.toAdd.{u1} (FreeAddMonoid.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (FreeAddMonoid.count.{u1} α (fun (a : α) (b : α) => _inst_2 a b) x) (FreeAddMonoid.of.{u1} α y)) (Pi.single.{u1, 0} α (fun (y : α) => Nat) (fun (a : α) (b : α) => _inst_2 a b) (fun (i : α) => LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) x (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) y)
Case conversion may be inaccurate. Consider using '#align free_add_monoid.count_of FreeAddMonoid.count_ofₓ'. -/
theorem count_of [DecidableEq α] (x y : α) : count x (of y) = Pi.single x 1 y := by
  simp only [count, countp_of, Pi.single_apply, eq_comm]
#align free_add_monoid.count_of FreeAddMonoid.count_of

/- warning: free_add_monoid.count_apply -> FreeAddMonoid.count_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α] (x : α) (l : FreeAddMonoid.{u1} α), Eq.{1} Nat (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (fun (_x : AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) => (FreeAddMonoid.{u1} α) -> Nat) (AddMonoidHom.hasCoeToFun.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.cancelAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.count.{u1} α (fun (a : α) (b : α) => _inst_2 a b) x) l) (List.count.{u1} α (fun (a : α) (b : α) => _inst_2 a b) x l)
but is expected to have type
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α] (x : α) (l : FreeAddMonoid.{u1} α), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) l) (FunLike.coe.{succ u1, succ u1, 1} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) (fun (_x : FreeAddMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : FreeAddMonoid.{u1} α) => Nat) _x) (AddHomClass.toFunLike.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) Nat (AddZeroClass.toAdd.{u1} (FreeAddMonoid.{u1} α) (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α))))) (AddZeroClass.toAdd.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (AddMonoidHomClass.toAddHomClass.{u1, u1, 0} (AddMonoidHom.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid) (AddMonoidHom.addMonoidHomClass.{u1, 0} (FreeAddMonoid.{u1} α) Nat (AddMonoid.toAddZeroClass.{u1} (FreeAddMonoid.{u1} α) (AddRightCancelMonoid.toAddMonoid.{u1} (FreeAddMonoid.{u1} α) (AddCancelMonoid.toAddRightCancelMonoid.{u1} (FreeAddMonoid.{u1} α) (FreeAddMonoid.instAddCancelMonoidFreeAddMonoid.{u1} α)))) (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))) (FreeAddMonoid.count.{u1} α (fun (a : α) (b : α) => _inst_2 a b) x) l) (List.count.{u1} α (instBEq.{u1} α (fun (a : α) (b : α) => _inst_2 a b)) x l)
Case conversion may be inaccurate. Consider using '#align free_add_monoid.count_apply FreeAddMonoid.count_applyₓ'. -/
theorem count_apply [DecidableEq α] (x : α) (l : FreeAddMonoid α) : count x l = List.count x l :=
  rfl
#align free_add_monoid.count_apply FreeAddMonoid.count_apply

end FreeAddMonoid

namespace FreeMonoid

/- warning: free_monoid.countp -> FreeMonoid.countp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_2 : DecidablePred.{succ u1} α p], MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))
but is expected to have type
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_2 : DecidablePred.{succ u1} α p], MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))
Case conversion may be inaccurate. Consider using '#align free_monoid.countp FreeMonoid.countpₓ'. -/
/-- `list.countp` as a bundled multiplicative monoid homomorphism. -/
def countp (p : α → Prop) [DecidablePred p] : FreeMonoid α →* Multiplicative ℕ :=
  (FreeAddMonoid.countp p).toMultiplicative
#align free_monoid.countp FreeMonoid.countp

/- warning: free_monoid.countp_of' -> FreeMonoid.countp_of' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_1 : DecidablePred.{succ u1} α p] (x : α), Eq.{1} (Multiplicative.{0} Nat) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (fun (_x : MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) => (FreeMonoid.{u1} α) -> (Multiplicative.{0} Nat)) (MonoidHom.hasCoeToFun.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.countp.{u1} α p (fun (a : α) => _inst_1 a)) (FreeMonoid.of.{u1} α x)) (ite.{1} (Multiplicative.{0} Nat) (p x) (_inst_1 x) (coeFn.{1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) (fun (_x : Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) => Nat -> (Multiplicative.{0} Nat)) (Equiv.hasCoeToFun.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (coeFn.{1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) (fun (_x : Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) => Nat -> (Multiplicative.{0} Nat)) (Equiv.hasCoeToFun.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))))
but is expected to have type
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_1 : DecidablePred.{succ u1} α p] (x : α), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : FreeMonoid.{u1} α) => Multiplicative.{0} Nat) (FreeMonoid.of.{u1} α x)) (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (fun (_x : FreeMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : FreeMonoid.{u1} α) => Multiplicative.{0} Nat) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (MonoidHom.monoidHomClass.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))))) (FreeMonoid.countp.{u1} α p (fun (a : α) => _inst_1 a)) (FreeMonoid.of.{u1} α x)) (ite.{1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Nat) => Multiplicative.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (p x) (_inst_1 x) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Nat) => Multiplicative.{0} Nat) _x) (EmbeddingLike.toFunLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (EquivLike.toEmbeddingLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (Equiv.instEquivLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)))) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Nat) => Multiplicative.{0} Nat) _x) (EmbeddingLike.toFunLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (EquivLike.toEmbeddingLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (Equiv.instEquivLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)))) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))
Case conversion may be inaccurate. Consider using '#align free_monoid.countp_of' FreeMonoid.countp_of'ₓ'. -/
theorem countp_of' (x : α) :
    countp p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 :=
  rfl
#align free_monoid.countp_of' FreeMonoid.countp_of'

/- warning: free_monoid.countp_of -> FreeMonoid.countp_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_1 : DecidablePred.{succ u1} α p] (x : α), Eq.{1} (Multiplicative.{0} Nat) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (fun (_x : MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) => (FreeMonoid.{u1} α) -> (Multiplicative.{0} Nat)) (MonoidHom.hasCoeToFun.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.countp.{u1} α p (fun (a : α) => _inst_1 a)) (FreeMonoid.of.{u1} α x)) (ite.{1} (Multiplicative.{0} Nat) (p x) (_inst_1 x) (coeFn.{1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) (fun (_x : Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) => Nat -> (Multiplicative.{0} Nat)) (Equiv.hasCoeToFun.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (OfNat.ofNat.{0} (Multiplicative.{0} Nat) 1 (OfNat.mk.{0} (Multiplicative.{0} Nat) 1 (One.one.{0} (Multiplicative.{0} Nat) (Multiplicative.hasOne.{0} Nat Nat.hasZero)))))
but is expected to have type
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_1 : DecidablePred.{succ u1} α p] (x : α), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : FreeMonoid.{u1} α) => Multiplicative.{0} Nat) (FreeMonoid.of.{u1} α x)) (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (fun (_x : FreeMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : FreeMonoid.{u1} α) => Multiplicative.{0} Nat) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (MonoidHom.monoidHomClass.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))))) (FreeMonoid.countp.{u1} α p (fun (a : α) => _inst_1 a)) (FreeMonoid.of.{u1} α x)) (ite.{1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Nat) => Multiplicative.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (p x) (_inst_1 x) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Nat) => Multiplicative.{0} Nat) _x) (EmbeddingLike.toFunLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (EquivLike.toEmbeddingLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (Equiv.instEquivLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)))) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (OfNat.ofNat.{0} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Nat) => Multiplicative.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 1 (One.toOfNat1.{0} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Nat) => Multiplicative.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (instOneMultiplicative.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)))))
Case conversion may be inaccurate. Consider using '#align free_monoid.countp_of FreeMonoid.countp_ofₓ'. -/
theorem countp_of (x : α) : countp p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by
  rw [countp_of', ofAdd_zero]
#align free_monoid.countp_of FreeMonoid.countp_of

/- warning: free_monoid.countp_apply -> FreeMonoid.countp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_1 : DecidablePred.{succ u1} α p] (l : FreeAddMonoid.{u1} α), Eq.{1} (Multiplicative.{0} Nat) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (fun (_x : MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) => (FreeMonoid.{u1} α) -> (Multiplicative.{0} Nat)) (MonoidHom.hasCoeToFun.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.countp.{u1} α p (fun (a : α) => _inst_1 a)) l) (coeFn.{1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) (fun (_x : Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) => Nat -> (Multiplicative.{0} Nat)) (Equiv.hasCoeToFun.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (List.countp.{u1} α p (fun (a : α) => _inst_1 a) l))
but is expected to have type
  forall {α : Type.{u1}} (p : α -> Prop) [_inst_1 : DecidablePred.{succ u1} α p] (l : FreeAddMonoid.{u1} α), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : FreeMonoid.{u1} α) => Multiplicative.{0} Nat) l) (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (fun (_x : FreeMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : FreeMonoid.{u1} α) => Multiplicative.{0} Nat) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (MonoidHom.monoidHomClass.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))))) (FreeMonoid.countp.{u1} α p (fun (a : α) => _inst_1 a)) l) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Nat) => Multiplicative.{0} Nat) _x) (EmbeddingLike.toFunLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (EquivLike.toEmbeddingLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (Equiv.instEquivLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)))) (Multiplicative.ofAdd.{0} Nat) (List.countp.{u1} α (fun (a : α) => Decidable.decide (p a) ((fun (a : α) => _inst_1 a) a)) l))
Case conversion may be inaccurate. Consider using '#align free_monoid.countp_apply FreeMonoid.countp_applyₓ'. -/
-- `rfl` is not transitive
theorem countp_apply (l : FreeAddMonoid α) : countp p l = Multiplicative.ofAdd (List.countp p l) :=
  rfl
#align free_monoid.countp_apply FreeMonoid.countp_apply

/- warning: free_monoid.count -> FreeMonoid.count is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α], α -> (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α], α -> (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)))
Case conversion may be inaccurate. Consider using '#align free_monoid.count FreeMonoid.countₓ'. -/
/-- `list.count` as a bundled additive monoid homomorphism. -/
def count [DecidableEq α] (x : α) : FreeMonoid α →* Multiplicative ℕ :=
  countp (Eq x)
#align free_monoid.count FreeMonoid.count

/- warning: free_monoid.count_apply -> FreeMonoid.count_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α] (x : α) (l : FreeAddMonoid.{u1} α), Eq.{1} (Multiplicative.{0} Nat) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (fun (_x : MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) => (FreeMonoid.{u1} α) -> (Multiplicative.{0} Nat)) (MonoidHom.hasCoeToFun.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.count.{u1} α (fun (a : α) (b : α) => _inst_2 a b) x) l) (coeFn.{1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) (fun (_x : Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) => Nat -> (Multiplicative.{0} Nat)) (Equiv.hasCoeToFun.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (List.count.{u1} α (fun (a : α) (b : α) => _inst_2 a b) x l))
but is expected to have type
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α] (x : α) (l : FreeAddMonoid.{u1} α), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : FreeMonoid.{u1} α) => Multiplicative.{0} Nat) l) (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (fun (_x : FreeMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : FreeMonoid.{u1} α) => Multiplicative.{0} Nat) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (MonoidHom.monoidHomClass.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))))) (FreeMonoid.count.{u1} α (fun (a : α) (b : α) => _inst_2 a b) x) l) (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Nat) => Multiplicative.{0} Nat) _x) (EmbeddingLike.toFunLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (EquivLike.toEmbeddingLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (Equiv.instEquivLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)))) (Multiplicative.ofAdd.{0} Nat) (List.count.{u1} α (instBEq.{u1} α (fun (a : α) (b : α) => _inst_2 a b)) x l))
Case conversion may be inaccurate. Consider using '#align free_monoid.count_apply FreeMonoid.count_applyₓ'. -/
theorem count_apply [DecidableEq α] (x : α) (l : FreeAddMonoid α) :
    count x l = Multiplicative.ofAdd (List.count x l) :=
  rfl
#align free_monoid.count_apply FreeMonoid.count_apply

/- warning: free_monoid.count_of -> FreeMonoid.count_of is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α] (x : α) (y : α), Eq.{1} (Multiplicative.{0} Nat) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (fun (_x : MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) => (FreeMonoid.{u1} α) -> (Multiplicative.{0} Nat)) (MonoidHom.hasCoeToFun.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.cancelMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.count.{u1} α (fun (a : α) (b : α) => _inst_2 a b) x) (FreeMonoid.of.{u1} α y)) (Pi.mulSingle.{u1, 0} α (fun (_x : α) => Multiplicative.{0} Nat) (fun (a : α) (b : α) => _inst_2 a b) (fun (i : α) => Multiplicative.hasOne.{0} Nat Nat.hasZero) x (coeFn.{1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) (fun (_x : Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) => Nat -> (Multiplicative.{0} Nat)) (Equiv.hasCoeToFun.{1, 1} Nat (Multiplicative.{0} Nat)) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) y)
but is expected to have type
  forall {α : Type.{u1}} [_inst_2 : DecidableEq.{succ u1} α] (x : α) (y : α), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : FreeMonoid.{u1} α) => Multiplicative.{0} Nat) (FreeMonoid.of.{u1} α y)) (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (fun (_x : FreeMonoid.{u1} α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : FreeMonoid.{u1} α) => Multiplicative.{0} Nat) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (MulOneClass.toMul.{u1} (FreeMonoid.{u1} α) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α))))) (MulOneClass.toMul.{0} (Multiplicative.{0} Nat) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))) (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid)) (MonoidHom.monoidHomClass.{u1, 0} (FreeMonoid.{u1} α) (Multiplicative.{0} Nat) (Monoid.toMulOneClass.{u1} (FreeMonoid.{u1} α) (RightCancelMonoid.toMonoid.{u1} (FreeMonoid.{u1} α) (CancelMonoid.toRightCancelMonoid.{u1} (FreeMonoid.{u1} α) (FreeMonoid.instCancelMonoidFreeMonoid.{u1} α)))) (Multiplicative.mulOneClass.{0} Nat (AddMonoid.toAddZeroClass.{0} Nat Nat.addMonoid))))) (FreeMonoid.count.{u1} α (fun (a : α) (b : α) => _inst_2 a b) x) (FreeMonoid.of.{u1} α y)) (Pi.mulSingle.{u1, 0} α (fun (_x : α) => Multiplicative.{0} Nat) (fun (a : α) (b : α) => _inst_2 a b) (fun (i : α) => instOneMultiplicative.{0} Nat (LinearOrderedCommMonoidWithZero.toZero.{0} Nat Nat.linearOrderedCommMonoidWithZero)) x (FunLike.coe.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (fun (_x : Nat) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Nat) => Multiplicative.{0} Nat) _x) (EmbeddingLike.toFunLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (EquivLike.toEmbeddingLike.{1, 1, 1} (Equiv.{1, 1} Nat (Multiplicative.{0} Nat)) Nat (Multiplicative.{0} Nat) (Equiv.instEquivLikeEquiv.{1, 1} Nat (Multiplicative.{0} Nat)))) (Multiplicative.ofAdd.{0} Nat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) y)
Case conversion may be inaccurate. Consider using '#align free_monoid.count_of FreeMonoid.count_ofₓ'. -/
theorem count_of [DecidableEq α] (x y : α) :
    count x (of y) = @Pi.mulSingle α (fun _ => Multiplicative ℕ) _ _ x (Multiplicative.ofAdd 1) y :=
  by simp only [count, countp_of, Pi.mulSingle_apply, eq_comm]
#align free_monoid.count_of FreeMonoid.count_of

end FreeMonoid

