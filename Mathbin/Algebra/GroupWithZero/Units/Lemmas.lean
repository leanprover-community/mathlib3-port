/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin

! This file was ported from Lean 3 source module algebra.group_with_zero.units.lemmas
! leanprover-community/mathlib commit b363547b3113d350d053abdf2884e9850a56b205
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.GroupWithZero.Commute
import Mathbin.Algebra.Hom.Units
import Mathbin.GroupTheory.GroupAction.Units

/-!
# Further lemmas about units in a `monoid_with_zero` or a `group_with_zero`.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

-/


variable {α M₀ G₀ M₀' G₀' F F' : Type _}

variable [MonoidWithZero M₀]

section GroupWithZero

variable [GroupWithZero G₀] {a b c : G₀}

/- warning: div_self -> div_self is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a a) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))))))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a a) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align div_self div_selfₓ'. -/
@[simp]
theorem div_self (h : a ≠ 0) : a / a = 1 :=
  h.IsUnit.div_self
#align div_self div_self

/- warning: eq_mul_inv_iff_mul_eq₀ -> eq_mul_inv_iff_mul_eq₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) b (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) c))) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a c) b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) b (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) c))) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a c) b))
Case conversion may be inaccurate. Consider using '#align eq_mul_inv_iff_mul_eq₀ eq_mul_inv_iff_mul_eq₀ₓ'. -/
theorem eq_mul_inv_iff_mul_eq₀ (hc : c ≠ 0) : a = b * c⁻¹ ↔ a * c = b :=
  hc.IsUnit.eq_mul_inv_iff_mul_eq
#align eq_mul_inv_iff_mul_eq₀ eq_mul_inv_iff_mul_eq₀

/- warning: eq_inv_mul_iff_mul_eq₀ -> eq_inv_mul_iff_mul_eq₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) b) c)) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) b a) c))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) b) c)) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) b a) c))
Case conversion may be inaccurate. Consider using '#align eq_inv_mul_iff_mul_eq₀ eq_inv_mul_iff_mul_eq₀ₓ'. -/
theorem eq_inv_mul_iff_mul_eq₀ (hb : b ≠ 0) : a = b⁻¹ * c ↔ b * a = c :=
  hb.IsUnit.eq_inv_mul_iff_mul_eq
#align eq_inv_mul_iff_mul_eq₀ eq_inv_mul_iff_mul_eq₀

/- warning: inv_mul_eq_iff_eq_mul₀ -> inv_mul_eq_iff_eq_mul₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) a) b) c) (Eq.{succ u1} G₀ b (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a c)))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) a) b) c) (Eq.{succ u1} G₀ b (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a c)))
Case conversion may be inaccurate. Consider using '#align inv_mul_eq_iff_eq_mul₀ inv_mul_eq_iff_eq_mul₀ₓ'. -/
theorem inv_mul_eq_iff_eq_mul₀ (ha : a ≠ 0) : a⁻¹ * b = c ↔ b = a * c :=
  ha.IsUnit.inv_mul_eq_iff_eq_mul
#align inv_mul_eq_iff_eq_mul₀ inv_mul_eq_iff_eq_mul₀

/- warning: mul_inv_eq_iff_eq_mul₀ -> mul_inv_eq_iff_eq_mul₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) b)) c) (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) c b)))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) b)) c) (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) c b)))
Case conversion may be inaccurate. Consider using '#align mul_inv_eq_iff_eq_mul₀ mul_inv_eq_iff_eq_mul₀ₓ'. -/
theorem mul_inv_eq_iff_eq_mul₀ (hb : b ≠ 0) : a * b⁻¹ = c ↔ a = c * b :=
  hb.IsUnit.mul_inv_eq_iff_eq_mul
#align mul_inv_eq_iff_eq_mul₀ mul_inv_eq_iff_eq_mul₀

/- warning: mul_inv_eq_one₀ -> mul_inv_eq_one₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) b)) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) (Eq.{succ u1} G₀ a b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) b)) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2))))))) (Eq.{succ u1} G₀ a b))
Case conversion may be inaccurate. Consider using '#align mul_inv_eq_one₀ mul_inv_eq_one₀ₓ'. -/
theorem mul_inv_eq_one₀ (hb : b ≠ 0) : a * b⁻¹ = 1 ↔ a = b :=
  hb.IsUnit.mul_inv_eq_one
#align mul_inv_eq_one₀ mul_inv_eq_one₀

/- warning: inv_mul_eq_one₀ -> inv_mul_eq_one₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) a) b) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) (Eq.{succ u1} G₀ a b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) a) b) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2))))))) (Eq.{succ u1} G₀ a b))
Case conversion may be inaccurate. Consider using '#align inv_mul_eq_one₀ inv_mul_eq_one₀ₓ'. -/
theorem inv_mul_eq_one₀ (ha : a ≠ 0) : a⁻¹ * b = 1 ↔ a = b :=
  ha.IsUnit.inv_mul_eq_one
#align inv_mul_eq_one₀ inv_mul_eq_one₀

/- warning: mul_eq_one_iff_eq_inv₀ -> mul_eq_one_iff_eq_inv₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) (Eq.{succ u1} G₀ a (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) b)))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2))))))) (Eq.{succ u1} G₀ a (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) b)))
Case conversion may be inaccurate. Consider using '#align mul_eq_one_iff_eq_inv₀ mul_eq_one_iff_eq_inv₀ₓ'. -/
theorem mul_eq_one_iff_eq_inv₀ (hb : b ≠ 0) : a * b = 1 ↔ a = b⁻¹ :=
  hb.IsUnit.mul_eq_one_iff_eq_inv
#align mul_eq_one_iff_eq_inv₀ mul_eq_one_iff_eq_inv₀

/- warning: mul_eq_one_iff_inv_eq₀ -> mul_eq_one_iff_inv_eq₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) (Eq.{succ u1} G₀ (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) a) b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2))))))) (Eq.{succ u1} G₀ (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) a) b))
Case conversion may be inaccurate. Consider using '#align mul_eq_one_iff_inv_eq₀ mul_eq_one_iff_inv_eq₀ₓ'. -/
theorem mul_eq_one_iff_inv_eq₀ (ha : a ≠ 0) : a * b = 1 ↔ a⁻¹ = b :=
  ha.IsUnit.mul_eq_one_iff_inv_eq
#align mul_eq_one_iff_inv_eq₀ mul_eq_one_iff_inv_eq₀

/- warning: div_mul_cancel -> div_mul_cancel is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {b : G₀} (a : G₀), (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b) b) a)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {b : G₀} (a : G₀), (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b) b) a)
Case conversion may be inaccurate. Consider using '#align div_mul_cancel div_mul_cancelₓ'. -/
@[simp]
theorem div_mul_cancel (a : G₀) (h : b ≠ 0) : a / b * b = a :=
  h.IsUnit.div_mul_cancelₓ _
#align div_mul_cancel div_mul_cancel

/- warning: mul_div_cancel -> mul_div_cancel is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {b : G₀} (a : G₀), (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b) b) a)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {b : G₀} (a : G₀), (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b) b) a)
Case conversion may be inaccurate. Consider using '#align mul_div_cancel mul_div_cancelₓ'. -/
@[simp]
theorem mul_div_cancel (a : G₀) (h : b ≠ 0) : a * b / b = a :=
  h.IsUnit.mul_div_cancel _
#align mul_div_cancel mul_div_cancel

/- warning: mul_one_div_cancel -> mul_one_div_cancel is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))))) a)) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))))))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2)))))) a)) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align mul_one_div_cancel mul_one_div_cancelₓ'. -/
theorem mul_one_div_cancel (h : a ≠ 0) : a * (1 / a) = 1 :=
  h.IsUnit.mul_one_div_cancel
#align mul_one_div_cancel mul_one_div_cancel

/- warning: one_div_mul_cancel -> one_div_mul_cancel is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))))) a) a) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))))))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2)))))) a) a) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align one_div_mul_cancel one_div_mul_cancelₓ'. -/
theorem one_div_mul_cancel (h : a ≠ 0) : 1 / a * a = 1 :=
  h.IsUnit.one_div_mul_cancel
#align one_div_mul_cancel one_div_mul_cancel

/- warning: div_left_inj' -> div_left_inj' is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a c) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) b c)) (Eq.{succ u1} G₀ a b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a c) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) b c)) (Eq.{succ u1} G₀ a b))
Case conversion may be inaccurate. Consider using '#align div_left_inj' div_left_inj'ₓ'. -/
theorem div_left_inj' (hc : c ≠ 0) : a / c = b / c ↔ a = b :=
  hc.IsUnit.div_left_inj
#align div_left_inj' div_left_inj'

/- warning: div_eq_iff -> div_eq_iff is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b) c) (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) c b)))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b) c) (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) c b)))
Case conversion may be inaccurate. Consider using '#align div_eq_iff div_eq_iffₓ'. -/
@[field_simps]
theorem div_eq_iff (hb : b ≠ 0) : a / b = c ↔ a = c * b :=
  hb.IsUnit.div_eq_iff
#align div_eq_iff div_eq_iff

/- warning: eq_div_iff -> eq_div_iff is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ c (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b)) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) c b) a))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ c (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b)) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) c b) a))
Case conversion may be inaccurate. Consider using '#align eq_div_iff eq_div_iffₓ'. -/
@[field_simps]
theorem eq_div_iff (hb : b ≠ 0) : c = a / b ↔ c * b = a :=
  hb.IsUnit.eq_div_iff
#align eq_div_iff eq_div_iff

/- warning: div_eq_iff_mul_eq -> div_eq_iff_mul_eq is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b) c) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) c b) a))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b) c) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) c b) a))
Case conversion may be inaccurate. Consider using '#align div_eq_iff_mul_eq div_eq_iff_mul_eqₓ'. -/
theorem div_eq_iff_mul_eq (hb : b ≠ 0) : a / b = c ↔ c * b = a :=
  hb.IsUnit.div_eq_iff.trans eq_comm
#align div_eq_iff_mul_eq div_eq_iff_mul_eq

/- warning: eq_div_iff_mul_eq -> eq_div_iff_mul_eq is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ a (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) b c)) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a c) b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ a (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) b c)) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a c) b))
Case conversion may be inaccurate. Consider using '#align eq_div_iff_mul_eq eq_div_iff_mul_eqₓ'. -/
theorem eq_div_iff_mul_eq (hc : c ≠ 0) : a = b / c ↔ a * c = b :=
  hc.IsUnit.eq_div_iff
#align eq_div_iff_mul_eq eq_div_iff_mul_eq

/- warning: div_eq_of_eq_mul -> div_eq_of_eq_mul is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) c b)) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b) c)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) c b)) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b) c)
Case conversion may be inaccurate. Consider using '#align div_eq_of_eq_mul div_eq_of_eq_mulₓ'. -/
theorem div_eq_of_eq_mul (hb : b ≠ 0) : a = c * b → a / b = c :=
  hb.IsUnit.div_eq_of_eq_mul
#align div_eq_of_eq_mul div_eq_of_eq_mul

/- warning: eq_div_of_mul_eq -> eq_div_of_mul_eq is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a c) b) -> (Eq.{succ u1} G₀ a (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) b c))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀}, (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a c) b) -> (Eq.{succ u1} G₀ a (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) b c))
Case conversion may be inaccurate. Consider using '#align eq_div_of_mul_eq eq_div_of_mul_eqₓ'. -/
theorem eq_div_of_mul_eq (hc : c ≠ 0) : a * c = b → a = b / c :=
  hc.IsUnit.eq_div_of_mul_eq
#align eq_div_of_mul_eq eq_div_of_mul_eq

/- warning: div_eq_one_iff_eq -> div_eq_one_iff_eq is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Iff (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) (Eq.{succ u1} G₀ a b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2))))))) (Eq.{succ u1} G₀ a b))
Case conversion may be inaccurate. Consider using '#align div_eq_one_iff_eq div_eq_one_iff_eqₓ'. -/
theorem div_eq_one_iff_eq (hb : b ≠ 0) : a / b = 1 ↔ a = b :=
  hb.IsUnit.div_eq_one_iff_eq
#align div_eq_one_iff_eq div_eq_one_iff_eq

/- warning: div_mul_left -> div_mul_left is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) b (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))))) a))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) b (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2)))))) a))
Case conversion may be inaccurate. Consider using '#align div_mul_left div_mul_leftₓ'. -/
theorem div_mul_left (hb : b ≠ 0) : b / (a * b) = 1 / a :=
  hb.IsUnit.div_mul_left
#align div_mul_left div_mul_left

/- warning: mul_div_mul_right -> mul_div_mul_right is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {c : G₀} (a : G₀) (b : G₀), (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a c) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) b c)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {c : G₀} (a : G₀) (b : G₀), (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a c) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) b c)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b))
Case conversion may be inaccurate. Consider using '#align mul_div_mul_right mul_div_mul_rightₓ'. -/
theorem mul_div_mul_right (a b : G₀) (hc : c ≠ 0) : a * c / (b * c) = a / b :=
  hc.IsUnit.mul_div_mul_right _ _
#align mul_div_mul_right mul_div_mul_right

/- warning: mul_mul_div -> mul_mul_div is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {b : G₀} (a : G₀), (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))))) b)))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {b : G₀} (a : G₀), (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (GroupWithZero.toDivisionMonoid.{u1} G₀ _inst_2)))))) b)))
Case conversion may be inaccurate. Consider using '#align mul_mul_div mul_mul_divₓ'. -/
theorem mul_mul_div (a : G₀) (hb : b ≠ 0) : a = a * b * (1 / b) :=
  (hb.IsUnit.mul_mul_div _).symm
#align mul_mul_div mul_mul_div

/- warning: div_div_div_cancel_right -> div_div_div_cancel_right is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {b : G₀} {c : G₀} (a : G₀), (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a c) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) b c)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {b : G₀} {c : G₀} (a : G₀), (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a c) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) b c)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b))
Case conversion may be inaccurate. Consider using '#align div_div_div_cancel_right div_div_div_cancel_rightₓ'. -/
theorem div_div_div_cancel_right (a : G₀) (hc : c ≠ 0) : a / c / (b / c) = a / b := by
  rw [div_div_eq_mul_div, div_mul_cancel _ hc]
#align div_div_div_cancel_right div_div_div_cancel_right

/- warning: div_mul_div_cancel -> div_mul_div_cancel is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {b : G₀} {c : G₀} (a : G₀), (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a c) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) c b)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {b : G₀} {c : G₀} (a : G₀), (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a c) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) c b)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b))
Case conversion may be inaccurate. Consider using '#align div_mul_div_cancel div_mul_div_cancelₓ'. -/
theorem div_mul_div_cancel (a : G₀) (hc : c ≠ 0) : a / c * (c / b) = a / b := by
  rw [← mul_div_assoc, div_mul_cancel _ hc]
#align div_mul_div_cancel div_mul_div_cancel

/- warning: div_mul_cancel_of_imp -> div_mul_cancel_of_imp is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, ((Eq.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b) b) a)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, ((Eq.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b) b) a)
Case conversion may be inaccurate. Consider using '#align div_mul_cancel_of_imp div_mul_cancel_of_impₓ'. -/
theorem div_mul_cancel_of_imp {a b : G₀} (h : b = 0 → a = 0) : a / b * b = a :=
  by_cases (fun hb : b = 0 => by simp [*]) (div_mul_cancel a)
#align div_mul_cancel_of_imp div_mul_cancel_of_imp

/- warning: mul_div_cancel_of_imp -> mul_div_cancel_of_imp is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, ((Eq.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) -> (Eq.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b) b) a)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, ((Eq.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) a b) b) a)
Case conversion may be inaccurate. Consider using '#align mul_div_cancel_of_imp mul_div_cancel_of_impₓ'. -/
theorem mul_div_cancel_of_imp {a b : G₀} (h : b = 0 → a = 0) : a * b / b = a :=
  by_cases (fun hb : b = 0 => by simp [*]) (mul_div_cancel a)
#align mul_div_cancel_of_imp mul_div_cancel_of_imp

/- warning: divp_mk0 -> divp_mk0 is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] (a : G₀) {b : G₀} (hb : Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))), Eq.{succ u1} G₀ (divp.{u1} G₀ (MonoidWithZero.toMonoid.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) a (Units.mk0.{u1} G₀ _inst_2 b hb)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] (a : G₀) {b : G₀} (hb : Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))), Eq.{succ u1} G₀ (divp.{u1} G₀ (MonoidWithZero.toMonoid.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) a (Units.mk0.{u1} G₀ _inst_2 b hb)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (GroupWithZero.toDiv.{u1} G₀ _inst_2)) a b)
Case conversion may be inaccurate. Consider using '#align divp_mk0 divp_mk0ₓ'. -/
@[simp]
theorem divp_mk0 (a : G₀) {b : G₀} (hb : b ≠ 0) : a /ₚ Units.mk0 b hb = a / b :=
  divp_eq_div _ _
#align divp_mk0 divp_mk0

end GroupWithZero

section CommGroupWithZero

-- comm
variable [CommGroupWithZero G₀] {a b c d : G₀}

/- warning: div_mul_right -> div_mul_right is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} (b : G₀), (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a b)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))))) b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} (b : G₀), (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) a (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a b)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (DivisionCommMonoid.toDivisionMonoid.{u1} G₀ (CommGroupWithZero.toDivisionCommMonoid.{u1} G₀ _inst_2))))))) b))
Case conversion may be inaccurate. Consider using '#align div_mul_right div_mul_rightₓ'. -/
theorem div_mul_right (b : G₀) (ha : a ≠ 0) : a / (a * b) = 1 / b :=
  ha.IsUnit.div_mul_right _
#align div_mul_right div_mul_right

/- warning: mul_div_cancel_left_of_imp -> mul_div_cancel_left_of_imp is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, ((Eq.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a b) a) b)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, ((Eq.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2)))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a b) a) b)
Case conversion may be inaccurate. Consider using '#align mul_div_cancel_left_of_imp mul_div_cancel_left_of_impₓ'. -/
theorem mul_div_cancel_left_of_imp {a b : G₀} (h : a = 0 → b = 0) : a * b / a = b := by
  rw [mul_comm, mul_div_cancel_of_imp h]
#align mul_div_cancel_left_of_imp mul_div_cancel_left_of_imp

/- warning: mul_div_cancel_left -> mul_div_cancel_left is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} (b : G₀), (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a b) a) b)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} (b : G₀), (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a b) a) b)
Case conversion may be inaccurate. Consider using '#align mul_div_cancel_left mul_div_cancel_leftₓ'. -/
theorem mul_div_cancel_left (b : G₀) (ha : a ≠ 0) : a * b / a = b :=
  ha.IsUnit.mul_div_cancel_left _
#align mul_div_cancel_left mul_div_cancel_left

/- warning: mul_div_cancel_of_imp' -> mul_div_cancel_of_imp' is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, ((Eq.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) b (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) a b)) a)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, ((Eq.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2)))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) b (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) a b)) a)
Case conversion may be inaccurate. Consider using '#align mul_div_cancel_of_imp' mul_div_cancel_of_imp'ₓ'. -/
theorem mul_div_cancel_of_imp' {a b : G₀} (h : b = 0 → a = 0) : b * (a / b) = a := by
  rw [mul_comm, div_mul_cancel_of_imp h]
#align mul_div_cancel_of_imp' mul_div_cancel_of_imp'

/- warning: mul_div_cancel' -> mul_div_cancel' is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {b : G₀} (a : G₀), (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) b (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) a b)) a)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {b : G₀} (a : G₀), (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) b (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) a b)) a)
Case conversion may be inaccurate. Consider using '#align mul_div_cancel' mul_div_cancel'ₓ'. -/
theorem mul_div_cancel' (a : G₀) (hb : b ≠ 0) : b * (a / b) = a :=
  hb.IsUnit.mul_div_cancel'ₓ _
#align mul_div_cancel' mul_div_cancel'

/- warning: mul_div_mul_left -> mul_div_mul_left is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {c : G₀} (a : G₀) (b : G₀), (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) c a) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) c b)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) a b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {c : G₀} (a : G₀) (b : G₀), (Ne.{succ u1} G₀ c (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) c a) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) c b)) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) a b))
Case conversion may be inaccurate. Consider using '#align mul_div_mul_left mul_div_mul_leftₓ'. -/
theorem mul_div_mul_left (a b : G₀) (hc : c ≠ 0) : c * a / (c * b) = a / b :=
  hc.IsUnit.mul_div_mul_left _ _
#align mul_div_mul_left mul_div_mul_left

/- warning: mul_eq_mul_of_div_eq_div -> mul_eq_mul_of_div_eq_div is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] (a : G₀) {b : G₀} (c : G₀) {d : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Ne.{succ u1} G₀ d (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) a b) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) c d)) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a d) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) c b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] (a : G₀) {b : G₀} (c : G₀) {d : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Ne.{succ u1} G₀ d (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) a b) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) c d)) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a d) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) c b))
Case conversion may be inaccurate. Consider using '#align mul_eq_mul_of_div_eq_div mul_eq_mul_of_div_eq_divₓ'. -/
theorem mul_eq_mul_of_div_eq_div (a : G₀) {b : G₀} (c : G₀) {d : G₀} (hb : b ≠ 0) (hd : d ≠ 0)
    (h : a / b = c / d) : a * d = c * b := by
  rw [← mul_one a, ← div_self hb, ← mul_comm_div, h, div_mul_eq_mul_div, div_mul_cancel _ hd]
#align mul_eq_mul_of_div_eq_div mul_eq_mul_of_div_eq_div

/- warning: div_eq_div_iff -> div_eq_div_iff is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀} {d : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Ne.{succ u1} G₀ d (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Iff (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) a b) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) c d)) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a d) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) c b)))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} {b : G₀} {c : G₀} {d : G₀}, (Ne.{succ u1} G₀ b (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Ne.{succ u1} G₀ d (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Iff (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) a b) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) c d)) (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a d) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) c b)))
Case conversion may be inaccurate. Consider using '#align div_eq_div_iff div_eq_div_iffₓ'. -/
@[field_simps]
theorem div_eq_div_iff (hb : b ≠ 0) (hd : d ≠ 0) : a / b = c / d ↔ a * d = c * b :=
  hb.IsUnit.div_eq_div_iff hd.IsUnit
#align div_eq_div_iff div_eq_div_iff

/- warning: div_div_cancel' -> div_div_cancel' is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) a (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) a b)) b)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} {b : G₀}, (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) a (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) a b)) b)
Case conversion may be inaccurate. Consider using '#align div_div_cancel' div_div_cancel'ₓ'. -/
theorem div_div_cancel' (ha : a ≠ 0) : a / (a / b) = b :=
  ha.IsUnit.div_div_cancel
#align div_div_cancel' div_div_cancel'

/- warning: div_helper -> div_helper is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} (b : G₀), (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2))))))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))))) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a b)) a) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))) (OfNat.ofNat.{u1} G₀ 1 (OfNat.mk.{u1} G₀ 1 (One.one.{u1} G₀ (MulOneClass.toHasOne.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))))) b))
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : CommGroupWithZero.{u1} G₀] {a : G₀} (b : G₀), (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (CommMonoidWithZero.toZero.{u1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u1} G₀ _inst_2))))) -> (Eq.{succ u1} G₀ (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (DivisionCommMonoid.toDivisionMonoid.{u1} G₀ (CommGroupWithZero.toDivisionCommMonoid.{u1} G₀ _inst_2))))))) (HMul.hMul.{u1, u1, u1} G₀ G₀ G₀ (instHMul.{u1} G₀ (MulZeroClass.toMul.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ (CommGroupWithZero.toGroupWithZero.{u1} G₀ _inst_2)))))) a b)) a) (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (CommGroupWithZero.toDiv.{u1} G₀ _inst_2)) (OfNat.ofNat.{u1} G₀ 1 (One.toOfNat1.{u1} G₀ (InvOneClass.toOne.{u1} G₀ (DivInvOneMonoid.toInvOneClass.{u1} G₀ (DivisionMonoid.toDivInvOneMonoid.{u1} G₀ (DivisionCommMonoid.toDivisionMonoid.{u1} G₀ (CommGroupWithZero.toDivisionCommMonoid.{u1} G₀ _inst_2))))))) b))
Case conversion may be inaccurate. Consider using '#align div_helper div_helperₓ'. -/
theorem div_helper (b : G₀) (h : a ≠ 0) : 1 / (a * b) * a = 1 / b := by
  rw [div_mul_eq_mul_div, one_mul, div_mul_right _ h]
#align div_helper div_helper

end CommGroupWithZero

section MonoidWithZero

variable [GroupWithZero G₀] [Nontrivial M₀] [MonoidWithZero M₀'] [MonoidWithZeroHomClass F G₀ M₀]
  [MonoidWithZeroHomClass F' G₀ M₀'] (f : F) {a : G₀}

include M₀

/- warning: map_ne_zero -> map_ne_zero is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u1}} {G₀ : Type.{u2}} {F : Type.{u3}} [_inst_1 : MonoidWithZero.{u1} M₀] [_inst_2 : GroupWithZero.{u2} G₀] [_inst_3 : Nontrivial.{u1} M₀] [_inst_5 : MonoidWithZeroHomClass.{u3, u2, u1} F G₀ M₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M₀ _inst_1)] (f : F) {a : G₀}, Iff (Ne.{succ u1} M₀ (coeFn.{succ u3, max (succ u2) (succ u1)} F (fun (_x : F) => G₀ -> M₀) (FunLike.hasCoeToFun.{succ u3, succ u2, succ u1} F G₀ (fun (_x : G₀) => M₀) (MulHomClass.toFunLike.{u3, u2, u1} F G₀ M₀ (MulOneClass.toHasMul.{u2} G₀ (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)))) (MulOneClass.toHasMul.{u1} M₀ (MulZeroOneClass.toMulOneClass.{u1} M₀ (MonoidWithZero.toMulZeroOneClass.{u1} M₀ _inst_1))) (MonoidHomClass.toMulHomClass.{u3, u2, u1} F G₀ M₀ (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u1} M₀ (MonoidWithZero.toMulZeroOneClass.{u1} M₀ _inst_1)) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u2, u1} F G₀ M₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M₀ _inst_1) _inst_5)))) f a) (OfNat.ofNat.{u1} M₀ 0 (OfNat.mk.{u1} M₀ 0 (Zero.zero.{u1} M₀ (MulZeroClass.toHasZero.{u1} M₀ (MulZeroOneClass.toMulZeroClass.{u1} M₀ (MonoidWithZero.toMulZeroOneClass.{u1} M₀ _inst_1))))))) (Ne.{succ u2} G₀ a (OfNat.ofNat.{u2} G₀ 0 (OfNat.mk.{u2} G₀ 0 (Zero.zero.{u2} G₀ (MulZeroClass.toHasZero.{u2} G₀ (MulZeroOneClass.toMulZeroClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2))))))))
but is expected to have type
  forall {M₀ : Type.{u3}} {G₀ : Type.{u1}} {F : Type.{u2}} [_inst_1 : MonoidWithZero.{u3} M₀] [_inst_2 : GroupWithZero.{u1} G₀] [_inst_3 : Nontrivial.{u3} M₀] [_inst_5 : MonoidWithZeroHomClass.{u2, u1, u3} F G₀ M₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} M₀ _inst_1)] (f : F) {a : G₀}, Iff (Ne.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀) a) (FunLike.coe.{succ u2, succ u1, succ u3} F G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀) _x) (MulHomClass.toFunLike.{u2, u1, u3} F G₀ M₀ (MulOneClass.toMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toMul.{u3} M₀ (MulZeroOneClass.toMulOneClass.{u3} M₀ (MonoidWithZero.toMulZeroOneClass.{u3} M₀ _inst_1))) (MonoidHomClass.toMulHomClass.{u2, u1, u3} F G₀ M₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} M₀ (MonoidWithZero.toMulZeroOneClass.{u3} M₀ _inst_1)) (MonoidWithZeroHomClass.toMonoidHomClass.{u2, u1, u3} F G₀ M₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} M₀ _inst_1) _inst_5))) f a) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀) a) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀) a) (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀) a) _inst_1)))) (Ne.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))
Case conversion may be inaccurate. Consider using '#align map_ne_zero map_ne_zeroₓ'. -/
theorem map_ne_zero : f a ≠ 0 ↔ a ≠ 0 :=
  ⟨fun hfa ha => hfa <| ha.symm ▸ map_zero f, fun ha => ((IsUnit.mk0 a ha).map f).NeZero⟩
#align map_ne_zero map_ne_zero

/- warning: map_eq_zero -> map_eq_zero is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u1}} {G₀ : Type.{u2}} {F : Type.{u3}} [_inst_1 : MonoidWithZero.{u1} M₀] [_inst_2 : GroupWithZero.{u2} G₀] [_inst_3 : Nontrivial.{u1} M₀] [_inst_5 : MonoidWithZeroHomClass.{u3, u2, u1} F G₀ M₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M₀ _inst_1)] (f : F) {a : G₀}, Iff (Eq.{succ u1} M₀ (coeFn.{succ u3, max (succ u2) (succ u1)} F (fun (_x : F) => G₀ -> M₀) (FunLike.hasCoeToFun.{succ u3, succ u2, succ u1} F G₀ (fun (_x : G₀) => M₀) (MulHomClass.toFunLike.{u3, u2, u1} F G₀ M₀ (MulOneClass.toHasMul.{u2} G₀ (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)))) (MulOneClass.toHasMul.{u1} M₀ (MulZeroOneClass.toMulOneClass.{u1} M₀ (MonoidWithZero.toMulZeroOneClass.{u1} M₀ _inst_1))) (MonoidHomClass.toMulHomClass.{u3, u2, u1} F G₀ M₀ (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u1} M₀ (MonoidWithZero.toMulZeroOneClass.{u1} M₀ _inst_1)) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u2, u1} F G₀ M₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M₀ _inst_1) _inst_5)))) f a) (OfNat.ofNat.{u1} M₀ 0 (OfNat.mk.{u1} M₀ 0 (Zero.zero.{u1} M₀ (MulZeroClass.toHasZero.{u1} M₀ (MulZeroOneClass.toMulZeroClass.{u1} M₀ (MonoidWithZero.toMulZeroOneClass.{u1} M₀ _inst_1))))))) (Eq.{succ u2} G₀ a (OfNat.ofNat.{u2} G₀ 0 (OfNat.mk.{u2} G₀ 0 (Zero.zero.{u2} G₀ (MulZeroClass.toHasZero.{u2} G₀ (MulZeroOneClass.toMulZeroClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2))))))))
but is expected to have type
  forall {M₀ : Type.{u3}} {G₀ : Type.{u1}} {F : Type.{u2}} [_inst_1 : MonoidWithZero.{u3} M₀] [_inst_2 : GroupWithZero.{u1} G₀] [_inst_3 : Nontrivial.{u3} M₀] [_inst_5 : MonoidWithZeroHomClass.{u2, u1, u3} F G₀ M₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} M₀ _inst_1)] (f : F) {a : G₀}, Iff (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀) a) (FunLike.coe.{succ u2, succ u1, succ u3} F G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀) _x) (MulHomClass.toFunLike.{u2, u1, u3} F G₀ M₀ (MulOneClass.toMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toMul.{u3} M₀ (MulZeroOneClass.toMulOneClass.{u3} M₀ (MonoidWithZero.toMulZeroOneClass.{u3} M₀ _inst_1))) (MonoidHomClass.toMulHomClass.{u2, u1, u3} F G₀ M₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} M₀ (MonoidWithZero.toMulZeroOneClass.{u3} M₀ _inst_1)) (MonoidWithZeroHomClass.toMonoidHomClass.{u2, u1, u3} F G₀ M₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} M₀ _inst_1) _inst_5))) f a) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀) a) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀) a) (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀) a) _inst_1)))) (Eq.{succ u1} G₀ a (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))
Case conversion may be inaccurate. Consider using '#align map_eq_zero map_eq_zeroₓ'. -/
@[simp]
theorem map_eq_zero : f a = 0 ↔ a = 0 :=
  not_iff_not.1 (map_ne_zero f)
#align map_eq_zero map_eq_zero

omit M₀

include M₀'

/- warning: eq_on_inv₀ -> eq_on_inv₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} {M₀' : Type.{u2}} {F' : Type.{u3}} [_inst_2 : GroupWithZero.{u1} G₀] [_inst_4 : MonoidWithZero.{u2} M₀'] [_inst_6 : MonoidWithZeroHomClass.{u3, u1, u2} F' G₀ M₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4)] {a : G₀} (f : F') (g : F'), (Eq.{succ u2} M₀' (coeFn.{succ u3, max (succ u1) (succ u2)} F' (fun (_x : F') => G₀ -> M₀') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F' G₀ (fun (_x : G₀) => M₀') (MulHomClass.toFunLike.{u3, u1, u2} F' G₀ M₀' (MulOneClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toHasMul.{u2} M₀' (MulZeroOneClass.toMulOneClass.{u2} M₀' (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F' G₀ M₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u2} M₀' (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4)) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F' G₀ M₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4) _inst_6)))) f a) (coeFn.{succ u3, max (succ u1) (succ u2)} F' (fun (_x : F') => G₀ -> M₀') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F' G₀ (fun (_x : G₀) => M₀') (MulHomClass.toFunLike.{u3, u1, u2} F' G₀ M₀' (MulOneClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toHasMul.{u2} M₀' (MulZeroOneClass.toMulOneClass.{u2} M₀' (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F' G₀ M₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u2} M₀' (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4)) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F' G₀ M₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4) _inst_6)))) g a)) -> (Eq.{succ u2} M₀' (coeFn.{succ u3, max (succ u1) (succ u2)} F' (fun (_x : F') => G₀ -> M₀') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F' G₀ (fun (_x : G₀) => M₀') (MulHomClass.toFunLike.{u3, u1, u2} F' G₀ M₀' (MulOneClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toHasMul.{u2} M₀' (MulZeroOneClass.toMulOneClass.{u2} M₀' (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F' G₀ M₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u2} M₀' (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4)) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F' G₀ M₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4) _inst_6)))) f (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) a)) (coeFn.{succ u3, max (succ u1) (succ u2)} F' (fun (_x : F') => G₀ -> M₀') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F' G₀ (fun (_x : G₀) => M₀') (MulHomClass.toFunLike.{u3, u1, u2} F' G₀ M₀' (MulOneClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toHasMul.{u2} M₀' (MulZeroOneClass.toMulOneClass.{u2} M₀' (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F' G₀ M₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u2} M₀' (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4)) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F' G₀ M₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} M₀' _inst_4) _inst_6)))) g (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) a)))
but is expected to have type
  forall {G₀ : Type.{u1}} {M₀' : Type.{u3}} {F' : Type.{u2}} [_inst_2 : GroupWithZero.{u1} G₀] [_inst_4 : MonoidWithZero.{u3} M₀'] [_inst_6 : MonoidWithZeroHomClass.{u2, u1, u3} F' G₀ M₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4)] {a : G₀} (f : F') (g : F'), (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀') a) (FunLike.coe.{succ u2, succ u1, succ u3} F' G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀') _x) (MulHomClass.toFunLike.{u2, u1, u3} F' G₀ M₀' (MulOneClass.toMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toMul.{u3} M₀' (MulZeroOneClass.toMulOneClass.{u3} M₀' (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4))) (MonoidHomClass.toMulHomClass.{u2, u1, u3} F' G₀ M₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} M₀' (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4)) (MonoidWithZeroHomClass.toMonoidHomClass.{u2, u1, u3} F' G₀ M₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4) _inst_6))) f a) (FunLike.coe.{succ u2, succ u1, succ u3} F' G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀') _x) (MulHomClass.toFunLike.{u2, u1, u3} F' G₀ M₀' (MulOneClass.toMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toMul.{u3} M₀' (MulZeroOneClass.toMulOneClass.{u3} M₀' (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4))) (MonoidHomClass.toMulHomClass.{u2, u1, u3} F' G₀ M₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} M₀' (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4)) (MonoidWithZeroHomClass.toMonoidHomClass.{u2, u1, u3} F' G₀ M₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4) _inst_6))) g a)) -> (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀') (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) a)) (FunLike.coe.{succ u2, succ u1, succ u3} F' G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀') _x) (MulHomClass.toFunLike.{u2, u1, u3} F' G₀ M₀' (MulOneClass.toMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toMul.{u3} M₀' (MulZeroOneClass.toMulOneClass.{u3} M₀' (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4))) (MonoidHomClass.toMulHomClass.{u2, u1, u3} F' G₀ M₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} M₀' (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4)) (MonoidWithZeroHomClass.toMonoidHomClass.{u2, u1, u3} F' G₀ M₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4) _inst_6))) f (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) a)) (FunLike.coe.{succ u2, succ u1, succ u3} F' G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => M₀') _x) (MulHomClass.toFunLike.{u2, u1, u3} F' G₀ M₀' (MulOneClass.toMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toMul.{u3} M₀' (MulZeroOneClass.toMulOneClass.{u3} M₀' (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4))) (MonoidHomClass.toMulHomClass.{u2, u1, u3} F' G₀ M₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} M₀' (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4)) (MonoidWithZeroHomClass.toMonoidHomClass.{u2, u1, u3} F' G₀ M₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} M₀' _inst_4) _inst_6))) g (Inv.inv.{u1} G₀ (GroupWithZero.toInv.{u1} G₀ _inst_2) a)))
Case conversion may be inaccurate. Consider using '#align eq_on_inv₀ eq_on_inv₀ₓ'. -/
theorem eq_on_inv₀ (f g : F') (h : f a = g a) : f a⁻¹ = g a⁻¹ :=
  by
  rcases eq_or_ne a 0 with (rfl | ha)
  · rw [inv_zero, map_zero, map_zero]
  · exact (IsUnit.mk0 a ha).eq_on_inv f g h
#align eq_on_inv₀ eq_on_inv₀

end MonoidWithZero

section GroupWithZero

variable [GroupWithZero G₀] [GroupWithZero G₀'] [MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a b : G₀)

include G₀'

/- warning: map_inv₀ -> map_inv₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} {G₀' : Type.{u2}} {F : Type.{u3}} [_inst_2 : GroupWithZero.{u1} G₀] [_inst_3 : GroupWithZero.{u2} G₀'] [_inst_4 : MonoidWithZeroHomClass.{u3, u1, u2} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3))] (f : F) (a : G₀), Eq.{succ u2} G₀' (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => G₀ -> G₀') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F G₀ (fun (_x : G₀) => G₀') (MulHomClass.toFunLike.{u3, u1, u2} F G₀ G₀' (MulOneClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toHasMul.{u2} G₀' (MulZeroOneClass.toMulOneClass.{u2} G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3)))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F G₀ G₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u2} G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3))) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3)) _inst_4)))) f (Inv.inv.{u1} G₀ (DivInvMonoid.toHasInv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2)) a)) (Inv.inv.{u2} G₀' (DivInvMonoid.toHasInv.{u2} G₀' (GroupWithZero.toDivInvMonoid.{u2} G₀' _inst_3)) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => G₀ -> G₀') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F G₀ (fun (_x : G₀) => G₀') (MulHomClass.toFunLike.{u3, u1, u2} F G₀ G₀' (MulOneClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toHasMul.{u2} G₀' (MulZeroOneClass.toMulOneClass.{u2} G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3)))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F G₀ G₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u2} G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3))) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3)) _inst_4)))) f a))
but is expected to have type
  forall {G₀ : Type.{u2}} {G₀' : Type.{u3}} {F : Type.{u1}} [_inst_2 : GroupWithZero.{u2} G₀] [_inst_3 : GroupWithZero.{u3} G₀'] [_inst_4 : MonoidWithZeroHomClass.{u1, u2, u3} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3))] (f : F) (a : G₀), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') (Inv.inv.{u2} G₀ (GroupWithZero.toInv.{u2} G₀ _inst_2) a)) (FunLike.coe.{succ u1, succ u2, succ u3} F G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') _x) (MulHomClass.toFunLike.{u1, u2, u3} F G₀ G₀' (MulOneClass.toMul.{u2} G₀ (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)))) (MulOneClass.toMul.{u3} G₀' (MulZeroOneClass.toMulOneClass.{u3} G₀' (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F G₀ G₀' (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} G₀' (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3))) (MonoidWithZeroHomClass.toMonoidHomClass.{u1, u2, u3} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3)) _inst_4))) f (Inv.inv.{u2} G₀ (GroupWithZero.toInv.{u2} G₀ _inst_2) a)) (Inv.inv.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') a) (GroupWithZero.toInv.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') a) _inst_3) (FunLike.coe.{succ u1, succ u2, succ u3} F G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') _x) (MulHomClass.toFunLike.{u1, u2, u3} F G₀ G₀' (MulOneClass.toMul.{u2} G₀ (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)))) (MulOneClass.toMul.{u3} G₀' (MulZeroOneClass.toMulOneClass.{u3} G₀' (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F G₀ G₀' (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} G₀' (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3))) (MonoidWithZeroHomClass.toMonoidHomClass.{u1, u2, u3} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3)) _inst_4))) f a))
Case conversion may be inaccurate. Consider using '#align map_inv₀ map_inv₀ₓ'. -/
/-- A monoid homomorphism between groups with zeros sending `0` to `0` sends `a⁻¹` to `(f a)⁻¹`. -/
@[simp]
theorem map_inv₀ : f a⁻¹ = (f a)⁻¹ := by
  by_cases h : a = 0; · simp [h]
  apply eq_inv_of_mul_eq_one_left
  rw [← map_mul, inv_mul_cancel h, map_one]
#align map_inv₀ map_inv₀

/- warning: map_div₀ -> map_div₀ is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} {G₀' : Type.{u2}} {F : Type.{u3}} [_inst_2 : GroupWithZero.{u1} G₀] [_inst_3 : GroupWithZero.{u2} G₀'] [_inst_4 : MonoidWithZeroHomClass.{u3, u1, u2} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3))] (f : F) (a : G₀) (b : G₀), Eq.{succ u2} G₀' (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => G₀ -> G₀') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F G₀ (fun (_x : G₀) => G₀') (MulHomClass.toFunLike.{u3, u1, u2} F G₀ G₀' (MulOneClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toHasMul.{u2} G₀' (MulZeroOneClass.toMulOneClass.{u2} G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3)))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F G₀ G₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u2} G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3))) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3)) _inst_4)))) f (HDiv.hDiv.{u1, u1, u1} G₀ G₀ G₀ (instHDiv.{u1} G₀ (DivInvMonoid.toHasDiv.{u1} G₀ (GroupWithZero.toDivInvMonoid.{u1} G₀ _inst_2))) a b)) (HDiv.hDiv.{u2, u2, u2} G₀' G₀' G₀' (instHDiv.{u2} G₀' (DivInvMonoid.toHasDiv.{u2} G₀' (GroupWithZero.toDivInvMonoid.{u2} G₀' _inst_3))) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => G₀ -> G₀') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F G₀ (fun (_x : G₀) => G₀') (MulHomClass.toFunLike.{u3, u1, u2} F G₀ G₀' (MulOneClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toHasMul.{u2} G₀' (MulZeroOneClass.toMulOneClass.{u2} G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3)))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F G₀ G₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u2} G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3))) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3)) _inst_4)))) f a) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => G₀ -> G₀') (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F G₀ (fun (_x : G₀) => G₀') (MulHomClass.toFunLike.{u3, u1, u2} F G₀ G₀' (MulOneClass.toHasMul.{u1} G₀ (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))) (MulOneClass.toHasMul.{u2} G₀' (MulZeroOneClass.toMulOneClass.{u2} G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3)))) (MonoidHomClass.toMulHomClass.{u3, u1, u2} F G₀ G₀' (MulZeroOneClass.toMulOneClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u2} G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3))) (MonoidWithZeroHomClass.toMonoidHomClass.{u3, u1, u2} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u2} G₀' (GroupWithZero.toMonoidWithZero.{u2} G₀' _inst_3)) _inst_4)))) f b))
but is expected to have type
  forall {G₀ : Type.{u2}} {G₀' : Type.{u3}} {F : Type.{u1}} [_inst_2 : GroupWithZero.{u2} G₀] [_inst_3 : GroupWithZero.{u3} G₀'] [_inst_4 : MonoidWithZeroHomClass.{u1, u2, u3} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3))] (f : F) (a : G₀) (b : G₀), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') (HDiv.hDiv.{u2, u2, u2} G₀ G₀ G₀ (instHDiv.{u2} G₀ (GroupWithZero.toDiv.{u2} G₀ _inst_2)) a b)) (FunLike.coe.{succ u1, succ u2, succ u3} F G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') _x) (MulHomClass.toFunLike.{u1, u2, u3} F G₀ G₀' (MulOneClass.toMul.{u2} G₀ (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)))) (MulOneClass.toMul.{u3} G₀' (MulZeroOneClass.toMulOneClass.{u3} G₀' (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F G₀ G₀' (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} G₀' (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3))) (MonoidWithZeroHomClass.toMonoidHomClass.{u1, u2, u3} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3)) _inst_4))) f (HDiv.hDiv.{u2, u2, u2} G₀ G₀ G₀ (instHDiv.{u2} G₀ (GroupWithZero.toDiv.{u2} G₀ _inst_2)) a b)) (HDiv.hDiv.{u3, u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') b) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') a) (instHDiv.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') a) (GroupWithZero.toDiv.{u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') a) _inst_3)) (FunLike.coe.{succ u1, succ u2, succ u3} F G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') _x) (MulHomClass.toFunLike.{u1, u2, u3} F G₀ G₀' (MulOneClass.toMul.{u2} G₀ (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)))) (MulOneClass.toMul.{u3} G₀' (MulZeroOneClass.toMulOneClass.{u3} G₀' (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F G₀ G₀' (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} G₀' (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3))) (MonoidWithZeroHomClass.toMonoidHomClass.{u1, u2, u3} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3)) _inst_4))) f a) (FunLike.coe.{succ u1, succ u2, succ u3} F G₀ (fun (_x : G₀) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G₀) => G₀') _x) (MulHomClass.toFunLike.{u1, u2, u3} F G₀ G₀' (MulOneClass.toMul.{u2} G₀ (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)))) (MulOneClass.toMul.{u3} G₀' (MulZeroOneClass.toMulOneClass.{u3} G₀' (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3)))) (MonoidHomClass.toMulHomClass.{u1, u2, u3} F G₀ G₀' (MulZeroOneClass.toMulOneClass.{u2} G₀ (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2))) (MulZeroOneClass.toMulOneClass.{u3} G₀' (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3))) (MonoidWithZeroHomClass.toMonoidHomClass.{u1, u2, u3} F G₀ G₀' (MonoidWithZero.toMulZeroOneClass.{u2} G₀ (GroupWithZero.toMonoidWithZero.{u2} G₀ _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u3} G₀' (GroupWithZero.toMonoidWithZero.{u3} G₀' _inst_3)) _inst_4))) f b))
Case conversion may be inaccurate. Consider using '#align map_div₀ map_div₀ₓ'. -/
@[simp]
theorem map_div₀ : f (a / b) = f a / f b :=
  map_div' f (map_inv₀ f) a b
#align map_div₀ map_div₀

end GroupWithZero

#print MonoidWithZero.inverse /-
/-- We define the inverse as a `monoid_with_zero_hom` by extending the inverse map by zero
on non-units. -/
noncomputable def MonoidWithZero.inverse {M : Type _} [CommMonoidWithZero M] : M →*₀ M
    where
  toFun := Ring.inverse
  map_zero' := Ring.inverse_zero _
  map_one' := Ring.inverse_one _
  map_mul' x y := (Ring.mul_inverse_rev x y).trans (mul_comm _ _)
#align monoid_with_zero.inverse MonoidWithZero.inverse
-/

/- warning: monoid_with_zero.coe_inverse -> MonoidWithZero.coe_inverse is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_2 : CommMonoidWithZero.{u1} M], Eq.{succ u1} ((fun (_x : MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) => M -> M) (MonoidWithZero.inverse.{u1} M _inst_2)) (coeFn.{succ u1, succ u1} (MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) (fun (_x : MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) => M -> M) (MonoidWithZeroHom.hasCoeToFun.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) (MonoidWithZero.inverse.{u1} M _inst_2)) (Ring.inverse.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))
but is expected to have type
  forall {M : Type.{u1}} [_inst_2 : CommMonoidWithZero.{u1} M], Eq.{succ u1} (forall (a : M), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => M) a) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => M) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) M M (MulOneClass.toMul.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)))) (MulOneClass.toMul.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) M M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) (MonoidWithZeroHomClass.toMonoidHomClass.{u1, u1, u1} (MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZeroHom.monoidWithZeroHomClass.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)))))) (MonoidWithZero.inverse.{u1} M _inst_2)) (Ring.inverse.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))
Case conversion may be inaccurate. Consider using '#align monoid_with_zero.coe_inverse MonoidWithZero.coe_inverseₓ'. -/
@[simp]
theorem MonoidWithZero.coe_inverse {M : Type _} [CommMonoidWithZero M] :
    (MonoidWithZero.inverse : M → M) = Ring.inverse :=
  rfl
#align monoid_with_zero.coe_inverse MonoidWithZero.coe_inverse

/- warning: monoid_with_zero.inverse_apply -> MonoidWithZero.inverse_apply is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_2 : CommMonoidWithZero.{u1} M] (a : M), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) (fun (_x : MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) => M -> M) (MonoidWithZeroHom.hasCoeToFun.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) (MonoidWithZero.inverse.{u1} M _inst_2) a) (Ring.inverse.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2) a)
but is expected to have type
  forall {M : Type.{u1}} [_inst_2 : CommMonoidWithZero.{u1} M] (a : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => M) a) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : M) => M) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) M M (MulOneClass.toMul.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)))) (MulOneClass.toMul.{u1} M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) M M (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) (MulZeroOneClass.toMulOneClass.{u1} M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) (MonoidWithZeroHomClass.toMonoidHomClass.{u1, u1, u1} (MonoidWithZeroHom.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2))) M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZeroHom.monoidWithZeroHomClass.{u1, u1} M M (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)) (MonoidWithZero.toMulZeroOneClass.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2)))))) (MonoidWithZero.inverse.{u1} M _inst_2) a) (Ring.inverse.{u1} M (CommMonoidWithZero.toMonoidWithZero.{u1} M _inst_2) a)
Case conversion may be inaccurate. Consider using '#align monoid_with_zero.inverse_apply MonoidWithZero.inverse_applyₓ'. -/
@[simp]
theorem MonoidWithZero.inverse_apply {M : Type _} [CommMonoidWithZero M] (a : M) :
    MonoidWithZero.inverse a = Ring.inverse a :=
  rfl
#align monoid_with_zero.inverse_apply MonoidWithZero.inverse_apply

#print invMonoidWithZeroHom /-
/-- Inversion on a commutative group with zero, considered as a monoid with zero homomorphism. -/
def invMonoidWithZeroHom {G₀ : Type _} [CommGroupWithZero G₀] : G₀ →*₀ G₀ :=
  { invMonoidHom with map_zero' := inv_zero }
#align inv_monoid_with_zero_hom invMonoidWithZeroHom
-/

namespace Units

variable [GroupWithZero G₀]

variable {a b : G₀}

/- warning: units.smul_mk0 -> Units.smul_mk0 is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {α : Type.{u2}} [_inst_3 : SMul.{u1, u2} G₀ α] {g : G₀} (hg : Ne.{succ u1} G₀ g (OfNat.ofNat.{u1} G₀ 0 (OfNat.mk.{u1} G₀ 0 (Zero.zero.{u1} G₀ (MulZeroClass.toHasZero.{u1} G₀ (MulZeroOneClass.toMulZeroClass.{u1} G₀ (MonoidWithZero.toMulZeroOneClass.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)))))))) (a : α), Eq.{succ u2} α (SMul.smul.{u1, u2} (Units.{u1} G₀ (MonoidWithZero.toMonoid.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) α (Units.hasSmul.{u1, u2} G₀ α (MonoidWithZero.toMonoid.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) _inst_3) (Units.mk0.{u1} G₀ _inst_2 g hg) a) (SMul.smul.{u1, u2} G₀ α _inst_3 g a)
but is expected to have type
  forall {G₀ : Type.{u1}} [_inst_2 : GroupWithZero.{u1} G₀] {α : Type.{u2}} [_inst_3 : SMul.{u1, u2} G₀ α] {g : G₀} (hg : Ne.{succ u1} G₀ g (OfNat.ofNat.{u1} G₀ 0 (Zero.toOfNat0.{u1} G₀ (MonoidWithZero.toZero.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))))) (a : α), Eq.{succ u2} α (HSMul.hSMul.{u1, u2, u2} (Units.{u1} G₀ (MonoidWithZero.toMonoid.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) α α (instHSMul.{u1, u2} (Units.{u1} G₀ (MonoidWithZero.toMonoid.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2))) α (Units.instSMulUnits.{u1, u2} G₀ α (MonoidWithZero.toMonoid.{u1} G₀ (GroupWithZero.toMonoidWithZero.{u1} G₀ _inst_2)) _inst_3)) (Units.mk0.{u1} G₀ _inst_2 g hg) a) (HSMul.hSMul.{u1, u2, u2} G₀ α α (instHSMul.{u1, u2} G₀ α _inst_3) g a)
Case conversion may be inaccurate. Consider using '#align units.smul_mk0 Units.smul_mk0ₓ'. -/
@[simp]
theorem smul_mk0 {α : Type _} [SMul G₀ α] {g : G₀} (hg : g ≠ 0) (a : α) : mk0 g hg • a = g • a :=
  rfl
#align units.smul_mk0 Units.smul_mk0

end Units

