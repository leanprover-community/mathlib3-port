/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin
-/
import Mathbin.Algebra.Group.InjSurj
import Mathbin.Algebra.GroupWithZero.Defs

/-!
# Lifting groups with zero along injective/surjective maps

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> https://github.com/leanprover-community/mathlib4/pull/722
> Any changes to this file require a corresponding PR to mathlib4.
-/


open Function

variable {M₀ G₀ M₀' G₀' : Type _}

section MulZeroClass

variable [MulZeroClass M₀] {a b : M₀}

/- warning: function.injective.mul_zero_class -> Function.Injective.mulZeroClass is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : MulZeroClass.{u_1} M₀] [_inst_2 : Mul.{u_3} M₀'] [_inst_3 : Zero.{u_3} M₀'] (f : M₀' -> M₀), (Function.Injective.{succ u_3, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_3)))) (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ _inst_1))))) -> (forall (a : M₀') (b : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_2) a b)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ _inst_1)) (f a) (f b))) -> (MulZeroClass.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.35 : MulZeroClass.{u_1} M₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.40 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.43 : Zero.{u_2} M₀'] (f : M₀' -> M₀), (Function.Injective.{succ u_2, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.43))) (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (MulZeroClass.toZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.35)))) -> (forall (a : M₀') (b : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.40) a b)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.35)) (f a) (f b))) -> (MulZeroClass.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.injective.mul_zero_class Function.Injective.mulZeroClassₓ'. -/
/-- Pullback a `mul_zero_class` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.mulZeroClass [Mul M₀'] [Zero M₀'] (f : M₀' → M₀) (hf : Injective f)
    (zero : f 0 = 0) (mul : ∀ a b, f (a * b) = f a * f b) :
    MulZeroClass M₀' where 
  mul := (· * ·)
  zero := 0
  zero_mul a := hf <| by simp only [mul, zero, zero_mul]
  mul_zero a := hf <| by simp only [mul, zero, mul_zero]
#align function.injective.mul_zero_class Function.Injective.mulZeroClass

/- warning: function.surjective.mul_zero_class -> Function.Surjective.mulZeroClass is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : MulZeroClass.{u_1} M₀] [_inst_2 : Mul.{u_3} M₀'] [_inst_3 : Zero.{u_3} M₀'] (f : M₀ -> M₀'), (Function.Surjective.{succ u_1, succ u_3} M₀ M₀' f) -> (Eq.{succ u_3} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ _inst_1))))) (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_3)))) -> (forall (a : M₀) (b : M₀), Eq.{succ u_3} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ _inst_1)) a b)) (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_2) (f a) (f b))) -> (MulZeroClass.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.128 : MulZeroClass.{u_1} M₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.133 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.136 : Zero.{u_2} M₀'] (f : M₀ -> M₀'), (Function.Surjective.{succ u_1, succ u_2} M₀ M₀' f) -> (Eq.{succ u_2} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (MulZeroClass.toZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.128)))) (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.136))) -> (forall (a : M₀) (b : M₀), Eq.{succ u_2} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.128)) a b)) (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.133) (f a) (f b))) -> (MulZeroClass.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.surjective.mul_zero_class Function.Surjective.mulZeroClassₓ'. -/
/-- Pushforward a `mul_zero_class` instance along an surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.mulZeroClass [Mul M₀'] [Zero M₀'] (f : M₀ → M₀')
    (hf : Surjective f) (zero : f 0 = 0) (mul : ∀ a b, f (a * b) = f a * f b) :
    MulZeroClass M₀' where 
  mul := (· * ·)
  zero := 0
  mul_zero := hf.forall.2 fun x => by simp only [← zero, ← mul, mul_zero]
  zero_mul := hf.forall.2 fun x => by simp only [← zero, ← mul, zero_mul]
#align function.surjective.mul_zero_class Function.Surjective.mulZeroClass

end MulZeroClass

section NoZeroDivisors

/- warning: function.injective.no_zero_divisors -> Function.Injective.NoZeroDivisors is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : Mul.{u_1} M₀] [_inst_2 : Zero.{u_1} M₀] [_inst_3 : Mul.{u_3} M₀'] [_inst_4 : Zero.{u_3} M₀'] [_inst_5 : NoZeroDivisors.{u_3} M₀' _inst_3 _inst_4] (f : M₀ -> M₀'), (Function.Injective.{succ u_1, succ u_3} M₀ M₀' f) -> (Eq.{succ u_3} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ _inst_2)))) (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_4)))) -> (forall (x : M₀) (y : M₀), Eq.{succ u_3} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ _inst_1) x y)) (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_3) (f x) (f y))) -> (NoZeroDivisors.{u_1} M₀ _inst_1 _inst_2)
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.219 : Mul.{u_1} M₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.222 : Zero.{u_1} M₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.225 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.228 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.231 : NoZeroDivisors.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.225 inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.228] (f : M₀ -> M₀'), (Function.Injective.{succ u_1, succ u_2} M₀ M₀' f) -> (Eq.{succ u_2} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.222))) (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.228))) -> (forall (x : M₀) (y : M₀), Eq.{succ u_2} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.219) x y)) (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.225) (f x) (f y))) -> (NoZeroDivisors.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.219 inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.222)
Case conversion may be inaccurate. Consider using '#align function.injective.no_zero_divisors Function.Injective.NoZeroDivisorsₓ'. -/
/-- Pushforward a `no_zero_divisors` instance along an injective function. -/
protected theorem Function.Injective.NoZeroDivisors [Mul M₀] [Zero M₀] [Mul M₀'] [Zero M₀']
    [NoZeroDivisors M₀'] (f : M₀ → M₀') (hf : Injective f) (zero : f 0 = 0)
    (mul : ∀ x y, f (x * y) = f x * f y) : NoZeroDivisors M₀ :=
  { eq_zero_or_eq_zero_of_mul_eq_zero := fun x y H =>
      have : f x * f y = 0 := by rw [← mul, H, zero]
      (eq_zero_or_eq_zero_of_mul_eq_zero this).imp (fun H => hf <| by rwa [zero]) fun H =>
        hf <| by rwa [zero] }
#align function.injective.no_zero_divisors Function.Injective.NoZeroDivisors

end NoZeroDivisors

section MulZeroOneClass

variable [MulZeroOneClass M₀]

/- warning: function.injective.mul_zero_one_class -> Function.Injective.mulZeroOneClass is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : MulZeroOneClass.{u_1} M₀] [_inst_2 : Mul.{u_3} M₀'] [_inst_3 : Zero.{u_3} M₀'] [_inst_4 : One.{u_3} M₀'] (f : M₀' -> M₀), (Function.Injective.{succ u_3, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_3)))) (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ _inst_1)))))) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 1 (OfNat.mk.{u_3} M₀' 1 (One.one.{u_3} M₀' _inst_4)))) (OfNat.ofNat.{u_1} M₀ 1 (OfNat.mk.{u_1} M₀ 1 (One.one.{u_1} M₀ (MulOneClass.toHasOne.{u_1} M₀ (MulZeroOneClass.toMulOneClass.{u_1} M₀ _inst_1)))))) -> (forall (a : M₀') (b : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_2) a b)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ _inst_1))) (f a) (f b))) -> (MulZeroOneClass.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.436 : MulZeroOneClass.{u_1} M₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.439 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.442 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.445 : One.{u_2} M₀'] (f : M₀' -> M₀), (Function.Injective.{succ u_2, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.442))) (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (MulZeroOneClass.toZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.436)))) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 1 (One.toOfNat1.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.445))) (OfNat.ofNat.{u_1} M₀ 1 (One.toOfNat1.{u_1} M₀ (MulOneClass.toOne.{u_1} M₀ (MulZeroOneClass.toMulOneClass.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.436))))) -> (forall (a : M₀') (b : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.439) a b)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.436))) (f a) (f b))) -> (MulZeroOneClass.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.injective.mul_zero_one_class Function.Injective.mulZeroOneClassₓ'. -/
/-- Pullback a `mul_zero_one_class` instance along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.mulZeroOneClass [Mul M₀'] [Zero M₀'] [One M₀'] (f : M₀' → M₀)
    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ∀ a b, f (a * b) = f a * f b) :
    MulZeroOneClass M₀' :=
  { hf.MulZeroClass f zero mul, hf.MulOneClass f one mul with }
#align function.injective.mul_zero_one_class Function.Injective.mulZeroOneClass

/- warning: function.surjective.mul_zero_one_class -> Function.Surjective.mulZeroOneClass is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : MulZeroOneClass.{u_1} M₀] [_inst_2 : Mul.{u_3} M₀'] [_inst_3 : Zero.{u_3} M₀'] [_inst_4 : One.{u_3} M₀'] (f : M₀ -> M₀'), (Function.Surjective.{succ u_1, succ u_3} M₀ M₀' f) -> (Eq.{succ u_3} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ _inst_1)))))) (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_3)))) -> (Eq.{succ u_3} M₀' (f (OfNat.ofNat.{u_1} M₀ 1 (OfNat.mk.{u_1} M₀ 1 (One.one.{u_1} M₀ (MulOneClass.toHasOne.{u_1} M₀ (MulZeroOneClass.toMulOneClass.{u_1} M₀ _inst_1)))))) (OfNat.ofNat.{u_3} M₀' 1 (OfNat.mk.{u_3} M₀' 1 (One.one.{u_3} M₀' _inst_4)))) -> (forall (a : M₀) (b : M₀), Eq.{succ u_3} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ _inst_1))) a b)) (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_2) (f a) (f b))) -> (MulZeroOneClass.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.524 : MulZeroOneClass.{u_1} M₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.527 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.530 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.533 : One.{u_2} M₀'] (f : M₀ -> M₀'), (Function.Surjective.{succ u_1, succ u_2} M₀ M₀' f) -> (Eq.{succ u_2} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (MulZeroOneClass.toZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.524)))) (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.530))) -> (Eq.{succ u_2} M₀' (f (OfNat.ofNat.{u_1} M₀ 1 (One.toOfNat1.{u_1} M₀ (MulOneClass.toOne.{u_1} M₀ (MulZeroOneClass.toMulOneClass.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.524))))) (OfNat.ofNat.{u_2} M₀' 1 (One.toOfNat1.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.533))) -> (forall (a : M₀) (b : M₀), Eq.{succ u_2} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.524))) a b)) (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.527) (f a) (f b))) -> (MulZeroOneClass.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.surjective.mul_zero_one_class Function.Surjective.mulZeroOneClassₓ'. -/
/-- Pushforward a `mul_zero_one_class` instance along an surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.mulZeroOneClass [Mul M₀'] [Zero M₀'] [One M₀'] (f : M₀ → M₀')
    (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : ∀ a b, f (a * b) = f a * f b) :
    MulZeroOneClass M₀' :=
  { hf.MulZeroClass f zero mul, hf.MulOneClass f one mul with }
#align function.surjective.mul_zero_one_class Function.Surjective.mulZeroOneClass

end MulZeroOneClass

section SemigroupWithZero

/- warning: function.injective.semigroup_with_zero -> Function.Injective.semigroupWithZero is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : Zero.{u_3} M₀'] [_inst_2 : Mul.{u_3} M₀'] [_inst_3 : SemigroupWithZero.{u_1} M₀] (f : M₀' -> M₀), (Function.Injective.{succ u_3, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_1)))) (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ (SemigroupWithZero.toMulZeroClass.{u_1} M₀ _inst_3)))))) -> (forall (x : M₀') (y : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_2) x y)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ (SemigroupWithZero.toMulZeroClass.{u_1} M₀ _inst_3))) (f x) (f y))) -> (SemigroupWithZero.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.614 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.617 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.620 : SemigroupWithZero.{u_1} M₀] (f : M₀' -> M₀), (Function.Injective.{succ u_2, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.614))) (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (SemigroupWithZero.toZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.620)))) -> (forall (x : M₀') (y : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.617) x y)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ (SemigroupWithZero.toMulZeroClass.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.620))) (f x) (f y))) -> (SemigroupWithZero.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.injective.semigroup_with_zero Function.Injective.semigroupWithZeroₓ'. -/
/-- Pullback a `semigroup_with_zero` class along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.semigroupWithZero [Zero M₀'] [Mul M₀'] [SemigroupWithZero M₀]
    (f : M₀' → M₀) (hf : Injective f) (zero : f 0 = 0) (mul : ∀ x y, f (x * y) = f x * f y) :
    SemigroupWithZero M₀' :=
  { hf.MulZeroClass f zero mul, ‹Zero M₀'›, hf.Semigroup f mul with }
#align function.injective.semigroup_with_zero Function.Injective.semigroupWithZero

/- warning: function.surjective.semigroup_with_zero -> Function.Surjective.semigroupWithZero is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : SemigroupWithZero.{u_1} M₀] [_inst_2 : Zero.{u_3} M₀'] [_inst_3 : Mul.{u_3} M₀'] (f : M₀ -> M₀'), (Function.Surjective.{succ u_1, succ u_3} M₀ M₀' f) -> (Eq.{succ u_3} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ (SemigroupWithZero.toMulZeroClass.{u_1} M₀ _inst_1)))))) (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_2)))) -> (forall (x : M₀) (y : M₀), Eq.{succ u_3} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ (SemigroupWithZero.toMulZeroClass.{u_1} M₀ _inst_1))) x y)) (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_3) (f x) (f y))) -> (SemigroupWithZero.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.703 : SemigroupWithZero.{u_1} M₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.706 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.709 : Mul.{u_2} M₀'] (f : M₀ -> M₀'), (Function.Surjective.{succ u_1, succ u_2} M₀ M₀' f) -> (Eq.{succ u_2} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (SemigroupWithZero.toZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.703)))) (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.706))) -> (forall (x : M₀) (y : M₀), Eq.{succ u_2} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ (SemigroupWithZero.toMulZeroClass.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.703))) x y)) (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.709) (f x) (f y))) -> (SemigroupWithZero.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.surjective.semigroup_with_zero Function.Surjective.semigroupWithZeroₓ'. -/
/-- Pushforward a `semigroup_with_zero` class along an surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.semigroupWithZero [SemigroupWithZero M₀] [Zero M₀'] [Mul M₀']
    (f : M₀ → M₀') (hf : Surjective f) (zero : f 0 = 0) (mul : ∀ x y, f (x * y) = f x * f y) :
    SemigroupWithZero M₀' :=
  { hf.MulZeroClass f zero mul, ‹Zero M₀'›, hf.Semigroup f mul with }
#align function.surjective.semigroup_with_zero Function.Surjective.semigroupWithZero

end SemigroupWithZero

section MonoidWithZero

/- warning: function.injective.monoid_with_zero -> Function.Injective.monoidWithZero is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : Zero.{u_3} M₀'] [_inst_2 : Mul.{u_3} M₀'] [_inst_3 : One.{u_3} M₀'] [_inst_4 : Pow.{u_3, 0} M₀' Nat] [_inst_5 : MonoidWithZero.{u_1} M₀] (f : M₀' -> M₀), (Function.Injective.{succ u_3, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_1)))) (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ _inst_5))))))) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 1 (OfNat.mk.{u_3} M₀' 1 (One.one.{u_3} M₀' _inst_3)))) (OfNat.ofNat.{u_1} M₀ 1 (OfNat.mk.{u_1} M₀ 1 (One.one.{u_1} M₀ (MulOneClass.toHasOne.{u_1} M₀ (MulZeroOneClass.toMulOneClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ _inst_5))))))) -> (forall (x : M₀') (y : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_2) x y)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ _inst_5)))) (f x) (f y))) -> (forall (x : M₀') (n : Nat), Eq.{succ u_1} M₀ (f (HPow.hPow.{u_3, 0, u_3} M₀' Nat M₀' (instHPow.{u_3, 0} M₀' Nat _inst_4) x n)) (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.hasPow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ _inst_5))) (f x) n)) -> (MonoidWithZero.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.794 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.797 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.800 : One.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.803 : Pow.{u_2, 0} M₀' Nat] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.809 : MonoidWithZero.{u_1} M₀] (f : M₀' -> M₀), (Function.Injective.{succ u_2, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.794))) (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (MonoidWithZero.toZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.809)))) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 1 (One.toOfNat1.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.800))) (OfNat.ofNat.{u_1} M₀ 1 (One.toOfNat1.{u_1} M₀ (Monoid.toOne.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.809))))) -> (forall (x : M₀') (y : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.797) x y)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.809)))) (f x) (f y))) -> (forall (x : M₀') (n : Nat), Eq.{succ u_1} M₀ (f (HPow.hPow.{u_2, 0, u_2} M₀' Nat M₀' (instHPow.{u_2, 0} M₀' Nat inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.803) x n)) (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.Pow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.809))) (f x) n)) -> (MonoidWithZero.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.injective.monoid_with_zero Function.Injective.monoidWithZeroₓ'. -/
/-- Pullback a `monoid_with_zero` class along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.monoidWithZero [Zero M₀'] [Mul M₀'] [One M₀'] [Pow M₀' ℕ]
    [MonoidWithZero M₀] (f : M₀' → M₀) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)
    (mul : ∀ x y, f (x * y) = f x * f y) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) :
    MonoidWithZero M₀' :=
  { hf.Monoid f one mul npow, hf.MulZeroClass f zero mul with }
#align function.injective.monoid_with_zero Function.Injective.monoidWithZero

/- warning: function.surjective.monoid_with_zero -> Function.Surjective.monoidWithZero is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : Zero.{u_3} M₀'] [_inst_2 : Mul.{u_3} M₀'] [_inst_3 : One.{u_3} M₀'] [_inst_4 : Pow.{u_3, 0} M₀' Nat] [_inst_5 : MonoidWithZero.{u_1} M₀] (f : M₀ -> M₀'), (Function.Surjective.{succ u_1, succ u_3} M₀ M₀' f) -> (Eq.{succ u_3} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ _inst_5))))))) (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_1)))) -> (Eq.{succ u_3} M₀' (f (OfNat.ofNat.{u_1} M₀ 1 (OfNat.mk.{u_1} M₀ 1 (One.one.{u_1} M₀ (MulOneClass.toHasOne.{u_1} M₀ (MulZeroOneClass.toMulOneClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ _inst_5))))))) (OfNat.ofNat.{u_3} M₀' 1 (OfNat.mk.{u_3} M₀' 1 (One.one.{u_3} M₀' _inst_3)))) -> (forall (x : M₀) (y : M₀), Eq.{succ u_3} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ _inst_5)))) x y)) (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_2) (f x) (f y))) -> (forall (x : M₀) (n : Nat), Eq.{succ u_3} M₀' (f (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.hasPow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ _inst_5))) x n)) (HPow.hPow.{u_3, 0, u_3} M₀' Nat M₀' (instHPow.{u_3, 0} M₀' Nat _inst_4) (f x) n)) -> (MonoidWithZero.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.913 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.916 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.919 : One.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.922 : Pow.{u_2, 0} M₀' Nat] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.928 : MonoidWithZero.{u_1} M₀] (f : M₀ -> M₀'), (Function.Surjective.{succ u_1, succ u_2} M₀ M₀' f) -> (Eq.{succ u_2} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (MonoidWithZero.toZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.928)))) (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.913))) -> (Eq.{succ u_2} M₀' (f (OfNat.ofNat.{u_1} M₀ 1 (One.toOfNat1.{u_1} M₀ (Monoid.toOne.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.928))))) (OfNat.ofNat.{u_2} M₀' 1 (One.toOfNat1.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.919))) -> (forall (x : M₀) (y : M₀), Eq.{succ u_2} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.928)))) x y)) (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.916) (f x) (f y))) -> (forall (x : M₀) (n : Nat), Eq.{succ u_2} M₀' (f (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.Pow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.928))) x n)) (HPow.hPow.{u_2, 0, u_2} M₀' Nat M₀' (instHPow.{u_2, 0} M₀' Nat inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.922) (f x) n)) -> (MonoidWithZero.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.surjective.monoid_with_zero Function.Surjective.monoidWithZeroₓ'. -/
/-- Pushforward a `monoid_with_zero` class along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.monoidWithZero [Zero M₀'] [Mul M₀'] [One M₀'] [Pow M₀' ℕ]
    [MonoidWithZero M₀] (f : M₀ → M₀') (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1)
    (mul : ∀ x y, f (x * y) = f x * f y) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) :
    MonoidWithZero M₀' :=
  { hf.Monoid f one mul npow, hf.MulZeroClass f zero mul with }
#align function.surjective.monoid_with_zero Function.Surjective.monoidWithZero

/- warning: function.injective.comm_monoid_with_zero -> Function.Injective.commMonoidWithZero is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : Zero.{u_3} M₀'] [_inst_2 : Mul.{u_3} M₀'] [_inst_3 : One.{u_3} M₀'] [_inst_4 : Pow.{u_3, 0} M₀' Nat] [_inst_5 : CommMonoidWithZero.{u_1} M₀] (f : M₀' -> M₀), (Function.Injective.{succ u_3, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_1)))) (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_5)))))))) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 1 (OfNat.mk.{u_3} M₀' 1 (One.one.{u_3} M₀' _inst_3)))) (OfNat.ofNat.{u_1} M₀ 1 (OfNat.mk.{u_1} M₀ 1 (One.one.{u_1} M₀ (MulOneClass.toHasOne.{u_1} M₀ (MulZeroOneClass.toMulOneClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_5)))))))) -> (forall (x : M₀') (y : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_2) x y)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_5))))) (f x) (f y))) -> (forall (x : M₀') (n : Nat), Eq.{succ u_1} M₀ (f (HPow.hPow.{u_3, 0, u_3} M₀' Nat M₀' (instHPow.{u_3, 0} M₀' Nat _inst_4) x n)) (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.hasPow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_5)))) (f x) n)) -> (CommMonoidWithZero.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1032 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1035 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1038 : One.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1041 : Pow.{u_2, 0} M₀' Nat] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1047 : CommMonoidWithZero.{u_1} M₀] (f : M₀' -> M₀), (Function.Injective.{succ u_2, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1032))) (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (CommMonoidWithZero.toZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1047)))) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 1 (One.toOfNat1.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1038))) (OfNat.ofNat.{u_1} M₀ 1 (One.toOfNat1.{u_1} M₀ (Monoid.toOne.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1047)))))) -> (forall (x : M₀') (y : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1035) x y)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1047))))) (f x) (f y))) -> (forall (x : M₀') (n : Nat), Eq.{succ u_1} M₀ (f (HPow.hPow.{u_2, 0, u_2} M₀' Nat M₀' (instHPow.{u_2, 0} M₀' Nat inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1041) x n)) (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.Pow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1047)))) (f x) n)) -> (CommMonoidWithZero.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.injective.comm_monoid_with_zero Function.Injective.commMonoidWithZeroₓ'. -/
/-- Pullback a `monoid_with_zero` class along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.commMonoidWithZero [Zero M₀'] [Mul M₀'] [One M₀'] [Pow M₀' ℕ]
    [CommMonoidWithZero M₀] (f : M₀' → M₀) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)
    (mul : ∀ x y, f (x * y) = f x * f y) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) :
    CommMonoidWithZero M₀' :=
  { hf.CommMonoid f one mul npow, hf.MulZeroClass f zero mul with }
#align function.injective.comm_monoid_with_zero Function.Injective.commMonoidWithZero

/- warning: function.surjective.comm_monoid_with_zero -> Function.Surjective.commMonoidWithZero is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : Zero.{u_3} M₀'] [_inst_2 : Mul.{u_3} M₀'] [_inst_3 : One.{u_3} M₀'] [_inst_4 : Pow.{u_3, 0} M₀' Nat] [_inst_5 : CommMonoidWithZero.{u_1} M₀] (f : M₀ -> M₀'), (Function.Surjective.{succ u_1, succ u_3} M₀ M₀' f) -> (Eq.{succ u_3} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_5)))))))) (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_1)))) -> (Eq.{succ u_3} M₀' (f (OfNat.ofNat.{u_1} M₀ 1 (OfNat.mk.{u_1} M₀ 1 (One.one.{u_1} M₀ (MulOneClass.toHasOne.{u_1} M₀ (MulZeroOneClass.toMulOneClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_5)))))))) (OfNat.ofNat.{u_3} M₀' 1 (OfNat.mk.{u_3} M₀' 1 (One.one.{u_3} M₀' _inst_3)))) -> (forall (x : M₀) (y : M₀), Eq.{succ u_3} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_5))))) x y)) (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_2) (f x) (f y))) -> (forall (x : M₀) (n : Nat), Eq.{succ u_3} M₀' (f (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.hasPow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_5)))) x n)) (HPow.hPow.{u_3, 0, u_3} M₀' Nat M₀' (instHPow.{u_3, 0} M₀' Nat _inst_4) (f x) n)) -> (CommMonoidWithZero.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1146 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1149 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1152 : One.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1155 : Pow.{u_2, 0} M₀' Nat] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1161 : CommMonoidWithZero.{u_1} M₀] (f : M₀ -> M₀'), (Function.Surjective.{succ u_1, succ u_2} M₀ M₀' f) -> (Eq.{succ u_2} M₀' (f (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (CommMonoidWithZero.toZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1161)))) (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1146))) -> (Eq.{succ u_2} M₀' (f (OfNat.ofNat.{u_1} M₀ 1 (One.toOfNat1.{u_1} M₀ (Monoid.toOne.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1161)))))) (OfNat.ofNat.{u_2} M₀' 1 (One.toOfNat1.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1152))) -> (forall (x : M₀) (y : M₀), Eq.{succ u_2} M₀' (f (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1161))))) x y)) (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1149) (f x) (f y))) -> (forall (x : M₀) (n : Nat), Eq.{succ u_2} M₀' (f (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.Pow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1161)))) x n)) (HPow.hPow.{u_2, 0, u_2} M₀' Nat M₀' (instHPow.{u_2, 0} M₀' Nat inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1155) (f x) n)) -> (CommMonoidWithZero.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.surjective.comm_monoid_with_zero Function.Surjective.commMonoidWithZeroₓ'. -/
/-- Pushforward a `monoid_with_zero` class along a surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.commMonoidWithZero [Zero M₀'] [Mul M₀'] [One M₀'] [Pow M₀' ℕ]
    [CommMonoidWithZero M₀] (f : M₀ → M₀') (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1)
    (mul : ∀ x y, f (x * y) = f x * f y) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) :
    CommMonoidWithZero M₀' :=
  { hf.CommMonoid f one mul npow, hf.MulZeroClass f zero mul with }
#align function.surjective.comm_monoid_with_zero Function.Surjective.commMonoidWithZero

end MonoidWithZero

section CancelMonoidWithZero

variable [CancelMonoidWithZero M₀] {a b c : M₀}

/- warning: function.injective.cancel_monoid_with_zero -> Function.Injective.cancelMonoidWithZero is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : CancelMonoidWithZero.{u_1} M₀] [_inst_2 : Zero.{u_3} M₀'] [_inst_3 : Mul.{u_3} M₀'] [_inst_4 : One.{u_3} M₀'] [_inst_5 : Pow.{u_3, 0} M₀' Nat] (f : M₀' -> M₀), (Function.Injective.{succ u_3, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_2)))) (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CancelMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_1)))))))) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 1 (OfNat.mk.{u_3} M₀' 1 (One.one.{u_3} M₀' _inst_4)))) (OfNat.ofNat.{u_1} M₀ 1 (OfNat.mk.{u_1} M₀ 1 (One.one.{u_1} M₀ (MulOneClass.toHasOne.{u_1} M₀ (MulZeroOneClass.toMulOneClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CancelMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_1)))))))) -> (forall (x : M₀') (y : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_3) x y)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CancelMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_1))))) (f x) (f y))) -> (forall (x : M₀') (n : Nat), Eq.{succ u_1} M₀ (f (HPow.hPow.{u_3, 0, u_3} M₀' Nat M₀' (instHPow.{u_3, 0} M₀' Nat _inst_5) x n)) (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.hasPow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CancelMonoidWithZero.toMonoidWithZero.{u_1} M₀ _inst_1)))) (f x) n)) -> (CancelMonoidWithZero.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1277 : CancelMonoidWithZero.{u_1} M₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1283 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1286 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1289 : One.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1292 : Pow.{u_2, 0} M₀' Nat] (f : M₀' -> M₀), (Function.Injective.{succ u_2, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1283))) (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (MonoidWithZero.toZero.{u_1} M₀ (CancelMonoidWithZero.toMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1277))))) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 1 (One.toOfNat1.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1289))) (OfNat.ofNat.{u_1} M₀ 1 (One.toOfNat1.{u_1} M₀ (Monoid.toOne.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CancelMonoidWithZero.toMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1277)))))) -> (forall (x : M₀') (y : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1286) x y)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CancelMonoidWithZero.toMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1277))))) (f x) (f y))) -> (forall (x : M₀') (n : Nat), Eq.{succ u_1} M₀ (f (HPow.hPow.{u_2, 0, u_2} M₀' Nat M₀' (instHPow.{u_2, 0} M₀' Nat inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1292) x n)) (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.Pow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CancelMonoidWithZero.toMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1277)))) (f x) n)) -> (CancelMonoidWithZero.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.injective.cancel_monoid_with_zero Function.Injective.cancelMonoidWithZeroₓ'. -/
/-- Pullback a `monoid_with_zero` class along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.cancelMonoidWithZero [Zero M₀'] [Mul M₀'] [One M₀'] [Pow M₀' ℕ]
    (f : M₀' → M₀) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)
    (mul : ∀ x y, f (x * y) = f x * f y) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) :
    CancelMonoidWithZero M₀' :=
  { hf.Monoid f one mul npow, hf.MulZeroClass f zero mul with
    mul_left_cancel_of_ne_zero := fun x y z hx H =>
      hf <| mul_left_cancel₀ ((hf.ne_iff' zero).2 hx) <| by erw [← mul, ← mul, H] <;> rfl,
    mul_right_cancel_of_ne_zero := fun x y z hx H =>
      hf <| mul_right_cancel₀ ((hf.ne_iff' zero).2 hx) <| by erw [← mul, ← mul, H] <;> rfl }
#align function.injective.cancel_monoid_with_zero Function.Injective.cancelMonoidWithZero

end CancelMonoidWithZero

section CancelCommMonoidWithZero

variable [CancelCommMonoidWithZero M₀] {a b c : M₀}

/- warning: function.injective.cancel_comm_monoid_with_zero -> Function.Injective.cancelCommMonoidWithZero is a dubious translation:
lean 3 declaration is
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_3}} [_inst_1 : CancelCommMonoidWithZero.{u_1} M₀] [_inst_2 : Zero.{u_3} M₀'] [_inst_3 : Mul.{u_3} M₀'] [_inst_4 : One.{u_3} M₀'] [_inst_5 : Pow.{u_3, 0} M₀' Nat] (f : M₀' -> M₀), (Function.Injective.{succ u_3, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 0 (OfNat.mk.{u_3} M₀' 0 (Zero.zero.{u_3} M₀' _inst_2)))) (OfNat.ofNat.{u_1} M₀ 0 (OfNat.mk.{u_1} M₀ 0 (Zero.zero.{u_1} M₀ (MulZeroClass.toHasZero.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ (CancelCommMonoidWithZero.toCommMonoidWithZero.{u_1} M₀ _inst_1))))))))) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_3} M₀' 1 (OfNat.mk.{u_3} M₀' 1 (One.one.{u_3} M₀' _inst_4)))) (OfNat.ofNat.{u_1} M₀ 1 (OfNat.mk.{u_1} M₀ 1 (One.one.{u_1} M₀ (MulOneClass.toHasOne.{u_1} M₀ (MulZeroOneClass.toMulOneClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ (CancelCommMonoidWithZero.toCommMonoidWithZero.{u_1} M₀ _inst_1))))))))) -> (forall (x : M₀') (y : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_3, u_3, u_3} M₀' M₀' M₀' (instHMul.{u_3} M₀' _inst_3) x y)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toHasMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ (CancelCommMonoidWithZero.toCommMonoidWithZero.{u_1} M₀ _inst_1)))))) (f x) (f y))) -> (forall (x : M₀') (n : Nat), Eq.{succ u_1} M₀ (f (HPow.hPow.{u_3, 0, u_3} M₀' Nat M₀' (instHPow.{u_3, 0} M₀' Nat _inst_5) x n)) (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.hasPow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ (CancelCommMonoidWithZero.toCommMonoidWithZero.{u_1} M₀ _inst_1))))) (f x) n)) -> (CancelCommMonoidWithZero.{u_3} M₀')
but is expected to have type
  forall {M₀ : Type.{u_1}} {M₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1536 : CancelCommMonoidWithZero.{u_1} M₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1542 : Zero.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1545 : Mul.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1548 : One.{u_2} M₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1551 : Pow.{u_2, 0} M₀' Nat] (f : M₀' -> M₀), (Function.Injective.{succ u_2, succ u_1} M₀' M₀ f) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 0 (Zero.toOfNat0.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1542))) (OfNat.ofNat.{u_1} M₀ 0 (Zero.toOfNat0.{u_1} M₀ (CommMonoidWithZero.toZero.{u_1} M₀ (CancelCommMonoidWithZero.toCommMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1536))))) -> (Eq.{succ u_1} M₀ (f (OfNat.ofNat.{u_2} M₀' 1 (One.toOfNat1.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1548))) (OfNat.ofNat.{u_1} M₀ 1 (One.toOfNat1.{u_1} M₀ (Monoid.toOne.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ (CancelCommMonoidWithZero.toCommMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1536))))))) -> (forall (x : M₀') (y : M₀'), Eq.{succ u_1} M₀ (f (HMul.hMul.{u_2, u_2, u_2} M₀' M₀' M₀' (instHMul.{u_2} M₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1545) x y)) (HMul.hMul.{u_1, u_1, u_1} M₀ M₀ M₀ (instHMul.{u_1} M₀ (MulZeroClass.toMul.{u_1} M₀ (MulZeroOneClass.toMulZeroClass.{u_1} M₀ (MonoidWithZero.toMulZeroOneClass.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ (CancelCommMonoidWithZero.toCommMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1536)))))) (f x) (f y))) -> (forall (x : M₀') (n : Nat), Eq.{succ u_1} M₀ (f (HPow.hPow.{u_2, 0, u_2} M₀' Nat M₀' (instHPow.{u_2, 0} M₀' Nat inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1551) x n)) (HPow.hPow.{u_1, 0, u_1} M₀ Nat M₀ (instHPow.{u_1, 0} M₀ Nat (Monoid.Pow.{u_1} M₀ (MonoidWithZero.toMonoid.{u_1} M₀ (CommMonoidWithZero.toMonoidWithZero.{u_1} M₀ (CancelCommMonoidWithZero.toCommMonoidWithZero.{u_1} M₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1536))))) (f x) n)) -> (CancelCommMonoidWithZero.{u_2} M₀')
Case conversion may be inaccurate. Consider using '#align function.injective.cancel_comm_monoid_with_zero Function.Injective.cancelCommMonoidWithZeroₓ'. -/
/-- Pullback a `cancel_comm_monoid_with_zero` class along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.cancelCommMonoidWithZero [Zero M₀'] [Mul M₀'] [One M₀'] [Pow M₀' ℕ]
    (f : M₀' → M₀) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)
    (mul : ∀ x y, f (x * y) = f x * f y) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) :
    CancelCommMonoidWithZero M₀' :=
  { hf.CommMonoidWithZero f zero one mul npow, hf.CancelMonoidWithZero f zero one mul npow with }
#align function.injective.cancel_comm_monoid_with_zero Function.Injective.cancelCommMonoidWithZero

end CancelCommMonoidWithZero

section GroupWithZero

variable [GroupWithZero G₀] {a b c g h x : G₀}

/- warning: function.injective.group_with_zero -> Function.Injective.groupWithZero is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u_2}} {G₀' : Type.{u_4}} [_inst_1 : GroupWithZero.{u_2} G₀] [_inst_2 : Zero.{u_4} G₀'] [_inst_3 : Mul.{u_4} G₀'] [_inst_4 : One.{u_4} G₀'] [_inst_5 : Inv.{u_4} G₀'] [_inst_6 : Div.{u_4} G₀'] [_inst_7 : Pow.{u_4, 0} G₀' Nat] [_inst_8 : Pow.{u_4, 0} G₀' Int] (f : G₀' -> G₀), (Function.Injective.{succ u_4, succ u_2} G₀' G₀ f) -> (Eq.{succ u_2} G₀ (f (OfNat.ofNat.{u_4} G₀' 0 (OfNat.mk.{u_4} G₀' 0 (Zero.zero.{u_4} G₀' _inst_2)))) (OfNat.ofNat.{u_2} G₀ 0 (OfNat.mk.{u_2} G₀ 0 (Zero.zero.{u_2} G₀ (MulZeroClass.toHasZero.{u_2} G₀ (MulZeroOneClass.toMulZeroClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ _inst_1)))))))) -> (Eq.{succ u_2} G₀ (f (OfNat.ofNat.{u_4} G₀' 1 (OfNat.mk.{u_4} G₀' 1 (One.one.{u_4} G₀' _inst_4)))) (OfNat.ofNat.{u_2} G₀ 1 (OfNat.mk.{u_2} G₀ 1 (One.one.{u_2} G₀ (MulOneClass.toHasOne.{u_2} G₀ (MulZeroOneClass.toMulOneClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ _inst_1)))))))) -> (forall (x : G₀') (y : G₀'), Eq.{succ u_2} G₀ (f (HMul.hMul.{u_4, u_4, u_4} G₀' G₀' G₀' (instHMul.{u_4} G₀' _inst_3) x y)) (HMul.hMul.{u_2, u_2, u_2} G₀ G₀ G₀ (instHMul.{u_2} G₀ (MulZeroClass.toHasMul.{u_2} G₀ (MulZeroOneClass.toMulZeroClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ _inst_1))))) (f x) (f y))) -> (forall (x : G₀'), Eq.{succ u_2} G₀ (f (Inv.inv.{u_4} G₀' _inst_5 x)) (Inv.inv.{u_2} G₀ (DivInvMonoid.toHasInv.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ _inst_1)) (f x))) -> (forall (x : G₀') (y : G₀'), Eq.{succ u_2} G₀ (f (HDiv.hDiv.{u_4, u_4, u_4} G₀' G₀' G₀' (instHDiv.{u_4} G₀' _inst_6) x y)) (HDiv.hDiv.{u_2, u_2, u_2} G₀ G₀ G₀ (instHDiv.{u_2} G₀ (DivInvMonoid.toHasDiv.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ _inst_1))) (f x) (f y))) -> (forall (x : G₀') (n : Nat), Eq.{succ u_2} G₀ (f (HPow.hPow.{u_4, 0, u_4} G₀' Nat G₀' (instHPow.{u_4, 0} G₀' Nat _inst_7) x n)) (HPow.hPow.{u_2, 0, u_2} G₀ Nat G₀ (instHPow.{u_2, 0} G₀ Nat (Monoid.hasPow.{u_2} G₀ (MonoidWithZero.toMonoid.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ _inst_1)))) (f x) n)) -> (forall (x : G₀') (n : Int), Eq.{succ u_2} G₀ (f (HPow.hPow.{u_4, 0, u_4} G₀' Int G₀' (instHPow.{u_4, 0} G₀' Int _inst_8) x n)) (HPow.hPow.{u_2, 0, u_2} G₀ Int G₀ (instHPow.{u_2, 0} G₀ Int (DivInvMonoid.hasPow.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ _inst_1))) (f x) n)) -> (GroupWithZero.{u_4} G₀')
but is expected to have type
  forall {G₀ : Type.{u_1}} {G₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1686 : GroupWithZero.{u_1} G₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1695 : Zero.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1698 : Mul.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1701 : One.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1704 : Inv.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1707 : Div.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1710 : Pow.{u_2, 0} G₀' Nat] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1716 : Pow.{u_2, 0} G₀' Int] (f : G₀' -> G₀), (Function.Injective.{succ u_2, succ u_1} G₀' G₀ f) -> (Eq.{succ u_1} G₀ (f (OfNat.ofNat.{u_2} G₀' 0 (Zero.toOfNat0.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1695))) (OfNat.ofNat.{u_1} G₀ 0 (Zero.toOfNat0.{u_1} G₀ (MonoidWithZero.toZero.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1686))))) -> (Eq.{succ u_1} G₀ (f (OfNat.ofNat.{u_2} G₀' 1 (One.toOfNat1.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1701))) (OfNat.ofNat.{u_1} G₀ 1 (One.toOfNat1.{u_1} G₀ (Monoid.toOne.{u_1} G₀ (MonoidWithZero.toMonoid.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1686)))))) -> (forall (x : G₀') (y : G₀'), Eq.{succ u_1} G₀ (f (HMul.hMul.{u_2, u_2, u_2} G₀' G₀' G₀' (instHMul.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1698) x y)) (HMul.hMul.{u_1, u_1, u_1} G₀ G₀ G₀ (instHMul.{u_1} G₀ (MulZeroClass.toMul.{u_1} G₀ (MulZeroOneClass.toMulZeroClass.{u_1} G₀ (MonoidWithZero.toMulZeroOneClass.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1686))))) (f x) (f y))) -> (forall (x : G₀'), Eq.{succ u_1} G₀ (f (Inv.inv.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1704 x)) (Inv.inv.{u_1} G₀ (GroupWithZero.toInv.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1686) (f x))) -> (forall (x : G₀') (y : G₀'), Eq.{succ u_1} G₀ (f (HDiv.hDiv.{u_2, u_2, u_2} G₀' G₀' G₀' (instHDiv.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1707) x y)) (HDiv.hDiv.{u_1, u_1, u_1} G₀ G₀ G₀ (instHDiv.{u_1} G₀ (GroupWithZero.toDiv.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1686)) (f x) (f y))) -> (forall (x : G₀') (n : Nat), Eq.{succ u_1} G₀ (f (HPow.hPow.{u_2, 0, u_2} G₀' Nat G₀' (instHPow.{u_2, 0} G₀' Nat inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1710) x n)) (HPow.hPow.{u_1, 0, u_1} G₀ Nat G₀ (instHPow.{u_1, 0} G₀ Nat (Monoid.Pow.{u_1} G₀ (MonoidWithZero.toMonoid.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1686)))) (f x) n)) -> (forall (x : G₀') (n : Int), Eq.{succ u_1} G₀ (f (HPow.hPow.{u_2, 0, u_2} G₀' Int G₀' (instHPow.{u_2, 0} G₀' Int inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1716) x n)) (HPow.hPow.{u_1, 0, u_1} G₀ Int G₀ (instHPow.{u_1, 0} G₀ Int (DivInvMonoid.Pow.{u_1} G₀ (GroupWithZero.toDivInvMonoid.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1686))) (f x) n)) -> (GroupWithZero.{u_2} G₀')
Case conversion may be inaccurate. Consider using '#align function.injective.group_with_zero Function.Injective.groupWithZeroₓ'. -/
/-- Pullback a `group_with_zero` class along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.groupWithZero [Zero G₀'] [Mul G₀'] [One G₀'] [Inv G₀'] [Div G₀']
    [Pow G₀' ℕ] [Pow G₀' ℤ] (f : G₀' → G₀) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)
    (mul : ∀ x y, f (x * y) = f x * f y) (inv : ∀ x, f x⁻¹ = (f x)⁻¹)
    (div : ∀ x y, f (x / y) = f x / f y) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (zpow : ∀ (x) (n : ℤ), f (x ^ n) = f x ^ n) : GroupWithZero G₀' :=
  { hf.MonoidWithZero f zero one mul npow, hf.DivInvMonoid f one mul inv div npow zpow,
    pullback_nonzero f zero one with inv_zero := hf <| by erw [inv, zero, inv_zero],
    mul_inv_cancel := fun x hx =>
      hf <| by erw [one, mul, inv, mul_inv_cancel ((hf.ne_iff' zero).2 hx)] }
#align function.injective.group_with_zero Function.Injective.groupWithZero

/- warning: function.surjective.group_with_zero -> Function.Surjective.groupWithZero is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u_2}} {G₀' : Type.{u_4}} [_inst_1 : GroupWithZero.{u_2} G₀] [_inst_2 : Zero.{u_4} G₀'] [_inst_3 : Mul.{u_4} G₀'] [_inst_4 : One.{u_4} G₀'] [_inst_5 : Inv.{u_4} G₀'] [_inst_6 : Div.{u_4} G₀'] [_inst_7 : Pow.{u_4, 0} G₀' Nat] [_inst_8 : Pow.{u_4, 0} G₀' Int], (Ne.{succ u_4} G₀' (OfNat.ofNat.{u_4} G₀' 0 (OfNat.mk.{u_4} G₀' 0 (Zero.zero.{u_4} G₀' _inst_2))) (OfNat.ofNat.{u_4} G₀' 1 (OfNat.mk.{u_4} G₀' 1 (One.one.{u_4} G₀' _inst_4)))) -> (forall (f : G₀ -> G₀'), (Function.Surjective.{succ u_2, succ u_4} G₀ G₀' f) -> (Eq.{succ u_4} G₀' (f (OfNat.ofNat.{u_2} G₀ 0 (OfNat.mk.{u_2} G₀ 0 (Zero.zero.{u_2} G₀ (MulZeroClass.toHasZero.{u_2} G₀ (MulZeroOneClass.toMulZeroClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ _inst_1)))))))) (OfNat.ofNat.{u_4} G₀' 0 (OfNat.mk.{u_4} G₀' 0 (Zero.zero.{u_4} G₀' _inst_2)))) -> (Eq.{succ u_4} G₀' (f (OfNat.ofNat.{u_2} G₀ 1 (OfNat.mk.{u_2} G₀ 1 (One.one.{u_2} G₀ (MulOneClass.toHasOne.{u_2} G₀ (MulZeroOneClass.toMulOneClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ _inst_1)))))))) (OfNat.ofNat.{u_4} G₀' 1 (OfNat.mk.{u_4} G₀' 1 (One.one.{u_4} G₀' _inst_4)))) -> (forall (x : G₀) (y : G₀), Eq.{succ u_4} G₀' (f (HMul.hMul.{u_2, u_2, u_2} G₀ G₀ G₀ (instHMul.{u_2} G₀ (MulZeroClass.toHasMul.{u_2} G₀ (MulZeroOneClass.toMulZeroClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ _inst_1))))) x y)) (HMul.hMul.{u_4, u_4, u_4} G₀' G₀' G₀' (instHMul.{u_4} G₀' _inst_3) (f x) (f y))) -> (forall (x : G₀), Eq.{succ u_4} G₀' (f (Inv.inv.{u_2} G₀ (DivInvMonoid.toHasInv.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ _inst_1)) x)) (Inv.inv.{u_4} G₀' _inst_5 (f x))) -> (forall (x : G₀) (y : G₀), Eq.{succ u_4} G₀' (f (HDiv.hDiv.{u_2, u_2, u_2} G₀ G₀ G₀ (instHDiv.{u_2} G₀ (DivInvMonoid.toHasDiv.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ _inst_1))) x y)) (HDiv.hDiv.{u_4, u_4, u_4} G₀' G₀' G₀' (instHDiv.{u_4} G₀' _inst_6) (f x) (f y))) -> (forall (x : G₀) (n : Nat), Eq.{succ u_4} G₀' (f (HPow.hPow.{u_2, 0, u_2} G₀ Nat G₀ (instHPow.{u_2, 0} G₀ Nat (Monoid.hasPow.{u_2} G₀ (MonoidWithZero.toMonoid.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ _inst_1)))) x n)) (HPow.hPow.{u_4, 0, u_4} G₀' Nat G₀' (instHPow.{u_4, 0} G₀' Nat _inst_7) (f x) n)) -> (forall (x : G₀) (n : Int), Eq.{succ u_4} G₀' (f (HPow.hPow.{u_2, 0, u_2} G₀ Int G₀ (instHPow.{u_2, 0} G₀ Int (DivInvMonoid.hasPow.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ _inst_1))) x n)) (HPow.hPow.{u_4, 0, u_4} G₀' Int G₀' (instHPow.{u_4, 0} G₀' Int _inst_8) (f x) n)) -> (GroupWithZero.{u_4} G₀'))
but is expected to have type
  forall {G₀ : Type.{u_1}} {G₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1994 : GroupWithZero.{u_1} G₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2003 : Zero.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2006 : Mul.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2009 : One.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2012 : Inv.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2015 : Div.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2018 : Pow.{u_2, 0} G₀' Nat] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2024 : Pow.{u_2, 0} G₀' Int], (Ne.{succ u_2} G₀' (OfNat.ofNat.{u_2} G₀' 0 (Zero.toOfNat0.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2003)) (OfNat.ofNat.{u_2} G₀' 1 (One.toOfNat1.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2009))) -> (forall (f : G₀ -> G₀'), (Function.Surjective.{succ u_1, succ u_2} G₀ G₀' f) -> (Eq.{succ u_2} G₀' (f (OfNat.ofNat.{u_1} G₀ 0 (Zero.toOfNat0.{u_1} G₀ (MonoidWithZero.toZero.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1994))))) (OfNat.ofNat.{u_2} G₀' 0 (Zero.toOfNat0.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2003))) -> (Eq.{succ u_2} G₀' (f (OfNat.ofNat.{u_1} G₀ 1 (One.toOfNat1.{u_1} G₀ (Monoid.toOne.{u_1} G₀ (MonoidWithZero.toMonoid.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1994)))))) (OfNat.ofNat.{u_2} G₀' 1 (One.toOfNat1.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2009))) -> (forall (x : G₀) (y : G₀), Eq.{succ u_2} G₀' (f (HMul.hMul.{u_1, u_1, u_1} G₀ G₀ G₀ (instHMul.{u_1} G₀ (MulZeroClass.toMul.{u_1} G₀ (MulZeroOneClass.toMulZeroClass.{u_1} G₀ (MonoidWithZero.toMulZeroOneClass.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1994))))) x y)) (HMul.hMul.{u_2, u_2, u_2} G₀' G₀' G₀' (instHMul.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2006) (f x) (f y))) -> (forall (x : G₀), Eq.{succ u_2} G₀' (f (Inv.inv.{u_1} G₀ (GroupWithZero.toInv.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1994) x)) (Inv.inv.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2012 (f x))) -> (forall (x : G₀) (y : G₀), Eq.{succ u_2} G₀' (f (HDiv.hDiv.{u_1, u_1, u_1} G₀ G₀ G₀ (instHDiv.{u_1} G₀ (GroupWithZero.toDiv.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1994)) x y)) (HDiv.hDiv.{u_2, u_2, u_2} G₀' G₀' G₀' (instHDiv.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2015) (f x) (f y))) -> (forall (x : G₀) (n : Nat), Eq.{succ u_2} G₀' (f (HPow.hPow.{u_1, 0, u_1} G₀ Nat G₀ (instHPow.{u_1, 0} G₀ Nat (Monoid.Pow.{u_1} G₀ (MonoidWithZero.toMonoid.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1994)))) x n)) (HPow.hPow.{u_2, 0, u_2} G₀' Nat G₀' (instHPow.{u_2, 0} G₀' Nat inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2018) (f x) n)) -> (forall (x : G₀) (n : Int), Eq.{succ u_2} G₀' (f (HPow.hPow.{u_1, 0, u_1} G₀ Int G₀ (instHPow.{u_1, 0} G₀ Int (DivInvMonoid.Pow.{u_1} G₀ (GroupWithZero.toDivInvMonoid.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.1994))) x n)) (HPow.hPow.{u_2, 0, u_2} G₀' Int G₀' (instHPow.{u_2, 0} G₀' Int inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2024) (f x) n)) -> (GroupWithZero.{u_2} G₀'))
Case conversion may be inaccurate. Consider using '#align function.surjective.group_with_zero Function.Surjective.groupWithZeroₓ'. -/
/-- Pushforward a `group_with_zero` class along an surjective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Surjective.groupWithZero [Zero G₀'] [Mul G₀'] [One G₀'] [Inv G₀'] [Div G₀']
    [Pow G₀' ℕ] [Pow G₀' ℤ] (h01 : (0 : G₀') ≠ 1) (f : G₀ → G₀') (hf : Surjective f)
    (zero : f 0 = 0) (one : f 1 = 1) (mul : ∀ x y, f (x * y) = f x * f y)
    (inv : ∀ x, f x⁻¹ = (f x)⁻¹) (div : ∀ x y, f (x / y) = f x / f y)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (zpow : ∀ (x) (n : ℤ), f (x ^ n) = f x ^ n) :
    GroupWithZero G₀' :=
  { hf.MonoidWithZero f zero one mul npow, hf.DivInvMonoid f one mul inv div npow zpow with
    inv_zero := by erw [← zero, ← inv, inv_zero],
    mul_inv_cancel :=
      hf.forall.2 fun x hx => by
        erw [← inv, ← mul, mul_inv_cancel (mt (congr_arg f) <| trans_rel_left Ne hx zero.symm)] <;>
          exact one,
    exists_pair_ne := ⟨0, 1, h01⟩ }
#align function.surjective.group_with_zero Function.Surjective.groupWithZero

end GroupWithZero

section CommGroupWithZero

variable [CommGroupWithZero G₀] {a b c d : G₀}

/- warning: function.injective.comm_group_with_zero -> Function.Injective.commGroupWithZero is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u_2}} {G₀' : Type.{u_4}} [_inst_1 : CommGroupWithZero.{u_2} G₀] [_inst_2 : Zero.{u_4} G₀'] [_inst_3 : Mul.{u_4} G₀'] [_inst_4 : One.{u_4} G₀'] [_inst_5 : Inv.{u_4} G₀'] [_inst_6 : Div.{u_4} G₀'] [_inst_7 : Pow.{u_4, 0} G₀' Nat] [_inst_8 : Pow.{u_4, 0} G₀' Int] (f : G₀' -> G₀), (Function.Injective.{succ u_4, succ u_2} G₀' G₀ f) -> (Eq.{succ u_2} G₀ (f (OfNat.ofNat.{u_4} G₀' 0 (OfNat.mk.{u_4} G₀' 0 (Zero.zero.{u_4} G₀' _inst_2)))) (OfNat.ofNat.{u_2} G₀ 0 (OfNat.mk.{u_2} G₀ 0 (Zero.zero.{u_2} G₀ (MulZeroClass.toHasZero.{u_2} G₀ (MulZeroOneClass.toMulZeroClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1))))))))) -> (Eq.{succ u_2} G₀ (f (OfNat.ofNat.{u_4} G₀' 1 (OfNat.mk.{u_4} G₀' 1 (One.one.{u_4} G₀' _inst_4)))) (OfNat.ofNat.{u_2} G₀ 1 (OfNat.mk.{u_2} G₀ 1 (One.one.{u_2} G₀ (MulOneClass.toHasOne.{u_2} G₀ (MulZeroOneClass.toMulOneClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1))))))))) -> (forall (x : G₀') (y : G₀'), Eq.{succ u_2} G₀ (f (HMul.hMul.{u_4, u_4, u_4} G₀' G₀' G₀' (instHMul.{u_4} G₀' _inst_3) x y)) (HMul.hMul.{u_2, u_2, u_2} G₀ G₀ G₀ (instHMul.{u_2} G₀ (MulZeroClass.toHasMul.{u_2} G₀ (MulZeroOneClass.toMulZeroClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1)))))) (f x) (f y))) -> (forall (x : G₀'), Eq.{succ u_2} G₀ (f (Inv.inv.{u_4} G₀' _inst_5 x)) (Inv.inv.{u_2} G₀ (DivInvMonoid.toHasInv.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1))) (f x))) -> (forall (x : G₀') (y : G₀'), Eq.{succ u_2} G₀ (f (HDiv.hDiv.{u_4, u_4, u_4} G₀' G₀' G₀' (instHDiv.{u_4} G₀' _inst_6) x y)) (HDiv.hDiv.{u_2, u_2, u_2} G₀ G₀ G₀ (instHDiv.{u_2} G₀ (DivInvMonoid.toHasDiv.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1)))) (f x) (f y))) -> (forall (x : G₀') (n : Nat), Eq.{succ u_2} G₀ (f (HPow.hPow.{u_4, 0, u_4} G₀' Nat G₀' (instHPow.{u_4, 0} G₀' Nat _inst_7) x n)) (HPow.hPow.{u_2, 0, u_2} G₀ Nat G₀ (instHPow.{u_2, 0} G₀ Nat (Monoid.hasPow.{u_2} G₀ (MonoidWithZero.toMonoid.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1))))) (f x) n)) -> (forall (x : G₀') (n : Int), Eq.{succ u_2} G₀ (f (HPow.hPow.{u_4, 0, u_4} G₀' Int G₀' (instHPow.{u_4, 0} G₀' Int _inst_8) x n)) (HPow.hPow.{u_2, 0, u_2} G₀ Int G₀ (instHPow.{u_2, 0} G₀ Int (DivInvMonoid.hasPow.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1)))) (f x) n)) -> (CommGroupWithZero.{u_4} G₀')
but is expected to have type
  forall {G₀ : Type.{u_1}} {G₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2334 : CommGroupWithZero.{u_1} G₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2341 : Zero.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2344 : Mul.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2347 : One.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2350 : Inv.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2353 : Div.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2356 : Pow.{u_2, 0} G₀' Nat] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2362 : Pow.{u_2, 0} G₀' Int] (f : G₀' -> G₀), (Function.Injective.{succ u_2, succ u_1} G₀' G₀ f) -> (Eq.{succ u_1} G₀ (f (OfNat.ofNat.{u_2} G₀' 0 (Zero.toOfNat0.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2341))) (OfNat.ofNat.{u_1} G₀ 0 (Zero.toOfNat0.{u_1} G₀ (CommMonoidWithZero.toZero.{u_1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2334))))) -> (Eq.{succ u_1} G₀ (f (OfNat.ofNat.{u_2} G₀' 1 (One.toOfNat1.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2347))) (OfNat.ofNat.{u_1} G₀ 1 (One.toOfNat1.{u_1} G₀ (Monoid.toOne.{u_1} G₀ (MonoidWithZero.toMonoid.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ (CommGroupWithZero.toGroupWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2334))))))) -> (forall (x : G₀') (y : G₀'), Eq.{succ u_1} G₀ (f (HMul.hMul.{u_2, u_2, u_2} G₀' G₀' G₀' (instHMul.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2344) x y)) (HMul.hMul.{u_1, u_1, u_1} G₀ G₀ G₀ (instHMul.{u_1} G₀ (MulZeroClass.toMul.{u_1} G₀ (MulZeroOneClass.toMulZeroClass.{u_1} G₀ (MonoidWithZero.toMulZeroOneClass.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ (CommGroupWithZero.toGroupWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2334)))))) (f x) (f y))) -> (forall (x : G₀'), Eq.{succ u_1} G₀ (f (Inv.inv.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2350 x)) (Inv.inv.{u_1} G₀ (CommGroupWithZero.toInv.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2334) (f x))) -> (forall (x : G₀') (y : G₀'), Eq.{succ u_1} G₀ (f (HDiv.hDiv.{u_2, u_2, u_2} G₀' G₀' G₀' (instHDiv.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2353) x y)) (HDiv.hDiv.{u_1, u_1, u_1} G₀ G₀ G₀ (instHDiv.{u_1} G₀ (CommGroupWithZero.toDiv.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2334)) (f x) (f y))) -> (forall (x : G₀') (n : Nat), Eq.{succ u_1} G₀ (f (HPow.hPow.{u_2, 0, u_2} G₀' Nat G₀' (instHPow.{u_2, 0} G₀' Nat inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2356) x n)) (HPow.hPow.{u_1, 0, u_1} G₀ Nat G₀ (instHPow.{u_1, 0} G₀ Nat (Monoid.Pow.{u_1} G₀ (MonoidWithZero.toMonoid.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ (CommGroupWithZero.toGroupWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2334))))) (f x) n)) -> (forall (x : G₀') (n : Int), Eq.{succ u_1} G₀ (f (HPow.hPow.{u_2, 0, u_2} G₀' Int G₀' (instHPow.{u_2, 0} G₀' Int inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2362) x n)) (HPow.hPow.{u_1, 0, u_1} G₀ Int G₀ (instHPow.{u_1, 0} G₀ Int (DivInvMonoid.Pow.{u_1} G₀ (GroupWithZero.toDivInvMonoid.{u_1} G₀ (CommGroupWithZero.toGroupWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2334)))) (f x) n)) -> (CommGroupWithZero.{u_2} G₀')
Case conversion may be inaccurate. Consider using '#align function.injective.comm_group_with_zero Function.Injective.commGroupWithZeroₓ'. -/
/-- Pullback a `comm_group_with_zero` class along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.commGroupWithZero [Zero G₀'] [Mul G₀'] [One G₀'] [Inv G₀']
    [Div G₀'] [Pow G₀' ℕ] [Pow G₀' ℤ] (f : G₀' → G₀) (hf : Injective f) (zero : f 0 = 0)
    (one : f 1 = 1) (mul : ∀ x y, f (x * y) = f x * f y) (inv : ∀ x, f x⁻¹ = (f x)⁻¹)
    (div : ∀ x y, f (x / y) = f x / f y) (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n)
    (zpow : ∀ (x) (n : ℤ), f (x ^ n) = f x ^ n) : CommGroupWithZero G₀' :=
  { hf.GroupWithZero f zero one mul inv div npow zpow, hf.CommSemigroup f mul with }
#align function.injective.comm_group_with_zero Function.Injective.commGroupWithZero

/- warning: function.surjective.comm_group_with_zero -> Function.Surjective.commGroupWithZero is a dubious translation:
lean 3 declaration is
  forall {G₀ : Type.{u_2}} {G₀' : Type.{u_4}} [_inst_1 : CommGroupWithZero.{u_2} G₀] [_inst_2 : Zero.{u_4} G₀'] [_inst_3 : Mul.{u_4} G₀'] [_inst_4 : One.{u_4} G₀'] [_inst_5 : Inv.{u_4} G₀'] [_inst_6 : Div.{u_4} G₀'] [_inst_7 : Pow.{u_4, 0} G₀' Nat] [_inst_8 : Pow.{u_4, 0} G₀' Int], (Ne.{succ u_4} G₀' (OfNat.ofNat.{u_4} G₀' 0 (OfNat.mk.{u_4} G₀' 0 (Zero.zero.{u_4} G₀' _inst_2))) (OfNat.ofNat.{u_4} G₀' 1 (OfNat.mk.{u_4} G₀' 1 (One.one.{u_4} G₀' _inst_4)))) -> (forall (f : G₀ -> G₀'), (Function.Surjective.{succ u_2, succ u_4} G₀ G₀' f) -> (Eq.{succ u_4} G₀' (f (OfNat.ofNat.{u_2} G₀ 0 (OfNat.mk.{u_2} G₀ 0 (Zero.zero.{u_2} G₀ (MulZeroClass.toHasZero.{u_2} G₀ (MulZeroOneClass.toMulZeroClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1))))))))) (OfNat.ofNat.{u_4} G₀' 0 (OfNat.mk.{u_4} G₀' 0 (Zero.zero.{u_4} G₀' _inst_2)))) -> (Eq.{succ u_4} G₀' (f (OfNat.ofNat.{u_2} G₀ 1 (OfNat.mk.{u_2} G₀ 1 (One.one.{u_2} G₀ (MulOneClass.toHasOne.{u_2} G₀ (MulZeroOneClass.toMulOneClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1))))))))) (OfNat.ofNat.{u_4} G₀' 1 (OfNat.mk.{u_4} G₀' 1 (One.one.{u_4} G₀' _inst_4)))) -> (forall (x : G₀) (y : G₀), Eq.{succ u_4} G₀' (f (HMul.hMul.{u_2, u_2, u_2} G₀ G₀ G₀ (instHMul.{u_2} G₀ (MulZeroClass.toHasMul.{u_2} G₀ (MulZeroOneClass.toMulZeroClass.{u_2} G₀ (MonoidWithZero.toMulZeroOneClass.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1)))))) x y)) (HMul.hMul.{u_4, u_4, u_4} G₀' G₀' G₀' (instHMul.{u_4} G₀' _inst_3) (f x) (f y))) -> (forall (x : G₀), Eq.{succ u_4} G₀' (f (Inv.inv.{u_2} G₀ (DivInvMonoid.toHasInv.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1))) x)) (Inv.inv.{u_4} G₀' _inst_5 (f x))) -> (forall (x : G₀) (y : G₀), Eq.{succ u_4} G₀' (f (HDiv.hDiv.{u_2, u_2, u_2} G₀ G₀ G₀ (instHDiv.{u_2} G₀ (DivInvMonoid.toHasDiv.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1)))) x y)) (HDiv.hDiv.{u_4, u_4, u_4} G₀' G₀' G₀' (instHDiv.{u_4} G₀' _inst_6) (f x) (f y))) -> (forall (x : G₀) (n : Nat), Eq.{succ u_4} G₀' (f (HPow.hPow.{u_2, 0, u_2} G₀ Nat G₀ (instHPow.{u_2, 0} G₀ Nat (Monoid.hasPow.{u_2} G₀ (MonoidWithZero.toMonoid.{u_2} G₀ (GroupWithZero.toMonoidWithZero.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1))))) x n)) (HPow.hPow.{u_4, 0, u_4} G₀' Nat G₀' (instHPow.{u_4, 0} G₀' Nat _inst_7) (f x) n)) -> (forall (x : G₀) (n : Int), Eq.{succ u_4} G₀' (f (HPow.hPow.{u_2, 0, u_2} G₀ Int G₀ (instHPow.{u_2, 0} G₀ Int (DivInvMonoid.hasPow.{u_2} G₀ (GroupWithZero.toDivInvMonoid.{u_2} G₀ (CommGroupWithZero.toGroupWithZero.{u_2} G₀ _inst_1)))) x n)) (HPow.hPow.{u_4, 0, u_4} G₀' Int G₀' (instHPow.{u_4, 0} G₀' Int _inst_8) (f x) n)) -> (CommGroupWithZero.{u_4} G₀'))
but is expected to have type
  forall {G₀ : Type.{u_1}} {G₀' : Type.{u_2}} [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2537 : CommGroupWithZero.{u_1} G₀] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2544 : Zero.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2547 : Mul.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2550 : One.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2553 : Inv.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2556 : Div.{u_2} G₀'] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2559 : Pow.{u_2, 0} G₀' Nat] [inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2565 : Pow.{u_2, 0} G₀' Int], (Ne.{succ u_2} G₀' (OfNat.ofNat.{u_2} G₀' 0 (Zero.toOfNat0.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2544)) (OfNat.ofNat.{u_2} G₀' 1 (One.toOfNat1.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2550))) -> (forall (f : G₀ -> G₀'), (Function.Surjective.{succ u_1, succ u_2} G₀ G₀' f) -> (Eq.{succ u_2} G₀' (f (OfNat.ofNat.{u_1} G₀ 0 (Zero.toOfNat0.{u_1} G₀ (CommMonoidWithZero.toZero.{u_1} G₀ (CommGroupWithZero.toCommMonoidWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2537))))) (OfNat.ofNat.{u_2} G₀' 0 (Zero.toOfNat0.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2544))) -> (Eq.{succ u_2} G₀' (f (OfNat.ofNat.{u_1} G₀ 1 (One.toOfNat1.{u_1} G₀ (Monoid.toOne.{u_1} G₀ (MonoidWithZero.toMonoid.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ (CommGroupWithZero.toGroupWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2537))))))) (OfNat.ofNat.{u_2} G₀' 1 (One.toOfNat1.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2550))) -> (forall (x : G₀) (y : G₀), Eq.{succ u_2} G₀' (f (HMul.hMul.{u_1, u_1, u_1} G₀ G₀ G₀ (instHMul.{u_1} G₀ (MulZeroClass.toMul.{u_1} G₀ (MulZeroOneClass.toMulZeroClass.{u_1} G₀ (MonoidWithZero.toMulZeroOneClass.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ (CommGroupWithZero.toGroupWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2537)))))) x y)) (HMul.hMul.{u_2, u_2, u_2} G₀' G₀' G₀' (instHMul.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2547) (f x) (f y))) -> (forall (x : G₀), Eq.{succ u_2} G₀' (f (Inv.inv.{u_1} G₀ (CommGroupWithZero.toInv.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2537) x)) (Inv.inv.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2553 (f x))) -> (forall (x : G₀) (y : G₀), Eq.{succ u_2} G₀' (f (HDiv.hDiv.{u_1, u_1, u_1} G₀ G₀ G₀ (instHDiv.{u_1} G₀ (CommGroupWithZero.toDiv.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2537)) x y)) (HDiv.hDiv.{u_2, u_2, u_2} G₀' G₀' G₀' (instHDiv.{u_2} G₀' inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2556) (f x) (f y))) -> (forall (x : G₀) (n : Nat), Eq.{succ u_2} G₀' (f (HPow.hPow.{u_1, 0, u_1} G₀ Nat G₀ (instHPow.{u_1, 0} G₀ Nat (Monoid.Pow.{u_1} G₀ (MonoidWithZero.toMonoid.{u_1} G₀ (GroupWithZero.toMonoidWithZero.{u_1} G₀ (CommGroupWithZero.toGroupWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2537))))) x n)) (HPow.hPow.{u_2, 0, u_2} G₀' Nat G₀' (instHPow.{u_2, 0} G₀' Nat inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2559) (f x) n)) -> (forall (x : G₀) (n : Int), Eq.{succ u_2} G₀' (f (HPow.hPow.{u_1, 0, u_1} G₀ Int G₀ (instHPow.{u_1, 0} G₀ Int (DivInvMonoid.Pow.{u_1} G₀ (GroupWithZero.toDivInvMonoid.{u_1} G₀ (CommGroupWithZero.toGroupWithZero.{u_1} G₀ inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2537)))) x n)) (HPow.hPow.{u_2, 0, u_2} G₀' Int G₀' (instHPow.{u_2, 0} G₀' Int inst._@.Mathlib.Algebra.GroupWithZero.InjSurj._hyg.2565) (f x) n)) -> (CommGroupWithZero.{u_2} G₀'))
Case conversion may be inaccurate. Consider using '#align function.surjective.comm_group_with_zero Function.Surjective.commGroupWithZeroₓ'. -/
/-- Pushforward a `comm_group_with_zero` class along a surjective function. -/
protected def Function.Surjective.commGroupWithZero [Zero G₀'] [Mul G₀'] [One G₀'] [Inv G₀']
    [Div G₀'] [Pow G₀' ℕ] [Pow G₀' ℤ] (h01 : (0 : G₀') ≠ 1) (f : G₀ → G₀') (hf : Surjective f)
    (zero : f 0 = 0) (one : f 1 = 1) (mul : ∀ x y, f (x * y) = f x * f y)
    (inv : ∀ x, f x⁻¹ = (f x)⁻¹) (div : ∀ x y, f (x / y) = f x / f y)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (zpow : ∀ (x) (n : ℤ), f (x ^ n) = f x ^ n) :
    CommGroupWithZero G₀' :=
  { hf.GroupWithZero h01 f zero one mul inv div npow zpow, hf.CommSemigroup f mul with }
#align function.surjective.comm_group_with_zero Function.Surjective.commGroupWithZero

end CommGroupWithZero

