/-
Copyright (c) 2018 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Callum Sutton, Yury Kudryashov

! This file was ported from Lean 3 source module algebra.hom.aut
! leanprover-community/mathlib commit d101e93197bb5f6ea89bd7ba386b7f7dff1f3903
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.GroupTheory.Perm.Basic

/-!
# Multiplicative and additive group automorphisms

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines the automorphism group structure on `add_aut R := add_equiv R R` and
`mul_aut R := mul_equiv R R`.

## Implementation notes

The definition of multiplication in the automorphism groups agrees with function composition,
multiplication in `equiv.perm`, and multiplication in `category_theory.End`, but not with
`category_theory.comp`.

This file is kept separate from `data/equiv/mul_add` so that `group_theory.perm` is free to use
equivalences (and other files that use them) before the group structure is defined.

## Tags

mul_aut, add_aut
-/


variable {A : Type _} {M : Type _} {G : Type _}

#print MulAut /-
/-- The group of multiplicative automorphisms. -/
@[reducible, to_additive "The group of additive automorphisms."]
def MulAut (M : Type _) [Mul M] :=
  M ≃* M
#align mul_aut MulAut
#align add_aut AddAut
-/

namespace MulAut

variable (M) [Mul M]

/-- The group operation on multiplicative automorphisms is defined by
`λ g h, mul_equiv.trans h g`.
This means that multiplication agrees with composition, `(g*h)(x) = g (h x)`.
-/
instance : Group (MulAut M) := by
  refine_struct
            { mul := fun g h => MulEquiv.trans h g
              one := MulEquiv.refl M
              inv := MulEquiv.symm
              div := _
              npow := @npowRec _ ⟨MulEquiv.refl M⟩ ⟨fun g h => MulEquiv.trans h g⟩
              zpow :=
                @zpowRec _ ⟨MulEquiv.refl M⟩ ⟨fun g h => MulEquiv.trans h g⟩ ⟨MulEquiv.symm⟩ } <;>
          intros <;>
        ext <;>
      try rfl <;>
    apply Equiv.left_inv

instance : Inhabited (MulAut M) :=
  ⟨1⟩

/- warning: mul_aut.coe_mul -> MulAut.coe_mul is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e₁ : MulAut.{u1} M _inst_1) (e₂ : MulAut.{u1} M _inst_1), Eq.{succ u1} (M -> M) (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) (HMul.hMul.{u1, u1, u1} (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (instHMul.{u1} (MulAut.{u1} M _inst_1) (MulOneClass.toHasMul.{u1} (MulAut.{u1} M _inst_1) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.group.{u1} M _inst_1)))))) e₁ e₂)) (Function.comp.{succ u1, succ u1, succ u1} M M M (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) e₁) (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) e₂))
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e₁ : MulAut.{u1} M _inst_1) (e₂ : MulAut.{u1} M _inst_1), Eq.{succ u1} (forall (ᾰ : M), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) (HMul.hMul.{u1, u1, u1} (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (instHMul.{u1} (MulAut.{u1} M _inst_1) (MulOneClass.toMul.{u1} (MulAut.{u1} M _inst_1) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1)))))) e₁ e₂)) (Function.comp.{succ u1, succ u1, succ u1} M M M (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) e₁) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) e₂))
Case conversion may be inaccurate. Consider using '#align mul_aut.coe_mul MulAut.coe_mulₓ'. -/
@[simp]
theorem coe_mul (e₁ e₂ : MulAut M) : ⇑(e₁ * e₂) = e₁ ∘ e₂ :=
  rfl
#align mul_aut.coe_mul MulAut.coe_mul

/- warning: mul_aut.coe_one -> MulAut.coe_one is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M], Eq.{succ u1} (M -> M) (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) (OfNat.ofNat.{u1} (MulAut.{u1} M _inst_1) 1 (OfNat.mk.{u1} (MulAut.{u1} M _inst_1) 1 (One.one.{u1} (MulAut.{u1} M _inst_1) (MulOneClass.toHasOne.{u1} (MulAut.{u1} M _inst_1) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.group.{u1} M _inst_1))))))))) (id.{succ u1} M)
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M], Eq.{succ u1} (forall (ᾰ : M), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) (OfNat.ofNat.{u1} (MulAut.{u1} M _inst_1) 1 (One.toOfNat1.{u1} (MulAut.{u1} M _inst_1) (InvOneClass.toOne.{u1} (MulAut.{u1} M _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (MulAut.{u1} M _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivisionMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1)))))))) (id.{succ u1} M)
Case conversion may be inaccurate. Consider using '#align mul_aut.coe_one MulAut.coe_oneₓ'. -/
@[simp]
theorem coe_one : ⇑(1 : MulAut M) = id :=
  rfl
#align mul_aut.coe_one MulAut.coe_one

/- warning: mul_aut.mul_def -> MulAut.mul_def is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e₁ : MulAut.{u1} M _inst_1) (e₂ : MulAut.{u1} M _inst_1), Eq.{succ u1} (MulAut.{u1} M _inst_1) (HMul.hMul.{u1, u1, u1} (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (instHMul.{u1} (MulAut.{u1} M _inst_1) (MulOneClass.toHasMul.{u1} (MulAut.{u1} M _inst_1) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.group.{u1} M _inst_1)))))) e₁ e₂) (MulEquiv.trans.{u1, u1, u1} M M M _inst_1 _inst_1 _inst_1 e₂ e₁)
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e₁ : MulAut.{u1} M _inst_1) (e₂ : MulAut.{u1} M _inst_1), Eq.{succ u1} (MulAut.{u1} M _inst_1) (HMul.hMul.{u1, u1, u1} (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (instHMul.{u1} (MulAut.{u1} M _inst_1) (MulOneClass.toMul.{u1} (MulAut.{u1} M _inst_1) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1)))))) e₁ e₂) (MulEquiv.trans.{u1, u1, u1} M M M _inst_1 _inst_1 _inst_1 e₂ e₁)
Case conversion may be inaccurate. Consider using '#align mul_aut.mul_def MulAut.mul_defₓ'. -/
theorem mul_def (e₁ e₂ : MulAut M) : e₁ * e₂ = e₂.trans e₁ :=
  rfl
#align mul_aut.mul_def MulAut.mul_def

/- warning: mul_aut.one_def -> MulAut.one_def is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M], Eq.{succ u1} (MulAut.{u1} M _inst_1) (OfNat.ofNat.{u1} (MulAut.{u1} M _inst_1) 1 (OfNat.mk.{u1} (MulAut.{u1} M _inst_1) 1 (One.one.{u1} (MulAut.{u1} M _inst_1) (MulOneClass.toHasOne.{u1} (MulAut.{u1} M _inst_1) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.group.{u1} M _inst_1)))))))) (MulEquiv.refl.{u1} M _inst_1)
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M], Eq.{succ u1} (MulAut.{u1} M _inst_1) (OfNat.ofNat.{u1} (MulAut.{u1} M _inst_1) 1 (One.toOfNat1.{u1} (MulAut.{u1} M _inst_1) (InvOneClass.toOne.{u1} (MulAut.{u1} M _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (MulAut.{u1} M _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivisionMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1))))))) (MulEquiv.refl.{u1} M _inst_1)
Case conversion may be inaccurate. Consider using '#align mul_aut.one_def MulAut.one_defₓ'. -/
theorem one_def : (1 : MulAut M) = MulEquiv.refl _ :=
  rfl
#align mul_aut.one_def MulAut.one_def

/- warning: mul_aut.inv_def -> MulAut.inv_def is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e₁ : MulAut.{u1} M _inst_1), Eq.{succ u1} (MulAut.{u1} M _inst_1) (Inv.inv.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toHasInv.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.group.{u1} M _inst_1))) e₁) (MulEquiv.symm.{u1, u1} M M _inst_1 _inst_1 e₁)
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e₁ : MulAut.{u1} M _inst_1), Eq.{succ u1} (MulAut.{u1} M _inst_1) (Inv.inv.{u1} (MulAut.{u1} M _inst_1) (InvOneClass.toInv.{u1} (MulAut.{u1} M _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (MulAut.{u1} M _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivisionMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1))))) e₁) (MulEquiv.symm.{u1, u1} M M _inst_1 _inst_1 e₁)
Case conversion may be inaccurate. Consider using '#align mul_aut.inv_def MulAut.inv_defₓ'. -/
theorem inv_def (e₁ : MulAut M) : e₁⁻¹ = e₁.symm :=
  rfl
#align mul_aut.inv_def MulAut.inv_def

/- warning: mul_aut.mul_apply -> MulAut.mul_apply is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e₁ : MulAut.{u1} M _inst_1) (e₂ : MulAut.{u1} M _inst_1) (m : M), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) (HMul.hMul.{u1, u1, u1} (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (instHMul.{u1} (MulAut.{u1} M _inst_1) (MulOneClass.toHasMul.{u1} (MulAut.{u1} M _inst_1) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.group.{u1} M _inst_1)))))) e₁ e₂) m) (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) e₁ (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) e₂ m))
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e₁ : MulAut.{u1} M _inst_1) (e₂ : MulAut.{u1} M _inst_1) (m : M), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) m) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) (HMul.hMul.{u1, u1, u1} (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (MulAut.{u1} M _inst_1) (instHMul.{u1} (MulAut.{u1} M _inst_1) (MulOneClass.toMul.{u1} (MulAut.{u1} M _inst_1) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1)))))) e₁ e₂) m) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) e₁ (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) e₂ m))
Case conversion may be inaccurate. Consider using '#align mul_aut.mul_apply MulAut.mul_applyₓ'. -/
@[simp]
theorem mul_apply (e₁ e₂ : MulAut M) (m : M) : (e₁ * e₂) m = e₁ (e₂ m) :=
  rfl
#align mul_aut.mul_apply MulAut.mul_apply

/- warning: mul_aut.one_apply -> MulAut.one_apply is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (m : M), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) (OfNat.ofNat.{u1} (MulAut.{u1} M _inst_1) 1 (OfNat.mk.{u1} (MulAut.{u1} M _inst_1) 1 (One.one.{u1} (MulAut.{u1} M _inst_1) (MulOneClass.toHasOne.{u1} (MulAut.{u1} M _inst_1) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.group.{u1} M _inst_1)))))))) m) m
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (m : M), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) m) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) (OfNat.ofNat.{u1} (MulAut.{u1} M _inst_1) 1 (One.toOfNat1.{u1} (MulAut.{u1} M _inst_1) (InvOneClass.toOne.{u1} (MulAut.{u1} M _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (MulAut.{u1} M _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivisionMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1))))))) m) m
Case conversion may be inaccurate. Consider using '#align mul_aut.one_apply MulAut.one_applyₓ'. -/
@[simp]
theorem one_apply (m : M) : (1 : MulAut M) m = m :=
  rfl
#align mul_aut.one_apply MulAut.one_apply

/- warning: mul_aut.apply_inv_self -> MulAut.apply_inv_self is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e : MulAut.{u1} M _inst_1) (m : M), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) e (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) (Inv.inv.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toHasInv.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.group.{u1} M _inst_1))) e) m)) m
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e : MulAut.{u1} M _inst_1) (m : M), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (a : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) (Inv.inv.{u1} (MulAut.{u1} M _inst_1) (InvOneClass.toInv.{u1} (MulAut.{u1} M _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (MulAut.{u1} M _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivisionMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1))))) e) m)) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) e (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) (Inv.inv.{u1} (MulAut.{u1} M _inst_1) (InvOneClass.toInv.{u1} (MulAut.{u1} M _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (MulAut.{u1} M _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivisionMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1))))) e) m)) m
Case conversion may be inaccurate. Consider using '#align mul_aut.apply_inv_self MulAut.apply_inv_selfₓ'. -/
@[simp]
theorem apply_inv_self (e : MulAut M) (m : M) : e (e⁻¹ m) = m :=
  MulEquiv.apply_symm_apply _ _
#align mul_aut.apply_inv_self MulAut.apply_inv_self

/- warning: mul_aut.inv_apply_self -> MulAut.inv_apply_self is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e : MulAut.{u1} M _inst_1) (m : M), Eq.{succ u1} M (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) (Inv.inv.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toHasInv.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.group.{u1} M _inst_1))) e) (coeFn.{succ u1, succ u1} (MulAut.{u1} M _inst_1) (fun (_x : MulEquiv.{u1, u1} M M _inst_1 _inst_1) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M _inst_1 _inst_1) e m)) m
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M] (e : MulAut.{u1} M _inst_1) (m : M), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (a : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) e m)) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) (Inv.inv.{u1} (MulAut.{u1} M _inst_1) (InvOneClass.toInv.{u1} (MulAut.{u1} M _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (MulAut.{u1} M _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivisionMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1))))) e) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M _inst_1) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M _inst_1) M M _inst_1 _inst_1 (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M _inst_1 _inst_1)))) e m)) m
Case conversion may be inaccurate. Consider using '#align mul_aut.inv_apply_self MulAut.inv_apply_selfₓ'. -/
@[simp]
theorem inv_apply_self (e : MulAut M) (m : M) : e⁻¹ (e m) = m :=
  MulEquiv.apply_symm_apply _ _
#align mul_aut.inv_apply_self MulAut.inv_apply_self

/- warning: mul_aut.to_perm -> MulAut.toPerm is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M], MonoidHom.{u1, u1} (MulAut.{u1} M _inst_1) (Equiv.Perm.{succ u1} M) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.group.{u1} M _inst_1)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} M) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} M) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} M) (Equiv.Perm.permGroup.{u1} M))))
but is expected to have type
  forall (M : Type.{u1}) [_inst_1 : Mul.{u1} M], MonoidHom.{u1, u1} (MulAut.{u1} M _inst_1) (Equiv.Perm.{succ u1} M) (Monoid.toMulOneClass.{u1} (MulAut.{u1} M _inst_1) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M _inst_1) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M _inst_1) (MulAut.instGroupMulAut.{u1} M _inst_1)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} M) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} M) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} M) (Equiv.Perm.permGroup.{u1} M))))
Case conversion may be inaccurate. Consider using '#align mul_aut.to_perm MulAut.toPermₓ'. -/
/-- Monoid hom from the group of multiplicative automorphisms to the group of permutations. -/
def toPerm : MulAut M →* Equiv.Perm M := by
  refine_struct { toFun := MulEquiv.toEquiv } <;> intros <;> rfl
#align mul_aut.to_perm MulAut.toPerm

/- warning: mul_aut.apply_mul_distrib_mul_action -> MulAut.applyMulDistribMulAction is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_2 : Monoid.{u1} M], MulDistribMulAction.{u1, u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (MulAut.group.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))))) _inst_2
but is expected to have type
  forall {M : Type.{u1}} [_inst_2 : Monoid.{u1} M], MulDistribMulAction.{u1, u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (MulAut.instGroupMulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))))) _inst_2
Case conversion may be inaccurate. Consider using '#align mul_aut.apply_mul_distrib_mul_action MulAut.applyMulDistribMulActionₓ'. -/
/-- The tautological action by `mul_aut M` on `M`.

This generalizes `function.End.apply_mul_action`. -/
instance applyMulDistribMulAction {M} [Monoid M] : MulDistribMulAction (MulAut M) M
    where
  smul := (· <| ·)
  one_smul _ := rfl
  mul_smul _ _ _ := rfl
  smul_one := MulEquiv.map_one
  smul_mul := MulEquiv.map_mul
#align mul_aut.apply_mul_distrib_mul_action MulAut.applyMulDistribMulAction

/- warning: mul_aut.smul_def -> MulAut.smul_def is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_2 : Monoid.{u1} M] (f : MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (a : M), Eq.{succ u1} M (SMul.smul.{u1, u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (MulAction.toHasSmul.{u1, u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (MulAut.group.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))))) (MulDistribMulAction.toMulAction.{u1, u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (MulAut.group.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))))) _inst_2 (MulAut.applyMulDistribMulAction.{u1} M _inst_2))) f a) (coeFn.{succ u1, succ u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (fun (_x : MulEquiv.{u1, u1} M M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2)) (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) => M -> M) (MulEquiv.hasCoeToFun.{u1, u1} M M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2)) (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) f a)
but is expected to have type
  forall {M : Type.{u1}} [_inst_2 : Monoid.{u1} M] (f : MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (a : M), Eq.{succ u1} M (HSMul.hSMul.{u1, u1, u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M M (instHSMul.{u1, u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (MulAction.toSMul.{u1, u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (MulAut.instGroupMulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))))) (MulDistribMulAction.toMulAction.{u1, u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (MulAut.instGroupMulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))))) _inst_2 (MulAut.applyMulDistribMulAction.{u1} M _inst_2)))) f a) (FunLike.coe.{succ u1, succ u1, succ u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (fun (_x : M) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : M) => M) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M M (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M M (MulEquivClass.toEquivLike.{u1, u1, u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2)) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2)) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} M M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2)) (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2)))))) f a)
Case conversion may be inaccurate. Consider using '#align mul_aut.smul_def MulAut.smul_defₓ'. -/
@[simp]
protected theorem smul_def {M} [Monoid M] (f : MulAut M) (a : M) : f • a = f a :=
  rfl
#align mul_aut.smul_def MulAut.smul_def

/- warning: mul_aut.apply_has_faithful_smul -> MulAut.apply_faithfulSMul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_2 : Monoid.{u1} M], FaithfulSMul.{u1, u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (MulAction.toHasSmul.{u1, u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (MulAut.group.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))))) (MulDistribMulAction.toMulAction.{u1, u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (MulAut.group.{u1} M (MulOneClass.toHasMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))))) _inst_2 (MulAut.applyMulDistribMulAction.{u1} M _inst_2)))
but is expected to have type
  forall {M : Type.{u1}} [_inst_2 : Monoid.{u1} M], FaithfulSMul.{u1, u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (MulAction.toSMul.{u1, u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (MulAut.instGroupMulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))))) (MulDistribMulAction.toMulAction.{u1, u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) M (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))) (MulAut.instGroupMulAut.{u1} M (MulOneClass.toMul.{u1} M (Monoid.toMulOneClass.{u1} M _inst_2))))) _inst_2 (MulAut.applyMulDistribMulAction.{u1} M _inst_2)))
Case conversion may be inaccurate. Consider using '#align mul_aut.apply_has_faithful_smul MulAut.apply_faithfulSMulₓ'. -/
/-- `mul_aut.apply_mul_action` is faithful. -/
instance apply_faithfulSMul {M} [Monoid M] : FaithfulSMul (MulAut M) M :=
  ⟨fun _ _ => MulEquiv.ext⟩
#align mul_aut.apply_has_faithful_smul MulAut.apply_faithfulSMul

/- warning: mul_aut.conj -> MulAut.conj is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_2 : Group.{u1} G], MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_2 : Group.{u1} G], MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align mul_aut.conj MulAut.conjₓ'. -/
/-- Group conjugation, `mul_aut.conj g h = g * h * g⁻¹`, as a monoid homomorphism
mapping multiplication in `G` into multiplication in the automorphism group `mul_aut G`.
See also the type `conj_act G` for any group `G`, which has a `mul_action (conj_act G) G` instance
where `conj G` acts on `G` by conjugation. -/
def conj [Group G] : G →* MulAut G
    where
  toFun g :=
    { toFun := fun h => g * h * g⁻¹
      invFun := fun h => g⁻¹ * h * g
      left_inv := fun _ => by simp [mul_assoc]
      right_inv := fun _ => by simp [mul_assoc]
      map_mul' := by simp [mul_assoc] }
  map_mul' _ _ := by ext <;> simp [mul_assoc]
  map_one' := by ext <;> simp [mul_assoc]
#align mul_aut.conj MulAut.conj

/- warning: mul_aut.conj_apply -> MulAut.conj_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_2 : Group.{u1} G] (g : G) (h : G), Eq.{succ u1} G (coeFn.{succ u1, succ u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (fun (_x : MulEquiv.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) => G -> G) (MulEquiv.hasCoeToFun.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) (fun (_x : MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) => G -> (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))))) (MonoidHom.hasCoeToFun.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) (MulAut.conj.{u1} G _inst_2) g) h) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g h) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) g))
but is expected to have type
  forall {G : Type.{u1}} [_inst_2 : Group.{u1} G] (g : G) (h : G), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) h) (FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) G (fun (_x : G) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) G G (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) G G (MulEquivClass.toEquivLike.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))))))) (MonoidHom.monoidHomClass.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))))) (MulAut.conj.{u1} G _inst_2) g) h) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g h) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_2)))) g))
Case conversion may be inaccurate. Consider using '#align mul_aut.conj_apply MulAut.conj_applyₓ'. -/
@[simp]
theorem conj_apply [Group G] (g h : G) : conj g h = g * h * g⁻¹ :=
  rfl
#align mul_aut.conj_apply MulAut.conj_apply

/- warning: mul_aut.conj_symm_apply -> MulAut.conj_symm_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_2 : Group.{u1} G] (g : G) (h : G), Eq.{succ u1} G (coeFn.{succ u1, succ u1} (MulEquiv.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (fun (_x : MulEquiv.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) => G -> G) (MulEquiv.hasCoeToFun.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulEquiv.symm.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) (fun (_x : MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) => G -> (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))))) (MonoidHom.hasCoeToFun.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) (MulAut.conj.{u1} G _inst_2) g)) h) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) g) h) g)
but is expected to have type
  forall {G : Type.{u1}} [_inst_2 : Group.{u1} G] (g : G) (h : G), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) h) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) G (fun (_x : G) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) G G (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) G G (MulEquivClass.toEquivLike.{u1, u1, u1} (MulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))))))) (MulEquiv.symm.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))))))) (MonoidHom.monoidHomClass.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))))) (MulAut.conj.{u1} G _inst_2) g)) h) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_2)))) g) h) g)
Case conversion may be inaccurate. Consider using '#align mul_aut.conj_symm_apply MulAut.conj_symm_applyₓ'. -/
@[simp]
theorem conj_symm_apply [Group G] (g h : G) : (conj g).symm h = g⁻¹ * h * g :=
  rfl
#align mul_aut.conj_symm_apply MulAut.conj_symm_apply

/- warning: mul_aut.conj_inv_apply -> MulAut.conj_inv_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_2 : Group.{u1} G] (g : G) (h : G), Eq.{succ u1} G (coeFn.{succ u1, succ u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (fun (_x : MulEquiv.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) => G -> G) (MulEquiv.hasCoeToFun.{u1, u1} G G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Inv.inv.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toHasInv.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) (fun (_x : MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) => G -> (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))))) (MonoidHom.hasCoeToFun.{u1, u1} G (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.group.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) (MulAut.conj.{u1} G _inst_2) g)) h) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toHasMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Inv.inv.{u1} G (DivInvMonoid.toHasInv.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)) g) h) g)
but is expected to have type
  forall {G : Type.{u1}} [_inst_2 : Group.{u1} G] (g : G) (h : G), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) h) (FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) G (fun (_x : G) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) G G (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) G G (MulEquivClass.toEquivLike.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} G G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))))))) (Inv.inv.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) (InvOneClass.toInv.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) (DivInvOneMonoid.toInvOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) (DivisionMonoid.toDivInvOneMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) (Group.toDivisionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) g) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2398 : G) => MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))) (MulOneClass.toMul.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))) G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2)))))))) (MonoidHom.monoidHomClass.{u1, u1} G (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))) (Monoid.toMulOneClass.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (MulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (MulAut.instGroupMulAut.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))))))))) (MulAut.conj.{u1} G _inst_2) g)) h) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (HMul.hMul.{u1, u1, u1} G G G (instHMul.{u1} G (MulOneClass.toMul.{u1} G (Monoid.toMulOneClass.{u1} G (DivInvMonoid.toMonoid.{u1} G (Group.toDivInvMonoid.{u1} G _inst_2))))) (Inv.inv.{u1} G (InvOneClass.toInv.{u1} G (DivInvOneMonoid.toInvOneClass.{u1} G (DivisionMonoid.toDivInvOneMonoid.{u1} G (Group.toDivisionMonoid.{u1} G _inst_2)))) g) h) g)
Case conversion may be inaccurate. Consider using '#align mul_aut.conj_inv_apply MulAut.conj_inv_applyₓ'. -/
@[simp]
theorem conj_inv_apply [Group G] (g h : G) : (conj g)⁻¹ h = g⁻¹ * h * g :=
  rfl
#align mul_aut.conj_inv_apply MulAut.conj_inv_apply

end MulAut

namespace AddAut

variable (A) [Add A]

#print AddAut.group /-
/-- The group operation on additive automorphisms is defined by
`λ g h, add_equiv.trans h g`.
This means that multiplication agrees with composition, `(g*h)(x) = g (h x)`.
-/
instance group : Group (AddAut A) := by
  refine_struct
            { mul := fun g h => AddEquiv.trans h g
              one := AddEquiv.refl A
              inv := AddEquiv.symm
              div := _
              npow := @npowRec _ ⟨AddEquiv.refl A⟩ ⟨fun g h => AddEquiv.trans h g⟩
              zpow :=
                @zpowRec _ ⟨AddEquiv.refl A⟩ ⟨fun g h => AddEquiv.trans h g⟩ ⟨AddEquiv.symm⟩ } <;>
          intros <;>
        ext <;>
      try rfl <;>
    apply Equiv.left_inv
#align add_aut.group AddAut.group
-/

instance : Inhabited (AddAut A) :=
  ⟨1⟩

/- warning: add_aut.coe_mul -> AddAut.coe_mul is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e₁ : AddAut.{u1} A _inst_1) (e₂ : AddAut.{u1} A _inst_1), Eq.{succ u1} (A -> A) (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) (HMul.hMul.{u1, u1, u1} (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (instHMul.{u1} (AddAut.{u1} A _inst_1) (MulOneClass.toHasMul.{u1} (AddAut.{u1} A _inst_1) (Monoid.toMulOneClass.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1)))))) e₁ e₂)) (Function.comp.{succ u1, succ u1, succ u1} A A A (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) e₁) (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) e₂))
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e₁ : AddAut.{u1} A _inst_1) (e₂ : AddAut.{u1} A _inst_1), Eq.{succ u1} (forall (ᾰ : A), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) (HMul.hMul.{u1, u1, u1} (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (instHMul.{u1} (AddAut.{u1} A _inst_1) (MulOneClass.toMul.{u1} (AddAut.{u1} A _inst_1) (Monoid.toMulOneClass.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1)))))) e₁ e₂)) (Function.comp.{succ u1, succ u1, succ u1} A A A (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) e₁) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) e₂))
Case conversion may be inaccurate. Consider using '#align add_aut.coe_mul AddAut.coe_mulₓ'. -/
@[simp]
theorem coe_mul (e₁ e₂ : AddAut A) : ⇑(e₁ * e₂) = e₁ ∘ e₂ :=
  rfl
#align add_aut.coe_mul AddAut.coe_mul

/- warning: add_aut.coe_one -> AddAut.coe_one is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A], Eq.{succ u1} (A -> A) (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) (OfNat.ofNat.{u1} (AddAut.{u1} A _inst_1) 1 (OfNat.mk.{u1} (AddAut.{u1} A _inst_1) 1 (One.one.{u1} (AddAut.{u1} A _inst_1) (MulOneClass.toHasOne.{u1} (AddAut.{u1} A _inst_1) (Monoid.toMulOneClass.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1))))))))) (id.{succ u1} A)
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A], Eq.{succ u1} (forall (ᾰ : A), (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) (OfNat.ofNat.{u1} (AddAut.{u1} A _inst_1) 1 (One.toOfNat1.{u1} (AddAut.{u1} A _inst_1) (InvOneClass.toOne.{u1} (AddAut.{u1} A _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (AddAut.{u1} A _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivisionMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1)))))))) (id.{succ u1} A)
Case conversion may be inaccurate. Consider using '#align add_aut.coe_one AddAut.coe_oneₓ'. -/
@[simp]
theorem coe_one : ⇑(1 : AddAut A) = id :=
  rfl
#align add_aut.coe_one AddAut.coe_one

/- warning: add_aut.mul_def -> AddAut.mul_def is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e₁ : AddAut.{u1} A _inst_1) (e₂ : AddAut.{u1} A _inst_1), Eq.{succ u1} (AddAut.{u1} A _inst_1) (HMul.hMul.{u1, u1, u1} (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (instHMul.{u1} (AddAut.{u1} A _inst_1) (MulOneClass.toHasMul.{u1} (AddAut.{u1} A _inst_1) (Monoid.toMulOneClass.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1)))))) e₁ e₂) (AddEquiv.trans.{u1, u1, u1} A A A _inst_1 _inst_1 _inst_1 e₂ e₁)
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e₁ : AddAut.{u1} A _inst_1) (e₂ : AddAut.{u1} A _inst_1), Eq.{succ u1} (AddAut.{u1} A _inst_1) (HMul.hMul.{u1, u1, u1} (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (instHMul.{u1} (AddAut.{u1} A _inst_1) (MulOneClass.toMul.{u1} (AddAut.{u1} A _inst_1) (Monoid.toMulOneClass.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1)))))) e₁ e₂) (AddEquiv.trans.{u1, u1, u1} A A A _inst_1 _inst_1 _inst_1 e₂ e₁)
Case conversion may be inaccurate. Consider using '#align add_aut.mul_def AddAut.mul_defₓ'. -/
theorem mul_def (e₁ e₂ : AddAut A) : e₁ * e₂ = e₂.trans e₁ :=
  rfl
#align add_aut.mul_def AddAut.mul_def

/- warning: add_aut.one_def -> AddAut.one_def is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A], Eq.{succ u1} (AddAut.{u1} A _inst_1) (OfNat.ofNat.{u1} (AddAut.{u1} A _inst_1) 1 (OfNat.mk.{u1} (AddAut.{u1} A _inst_1) 1 (One.one.{u1} (AddAut.{u1} A _inst_1) (MulOneClass.toHasOne.{u1} (AddAut.{u1} A _inst_1) (Monoid.toMulOneClass.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1)))))))) (AddEquiv.refl.{u1} A _inst_1)
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A], Eq.{succ u1} (AddAut.{u1} A _inst_1) (OfNat.ofNat.{u1} (AddAut.{u1} A _inst_1) 1 (One.toOfNat1.{u1} (AddAut.{u1} A _inst_1) (InvOneClass.toOne.{u1} (AddAut.{u1} A _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (AddAut.{u1} A _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivisionMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1))))))) (AddEquiv.refl.{u1} A _inst_1)
Case conversion may be inaccurate. Consider using '#align add_aut.one_def AddAut.one_defₓ'. -/
theorem one_def : (1 : AddAut A) = AddEquiv.refl _ :=
  rfl
#align add_aut.one_def AddAut.one_def

/- warning: add_aut.inv_def -> AddAut.inv_def is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e₁ : AddAut.{u1} A _inst_1), Eq.{succ u1} (AddAut.{u1} A _inst_1) (Inv.inv.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toHasInv.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1))) e₁) (AddEquiv.symm.{u1, u1} A A _inst_1 _inst_1 e₁)
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e₁ : AddAut.{u1} A _inst_1), Eq.{succ u1} (AddAut.{u1} A _inst_1) (Inv.inv.{u1} (AddAut.{u1} A _inst_1) (InvOneClass.toInv.{u1} (AddAut.{u1} A _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (AddAut.{u1} A _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivisionMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1))))) e₁) (AddEquiv.symm.{u1, u1} A A _inst_1 _inst_1 e₁)
Case conversion may be inaccurate. Consider using '#align add_aut.inv_def AddAut.inv_defₓ'. -/
theorem inv_def (e₁ : AddAut A) : e₁⁻¹ = e₁.symm :=
  rfl
#align add_aut.inv_def AddAut.inv_def

/- warning: add_aut.mul_apply -> AddAut.mul_apply is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e₁ : AddAut.{u1} A _inst_1) (e₂ : AddAut.{u1} A _inst_1) (a : A), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) (HMul.hMul.{u1, u1, u1} (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (instHMul.{u1} (AddAut.{u1} A _inst_1) (MulOneClass.toHasMul.{u1} (AddAut.{u1} A _inst_1) (Monoid.toMulOneClass.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1)))))) e₁ e₂) a) (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) e₁ (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) e₂ a))
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e₁ : AddAut.{u1} A _inst_1) (e₂ : AddAut.{u1} A _inst_1) (a : A), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) a) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) (HMul.hMul.{u1, u1, u1} (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (AddAut.{u1} A _inst_1) (instHMul.{u1} (AddAut.{u1} A _inst_1) (MulOneClass.toMul.{u1} (AddAut.{u1} A _inst_1) (Monoid.toMulOneClass.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1)))))) e₁ e₂) a) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) e₁ (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) e₂ a))
Case conversion may be inaccurate. Consider using '#align add_aut.mul_apply AddAut.mul_applyₓ'. -/
@[simp]
theorem mul_apply (e₁ e₂ : AddAut A) (a : A) : (e₁ * e₂) a = e₁ (e₂ a) :=
  rfl
#align add_aut.mul_apply AddAut.mul_apply

/- warning: add_aut.one_apply -> AddAut.one_apply is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (a : A), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) (OfNat.ofNat.{u1} (AddAut.{u1} A _inst_1) 1 (OfNat.mk.{u1} (AddAut.{u1} A _inst_1) 1 (One.one.{u1} (AddAut.{u1} A _inst_1) (MulOneClass.toHasOne.{u1} (AddAut.{u1} A _inst_1) (Monoid.toMulOneClass.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1)))))))) a) a
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (a : A), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) a) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) (OfNat.ofNat.{u1} (AddAut.{u1} A _inst_1) 1 (One.toOfNat1.{u1} (AddAut.{u1} A _inst_1) (InvOneClass.toOne.{u1} (AddAut.{u1} A _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (AddAut.{u1} A _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivisionMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1))))))) a) a
Case conversion may be inaccurate. Consider using '#align add_aut.one_apply AddAut.one_applyₓ'. -/
@[simp]
theorem one_apply (a : A) : (1 : AddAut A) a = a :=
  rfl
#align add_aut.one_apply AddAut.one_apply

/- warning: add_aut.apply_inv_self -> AddAut.apply_inv_self is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e : AddAut.{u1} A _inst_1) (a : A), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) (Inv.inv.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toHasInv.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1))) e) (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) e a)) a
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e : AddAut.{u1} A _inst_1) (a : A), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (a : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) e a)) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) (Inv.inv.{u1} (AddAut.{u1} A _inst_1) (InvOneClass.toInv.{u1} (AddAut.{u1} A _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (AddAut.{u1} A _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivisionMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1))))) e) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) e a)) a
Case conversion may be inaccurate. Consider using '#align add_aut.apply_inv_self AddAut.apply_inv_selfₓ'. -/
@[simp]
theorem apply_inv_self (e : AddAut A) (a : A) : e⁻¹ (e a) = a :=
  AddEquiv.apply_symm_apply _ _
#align add_aut.apply_inv_self AddAut.apply_inv_self

/- warning: add_aut.inv_apply_self -> AddAut.inv_apply_self is a dubious translation:
lean 3 declaration is
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e : AddAut.{u1} A _inst_1) (a : A), Eq.{succ u1} A (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) e (coeFn.{succ u1, succ u1} (AddAut.{u1} A _inst_1) (fun (_x : AddEquiv.{u1, u1} A A _inst_1 _inst_1) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A _inst_1 _inst_1) (Inv.inv.{u1} (AddAut.{u1} A _inst_1) (DivInvMonoid.toHasInv.{u1} (AddAut.{u1} A _inst_1) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1))) e) a)) a
but is expected to have type
  forall (A : Type.{u1}) [_inst_1 : Add.{u1} A] (e : AddAut.{u1} A _inst_1) (a : A), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (a : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) (Inv.inv.{u1} (AddAut.{u1} A _inst_1) (InvOneClass.toInv.{u1} (AddAut.{u1} A _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (AddAut.{u1} A _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivisionMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1))))) e) a)) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) e (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A _inst_1) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A _inst_1) A A _inst_1 _inst_1 (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A _inst_1 _inst_1)))) (Inv.inv.{u1} (AddAut.{u1} A _inst_1) (InvOneClass.toInv.{u1} (AddAut.{u1} A _inst_1) (DivInvOneMonoid.toInvOneClass.{u1} (AddAut.{u1} A _inst_1) (DivisionMonoid.toDivInvOneMonoid.{u1} (AddAut.{u1} A _inst_1) (Group.toDivisionMonoid.{u1} (AddAut.{u1} A _inst_1) (AddAut.group.{u1} A _inst_1))))) e) a)) a
Case conversion may be inaccurate. Consider using '#align add_aut.inv_apply_self AddAut.inv_apply_selfₓ'. -/
@[simp]
theorem inv_apply_self (e : AddAut A) (a : A) : e (e⁻¹ a) = a :=
  AddEquiv.apply_symm_apply _ _
#align add_aut.inv_apply_self AddAut.inv_apply_self

#print AddAut.toPerm /-
/-- Monoid hom from the group of multiplicative automorphisms to the group of permutations. -/
def toPerm : AddAut A →* Equiv.Perm A := by
  refine_struct { toFun := AddEquiv.toEquiv } <;> intros <;> rfl
#align add_aut.to_perm AddAut.toPerm
-/

/- warning: add_aut.apply_distrib_mul_action -> AddAut.applyDistribMulAction is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A], DistribMulAction.{u1, u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (AddAut.group.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))))) _inst_2
but is expected to have type
  forall {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A], DistribMulAction.{u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (AddAut.group.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))))) _inst_2
Case conversion may be inaccurate. Consider using '#align add_aut.apply_distrib_mul_action AddAut.applyDistribMulActionₓ'. -/
/-- The tautological action by `add_aut A` on `A`.

This generalizes `function.End.apply_mul_action`. -/
instance applyDistribMulAction {A} [AddMonoid A] : DistribMulAction (AddAut A) A
    where
  smul := (· <| ·)
  smul_zero := AddEquiv.map_zero
  smul_add := AddEquiv.map_add
  one_smul _ := rfl
  mul_smul _ _ _ := rfl
#align add_aut.apply_distrib_mul_action AddAut.applyDistribMulAction

/- warning: add_aut.smul_def -> AddAut.smul_def is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A] (f : AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (a : A), Eq.{succ u1} A (SMul.smul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (SMulZeroClass.toHasSmul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (AddMonoid.toAddZeroClass.{u1} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (AddAut.group.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))))) _inst_2 (AddAut.applyDistribMulAction.{u1} A _inst_2)))) f a) (coeFn.{succ u1, succ u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (fun (_x : AddEquiv.{u1, u1} A A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) => A -> A) (AddEquiv.hasCoeToFun.{u1, u1} A A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) f a)
but is expected to have type
  forall {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A] (f : AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (a : A), Eq.{succ u1} A (HSMul.hSMul.{u1, u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A A (instHSMul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (SMulZeroClass.toSMul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (AddMonoid.toZero.{u1} A _inst_2) (DistribSMul.toSMulZeroClass.{u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (AddMonoid.toAddZeroClass.{u1} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (AddAut.group.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))))) _inst_2 (AddAut.applyDistribMulAction.{u1} A _inst_2))))) f a) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (fun (_x : A) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : A) => A) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A A (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A A (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} A A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)))))) f a)
Case conversion may be inaccurate. Consider using '#align add_aut.smul_def AddAut.smul_defₓ'. -/
@[simp]
protected theorem smul_def {A} [AddMonoid A] (f : AddAut A) (a : A) : f • a = f a :=
  rfl
#align add_aut.smul_def AddAut.smul_def

/- warning: add_aut.apply_has_faithful_smul -> AddAut.apply_faithfulSMul is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A], FaithfulSMul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (SMulZeroClass.toHasSmul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2)) (DistribSMul.toSmulZeroClass.{u1, u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (AddMonoid.toAddZeroClass.{u1} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (AddAut.group.{u1} A (AddZeroClass.toHasAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))))) _inst_2 (AddAut.applyDistribMulAction.{u1} A _inst_2))))
but is expected to have type
  forall {A : Type.{u1}} [_inst_2 : AddMonoid.{u1} A], FaithfulSMul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (SMulZeroClass.toSMul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (AddMonoid.toZero.{u1} A _inst_2) (DistribSMul.toSMulZeroClass.{u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (AddMonoid.toAddZeroClass.{u1} A _inst_2) (DistribMulAction.toDistribSMul.{u1, u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) A (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))) (AddAut.group.{u1} A (AddZeroClass.toAdd.{u1} A (AddMonoid.toAddZeroClass.{u1} A _inst_2))))) _inst_2 (AddAut.applyDistribMulAction.{u1} A _inst_2))))
Case conversion may be inaccurate. Consider using '#align add_aut.apply_has_faithful_smul AddAut.apply_faithfulSMulₓ'. -/
/-- `add_aut.apply_distrib_mul_action` is faithful. -/
instance apply_faithfulSMul {A} [AddMonoid A] : FaithfulSMul (AddAut A) A :=
  ⟨fun _ _ => AddEquiv.ext⟩
#align add_aut.apply_has_faithful_smul AddAut.apply_faithfulSMul

/- warning: add_aut.conj -> AddAut.conj is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_2 : AddGroup.{u1} G], AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))
but is expected to have type
  forall {G : Type.{u1}} [_inst_2 : AddGroup.{u1} G], AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))
Case conversion may be inaccurate. Consider using '#align add_aut.conj AddAut.conjₓ'. -/
/-- Additive group conjugation, `add_aut.conj g h = g + h - g`, as an additive monoid
homomorphism mapping addition in `G` into multiplication in the automorphism group `add_aut G`
(written additively in order to define the map). -/
def conj [AddGroup G] : G →+ Additive (AddAut G)
    where
  toFun g :=
    @Additive.ofMul (AddAut G)
      { toFun := fun h => g + h + -g
        -- this definition is chosen to match `mul_aut.conj`
        invFun := fun h => -g + h + g
        left_inv := fun _ => by simp [add_assoc]
        right_inv := fun _ => by simp [add_assoc]
        map_add' := by simp [add_assoc] }
  map_add' _ _ := by apply additive.to_mul.injective <;> ext <;> simp [add_assoc]
  map_zero' := by ext <;> simpa
#align add_aut.conj AddAut.conj

/- warning: add_aut.conj_apply -> AddAut.conj_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_2 : AddGroup.{u1} G] (g : G) (h : G), Eq.{succ u1} G (coeFn.{succ u1, succ u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (fun (a : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => G -> G) (Additive.coeToFun.{u1, succ u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (fun (_x : AddEquiv.{u1, u1} G G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) => G -> G) (AddEquiv.hasCoeToFun.{u1, u1} G G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (fun (_x : AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) => G -> (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))) (AddMonoidHom.hasCoeToFun.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddAut.conj.{u1} G _inst_2) g) h) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) g h) (Neg.neg.{u1} G (SubNegMonoid.toHasNeg.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)) g))
but is expected to have type
  forall {G : Type.{u1}} [_inst_2 : AddGroup.{u1} G] (g : G) (h : G), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) h) (FunLike.coe.{succ u1, succ u1, succ u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) G (fun (a : G) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) G G (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) G G (AddEquivClass.toEquivLike.{u1, u1, u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (fun (_x : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.toMul.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) h) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) g h) (Neg.neg.{u1} G (NegZeroClass.toNeg.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_2)))) g))
Case conversion may be inaccurate. Consider using '#align add_aut.conj_apply AddAut.conj_applyₓ'. -/
@[simp]
theorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g :=
  rfl
#align add_aut.conj_apply AddAut.conj_apply

/- warning: add_aut.conj_symm_apply -> AddAut.conj_symm_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_2 : AddGroup.{u1} G] (g : G) (h : G), Eq.{succ u1} G (coeFn.{succ u1, succ u1} (AddEquiv.{u1, u1} G G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (fun (_x : AddEquiv.{u1, u1} G G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) => G -> G) (AddEquiv.hasCoeToFun.{u1, u1} G G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddEquiv.symm.{u1, u1} G G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (fun (_x : AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) => G -> (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))) (AddMonoidHom.hasCoeToFun.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddAut.conj.{u1} G _inst_2) g)) h) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Neg.neg.{u1} G (SubNegMonoid.toHasNeg.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)) g) h) g)
but is expected to have type
  forall {G : Type.{u1}} [_inst_2 : AddGroup.{u1} G] (g : G) (h : G), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) h) (FunLike.coe.{succ u1, succ u1, succ u1} (AddEquiv.{u1, u1} G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) G (fun (_x : G) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (AddEquiv.{u1, u1} G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) G G (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (AddEquiv.{u1, u1} G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) G G (AddEquivClass.toEquivLike.{u1, u1, u1} (AddEquiv.{u1, u1} G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))) (AddEquiv.symm.{u1, u1} G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (_x : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) h) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Neg.neg.{u1} G (NegZeroClass.toNeg.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_2)))) g) h) g)
Case conversion may be inaccurate. Consider using '#align add_aut.conj_symm_apply AddAut.conj_symm_applyₓ'. -/
@[simp]
theorem conj_symm_apply [AddGroup G] (g h : G) : (conj g).symm h = -g + h + g :=
  rfl
#align add_aut.conj_symm_apply AddAut.conj_symm_apply

/- warning: add_aut.conj_inv_apply -> AddAut.conj_inv_apply is a dubious translation:
lean 3 declaration is
  forall {G : Type.{u1}} [_inst_2 : AddGroup.{u1} G] (g : G) (h : G), Eq.{succ u1} G (coeFn.{succ u1, succ u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (fun (a : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => G -> G) (Additive.coeToFun.{u1, succ u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (fun (_x : AddEquiv.{u1, u1} G G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) => G -> G) (AddEquiv.hasCoeToFun.{u1, u1} G G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Neg.neg.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.hasNeg.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toHasInv.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (fun (_x : AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) => G -> (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))) (AddMonoidHom.hasCoeToFun.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddAut.conj.{u1} G _inst_2) g)) h) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toHasAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Neg.neg.{u1} G (SubNegMonoid.toHasNeg.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)) g) h) g)
but is expected to have type
  forall {G : Type.{u1}} [_inst_2 : AddGroup.{u1} G] (g : G) (h : G), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) h) (FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) G (fun (a : G) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : G) => G) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) G G (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) G G (AddEquivClass.toEquivLike.{u1, u1, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddEquiv.instAddEquivClassAddEquiv.{u1, u1} G G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))) (Inv.inv.{u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) (InvOneClass.toInv.{u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) (DivInvOneMonoid.toInvOneClass.{u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) (DivisionMonoid.toDivInvOneMonoid.{u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) (Group.toDivisionMonoid.{u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g)) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (fun (_x : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.805 : Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) => AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.toMul.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (fun (a : G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : G) => Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) a) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))) (AddZeroClass.toAdd.{u1} (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))) G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))))))) (AddMonoidHom.addMonoidHomClass.{u1, u1} G (Additive.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))) (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))) (Additive.addZeroClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Monoid.toMulOneClass.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (DivInvMonoid.toMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Group.toDivInvMonoid.{u1} (AddAut.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (AddAut.group.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2)))))))))))) (AddAut.conj.{u1} G _inst_2) g))) h) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (HAdd.hAdd.{u1, u1, u1} G G G (instHAdd.{u1} G (AddZeroClass.toAdd.{u1} G (AddMonoid.toAddZeroClass.{u1} G (SubNegMonoid.toAddMonoid.{u1} G (AddGroup.toSubNegMonoid.{u1} G _inst_2))))) (Neg.neg.{u1} G (NegZeroClass.toNeg.{u1} G (SubNegZeroMonoid.toNegZeroClass.{u1} G (SubtractionMonoid.toSubNegZeroMonoid.{u1} G (AddGroup.toSubtractionMonoid.{u1} G _inst_2)))) g) h) g)
Case conversion may be inaccurate. Consider using '#align add_aut.conj_inv_apply AddAut.conj_inv_applyₓ'. -/
@[simp]
theorem conj_inv_apply [AddGroup G] (g h : G) : (-conj g) h = -g + h + g :=
  rfl
#align add_aut.conj_inv_apply AddAut.conj_inv_apply

end AddAut

