/-
Copyright (c) 2019 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston, Jireh Loreaux

! This file was ported from Lean 3 source module algebra.hom.ring
! leanprover-community/mathlib commit 706d88f2b8fdfeb0b22796433d7a6c1a010af9f2
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.GroupWithZero.InjSurj
import Mathbin.Algebra.Ring.Basic
import Mathbin.Algebra.Divisibility.Basic
import Mathbin.Data.Pi.Algebra
import Mathbin.Algebra.Hom.Units
import Mathbin.Data.Set.Image

/-!
# Homomorphisms of semirings and rings

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> https://github.com/leanprover-community/mathlib4/pull/958
> Any changes to this file require a corresponding PR to mathlib4.

This file defines bundled homomorphisms of (non-unital) semirings and rings. As with monoid and
groups, we use the same structure `ring_hom a β`, a.k.a. `α →+* β`, for both types of homomorphisms.

The unbundled homomorphisms are defined in `deprecated.ring`. They are deprecated and the plan is to
slowly remove them from mathlib.

## Main definitions

* `non_unital_ring_hom`: Non-unital (semi)ring homomorphisms. Additive monoid homomorphism which
  preserve multiplication.
* `ring_hom`: (Semi)ring homomorphisms. Monoid homomorphisms which are also additive monoid
  homomorphism.

## Notations

* `→ₙ+*`: Non-unital (semi)ring homs
* `→+*`: (Semi)ring homs

## Implementation notes

* There's a coercion from bundled homs to fun, and the canonical notation is to
  use the bundled hom as a function via this coercion.

* There is no `semiring_hom` -- the idea is that `ring_hom` is used.
  The constructor for a `ring_hom` between semirings needs a proof of `map_zero`,
  `map_one` and `map_add` as well as `map_mul`; a separate constructor
  `ring_hom.mk'` will construct ring homs between rings from monoid homs given
  only a proof that addition is preserved.

## Tags

`ring_hom`, `semiring_hom`
-/


open Function

variable {F α β γ : Type _}

#print NonUnitalRingHom /-
/-- Bundled non-unital semiring homomorphisms `α →ₙ+* β`; use this for bundled non-unital ring
homomorphisms too.

When possible, instead of parametrizing results over `(f : α →ₙ+* β)`,
you should parametrize over `(F : Type*) [non_unital_ring_hom_class F α β] (f : F)`.

When you extend this structure, make sure to extend `non_unital_ring_hom_class`. -/
structure NonUnitalRingHom (α β : Type _) [NonUnitalNonAssocSemiring α]
  [NonUnitalNonAssocSemiring β] extends α →ₙ* β, α →+ β
#align non_unital_ring_hom NonUnitalRingHom
-/

-- mathport name: «expr →ₙ+* »
infixr:25 " →ₙ+* " => NonUnitalRingHom

/-- Reinterpret a non-unital ring homomorphism `f : α →ₙ+* β` as a semigroup
homomorphism `α →ₙ* β`. The `simp`-normal form is `(f : α →ₙ* β)`. -/
add_decl_doc NonUnitalRingHom.toMulHom

/-- Reinterpret a non-unital ring homomorphism `f : α →ₙ+* β` as an additive
monoid homomorphism `α →+ β`. The `simp`-normal form is `(f : α →+ β)`. -/
add_decl_doc NonUnitalRingHom.toAddMonoidHom

section NonUnitalRingHomClass

#print NonUnitalRingHomClass /-
/-- `non_unital_ring_hom_class F α β` states that `F` is a type of non-unital (semi)ring
homomorphisms. You should extend this class when you extend `non_unital_ring_hom`. -/
class NonUnitalRingHomClass (F : Type _) (α β : outParam (Type _)) [NonUnitalNonAssocSemiring α]
  [NonUnitalNonAssocSemiring β] extends MulHomClass F α β, AddMonoidHomClass F α β
#align non_unital_ring_hom_class NonUnitalRingHomClass
-/

variable [NonUnitalNonAssocSemiring α] [NonUnitalNonAssocSemiring β] [NonUnitalRingHomClass F α β]

instance : CoeTC F (α →ₙ+* β) :=
  ⟨fun f =>
    { toFun := f
      map_zero' := map_zero f
      map_mul' := map_mul f
      map_add' := map_add f }⟩

end NonUnitalRingHomClass

namespace NonUnitalRingHom

section coe

/-!
Throughout this section, some `semiring` arguments are specified with `{}` instead of `[]`.
See note [implicit instance arguments].
-/


variable {rα : NonUnitalNonAssocSemiring α} {rβ : NonUnitalNonAssocSemiring β}

include rα rβ

instance : NonUnitalRingHomClass (α →ₙ+* β) α
      β where 
  coe := NonUnitalRingHom.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
  map_add := NonUnitalRingHom.map_add'
  map_zero := NonUnitalRingHom.map_zero'
  map_mul := NonUnitalRingHom.map_mul'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (α →ₙ+* β) fun _ => α → β :=
  ⟨NonUnitalRingHom.toFun⟩

/- warning: non_unital_ring_hom.to_fun_eq_coe clashes with [anonymous] -> [anonymous]
warning: non_unital_ring_hom.to_fun_eq_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_2}} {β : Type.{u_3}} {rα : NonUnitalNonAssocSemiring.{u_2} α} {rβ : NonUnitalNonAssocSemiring.{u_3} β} (f : NonUnitalRingHom.{u_2, u_3} α β rα rβ), Eq.{max (succ u_2) (succ u_3)} (α -> β) (NonUnitalRingHom.toFun.{u_2, u_3} α β rα rβ f) (coeFn.{max (succ u_2) (succ u_3), max (succ u_2) (succ u_3)} (NonUnitalRingHom.{u_2, u_3} α β rα rβ) (fun (_x : NonUnitalRingHom.{u_2, u_3} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u_2, u_3} α β rα rβ) f)
but is expected to have type
  forall {α : Sort.{u}} {β : Nat}, ((Eq.{1} Nat β (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> α) -> (forall (m : Nat), (Eq.{1} Nat β (Nat.succ m)) -> α) -> α
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.to_fun_eq_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (f : α →ₙ+* β) : f.toFun = f :=
  rfl
#align non_unital_ring_hom.to_fun_eq_coe[anonymous]

/- warning: non_unital_ring_hom.coe_mk clashes with [anonymous] -> [anonymous]
warning: non_unital_ring_hom.coe_mk -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_2}} {β : Type.{u_3}} {rα : NonUnitalNonAssocSemiring.{u_2} α} {rβ : NonUnitalNonAssocSemiring.{u_3} β} (f : α -> β) (h₁ : forall (x : α) (y : α), Eq.{succ u_3} β (f (HMul.hMul.{u_2, u_2, u_2} α α α (instHMul.{u_2} α (Distrib.toHasMul.{u_2} α (NonUnitalNonAssocSemiring.toDistrib.{u_2} α rα))) x y)) (HMul.hMul.{u_3, u_3, u_3} β β β (instHMul.{u_3} β (Distrib.toHasMul.{u_3} β (NonUnitalNonAssocSemiring.toDistrib.{u_3} β rβ))) (f x) (f y))) (h₂ : Eq.{succ u_3} β (f (OfNat.ofNat.{u_2} α 0 (OfNat.mk.{u_2} α 0 (Zero.zero.{u_2} α (AddZeroClass.toHasZero.{u_2} α (AddMonoid.toAddZeroClass.{u_2} α (AddCommMonoid.toAddMonoid.{u_2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u_2} α rα)))))))) (OfNat.ofNat.{u_3} β 0 (OfNat.mk.{u_3} β 0 (Zero.zero.{u_3} β (AddZeroClass.toHasZero.{u_3} β (AddMonoid.toAddZeroClass.{u_3} β (AddCommMonoid.toAddMonoid.{u_3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u_3} β rβ)))))))) (h₃ : forall (x : α) (y : α), Eq.{succ u_3} β (f (HAdd.hAdd.{u_2, u_2, u_2} α α α (instHAdd.{u_2} α (AddZeroClass.toHasAdd.{u_2} α (AddMonoid.toAddZeroClass.{u_2} α (AddCommMonoid.toAddMonoid.{u_2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u_2} α rα))))) x y)) (HAdd.hAdd.{u_3, u_3, u_3} β β β (instHAdd.{u_3} β (AddZeroClass.toHasAdd.{u_3} β (AddMonoid.toAddZeroClass.{u_3} β (AddCommMonoid.toAddMonoid.{u_3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u_3} β rβ))))) (f x) (f y))), Eq.{max (succ u_2) (succ u_3)} (α -> β) (coeFn.{max (succ u_2) (succ u_3), max (succ u_2) (succ u_3)} (NonUnitalRingHom.{u_2, u_3} α β rα rβ) (fun (_x : NonUnitalRingHom.{u_2, u_3} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u_2, u_3} α β rα rβ) (NonUnitalRingHom.mk.{u_2, u_3} α β rα rβ f h₁ h₂ h₃)) f
but is expected to have type
  forall {α : Sort.{u}} {β : Nat}, ((Eq.{1} Nat β (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> α) -> (forall (m : Nat), (Eq.{1} Nat β (Nat.succ m)) -> α) -> α
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_mk [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] (f : α → β) (h₁ h₂ h₃) : ⇑(⟨f, h₁, h₂, h₃⟩ : α →ₙ+* β) = f :=
  rfl
#align non_unital_ring_hom.coe_mk[anonymous]

/- warning: non_unital_ring_hom.coe_coe clashes with [anonymous] -> [anonymous]
warning: non_unital_ring_hom.coe_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u_1}} {α : Type.{u_2}} {β : Type.{u_3}} {rα : NonUnitalNonAssocSemiring.{u_2} α} {rβ : NonUnitalNonAssocSemiring.{u_3} β} [_inst_1 : NonUnitalRingHomClass.{u_1, u_2, u_3} F α β rα rβ] (f : F), Eq.{max (succ u_2) (succ u_3)} ((fun (_x : NonUnitalRingHom.{u_2, u_3} α β rα rβ) => α -> β) ((fun (a : Type.{u_1}) (b : Sort.{max (succ u_2) (succ u_3)}) [self : HasLiftT.{succ u_1, max (succ u_2) (succ u_3)} a b] => self.0) F (NonUnitalRingHom.{u_2, u_3} α β rα rβ) (HasLiftT.mk.{succ u_1, max (succ u_2) (succ u_3)} F (NonUnitalRingHom.{u_2, u_3} α β rα rβ) (CoeTCₓ.coe.{succ u_1, max (succ u_2) (succ u_3)} F (NonUnitalRingHom.{u_2, u_3} α β rα rβ) (NonUnitalRingHom.hasCoeT.{u_1, u_2, u_3} F α β rα rβ _inst_1))) f)) (coeFn.{max (succ u_2) (succ u_3), max (succ u_2) (succ u_3)} (NonUnitalRingHom.{u_2, u_3} α β rα rβ) (fun (_x : NonUnitalRingHom.{u_2, u_3} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u_2, u_3} α β rα rβ) ((fun (a : Type.{u_1}) (b : Sort.{max (succ u_2) (succ u_3)}) [self : HasLiftT.{succ u_1, max (succ u_2) (succ u_3)} a b] => self.0) F (NonUnitalRingHom.{u_2, u_3} α β rα rβ) (HasLiftT.mk.{succ u_1, max (succ u_2) (succ u_3)} F (NonUnitalRingHom.{u_2, u_3} α β rα rβ) (CoeTCₓ.coe.{succ u_1, max (succ u_2) (succ u_3)} F (NonUnitalRingHom.{u_2, u_3} α β rα rβ) (NonUnitalRingHom.hasCoeT.{u_1, u_2, u_3} F α β rα rβ _inst_1))) f)) (coeFn.{succ u_1, max (succ u_2) (succ u_3)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u_1, succ u_2, succ u_3} F α (fun (_x : α) => β) (MulHomClass.toFunLike.{u_1, u_2, u_3} F α β (Distrib.toHasMul.{u_2} α (NonUnitalNonAssocSemiring.toDistrib.{u_2} α rα)) (Distrib.toHasMul.{u_3} β (NonUnitalNonAssocSemiring.toDistrib.{u_3} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{u_1, u_2, u_3} F α β rα rβ _inst_1))) f)
but is expected to have type
  forall {F : Sort.{u}} {α : Nat}, ((Eq.{1} Nat α (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> F) -> (forall (m : Nat), (Eq.{1} Nat α (Nat.succ m)) -> F) -> F
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_coe [anonymous]ₓ'. -/
@[simp]
theorem [anonymous] [NonUnitalRingHomClass F α β] (f : F) : ((f : α →ₙ+* β) : α → β) = f :=
  rfl
#align non_unital_ring_hom.coe_coe[anonymous]

/- warning: non_unital_ring_hom.coe_to_mul_hom -> NonUnitalRingHom.coe_to_mulHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : NonUnitalRingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (fun (_x : MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) => α -> β) (MulHom.hasCoeToFun.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (NonUnitalRingHom.toMulHom.{u1, u2} α β rα rβ f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonUnitalNonAssocSemiring.{u2} α} {rβ : NonUnitalNonAssocSemiring.{u1} β} (f : NonUnitalRingHom.{u2, u1} α β rα rβ), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulHom.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MulHom.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ)) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (MulHom.mulHomClass.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ))) (NonUnitalRingHom.toMulHom.{u2, u1} α β rα rβ f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_to_mul_hom NonUnitalRingHom.coe_to_mulHomₓ'. -/
@[simp]
theorem coe_to_mulHom (f : α →ₙ+* β) : ⇑f.toMulHom = f :=
  rfl
#align non_unital_ring_hom.coe_to_mul_hom NonUnitalRingHom.coe_to_mulHom

/- warning: non_unital_ring_hom.coe_mul_hom_mk -> NonUnitalRingHom.coe_mulHom_mk is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : α -> β) (h₁ : forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (f x) (f y))) (h₂ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))))))) (h₃ : forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))))) (f x) (f y))), Eq.{max (succ u2) (succ u1)} (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (NonUnitalRingHom.{u1, u2} α β rα rβ) (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (MulHom.hasCoeT.{u1, u2, max u1 u2} α β (NonUnitalRingHom.{u1, u2} α β rα rβ) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} α β rα rβ))))) (NonUnitalRingHom.mk.{u1, u2} α β rα rβ f h₁ h₂ h₃)) (MulHom.mk.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ)) f h₁)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : α -> β) (h₁ : forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α rα)) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (NonUnitalNonAssocSemiring.toMul.{u2} β rβ)) (f x) (f y))) (h₂ : Eq.{succ u2} β (MulHom.toFun.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (AddZeroClass.toZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))))))) (h₃ : forall (x : α) (y : α), Eq.{succ u2} β (MulHom.toFun.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))))) (MulHom.toFun.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) x) (MulHom.toFun.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) y))), Eq.{max (succ u1) (succ u2)} (MulHom.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ)) (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (FunLike.coe.{succ (max u1 u2), succ u1, succ u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} α β rα rβ))) (NonUnitalRingHom.mk.{u1, u2} α β rα rβ (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) h₂ h₃)) (map_mul.{u2, u1, max u1 u2} α β (NonUnitalRingHom.{u1, u2} α β rα rβ) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} α β rα rβ)) (NonUnitalRingHom.mk.{u1, u2} α β rα rβ (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) h₂ h₃))) (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_mul_hom_mk NonUnitalRingHom.coe_mulHom_mkₓ'. -/
@[simp]
theorem coe_mulHom_mk (f : α → β) (h₁ h₂ h₃) : ((⟨f, h₁, h₂, h₃⟩ : α →ₙ+* β) : α →ₙ* β) = ⟨f, h₁⟩ :=
  rfl
#align non_unital_ring_hom.coe_mul_hom_mk NonUnitalRingHom.coe_mulHom_mk

/- warning: non_unital_ring_hom.coe_to_add_monoid_hom -> NonUnitalRingHom.coe_toAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : NonUnitalRingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (fun (_x : AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) => α -> β) (AddMonoidHom.hasCoeToFun.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (NonUnitalRingHom.toAddMonoidHom.{u1, u2} α β rα rβ f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonUnitalNonAssocSemiring.{u2} α} {rβ : NonUnitalNonAssocSemiring.{u1} β} (f : NonUnitalRingHom.{u2, u1} α β rα rβ), Eq.{max (succ u2) (succ u1)} (MulHom.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ)) (NonUnitalRingHom.toMulHom.{u2, u1} α β rα rβ f) (MulHom.mk.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f) (map_mul.{u1, u2, max u2 u1} α β (NonUnitalRingHom.{u2, u1} α β rα rβ) (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ)) f))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_to_add_monoid_hom NonUnitalRingHom.coe_toAddMonoidHomₓ'. -/
@[simp]
theorem coe_toAddMonoidHom (f : α →ₙ+* β) : ⇑f.toAddMonoidHom = f :=
  rfl
#align non_unital_ring_hom.coe_to_add_monoid_hom NonUnitalRingHom.coe_toAddMonoidHom

/- warning: non_unital_ring_hom.coe_add_monoid_hom_mk -> NonUnitalRingHom.coe_addMonoidHom_mk is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : α -> β) (h₁ : forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (f x) (f y))) (h₂ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))))))) (h₃ : forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))))) (f x) (f y))), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (AddMonoidHom.hasCoeT.{u1, u2, max u1 u2} α β (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} α β rα rβ))))) (NonUnitalRingHom.mk.{u1, u2} α β rα rβ f h₁ h₂ h₃)) (AddMonoidHom.mk.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) f h₂ h₃)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : α -> β) (h₁ : forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α rα)) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (NonUnitalNonAssocSemiring.toMul.{u2} β rβ)) (f x) (f y))) (h₂ : Eq.{succ u2} β (MulHom.toFun.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (AddZeroClass.toZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))))))) (h₃ : forall (x : α) (y : α), Eq.{succ u2} β (MulHom.toFun.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))))) (MulHom.toFun.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) x) (MulHom.toFun.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) y))), Eq.{max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (AddMonoidHom.mk.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (ZeroHom.mk.{u1, u2} α β (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddZeroClass.toZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (FunLike.coe.{succ (max u1 u2), succ u1, succ u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => β) a) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} α β rα rβ)))) (NonUnitalRingHom.mk.{u1, u2} α β rα rβ (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) h₂ h₃)) (instCoeTCAddMonoidHom_1.proof_1.{u2, u1, max u1 u2} α β (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} α β rα rβ)) (NonUnitalRingHom.mk.{u1, u2} α β rα rβ (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) h₂ h₃))) (instCoeTCAddMonoidHom_1.proof_2.{u2, u1, max u1 u2} α β (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} α β rα rβ)) (NonUnitalRingHom.mk.{u1, u2} α β rα rβ (MulHom.mk.{u1, u2} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) f h₁) h₂ h₃))) (AddMonoidHom.mk.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (ZeroHom.mk.{u1, u2} α β (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddZeroClass.toZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) f h₂) h₃)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_add_monoid_hom_mk NonUnitalRingHom.coe_addMonoidHom_mkₓ'. -/
@[simp]
theorem coe_addMonoidHom_mk (f : α → β) (h₁ h₂ h₃) :
    ((⟨f, h₁, h₂, h₃⟩ : α →ₙ+* β) : α →+ β) = ⟨f, h₂, h₃⟩ :=
  rfl
#align non_unital_ring_hom.coe_add_monoid_hom_mk NonUnitalRingHom.coe_addMonoidHom_mk

/- warning: non_unital_ring_hom.copy -> NonUnitalRingHom.copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : NonUnitalRingHom.{u1, u2} α β rα rβ) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)) -> (NonUnitalRingHom.{u1, u2} α β rα rβ)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : NonUnitalRingHom.{u1, u2} α β rα rβ) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} α β rα rβ))) f)) -> (NonUnitalRingHom.{u1, u2} α β rα rβ)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.copy NonUnitalRingHom.copyₓ'. -/
/-- Copy of a `ring_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def copy (f : α →ₙ+* β) (f' : α → β) (h : f' = f) : α →ₙ+* β :=
  { f.toMulHom.copy f' h, f.toAddMonoidHom.copy f' h with }
#align non_unital_ring_hom.copy NonUnitalRingHom.copy

/- warning: non_unital_ring_hom.coe_copy -> NonUnitalRingHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : NonUnitalRingHom.{u1, u2} α β rα rβ) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) (NonUnitalRingHom.copy.{u1, u2} α β rα rβ f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonUnitalNonAssocSemiring.{u2} α} {rβ : NonUnitalNonAssocSemiring.{u1} β} (f : NonUnitalRingHom.{u2, u1} α β rα rβ) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) (NonUnitalRingHom.copy.{u2, u1} α β rα rβ f f' h)) f'
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_copy NonUnitalRingHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : α →ₙ+* β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align non_unital_ring_hom.coe_copy NonUnitalRingHom.coe_copy

/- warning: non_unital_ring_hom.copy_eq -> NonUnitalRingHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : NonUnitalRingHom.{u1, u2} α β rα rβ) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)), Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (NonUnitalRingHom.copy.{u1, u2} α β rα rβ f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonUnitalNonAssocSemiring.{u2} α} {rβ : NonUnitalNonAssocSemiring.{u1} β} (f : NonUnitalRingHom.{u2, u1} α β rα rβ) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f)), Eq.{max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} α β rα rβ) (NonUnitalRingHom.copy.{u2, u1} α β rα rβ f f' h) f
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.copy_eq NonUnitalRingHom.copy_eqₓ'. -/
theorem copy_eq (f : α →ₙ+* β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align non_unital_ring_hom.copy_eq NonUnitalRingHom.copy_eq

end coe

variable [rα : NonUnitalNonAssocSemiring α] [rβ : NonUnitalNonAssocSemiring β]

section

include rα rβ

variable (f : α →ₙ+* β) {x y : α} {rα rβ}

/- warning: non_unital_ring_hom.ext -> NonUnitalRingHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} {{f : NonUnitalRingHom.{u1, u2} α β rα rβ}} {{g : NonUnitalRingHom.{u1, u2} α β rα rβ}}, (forall (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) g x)) -> (Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonUnitalNonAssocSemiring.{u2} α} {rβ : NonUnitalNonAssocSemiring.{u1} β} {{f : NonUnitalRingHom.{u2, u1} α β rα rβ}} {{g : NonUnitalRingHom.{u2, u1} α β rα rβ}}, (forall (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) g x)) -> (Eq.{max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} α β rα rβ) f g)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.ext NonUnitalRingHom.extₓ'. -/
@[ext]
theorem ext ⦃f g : α →ₙ+* β⦄ : (∀ x, f x = g x) → f = g :=
  FunLike.ext _ _
#align non_unital_ring_hom.ext NonUnitalRingHom.ext

/- warning: non_unital_ring_hom.ext_iff -> NonUnitalRingHom.ext_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} {f : NonUnitalRingHom.{u1, u2} α β rα rβ} {g : NonUnitalRingHom.{u1, u2} α β rα rβ}, Iff (Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) f g) (forall (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) g x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonUnitalNonAssocSemiring.{u2} α} {rβ : NonUnitalNonAssocSemiring.{u1} β} {f : NonUnitalRingHom.{u2, u1} α β rα rβ} {g : NonUnitalRingHom.{u2, u1} α β rα rβ}, Iff (Eq.{max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} α β rα rβ) f g) (forall (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) g x))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.ext_iff NonUnitalRingHom.ext_iffₓ'. -/
theorem ext_iff {f g : α →ₙ+* β} : f = g ↔ ∀ x, f x = g x :=
  FunLike.ext_iff
#align non_unital_ring_hom.ext_iff NonUnitalRingHom.ext_iff

/- warning: non_unital_ring_hom.mk_coe -> NonUnitalRingHom.mk_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β} (f : NonUnitalRingHom.{u1, u2} α β rα rβ) (h₁ : forall (x : α) (y : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f y))) (h₂ : Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))))))) (h₃ : forall (x : α) (y : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f y))), Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (NonUnitalRingHom.mk.{u1, u2} α β rα rβ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f) h₁ h₂ h₃) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonUnitalNonAssocSemiring.{u2} α} {rβ : NonUnitalNonAssocSemiring.{u1} β} (f : NonUnitalRingHom.{u2, u1} α β rα rβ) (h₁ : forall (x : α) (y : α), Eq.{succ u1} β (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α rα)) x y)) (HMul.hMul.{u1, u1, u1} β β β (instHMul.{u1} β (NonUnitalNonAssocSemiring.toMul.{u1} β rβ)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f y))) (h₂ : Eq.{succ u1} β (MulHom.toFun.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (MulHom.mk.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f) h₁) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (AddZeroClass.toZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α rα))))))) (OfNat.ofNat.{u1} β 0 (Zero.toOfNat0.{u1} β (AddZeroClass.toZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} β rβ))))))) (h₃ : forall (x : α) (y : α), Eq.{succ u1} β (MulHom.toFun.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (MulHom.mk.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f) h₁) (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α rα))))) x y)) (HAdd.hAdd.{u1, u1, u1} β β β (instHAdd.{u1} β (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} β rβ))))) (MulHom.toFun.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (MulHom.mk.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f) h₁) x) (MulHom.toFun.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (MulHom.mk.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f) h₁) y))), Eq.{max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} α β rα rβ) (NonUnitalRingHom.mk.{u2, u1} α β rα rβ (MulHom.mk.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f) h₁) h₂ h₃) f
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.mk_coe NonUnitalRingHom.mk_coeₓ'. -/
@[simp]
theorem mk_coe (f : α →ₙ+* β) (h₁ h₂ h₃) : NonUnitalRingHom.mk f h₁ h₂ h₃ = f :=
  ext fun _ => rfl
#align non_unital_ring_hom.mk_coe NonUnitalRingHom.mk_coe

/- warning: non_unital_ring_hom.coe_add_monoid_hom_injective -> NonUnitalRingHom.coe_addMonoidHom_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β}, Function.Injective.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (AddMonoidHom.hasCoeT.{u1, u2, max u1 u2} α β (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} α β rα rβ))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonUnitalNonAssocSemiring.{u2} α} {rβ : NonUnitalNonAssocSemiring.{u1} β}, Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} α β rα rβ) (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α rα))) (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} β rβ)))) (fun (f : NonUnitalRingHom.{u2, u1} α β rα rβ) => AddMonoidHom.mk.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α rα))) (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} β rβ))) (ZeroHom.mk.{u2, u1} α β (AddZeroClass.toZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α rα)))) (AddZeroClass.toZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} β rβ)))) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => β) a) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α rα)))) (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} β rβ)))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α rα))) (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ)))) f) (instCoeTCAddMonoidHom_1.proof_1.{u1, u2, max u2 u1} α β (NonUnitalRingHom.{u2, u1} α β rα rβ) (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α rα))) (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ)) f)) (instCoeTCAddMonoidHom_1.proof_2.{u1, u2, max u2 u1} α β (NonUnitalRingHom.{u2, u1} α β rα rβ) (AddMonoid.toAddZeroClass.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α rα))) (AddMonoid.toAddZeroClass.{u1} β (AddCommMonoid.toAddMonoid.{u1} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ)) f))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_add_monoid_hom_injective NonUnitalRingHom.coe_addMonoidHom_injectiveₓ'. -/
theorem coe_addMonoidHom_injective : Injective (coe : (α →ₙ+* β) → α →+ β) := fun f g h =>
  ext <| AddMonoidHom.congr_fun h
#align non_unital_ring_hom.coe_add_monoid_hom_injective NonUnitalRingHom.coe_addMonoidHom_injective

/- warning: non_unital_ring_hom.coe_mul_hom_injective -> NonUnitalRingHom.coe_mulHom_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonUnitalNonAssocSemiring.{u1} α} {rβ : NonUnitalNonAssocSemiring.{u2} β}, Function.Injective.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (NonUnitalRingHom.{u1, u2} α β rα rβ) (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (MulHom.hasCoeT.{u1, u2, max u1 u2} α β (NonUnitalRingHom.{u1, u2} α β rα rβ) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} α β rα rβ))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonUnitalNonAssocSemiring.{u2} α} {rβ : NonUnitalNonAssocSemiring.{u1} β}, Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} α β rα rβ) (MulHom.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ)) (fun (f : NonUnitalRingHom.{u2, u1} α β rα rβ) => MulHom.mk.{u2, u1} α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) f) (map_mul.{u1, u2, max u2 u1} α β (NonUnitalRingHom.{u2, u1} α β rα rβ) (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ)) f))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_mul_hom_injective NonUnitalRingHom.coe_mulHom_injectiveₓ'. -/
theorem coe_mulHom_injective : Injective (coe : (α →ₙ+* β) → α →ₙ* β) := fun f g h =>
  ext <| MulHom.congr_fun h
#align non_unital_ring_hom.coe_mul_hom_injective NonUnitalRingHom.coe_mulHom_injective

end

#print NonUnitalRingHom.id /-
/-- The identity non-unital ring homomorphism from a non-unital semiring to itself. -/
protected def id (α : Type _) [NonUnitalNonAssocSemiring α] : α →ₙ+* α := by
  refine' { toFun := id.. } <;> intros <;> rfl
#align non_unital_ring_hom.id NonUnitalRingHom.id
-/

include rα rβ

instance : Zero (α →ₙ+* β) :=
  ⟨{  toFun := 0
      map_mul' := fun x y => (mul_zero (0 : β)).symm
      map_zero' := rfl
      map_add' := fun x y => (add_zero (0 : β)).symm }⟩

instance : Inhabited (α →ₙ+* β) :=
  ⟨0⟩

/- warning: non_unital_ring_hom.coe_zero -> NonUnitalRingHom.coe_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β], Eq.{succ (max u1 u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), succ (max u1 u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) (OfNat.ofNat.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) 0 (OfNat.mk.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) 0 (Zero.zero.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) (NonUnitalRingHom.hasZero.{u1, u2} α β rα rβ))))) (OfNat.ofNat.{max u1 u2} (α -> β) 0 (OfNat.mk.{max u1 u2} (α -> β) 0 (Zero.zero.{max u1 u2} (α -> β) (Pi.instZero.{u1, u2} α (fun (ᾰ : α) => β) (fun (i : α) => MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β rβ))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u2} α] [rβ : NonUnitalNonAssocSemiring.{u1} β], Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u2, u1} α β rα rβ))) (OfNat.ofNat.{max u2 u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) 0 (Zero.toOfNat0.{max u2 u1} (NonUnitalRingHom.{u2, u1} α β rα rβ) (NonUnitalRingHom.instZeroNonUnitalRingHom.{u2, u1} α β rα rβ)))) (OfNat.ofNat.{max u2 u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) ᾰ) 0 (Zero.toOfNat0.{max u2 u1} (forall (a : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (Pi.instZero.{u2, u1} α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (fun (i : α) => MulZeroClass.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) i) (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) i) rβ)))))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_zero NonUnitalRingHom.coe_zeroₓ'. -/
@[simp]
theorem coe_zero : ⇑(0 : α →ₙ+* β) = 0 :=
  rfl
#align non_unital_ring_hom.coe_zero NonUnitalRingHom.coe_zero

/- warning: non_unital_ring_hom.zero_apply -> NonUnitalRingHom.zero_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) (OfNat.ofNat.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) 0 (OfNat.mk.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) 0 (Zero.zero.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) (NonUnitalRingHom.hasZero.{u1, u2} α β rα rβ)))) x) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β rβ)))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} α β rα rβ))) (OfNat.ofNat.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) 0 (Zero.toOfNat0.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) (NonUnitalRingHom.instZeroNonUnitalRingHom.{u1, u2} α β rα rβ))) x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (MulZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) rβ))))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.zero_apply NonUnitalRingHom.zero_applyₓ'. -/
@[simp]
theorem zero_apply (x : α) : (0 : α →ₙ+* β) x = 0 :=
  rfl
#align non_unital_ring_hom.zero_apply NonUnitalRingHom.zero_apply

omit rβ

/- warning: non_unital_ring_hom.id_apply -> NonUnitalRingHom.id_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α] (x : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (fun (_x : NonUnitalRingHom.{u1, u1} α α rα rα) => α -> α) (NonUnitalRingHom.hasCoeToFun.{u1, u1} α α rα rα) (NonUnitalRingHom.id.{u1} α rα) x) x
but is expected to have type
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α] (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) x) (FunLike.coe.{succ u1, succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} α α rα rα))) (NonUnitalRingHom.id.{u1} α rα) x) x
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.id_apply NonUnitalRingHom.id_applyₓ'. -/
@[simp]
theorem id_apply (x : α) : NonUnitalRingHom.id α x = x :=
  rfl
#align non_unital_ring_hom.id_apply NonUnitalRingHom.id_apply

/- warning: non_unital_ring_hom.coe_add_monoid_hom_id -> NonUnitalRingHom.coe_addMonoidHom_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalRingHom.{u1, u1} α α rα rα) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddMonoidHom.hasCoeT.{u1, u1, u1} α α (NonUnitalRingHom.{u1, u1} α α rα rα) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (NonUnitalRingHomClass.toAddMonoidHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u1} α α rα rα))))) (NonUnitalRingHom.id.{u1} α rα)) (AddMonoidHom.id.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))))
but is expected to have type
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddMonoidHom.mk.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (ZeroHom.mk.{u1, u1} α α (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (FunLike.coe.{succ u1, succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (AddHomClass.toFunLike.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (NonUnitalRingHomClass.toAddMonoidHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} α α rα rα)))) (NonUnitalRingHom.id.{u1} α rα)) (instCoeTCAddMonoidHom_1.proof_1.{u1, u1, u1} α α (NonUnitalRingHom.{u1, u1} α α rα rα) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (NonUnitalRingHomClass.toAddMonoidHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} α α rα rα)) (NonUnitalRingHom.id.{u1} α rα))) (instCoeTCAddMonoidHom_1.proof_2.{u1, u1, u1} α α (NonUnitalRingHom.{u1, u1} α α rα rα) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (NonUnitalRingHomClass.toAddMonoidHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} α α rα rα)) (NonUnitalRingHom.id.{u1} α rα))) (AddMonoidHom.id.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_add_monoid_hom_id NonUnitalRingHom.coe_addMonoidHom_idₓ'. -/
@[simp]
theorem coe_addMonoidHom_id : (NonUnitalRingHom.id α : α →+ α) = AddMonoidHom.id α :=
  rfl
#align non_unital_ring_hom.coe_add_monoid_hom_id NonUnitalRingHom.coe_addMonoidHom_id

/- warning: non_unital_ring_hom.coe_mul_hom_id -> NonUnitalRingHom.coe_mulHom_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (MulHom.{u1, u1} α α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (NonUnitalRingHom.{u1, u1} α α rα rα) (MulHom.{u1, u1} α α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα))) (HasLiftT.mk.{succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulHom.{u1, u1} α α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα))) (CoeTCₓ.coe.{succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulHom.{u1, u1} α α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα))) (MulHom.hasCoeT.{u1, u1, u1} α α (NonUnitalRingHom.{u1, u1} α α rα rα) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u1} α α rα rα))))) (NonUnitalRingHom.id.{u1} α rα)) (MulHom.id.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)))
but is expected to have type
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (MulHom.{u1, u1} α α (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} α rα)) (MulHom.mk.{u1, u1} α α (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (FunLike.coe.{succ u1, succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) a) (MulHomClass.toFunLike.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} α α rα rα))) (NonUnitalRingHom.id.{u1} α rα)) (map_mul.{u1, u1, u1} α α (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} α α rα rα)) (NonUnitalRingHom.id.{u1} α rα))) (MulHom.id.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α rα))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_mul_hom_id NonUnitalRingHom.coe_mulHom_idₓ'. -/
@[simp]
theorem coe_mulHom_id : (NonUnitalRingHom.id α : α →ₙ* α) = MulHom.id α :=
  rfl
#align non_unital_ring_hom.coe_mul_hom_id NonUnitalRingHom.coe_mulHom_id

variable {rγ : NonUnitalNonAssocSemiring γ}

include rβ rγ

#print NonUnitalRingHom.comp /-
/-- Composition of non-unital ring homomorphisms is a non-unital ring homomorphism. -/
def comp (g : β →ₙ+* γ) (f : α →ₙ+* β) : α →ₙ+* γ :=
  { g.toMulHom.comp f.toMulHom, g.toAddMonoidHom.comp f.toAddMonoidHom with }
#align non_unital_ring_hom.comp NonUnitalRingHom.comp
-/

/- warning: non_unital_ring_hom.comp_assoc -> NonUnitalRingHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u3} γ} {δ : Type.{u4}} {rδ : NonUnitalNonAssocSemiring.{u4} δ} (f : NonUnitalRingHom.{u1, u2} α β rα rβ) (g : NonUnitalRingHom.{u2, u3} β γ rβ rγ) (h : NonUnitalRingHom.{u3, u4} γ δ rγ rδ), Eq.{max (succ u1) (succ u4)} (NonUnitalRingHom.{u1, u4} α δ rα rδ) (NonUnitalRingHom.comp.{u1, u2, u4} α β δ rα rβ rδ (NonUnitalRingHom.comp.{u2, u3, u4} β γ δ rβ rγ rδ h g) f) (NonUnitalRingHom.comp.{u1, u3, u4} α γ δ rα rγ rδ h (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g f))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u3} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u1} γ} {δ : Type.{u4}} {rδ : NonUnitalNonAssocSemiring.{u4} δ} (f : NonUnitalRingHom.{u3, u2} α β rα rβ) (g : NonUnitalRingHom.{u2, u1} β γ rβ rγ) (h : NonUnitalRingHom.{u1, u4} γ δ rγ rδ), Eq.{max (succ u3) (succ u4)} (NonUnitalRingHom.{u3, u4} α δ rα rδ) (NonUnitalRingHom.comp.{u3, u2, u4} α β δ rα rβ rδ (NonUnitalRingHom.comp.{u2, u1, u4} β γ δ rβ rγ rδ h g) f) (NonUnitalRingHom.comp.{u3, u1, u4} α γ δ rα rγ rδ h (NonUnitalRingHom.comp.{u3, u2, u1} α β γ rα rβ rγ g f))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.comp_assoc NonUnitalRingHom.comp_assocₓ'. -/
/-- Composition of non-unital ring homomorphisms is associative. -/
theorem comp_assoc {δ} {rδ : NonUnitalNonAssocSemiring δ} (f : α →ₙ+* β) (g : β →ₙ+* γ)
    (h : γ →ₙ+* δ) : (h.comp g).comp f = h.comp (g.comp f) :=
  rfl
#align non_unital_ring_hom.comp_assoc NonUnitalRingHom.comp_assoc

/- warning: non_unital_ring_hom.coe_comp -> NonUnitalRingHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u3} γ} (g : NonUnitalRingHom.{u2, u3} β γ rβ rγ) (f : NonUnitalRingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u3)} (α -> γ) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (fun (_x : NonUnitalRingHom.{u1, u3} α γ rα rγ) => α -> γ) (NonUnitalRingHom.hasCoeToFun.{u1, u3} α γ rα rγ) (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g f)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (fun (_x : NonUnitalRingHom.{u2, u3} β γ rβ rγ) => β -> γ) (NonUnitalRingHom.hasCoeToFun.{u2, u3} β γ rβ rγ) g) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u3} β] {rγ : NonUnitalNonAssocSemiring.{u2} γ} (g : NonUnitalRingHom.{u3, u2} β γ rβ rγ) (f : NonUnitalRingHom.{u1, u3} α β rα rβ), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => γ) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NonUnitalRingHom.{u1, u2} α γ rα rγ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => γ) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α γ rα rγ) α γ (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α γ rα rγ) α γ rα rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} α γ rα rγ))) (NonUnitalRingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g f)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => γ) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u2} β γ rβ rγ))) g) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} α β rα rβ))) f))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_comp NonUnitalRingHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (g : β →ₙ+* γ) (f : α →ₙ+* β) : ⇑(g.comp f) = g ∘ f :=
  rfl
#align non_unital_ring_hom.coe_comp NonUnitalRingHom.coe_comp

/- warning: non_unital_ring_hom.comp_apply -> NonUnitalRingHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u3} γ} (g : NonUnitalRingHom.{u2, u3} β γ rβ rγ) (f : NonUnitalRingHom.{u1, u2} α β rα rβ) (x : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (fun (_x : NonUnitalRingHom.{u1, u3} α γ rα rγ) => α -> γ) (NonUnitalRingHom.hasCoeToFun.{u1, u3} α γ rα rγ) (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g f) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (fun (_x : NonUnitalRingHom.{u2, u3} β γ rβ rγ) => β -> γ) (NonUnitalRingHom.hasCoeToFun.{u2, u3} β γ rβ rγ) g (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u3} β] {rγ : NonUnitalNonAssocSemiring.{u2} γ} (g : NonUnitalRingHom.{u3, u2} β γ rβ rγ) (f : NonUnitalRingHom.{u1, u3} α β rα rβ) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => γ) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (NonUnitalRingHom.{u1, u2} α γ rα rγ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => γ) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α γ rα rγ) α γ (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α γ rα rγ) α γ rα rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u2} α γ rα rγ))) (NonUnitalRingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g f) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => γ) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u2} β γ rβ rγ))) g (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} α β rα rβ))) f x))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.comp_apply NonUnitalRingHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (g : β →ₙ+* γ) (f : α →ₙ+* β) (x : α) : g.comp f x = g (f x) :=
  rfl
#align non_unital_ring_hom.comp_apply NonUnitalRingHom.comp_apply

/- warning: non_unital_ring_hom.coe_comp_add_monoid_hom -> NonUnitalRingHom.coe_comp_addMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u3} γ} (g : NonUnitalRingHom.{u2, u3} β γ rβ rγ) (f : NonUnitalRingHom.{u1, u2} α β rα rβ), Eq.{max (succ u3) (succ u1)} (AddMonoidHom.{u1, u3} α γ (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} γ rγ)))) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u3) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u3) (succ u1)} a b] => self.0) (NonUnitalRingHom.{u1, u3} α γ rα rγ) (AddMonoidHom.{u1, u3} α γ (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} γ rγ)))) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (AddMonoidHom.{u1, u3} α γ (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} γ rγ)))) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (AddMonoidHom.{u1, u3} α γ (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} γ rγ)))) (AddMonoidHom.hasCoeT.{u1, u3, max u1 u3} α γ (NonUnitalRingHom.{u1, u3} α γ rα rγ) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} γ rγ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α γ rα rγ) α γ rα rγ (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u3} α γ rα rγ))))) (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g f)) (AddMonoidHom.comp.{u1, u2, u3} α β γ (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} γ rγ))) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u3) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u3) (succ u2)} a b] => self.0) (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (AddMonoidHom.{u2, u3} β γ (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} γ rγ)))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (AddMonoidHom.{u2, u3} β γ (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} γ rγ)))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (AddMonoidHom.{u2, u3} β γ (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} γ rγ)))) (AddMonoidHom.hasCoeT.{u2, u3, max u2 u3} β γ (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (AddMonoid.toAddZeroClass.{u3} γ (AddCommMonoid.toAddMonoid.{u3} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} γ rγ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u2 u3, u2, u3} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.nonUnitalRingHomClass.{u2, u3} β γ rβ rγ))))) g) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ)))) (AddMonoidHom.hasCoeT.{u1, u2, max u1 u2} α β (NonUnitalRingHom.{u1, u2} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} α β rα rβ))))) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u3} β] {rγ : NonUnitalNonAssocSemiring.{u2} γ} (g : NonUnitalRingHom.{u3, u2} β γ rβ rγ) (f : NonUnitalRingHom.{u1, u3} α β rα rβ), Eq.{max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} γ rγ)))) (AddMonoidHom.mk.{u1, u2} α γ (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} γ rγ))) (ZeroHom.mk.{u1, u2} α γ (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddZeroClass.toZero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} γ rγ)))) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β (fun (a : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => γ) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u2} β γ rβ rγ))) g) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} α β rα rβ))) f)) (NonUnitalRingHom.map_zero'.{u1, u2} α γ rα rγ (NonUnitalRingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g f))) (NonUnitalRingHom.map_add'.{u1, u2} α γ rα rγ (NonUnitalRingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g f))) (AddMonoidHom.comp.{u1, u3, u2} α β γ (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} γ rγ))) (AddMonoidHom.mk.{u3, u2} β γ (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} γ rγ))) (ZeroHom.mk.{u3, u2} β γ (AddZeroClass.toZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ)))) (AddZeroClass.toZero.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} γ rγ)))) (FunLike.coe.{succ (max u3 u2), succ u3, succ u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β (fun (a : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => γ) a) (AddHomClass.toFunLike.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ (AddZeroClass.toAdd.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ)))) (AddZeroClass.toAdd.{u2} γ (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} γ rγ)))) (AddMonoidHomClass.toAddHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} γ rγ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u2} β γ rβ rγ)))) g) (instCoeTCAddMonoidHom_1.proof_1.{u2, u3, max u3 u2} β γ (NonUnitalRingHom.{u3, u2} β γ rβ rγ) (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} γ rγ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u2} β γ rβ rγ)) g)) (instCoeTCAddMonoidHom_1.proof_2.{u2, u3, max u3 u2} β γ (NonUnitalRingHom.{u3, u2} β γ rβ rγ) (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ))) (AddMonoid.toAddZeroClass.{u2} γ (AddCommMonoid.toAddMonoid.{u2} γ (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} γ rγ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u2} β γ rβ rγ)) g)) (AddMonoidHom.mk.{u1, u3} α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ))) (ZeroHom.mk.{u1, u3} α β (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddZeroClass.toZero.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ)))) (FunLike.coe.{succ (max u1 u3), succ u1, succ u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => β) a) (AddHomClass.toFunLike.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα)))) (AddZeroClass.toAdd.{u3} β (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ)))) (AddMonoidHomClass.toAddHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} α β rα rβ)))) f) (instCoeTCAddMonoidHom_1.proof_1.{u3, u1, max u1 u3} α β (NonUnitalRingHom.{u1, u3} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} α β rα rβ)) f)) (instCoeTCAddMonoidHom_1.proof_2.{u3, u1, max u1 u3} α β (NonUnitalRingHom.{u1, u3} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α rα))) (AddMonoid.toAddZeroClass.{u3} β (AddCommMonoid.toAddMonoid.{u3} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} β rβ))) (NonUnitalRingHomClass.toAddMonoidHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} α β rα rβ)) f)))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_comp_add_monoid_hom NonUnitalRingHom.coe_comp_addMonoidHomₓ'. -/
@[simp]
theorem coe_comp_addMonoidHom (g : β →ₙ+* γ) (f : α →ₙ+* β) :
    (g.comp f : α →+ γ) = (g : β →+ γ).comp f :=
  rfl
#align non_unital_ring_hom.coe_comp_add_monoid_hom NonUnitalRingHom.coe_comp_addMonoidHom

/- warning: non_unital_ring_hom.coe_comp_mul_hom -> NonUnitalRingHom.coe_comp_mulHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u3} γ} (g : NonUnitalRingHom.{u2, u3} β γ rβ rγ) (f : NonUnitalRingHom.{u1, u2} α β rα rβ), Eq.{max (succ u3) (succ u1)} (MulHom.{u1, u3} α γ (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u3} γ (NonUnitalNonAssocSemiring.toDistrib.{u3} γ rγ))) ((fun (a : Sort.{max (succ u1) (succ u3)}) (b : Sort.{max (succ u3) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u3), max (succ u3) (succ u1)} a b] => self.0) (NonUnitalRingHom.{u1, u3} α γ rα rγ) (MulHom.{u1, u3} α γ (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u3} γ (NonUnitalNonAssocSemiring.toDistrib.{u3} γ rγ))) (HasLiftT.mk.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (MulHom.{u1, u3} α γ (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u3} γ (NonUnitalNonAssocSemiring.toDistrib.{u3} γ rγ))) (CoeTCₓ.coe.{max (succ u1) (succ u3), max (succ u3) (succ u1)} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (MulHom.{u1, u3} α γ (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u3} γ (NonUnitalNonAssocSemiring.toDistrib.{u3} γ rγ))) (MulHom.hasCoeT.{u1, u3, max u1 u3} α γ (NonUnitalRingHom.{u1, u3} α γ rα rγ) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u3} γ (NonUnitalNonAssocSemiring.toDistrib.{u3} γ rγ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α γ rα rγ) α γ rα rγ (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u3} α γ rα rγ))))) (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g f)) (MulHom.comp.{u1, u2, u3} α β γ (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ)) (Distrib.toHasMul.{u3} γ (NonUnitalNonAssocSemiring.toDistrib.{u3} γ rγ)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u3) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u3) (succ u2)} a b] => self.0) (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (MulHom.{u2, u3} β γ (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ)) (Distrib.toHasMul.{u3} γ (NonUnitalNonAssocSemiring.toDistrib.{u3} γ rγ))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (MulHom.{u2, u3} β γ (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ)) (Distrib.toHasMul.{u3} γ (NonUnitalNonAssocSemiring.toDistrib.{u3} γ rγ))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (MulHom.{u2, u3} β γ (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ)) (Distrib.toHasMul.{u3} γ (NonUnitalNonAssocSemiring.toDistrib.{u3} γ rγ))) (MulHom.hasCoeT.{u2, u3, max u2 u3} β γ (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ)) (Distrib.toHasMul.{u3} γ (NonUnitalNonAssocSemiring.toDistrib.{u3} γ rγ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u2, u3} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.nonUnitalRingHomClass.{u2, u3} β γ rβ rγ))))) g) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (NonUnitalRingHom.{u1, u2} α β rα rβ) (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (MulHom.{u1, u2} α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ))) (MulHom.hasCoeT.{u1, u2, max u1 u2} α β (NonUnitalRingHom.{u1, u2} α β rα rβ) (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α rα)) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) α β rα rβ (NonUnitalRingHom.nonUnitalRingHomClass.{u1, u2} α β rα rβ))))) f))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u3} β] {rγ : NonUnitalNonAssocSemiring.{u2} γ} (g : NonUnitalRingHom.{u3, u2} β γ rβ rγ) (f : NonUnitalRingHom.{u1, u3} α β rα rβ), Eq.{max (succ u1) (succ u2)} (MulHom.{u1, u2} α γ (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ)) (MulHom.mk.{u1, u2} α γ (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β (fun (a : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => γ) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u2} β γ rβ rγ))) g) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} α β rα rβ))) f)) (MulHom.map_mul'.{u1, u2} α γ (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (NonUnitalRingHom.toMulHom.{u1, u2} α γ rα rγ (NonUnitalRingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g f)))) (MulHom.comp.{u1, u3, u2} α β γ (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (MulHom.mk.{u3, u2} β γ (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (FunLike.coe.{succ (max u3 u2), succ u3, succ u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β (fun (a : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => γ) a) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u2} β γ rβ rγ))) g) (map_mul.{u2, u3, max u3 u2} β γ (NonUnitalRingHom.{u3, u2} β γ rβ rγ) (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u2} β γ rβ rγ)) g)) (MulHom.mk.{u1, u3} α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (FunLike.coe.{succ (max u1 u3), succ u1, succ u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} α β rα rβ))) f) (map_mul.{u3, u1, max u1 u3} α β (NonUnitalRingHom.{u1, u3} α β rα rβ) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} α β rα rβ)) f)))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_comp_mul_hom NonUnitalRingHom.coe_comp_mulHomₓ'. -/
@[simp]
theorem coe_comp_mulHom (g : β →ₙ+* γ) (f : α →ₙ+* β) :
    (g.comp f : α →ₙ* γ) = (g : β →ₙ* γ).comp f :=
  rfl
#align non_unital_ring_hom.coe_comp_mul_hom NonUnitalRingHom.coe_comp_mulHom

/- warning: non_unital_ring_hom.comp_zero -> NonUnitalRingHom.comp_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u3} γ} (g : NonUnitalRingHom.{u2, u3} β γ rβ rγ), Eq.{max (succ u1) (succ u3)} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g (OfNat.ofNat.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) 0 (OfNat.mk.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) 0 (Zero.zero.{max u1 u2} (NonUnitalRingHom.{u1, u2} α β rα rβ) (NonUnitalRingHom.hasZero.{u1, u2} α β rα rβ))))) (OfNat.ofNat.{max u1 u3} (NonUnitalRingHom.{u1, u3} α γ rα rγ) 0 (OfNat.mk.{max u1 u3} (NonUnitalRingHom.{u1, u3} α γ rα rγ) 0 (Zero.zero.{max u1 u3} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (NonUnitalRingHom.hasZero.{u1, u3} α γ rα rγ))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u3} β] {rγ : NonUnitalNonAssocSemiring.{u2} γ} (g : NonUnitalRingHom.{u3, u2} β γ rβ rγ), Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α γ rα rγ) (NonUnitalRingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g (OfNat.ofNat.{max u1 u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) 0 (Zero.toOfNat0.{max u1 u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) (NonUnitalRingHom.instZeroNonUnitalRingHom.{u1, u3} α β rα rβ)))) (OfNat.ofNat.{max u1 u2} (NonUnitalRingHom.{u1, u2} α γ rα rγ) 0 (Zero.toOfNat0.{max u1 u2} (NonUnitalRingHom.{u1, u2} α γ rα rγ) (NonUnitalRingHom.instZeroNonUnitalRingHom.{u1, u2} α γ rα rγ)))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.comp_zero NonUnitalRingHom.comp_zeroₓ'. -/
@[simp]
theorem comp_zero (g : β →ₙ+* γ) : g.comp (0 : α →ₙ+* β) = 0 := by
  ext
  simp
#align non_unital_ring_hom.comp_zero NonUnitalRingHom.comp_zero

/- warning: non_unital_ring_hom.zero_comp -> NonUnitalRingHom.zero_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u3} γ} (f : NonUnitalRingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u3)} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ (OfNat.ofNat.{max u2 u3} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) 0 (OfNat.mk.{max u2 u3} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) 0 (Zero.zero.{max u2 u3} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (NonUnitalRingHom.hasZero.{u2, u3} β γ rβ rγ)))) f) (OfNat.ofNat.{max u1 u3} (NonUnitalRingHom.{u1, u3} α γ rα rγ) 0 (OfNat.mk.{max u1 u3} (NonUnitalRingHom.{u1, u3} α γ rα rγ) 0 (Zero.zero.{max u1 u3} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (NonUnitalRingHom.hasZero.{u1, u3} α γ rα rγ))))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u3} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u1} γ} (f : NonUnitalRingHom.{u3, u2} α β rα rβ), Eq.{max (succ u3) (succ u1)} (NonUnitalRingHom.{u3, u1} α γ rα rγ) (NonUnitalRingHom.comp.{u3, u2, u1} α β γ rα rβ rγ (OfNat.ofNat.{max u2 u1} (NonUnitalRingHom.{u2, u1} β γ rβ rγ) 0 (Zero.toOfNat0.{max u2 u1} (NonUnitalRingHom.{u2, u1} β γ rβ rγ) (NonUnitalRingHom.instZeroNonUnitalRingHom.{u2, u1} β γ rβ rγ))) f) (OfNat.ofNat.{max u3 u1} (NonUnitalRingHom.{u3, u1} α γ rα rγ) 0 (Zero.toOfNat0.{max u3 u1} (NonUnitalRingHom.{u3, u1} α γ rα rγ) (NonUnitalRingHom.instZeroNonUnitalRingHom.{u3, u1} α γ rα rγ)))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.zero_comp NonUnitalRingHom.zero_compₓ'. -/
@[simp]
theorem zero_comp (f : α →ₙ+* β) : (0 : β →ₙ+* γ).comp f = 0 := by
  ext
  rfl
#align non_unital_ring_hom.zero_comp NonUnitalRingHom.zero_comp

omit rγ

/- warning: non_unital_ring_hom.comp_id -> NonUnitalRingHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] (f : NonUnitalRingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (NonUnitalRingHom.comp.{u1, u1, u2} α α β rα rα rβ f (NonUnitalRingHom.id.{u1} α rα)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u2} α] [rβ : NonUnitalNonAssocSemiring.{u1} β] (f : NonUnitalRingHom.{u2, u1} α β rα rβ), Eq.{max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} α β rα rβ) (NonUnitalRingHom.comp.{u2, u2, u1} α α β rα rα rβ f (NonUnitalRingHom.id.{u2} α rα)) f
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.comp_id NonUnitalRingHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : α →ₙ+* β) : f.comp (NonUnitalRingHom.id α) = f :=
  ext fun x => rfl
#align non_unital_ring_hom.comp_id NonUnitalRingHom.comp_id

/- warning: non_unital_ring_hom.id_comp -> NonUnitalRingHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] (f : NonUnitalRingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (NonUnitalRingHom.comp.{u1, u2, u2} α β β rα rβ rβ (NonUnitalRingHom.id.{u2} β rβ) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u2} α] [rβ : NonUnitalNonAssocSemiring.{u1} β] (f : NonUnitalRingHom.{u2, u1} α β rα rβ), Eq.{max (succ u2) (succ u1)} (NonUnitalRingHom.{u2, u1} α β rα rβ) (NonUnitalRingHom.comp.{u2, u1, u1} α β β rα rβ rβ (NonUnitalRingHom.id.{u1} β rβ) f) f
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.id_comp NonUnitalRingHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : α →ₙ+* β) : (NonUnitalRingHom.id β).comp f = f :=
  ext fun x => rfl
#align non_unital_ring_hom.id_comp NonUnitalRingHom.id_comp

omit rβ

instance : MonoidWithZero
      (α →ₙ+* α) where 
  one := NonUnitalRingHom.id α
  mul := comp
  mul_one := comp_id
  one_mul := id_comp
  mul_assoc f g h := comp_assoc _ _ _
  zero := 0
  mul_zero := comp_zero
  zero_mul := zero_comp

/- warning: non_unital_ring_hom.one_def -> NonUnitalRingHom.one_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (OfNat.ofNat.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) 1 (OfNat.mk.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) 1 (One.one.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulOneClass.toHasOne.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulZeroOneClass.toMulOneClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MonoidWithZero.toMulZeroOneClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.monoidWithZero.{u1} α rα))))))) (NonUnitalRingHom.id.{u1} α rα)
but is expected to have type
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (OfNat.ofNat.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) 1 (One.toOfNat1.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (Monoid.toOne.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MonoidWithZero.toMonoid.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.instMonoidWithZeroNonUnitalRingHom.{u1} α rα))))) (NonUnitalRingHom.id.{u1} α rα)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.one_def NonUnitalRingHom.one_defₓ'. -/
theorem one_def : (1 : α →ₙ+* α) = NonUnitalRingHom.id α :=
  rfl
#align non_unital_ring_hom.one_def NonUnitalRingHom.one_def

/- warning: non_unital_ring_hom.coe_one -> NonUnitalRingHom.coe_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (fun (_x : NonUnitalRingHom.{u1, u1} α α rα rα) => α -> α) (NonUnitalRingHom.hasCoeToFun.{u1, u1} α α rα rα) (OfNat.ofNat.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) 1 (OfNat.mk.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) 1 (One.one.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulOneClass.toHasOne.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulZeroOneClass.toMulOneClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MonoidWithZero.toMulZeroOneClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.monoidWithZero.{u1} α rα)))))))) (id.{succ u1} α)
but is expected to have type
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} α α rα rα))) (OfNat.ofNat.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) 1 (One.toOfNat1.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (Monoid.toOne.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MonoidWithZero.toMonoid.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.instMonoidWithZeroNonUnitalRingHom.{u1} α rα)))))) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_one NonUnitalRingHom.coe_oneₓ'. -/
@[simp]
theorem coe_one : ⇑(1 : α →ₙ+* α) = id :=
  rfl
#align non_unital_ring_hom.coe_one NonUnitalRingHom.coe_one

/- warning: non_unital_ring_hom.mul_def -> NonUnitalRingHom.mul_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α] (f : NonUnitalRingHom.{u1, u1} α α rα rα) (g : NonUnitalRingHom.{u1, u1} α α rα rα), Eq.{succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (HMul.hMul.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.{u1, u1} α α rα rα) (instHMul.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulZeroClass.toHasMul.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulZeroOneClass.toMulZeroClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MonoidWithZero.toMulZeroOneClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.monoidWithZero.{u1} α rα))))) f g) (NonUnitalRingHom.comp.{u1, u1, u1} α α α rα rα rα f g)
but is expected to have type
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α] (f : NonUnitalRingHom.{u1, u1} α α rα rα) (g : NonUnitalRingHom.{u1, u1} α α rα rα), Eq.{succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (HMul.hMul.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.{u1, u1} α α rα rα) (instHMul.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulZeroClass.toMul.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulZeroOneClass.toMulZeroClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MonoidWithZero.toMulZeroOneClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.instMonoidWithZeroNonUnitalRingHom.{u1} α rα))))) f g) (NonUnitalRingHom.comp.{u1, u1, u1} α α α rα rα rα f g)
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.mul_def NonUnitalRingHom.mul_defₓ'. -/
theorem mul_def (f g : α →ₙ+* α) : f * g = f.comp g :=
  rfl
#align non_unital_ring_hom.mul_def NonUnitalRingHom.mul_def

/- warning: non_unital_ring_hom.coe_mul -> NonUnitalRingHom.coe_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α] (f : NonUnitalRingHom.{u1, u1} α α rα rα) (g : NonUnitalRingHom.{u1, u1} α α rα rα), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (fun (_x : NonUnitalRingHom.{u1, u1} α α rα rα) => α -> α) (NonUnitalRingHom.hasCoeToFun.{u1, u1} α α rα rα) (HMul.hMul.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.{u1, u1} α α rα rα) (instHMul.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulZeroClass.toHasMul.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulZeroOneClass.toMulZeroClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MonoidWithZero.toMulZeroOneClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.monoidWithZero.{u1} α rα))))) f g)) (Function.comp.{succ u1, succ u1, succ u1} α α α (coeFn.{succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (fun (_x : NonUnitalRingHom.{u1, u1} α α rα rα) => α -> α) (NonUnitalRingHom.hasCoeToFun.{u1, u1} α α rα rα) f) (coeFn.{succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (fun (_x : NonUnitalRingHom.{u1, u1} α α rα rα) => α -> α) (NonUnitalRingHom.hasCoeToFun.{u1, u1} α α rα rα) g))
but is expected to have type
  forall {α : Type.{u1}} [rα : NonUnitalNonAssocSemiring.{u1} α] (f : NonUnitalRingHom.{u1, u1} α α rα rα) (g : NonUnitalRingHom.{u1, u1} α α rα rα), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} α α rα rα))) (HMul.hMul.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.{u1, u1} α α rα rα) (instHMul.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulZeroClass.toMul.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MulZeroOneClass.toMulZeroClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (MonoidWithZero.toMulZeroOneClass.{u1} (NonUnitalRingHom.{u1, u1} α α rα rα) (NonUnitalRingHom.instMonoidWithZeroNonUnitalRingHom.{u1} α rα))))) f g)) (Function.comp.{succ u1, succ u1, succ u1} α α α (FunLike.coe.{succ u1, succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} α α rα rα))) f) (FunLike.coe.{succ u1, succ u1, succ u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (NonUnitalRingHom.{u1, u1} α α rα rα) α α rα rα (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u1} α α rα rα))) g))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.coe_mul NonUnitalRingHom.coe_mulₓ'. -/
@[simp]
theorem coe_mul (f g : α →ₙ+* α) : ⇑(f * g) = f ∘ g :=
  rfl
#align non_unital_ring_hom.coe_mul NonUnitalRingHom.coe_mul

include rβ rγ

/- warning: non_unital_ring_hom.cancel_right -> NonUnitalRingHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u3} γ} {g₁ : NonUnitalRingHom.{u2, u3} β γ rβ rγ} {g₂ : NonUnitalRingHom.{u2, u3} β γ rβ rγ} {f : NonUnitalRingHom.{u1, u2} α β rα rβ}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) (fun (_x : NonUnitalRingHom.{u1, u2} α β rα rβ) => α -> β) (NonUnitalRingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g₁ f) (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g₂ f)) (Eq.{max (succ u2) (succ u3)} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u3} β] {rγ : NonUnitalNonAssocSemiring.{u2} γ} {g₁ : NonUnitalRingHom.{u3, u2} β γ rβ rγ} {g₂ : NonUnitalRingHom.{u3, u2} β γ rβ rγ} {f : NonUnitalRingHom.{u1, u3} α β rα rβ}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α rα) (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (NonUnitalRingHom.{u1, u3} α β rα rβ) α β rα rβ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u1, u3} α β rα rβ))) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α γ rα rγ) (NonUnitalRingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g₁ f) (NonUnitalRingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g₂ f)) (Eq.{max (succ u3) (succ u2)} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.cancel_right NonUnitalRingHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : β →ₙ+* γ} {f : α →ₙ+* β} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => ext <| hf.forall.2 (ext_iff.1 h), fun h => h ▸ rfl⟩
#align non_unital_ring_hom.cancel_right NonUnitalRingHom.cancel_right

/- warning: non_unital_ring_hom.cancel_left -> NonUnitalRingHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u2} β] {rγ : NonUnitalNonAssocSemiring.{u3} γ} {g : NonUnitalRingHom.{u2, u3} β γ rβ rγ} {f₁ : NonUnitalRingHom.{u1, u2} α β rα rβ} {f₂ : NonUnitalRingHom.{u1, u2} α β rα rβ}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (NonUnitalRingHom.{u2, u3} β γ rβ rγ) (fun (_x : NonUnitalRingHom.{u2, u3} β γ rβ rγ) => β -> γ) (NonUnitalRingHom.hasCoeToFun.{u2, u3} β γ rβ rγ) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (NonUnitalRingHom.{u1, u3} α γ rα rγ) (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g f₁) (NonUnitalRingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g f₂)) (Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α β rα rβ) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} [rα : NonUnitalNonAssocSemiring.{u1} α] [rβ : NonUnitalNonAssocSemiring.{u3} β] {rγ : NonUnitalNonAssocSemiring.{u2} γ} {g : NonUnitalRingHom.{u3, u2} β γ rβ rγ} {f₁ : NonUnitalRingHom.{u1, u3} α β rα rβ} {f₂ : NonUnitalRingHom.{u1, u3} α β rα rβ}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => γ) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ (NonUnitalNonAssocSemiring.toMul.{u3} β rβ) (NonUnitalNonAssocSemiring.toMul.{u2} γ rγ) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (NonUnitalRingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (NonUnitalRingHom.instNonUnitalRingHomClassNonUnitalRingHom.{u3, u2} β γ rβ rγ))) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (NonUnitalRingHom.{u1, u2} α γ rα rγ) (NonUnitalRingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g f₁) (NonUnitalRingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g f₂)) (Eq.{max (succ u1) (succ u3)} (NonUnitalRingHom.{u1, u3} α β rα rβ) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align non_unital_ring_hom.cancel_left NonUnitalRingHom.cancel_leftₓ'. -/
theorem cancel_left {g : β →ₙ+* γ} {f₁ f₂ : α →ₙ+* β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun x => hg <| by rw [← comp_apply, h, comp_apply], fun h => h ▸ rfl⟩
#align non_unital_ring_hom.cancel_left NonUnitalRingHom.cancel_left

omit rα rβ rγ

end NonUnitalRingHom

#print RingHom /-
/-- Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.

This extends from both `monoid_hom` and `monoid_with_zero_hom` in order to put the fields in a
sensible order, even though `monoid_with_zero_hom` already extends `monoid_hom`. -/
structure RingHom (α : Type _) (β : Type _) [NonAssocSemiring α] [NonAssocSemiring β] extends
  α →* β, α →+ β, α →ₙ+* β, α →*₀ β
#align ring_hom RingHom
-/

-- mathport name: «expr →+* »
infixr:25 " →+* " => RingHom

/-- Reinterpret a ring homomorphism `f : α →+* β` as a monoid with zero homomorphism `α →*₀ β`.
The `simp`-normal form is `(f : α →*₀ β)`. -/
add_decl_doc RingHom.toMonoidWithZeroHom

/-- Reinterpret a ring homomorphism `f : α →+* β` as a monoid homomorphism `α →* β`.
The `simp`-normal form is `(f : α →* β)`. -/
add_decl_doc RingHom.toMonoidHom

/-- Reinterpret a ring homomorphism `f : α →+* β` as an additive monoid homomorphism `α →+ β`.
The `simp`-normal form is `(f : α →+ β)`. -/
add_decl_doc RingHom.toAddMonoidHom

/-- Reinterpret a ring homomorphism `f : α →+* β` as a non-unital ring homomorphism `α →ₙ+* β`. The
`simp`-normal form is `(f : α →ₙ+* β)`. -/
add_decl_doc RingHom.toNonUnitalRingHom

section RingHomClass

#print RingHomClass /-
/-- `ring_hom_class F α β` states that `F` is a type of (semi)ring homomorphisms.
You should extend this class when you extend `ring_hom`.

This extends from both `monoid_hom_class` and `monoid_with_zero_hom_class` in
order to put the fields in a sensible order, even though
`monoid_with_zero_hom_class` already extends `monoid_hom_class`. -/
class RingHomClass (F : Type _) (α β : outParam (Type _)) [NonAssocSemiring α]
  [NonAssocSemiring β] extends MonoidHomClass F α β, AddMonoidHomClass F α β,
  MonoidWithZeroHomClass F α β
#align ring_hom_class RingHomClass
-/

variable [NonAssocSemiring α] [NonAssocSemiring β] [RingHomClass F α β]

/-- Ring homomorphisms preserve `bit1`. -/
@[simp]
theorem map_bit1 (f : F) (a : α) : (f (bit1 a) : β) = bit1 (f a) := by simp [bit1]
#align map_bit1 map_bit1

instance : CoeTC F (α →+* β) :=
  ⟨fun f =>
    { toFun := f
      map_zero' := map_zero f
      map_one' := map_one f
      map_mul' := map_mul f
      map_add' := map_add f }⟩

#print RingHomClass.toNonUnitalRingHomClass /-
instance (priority := 100) RingHomClass.toNonUnitalRingHomClass : NonUnitalRingHomClass F α β :=
  { ‹RingHomClass F α β› with }
#align ring_hom_class.to_non_unital_ring_hom_class RingHomClass.toNonUnitalRingHomClass
-/

end RingHomClass

namespace RingHom

section coe

/-!
Throughout this section, some `semiring` arguments are specified with `{}` instead of `[]`.
See note [implicit instance arguments].
-/


variable {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β}

include rα rβ

instance : RingHomClass (α →+* β) α
      β where 
  coe := RingHom.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
  map_add := RingHom.map_add'
  map_zero := RingHom.map_zero'
  map_mul := RingHom.map_mul'
  map_one := RingHom.map_one'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly.
-/
instance : CoeFun (α →+* β) fun _ => α → β :=
  ⟨RingHom.toFun⟩

initialize_simps_projections RingHom (toFun → apply)

/- warning: ring_hom.to_fun_eq_coe -> RingHom.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u2)} (α -> β) (RingHom.toFun.{u1, u2} α β rα rβ f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ), Eq.{max (succ u2) (succ u1)} (α -> β) (OneHom.toFun.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (MonoidHom.toOneHom.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (RingHom.toMonoidHom.{u2, u1} α β rα rβ f))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f)
Case conversion may be inaccurate. Consider using '#align ring_hom.to_fun_eq_coe RingHom.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe (f : α →+* β) : f.toFun = f :=
  rfl
#align ring_hom.to_fun_eq_coe RingHom.toFun_eq_coe

/- warning: ring_hom.coe_mk -> RingHom.coe_mk is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : α -> β) (h₁ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (MulOneClass.toHasOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))))))) (h₂ : forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toHasMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (MulOneClass.toHasMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))) (f x) (f y))) (h₃ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))))))) (h₄ : forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))) (f x) (f y))), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) (RingHom.mk.{u1, u2} α β rα rβ f h₁ h₂ h₃ h₄)) f
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : α -> β) (h₁ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))))) (h₂ : forall (x : α) (y : α), Eq.{succ u2} β (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (MulOneClass.toMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) x) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) y))) (h₃ : Eq.{succ u2} β (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (AddZeroClass.toZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))))) (h₄ : forall (x : α) (y : α), Eq.{succ u2} β (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) x) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) y))), Eq.{max (succ u1) (succ u2)} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) ᾰ) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)))) (RingHom.mk.{u1, u2} α β rα rβ (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂) h₃ h₄)) f
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_mk RingHom.coe_mkₓ'. -/
@[simp]
theorem coe_mk (f : α → β) (h₁ h₂ h₃ h₄) : ⇑(⟨f, h₁, h₂, h₃, h₄⟩ : α →+* β) = f :=
  rfl
#align ring_hom.coe_mk RingHom.coe_mk

/- warning: ring_hom.coe_coe -> RingHom.coe_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} {F : Type.{u3}} [_inst_1 : RingHomClass.{u3, u1, u2} F α β rα rβ] (f : F), Eq.{max (succ u1) (succ u2)} ((fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) ((fun (a : Type.{u3}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u3, max (succ u1) (succ u2)} a b] => self.0) F (RingHom.{u1, u2} α β rα rβ) (HasLiftT.mk.{succ u3, max (succ u1) (succ u2)} F (RingHom.{u1, u2} α β rα rβ) (CoeTCₓ.coe.{succ u3, max (succ u1) (succ u2)} F (RingHom.{u1, u2} α β rα rβ) (RingHom.hasCoeT.{u3, u1, u2} F α β rα rβ _inst_1))) f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) ((fun (a : Type.{u3}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ u3, max (succ u1) (succ u2)} a b] => self.0) F (RingHom.{u1, u2} α β rα rβ) (HasLiftT.mk.{succ u3, max (succ u1) (succ u2)} F (RingHom.{u1, u2} α β rα rβ) (CoeTCₓ.coe.{succ u3, max (succ u1) (succ u2)} F (RingHom.{u1, u2} α β rα rβ) (RingHom.hasCoeT.{u3, u1, u2} F α β rα rβ _inst_1))) f)) (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F α (fun (_x : α) => β) (MulHomClass.toFunLike.{u3, u1, u2} F α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα))) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F α β rα rβ _inst_1)))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} {F : Type.{u3}} [_inst_1 : RingHomClass.{u3, u2, u1} F α β rα rβ] (f : F), Eq.{max (succ u2) (succ u1)} (forall (a : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) (RingHom.mk.{u2, u1} α β rα rβ (MonoidHom.mk.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{succ u3, succ u2, succ u1} F α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{u3, u2, u1} F α β (MulOneClass.toMul.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toMul.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (MonoidHomClass.toMulHomClass.{u3, u2, u1} F α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (RingHomClass.toMonoidHomClass.{u3, u2, u1} F α β rα rβ _inst_1))) f) (instCoeTCRingHom.proof_1.{u1, u2, u3} F α β rα rβ _inst_1 f)) (instCoeTCRingHom.proof_2.{u1, u2, u3} F α β rα rβ _inst_1 f)) (instCoeTCRingHom.proof_3.{u1, u2, u3} F α β rα rβ _inst_1 f) (instCoeTCRingHom.proof_4.{u1, u2, u3} F α β rα rβ _inst_1 f))) (FunLike.coe.{succ u3, succ u2, succ u1} F α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{u3, u2, u1} F α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{u3, u2, u1} F α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{u3, u2, u1} F α β rα rβ _inst_1))) f)
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_coe RingHom.coe_coeₓ'. -/
@[simp]
theorem coe_coe {F : Type _} [RingHomClass F α β] (f : F) : ((f : α →+* β) : α → β) = f :=
  rfl
#align ring_hom.coe_coe RingHom.coe_coe

#print RingHom.coeToMonoidHom /-
instance coeToMonoidHom : Coe (α →+* β) (α →* β) :=
  ⟨RingHom.toMonoidHom⟩
#align ring_hom.has_coe_monoid_hom RingHom.coeToMonoidHom
-/

/- warning: ring_hom.coe_monoid_hom clashes with [anonymous] -> [anonymous]
warning: ring_hom.coe_monoid_hom -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_2}} {β : Type.{u_3}} {rα : NonAssocSemiring.{u_2} α} {rβ : NonAssocSemiring.{u_3} β} (f : RingHom.{u_2, u_3} α β rα rβ), Eq.{max (succ u_2) (succ u_3)} (α -> β) (coeFn.{max (succ u_3) (succ u_2), max (succ u_2) (succ u_3)} (MonoidHom.{u_2, u_3} α β (MulZeroOneClass.toMulOneClass.{u_2} α (NonAssocSemiring.toMulZeroOneClass.{u_2} α rα)) (MulZeroOneClass.toMulOneClass.{u_3} β (NonAssocSemiring.toMulZeroOneClass.{u_3} β rβ))) (fun (_x : MonoidHom.{u_2, u_3} α β (MulZeroOneClass.toMulOneClass.{u_2} α (NonAssocSemiring.toMulZeroOneClass.{u_2} α rα)) (MulZeroOneClass.toMulOneClass.{u_3} β (NonAssocSemiring.toMulZeroOneClass.{u_3} β rβ))) => α -> β) (MonoidHom.hasCoeToFun.{u_2, u_3} α β (MulZeroOneClass.toMulOneClass.{u_2} α (NonAssocSemiring.toMulZeroOneClass.{u_2} α rα)) (MulZeroOneClass.toMulOneClass.{u_3} β (NonAssocSemiring.toMulZeroOneClass.{u_3} β rβ))) ((fun (a : Sort.{max (succ u_2) (succ u_3)}) (b : Sort.{max (succ u_3) (succ u_2)}) [self : HasLiftT.{max (succ u_2) (succ u_3), max (succ u_3) (succ u_2)} a b] => self.0) (RingHom.{u_2, u_3} α β rα rβ) (MonoidHom.{u_2, u_3} α β (MulZeroOneClass.toMulOneClass.{u_2} α (NonAssocSemiring.toMulZeroOneClass.{u_2} α rα)) (MulZeroOneClass.toMulOneClass.{u_3} β (NonAssocSemiring.toMulZeroOneClass.{u_3} β rβ))) (HasLiftT.mk.{max (succ u_2) (succ u_3), max (succ u_3) (succ u_2)} (RingHom.{u_2, u_3} α β rα rβ) (MonoidHom.{u_2, u_3} α β (MulZeroOneClass.toMulOneClass.{u_2} α (NonAssocSemiring.toMulZeroOneClass.{u_2} α rα)) (MulZeroOneClass.toMulOneClass.{u_3} β (NonAssocSemiring.toMulZeroOneClass.{u_3} β rβ))) (CoeTCₓ.coe.{max (succ u_2) (succ u_3), max (succ u_3) (succ u_2)} (RingHom.{u_2, u_3} α β rα rβ) (MonoidHom.{u_2, u_3} α β (MulZeroOneClass.toMulOneClass.{u_2} α (NonAssocSemiring.toMulZeroOneClass.{u_2} α rα)) (MulZeroOneClass.toMulOneClass.{u_3} β (NonAssocSemiring.toMulZeroOneClass.{u_3} β rβ))) (MonoidHom.hasCoeT.{u_2, u_3, max u_2 u_3} α β (RingHom.{u_2, u_3} α β rα rβ) (MulZeroOneClass.toMulOneClass.{u_2} α (NonAssocSemiring.toMulZeroOneClass.{u_2} α rα)) (MulZeroOneClass.toMulOneClass.{u_3} β (NonAssocSemiring.toMulZeroOneClass.{u_3} β rβ)) (RingHomClass.toMonoidHomClass.{max u_2 u_3, u_2, u_3} (RingHom.{u_2, u_3} α β rα rβ) α β rα rβ (RingHom.ringHomClass.{u_2, u_3} α β rα rβ))))) f)) (coeFn.{max (succ u_2) (succ u_3), max (succ u_2) (succ u_3)} (RingHom.{u_2, u_3} α β rα rβ) (fun (_x : RingHom.{u_2, u_3} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u_2, u_3} α β rα rβ) f)
but is expected to have type
  forall {α : Sort.{u}} {β : Nat}, ((Eq.{1} Nat β (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> α) -> (forall (m : Nat), (Eq.{1} Nat β (Nat.succ m)) -> α) -> α
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_monoid_hom [anonymous]ₓ'. -/
@[simp, norm_cast]
theorem [anonymous] (f : α →+* β) : ⇑(f : α →* β) = f :=
  rfl
#align ring_hom.coe_monoid_hom[anonymous]

/- warning: ring_hom.to_monoid_hom_eq_coe -> RingHom.toMonoidHom_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (RingHom.toMonoidHom.{u1, u2} α β rα rβ f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (RingHom.{u1, u2} α β rα rβ) (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} α β (RingHom.{u1, u2} α β rα rβ) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (RingHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.ringHomClass.{u1, u2} α β rα rβ))))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ), Eq.{max (succ u2) (succ u1)} (MonoidHom.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (RingHom.toMonoidHom.{u2, u1} α β rα rβ f) (MonoidHom.mk.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (MulOneClass.toMul.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toMul.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (RingHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) (instCoeTCMonoidHom.proof_1.{u1, u2, max u2 u1} α β (RingHom.{u2, u1} α β rα rβ) (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (RingHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)) f)) (instCoeTCMonoidHom.proof_2.{u1, u2, max u2 u1} α β (RingHom.{u2, u1} α β rα rβ) (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (RingHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)) f))
Case conversion may be inaccurate. Consider using '#align ring_hom.to_monoid_hom_eq_coe RingHom.toMonoidHom_eq_coeₓ'. -/
@[simp]
theorem toMonoidHom_eq_coe (f : α →+* β) : f.toMonoidHom = f :=
  rfl
#align ring_hom.to_monoid_hom_eq_coe RingHom.toMonoidHom_eq_coe

/- warning: ring_hom.to_monoid_with_zero_hom_eq_coe -> RingHom.toMonoidWithZeroHom_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u2)} ((fun (_x : MonoidWithZeroHom.{u1, u2} α β (NonAssocSemiring.toMulZeroOneClass.{u1} α rα) (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) => α -> β) (RingHom.toMonoidWithZeroHom.{u1, u2} α β rα rβ f)) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidWithZeroHom.{u1, u2} α β (NonAssocSemiring.toMulZeroOneClass.{u1} α rα) (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (fun (_x : MonoidWithZeroHom.{u1, u2} α β (NonAssocSemiring.toMulZeroOneClass.{u1} α rα) (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) => α -> β) (MonoidWithZeroHom.hasCoeToFun.{u1, u2} α β (NonAssocSemiring.toMulZeroOneClass.{u1} α rα) (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (RingHom.toMonoidWithZeroHom.{u1, u2} α β rα rβ f)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ), Eq.{max (succ u2) (succ u1)} (forall (a : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MonoidWithZeroHom.{u2, u1} α β (NonAssocSemiring.toMulZeroOneClass.{u2} α rα) (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} α β (NonAssocSemiring.toMulZeroOneClass.{u2} α rα) (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) α β (MulOneClass.toMul.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toMul.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} α β (NonAssocSemiring.toMulZeroOneClass.{u2} α rα) (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (MonoidWithZeroHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (MonoidWithZeroHom.{u2, u1} α β (NonAssocSemiring.toMulZeroOneClass.{u2} α rα) (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) α β (NonAssocSemiring.toMulZeroOneClass.{u2} α rα) (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ) (MonoidWithZeroHom.monoidWithZeroHomClass.{u2, u1} α β (NonAssocSemiring.toMulZeroOneClass.{u2} α rα) (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))))) (RingHom.toMonoidWithZeroHom.{u2, u1} α β rα rβ f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f)
Case conversion may be inaccurate. Consider using '#align ring_hom.to_monoid_with_zero_hom_eq_coe RingHom.toMonoidWithZeroHom_eq_coeₓ'. -/
@[simp]
theorem toMonoidWithZeroHom_eq_coe (f : α →+* β) : (f.toMonoidWithZeroHom : α → β) = f :=
  rfl
#align ring_hom.to_monoid_with_zero_hom_eq_coe RingHom.toMonoidWithZeroHom_eq_coe

/- warning: ring_hom.coe_monoid_hom_mk -> RingHom.coe_monoidHom_mk is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : α -> β) (h₁ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (MulOneClass.toHasOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))))))) (h₂ : forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toHasMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (MulOneClass.toHasMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))) (f x) (f y))) (h₃ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))))))) (h₄ : forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))) (f x) (f y))), Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (RingHom.{u1, u2} α β rα rβ) (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} α β (RingHom.{u1, u2} α β rα rβ) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (RingHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.ringHomClass.{u1, u2} α β rα rβ))))) (RingHom.mk.{u1, u2} α β rα rβ f h₁ h₂ h₃ h₄)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) f h₁ h₂)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : α -> β) (h₁ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))))) (h₂ : forall (x : α) (y : α), Eq.{succ u2} β (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (MulOneClass.toMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) x) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) y))) (h₃ : Eq.{succ u2} β (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (AddZeroClass.toZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))))) (h₄ : forall (x : α) (y : α), Eq.{succ u2} β (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) x) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) y))), Eq.{max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (FunLike.coe.{succ (max u1 u2), succ u1, succ u2} (RingHom.{u1, u2} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (MulOneClass.toMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (RingHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)))) (RingHom.mk.{u1, u2} α β rα rβ (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂) h₃ h₄)) (instCoeTCMonoidHom.proof_1.{u2, u1, max u1 u2} α β (RingHom.{u1, u2} α β rα rβ) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (RingHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)) (RingHom.mk.{u1, u2} α β rα rβ (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂) h₃ h₄))) (instCoeTCMonoidHom.proof_2.{u2, u1, max u1 u2} α β (RingHom.{u1, u2} α β rα rβ) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (RingHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)) (RingHom.mk.{u1, u2} α β rα rβ (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂) h₃ h₄))) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_monoid_hom_mk RingHom.coe_monoidHom_mkₓ'. -/
@[simp]
theorem coe_monoidHom_mk (f : α → β) (h₁ h₂ h₃ h₄) :
    ((⟨f, h₁, h₂, h₃, h₄⟩ : α →+* β) : α →* β) = ⟨f, h₁, h₂⟩ :=
  rfl
#align ring_hom.coe_monoid_hom_mk RingHom.coe_monoidHom_mk

/- warning: ring_hom.coe_add_monoid_hom clashes with [anonymous] -> [anonymous]
warning: ring_hom.coe_add_monoid_hom -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u_2}} {β : Type.{u_3}} {rα : NonAssocSemiring.{u_2} α} {rβ : NonAssocSemiring.{u_3} β} (f : RingHom.{u_2, u_3} α β rα rβ), Eq.{max (succ u_2) (succ u_3)} (α -> β) (coeFn.{max (succ u_3) (succ u_2), max (succ u_2) (succ u_3)} (AddMonoidHom.{u_2, u_3} α β (AddMonoid.toAddZeroClass.{u_2} α (AddMonoidWithOne.toAddMonoid.{u_2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u_2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u_2} α rα)))) (AddMonoid.toAddZeroClass.{u_3} β (AddMonoidWithOne.toAddMonoid.{u_3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u_3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u_3} β rβ))))) (fun (_x : AddMonoidHom.{u_2, u_3} α β (AddMonoid.toAddZeroClass.{u_2} α (AddMonoidWithOne.toAddMonoid.{u_2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u_2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u_2} α rα)))) (AddMonoid.toAddZeroClass.{u_3} β (AddMonoidWithOne.toAddMonoid.{u_3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u_3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u_3} β rβ))))) => α -> β) (AddMonoidHom.hasCoeToFun.{u_2, u_3} α β (AddMonoid.toAddZeroClass.{u_2} α (AddMonoidWithOne.toAddMonoid.{u_2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u_2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u_2} α rα)))) (AddMonoid.toAddZeroClass.{u_3} β (AddMonoidWithOne.toAddMonoid.{u_3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u_3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u_3} β rβ))))) ((fun (a : Sort.{max (succ u_2) (succ u_3)}) (b : Sort.{max (succ u_3) (succ u_2)}) [self : HasLiftT.{max (succ u_2) (succ u_3), max (succ u_3) (succ u_2)} a b] => self.0) (RingHom.{u_2, u_3} α β rα rβ) (AddMonoidHom.{u_2, u_3} α β (AddMonoid.toAddZeroClass.{u_2} α (AddMonoidWithOne.toAddMonoid.{u_2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u_2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u_2} α rα)))) (AddMonoid.toAddZeroClass.{u_3} β (AddMonoidWithOne.toAddMonoid.{u_3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u_3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u_3} β rβ))))) (HasLiftT.mk.{max (succ u_2) (succ u_3), max (succ u_3) (succ u_2)} (RingHom.{u_2, u_3} α β rα rβ) (AddMonoidHom.{u_2, u_3} α β (AddMonoid.toAddZeroClass.{u_2} α (AddMonoidWithOne.toAddMonoid.{u_2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u_2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u_2} α rα)))) (AddMonoid.toAddZeroClass.{u_3} β (AddMonoidWithOne.toAddMonoid.{u_3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u_3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u_3} β rβ))))) (CoeTCₓ.coe.{max (succ u_2) (succ u_3), max (succ u_3) (succ u_2)} (RingHom.{u_2, u_3} α β rα rβ) (AddMonoidHom.{u_2, u_3} α β (AddMonoid.toAddZeroClass.{u_2} α (AddMonoidWithOne.toAddMonoid.{u_2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u_2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u_2} α rα)))) (AddMonoid.toAddZeroClass.{u_3} β (AddMonoidWithOne.toAddMonoid.{u_3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u_3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u_3} β rβ))))) (AddMonoidHom.hasCoeT.{u_2, u_3, max u_2 u_3} α β (RingHom.{u_2, u_3} α β rα rβ) (AddMonoid.toAddZeroClass.{u_2} α (AddMonoidWithOne.toAddMonoid.{u_2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u_2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u_2} α rα)))) (AddMonoid.toAddZeroClass.{u_3} β (AddMonoidWithOne.toAddMonoid.{u_3} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u_3} β (NonAssocSemiring.toAddCommMonoidWithOne.{u_3} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u_2 u_3, u_2, u_3} (RingHom.{u_2, u_3} α β rα rβ) α β rα rβ (RingHom.ringHomClass.{u_2, u_3} α β rα rβ))))) f)) (coeFn.{max (succ u_2) (succ u_3), max (succ u_2) (succ u_3)} (RingHom.{u_2, u_3} α β rα rβ) (fun (_x : RingHom.{u_2, u_3} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u_2, u_3} α β rα rβ) f)
but is expected to have type
  forall {α : Sort.{u}} {β : Nat}, ((Eq.{1} Nat β (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> α) -> (forall (m : Nat), (Eq.{1} Nat β (Nat.succ m)) -> α) -> α
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_add_monoid_hom [anonymous]ₓ'. -/
@[simp, norm_cast]
theorem [anonymous] (f : α →+* β) : ⇑(f : α →+ β) = f :=
  rfl
#align ring_hom.coe_add_monoid_hom[anonymous]

/- warning: ring_hom.to_add_monoid_hom_eq_coe -> RingHom.toAddMonoidHom_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (RingHom.toAddMonoidHom.{u1, u2} α β rα rβ f) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (RingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (AddMonoidHom.hasCoeT.{u1, u2, max u1 u2} α β (RingHom.{u1, u2} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.ringHomClass.{u1, u2} α β rα rβ))))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ))))) (RingHom.toAddMonoidHom.{u2, u1} α β rα rβ f) (AddMonoidHom.mk.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ)))) (ZeroHom.mk.{u2, u1} α β (AddZeroClass.toZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα))))) (AddZeroClass.toZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ))))) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => β) a) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα))))) (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) (instCoeTCAddMonoidHom_1.proof_1.{u1, u2, max u2 u1} α β (RingHom.{u2, u1} α β rα rβ) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)) f)) (instCoeTCAddMonoidHom_1.proof_2.{u1, u2, max u2 u1} α β (RingHom.{u2, u1} α β rα rβ) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)) f))
Case conversion may be inaccurate. Consider using '#align ring_hom.to_add_monoid_hom_eq_coe RingHom.toAddMonoidHom_eq_coeₓ'. -/
@[simp]
theorem toAddMonoidHom_eq_coe (f : α →+* β) : f.toAddMonoidHom = f :=
  rfl
#align ring_hom.to_add_monoid_hom_eq_coe RingHom.toAddMonoidHom_eq_coe

/- warning: ring_hom.coe_add_monoid_hom_mk -> RingHom.coe_addMonoidHom_mk is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : α -> β) (h₁ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (MulOneClass.toHasOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))))))) (h₂ : forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toHasMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (MulOneClass.toHasMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))) (f x) (f y))) (h₃ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))))))) (h₄ : forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))) (f x) (f y))), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (RingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (AddMonoidHom.hasCoeT.{u1, u2, max u1 u2} α β (RingHom.{u1, u2} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.ringHomClass.{u1, u2} α β rα rβ))))) (RingHom.mk.{u1, u2} α β rα rβ f h₁ h₂ h₃ h₄)) (AddMonoidHom.mk.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))) f h₃ h₄)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : α -> β) (h₁ : Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))))) (h₂ : forall (x : α) (y : α), Eq.{succ u2} β (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (MulOneClass.toMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) x) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) y))) (h₃ : Eq.{succ u2} β (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (AddZeroClass.toZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))))) (h₄ : forall (x : α) (y : α), Eq.{succ u2} β (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) x) (OneHom.toFun.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.toOneHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂)) y))), Eq.{max (succ u1) (succ u2)} (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (AddMonoidHom.mk.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))) (ZeroHom.mk.{u1, u2} α β (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (AddZeroClass.toZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (FunLike.coe.{succ (max u1 u2), succ u1, succ u2} (RingHom.{u1, u2} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => β) a) (AddHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)))) (RingHom.mk.{u1, u2} α β rα rβ (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂) h₃ h₄)) (instCoeTCAddMonoidHom_1.proof_1.{u2, u1, max u1 u2} α β (RingHom.{u1, u2} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)) (RingHom.mk.{u1, u2} α β rα rβ (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂) h₃ h₄))) (instCoeTCAddMonoidHom_1.proof_2.{u2, u1, max u1 u2} α β (RingHom.{u1, u2} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)) (RingHom.mk.{u1, u2} α β rα rβ (MonoidHom.mk.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (OneHom.mk.{u1, u2} α β (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) f h₁) h₂) h₃ h₄))) (AddMonoidHom.mk.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))) (ZeroHom.mk.{u1, u2} α β (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (AddZeroClass.toZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) f h₃) h₄)
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_add_monoid_hom_mk RingHom.coe_addMonoidHom_mkₓ'. -/
@[simp]
theorem coe_addMonoidHom_mk (f : α → β) (h₁ h₂ h₃ h₄) :
    ((⟨f, h₁, h₂, h₃, h₄⟩ : α →+* β) : α →+ β) = ⟨f, h₃, h₄⟩ :=
  rfl
#align ring_hom.coe_add_monoid_hom_mk RingHom.coe_addMonoidHom_mk

/- warning: ring_hom.copy -> RingHom.copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)) -> (RingHom.{u1, u2} α β rα rβ)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ) (f' : α -> β), (Eq.{max (succ u1) (succ u2)} (α -> β) f' (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)))) f)) -> (RingHom.{u1, u2} α β rα rβ)
Case conversion may be inaccurate. Consider using '#align ring_hom.copy RingHom.copyₓ'. -/
/-- Copy of a `ring_hom` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
def copy (f : α →+* β) (f' : α → β) (h : f' = f) : α →+* β :=
  { f.toMonoidWithZeroHom.copy f' h, f.toAddMonoidHom.copy f' h with }
#align ring_hom.copy RingHom.copy

/- warning: ring_hom.coe_copy -> RingHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)), Eq.{max (succ u1) (succ u2)} (α -> β) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) (RingHom.copy.{u1, u2} α β rα rβ f f' h)) f'
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f)), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) (RingHom.copy.{u2, u1} α β rα rβ f f' h)) f'
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_copy RingHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : α →+* β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align ring_hom.coe_copy RingHom.coe_copy

/- warning: ring_hom.copy_eq -> RingHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ) (f' : α -> β) (h : Eq.{max (succ u1) (succ u2)} (α -> β) f' (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)), Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (RingHom.copy.{u1, u2} α β rα rβ f f' h) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ) (f' : α -> β) (h : Eq.{max (succ u2) (succ u1)} (α -> β) f' (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f)), Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} α β rα rβ) (RingHom.copy.{u2, u1} α β rα rβ f f' h) f
Case conversion may be inaccurate. Consider using '#align ring_hom.copy_eq RingHom.copy_eqₓ'. -/
theorem copy_eq (f : α →+* β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align ring_hom.copy_eq RingHom.copy_eq

end coe

variable [rα : NonAssocSemiring α] [rβ : NonAssocSemiring β]

section

include rα rβ

variable (f : α →+* β) {x y : α} {rα rβ}

/- warning: ring_hom.congr_fun -> RingHom.congr_fun is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} {f : RingHom.{u1, u2} α β rα rβ} {g : RingHom.{u1, u2} α β rα rβ}, (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) f g) -> (forall (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) g x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} {f : RingHom.{u2, u1} α β rα rβ} {g : RingHom.{u2, u1} α β rα rβ}, (Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} α β rα rβ) f g) -> (forall (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) g x))
Case conversion may be inaccurate. Consider using '#align ring_hom.congr_fun RingHom.congr_funₓ'. -/
theorem congr_fun {f g : α →+* β} (h : f = g) (x : α) : f x = g x :=
  FunLike.congr_fun h x
#align ring_hom.congr_fun RingHom.congr_fun

/- warning: ring_hom.congr_arg -> RingHom.congr_arg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ) {x : α} {y : α}, (Eq.{succ u1} α x y) -> (Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ) {x : α} {y : α}, (Eq.{succ u2} α x y) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f y))
Case conversion may be inaccurate. Consider using '#align ring_hom.congr_arg RingHom.congr_argₓ'. -/
theorem congr_arg (f : α →+* β) {x y : α} (h : x = y) : f x = f y :=
  FunLike.congr_arg f h
#align ring_hom.congr_arg RingHom.congr_arg

/- warning: ring_hom.coe_inj -> RingHom.coe_inj is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} {{f : RingHom.{u1, u2} α β rα rβ}} {{g : RingHom.{u1, u2} α β rα rβ}}, (Eq.{max (succ u1) (succ u2)} ((fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) g)) -> (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} {{f : RingHom.{u2, u1} α β rα rβ}} {{g : RingHom.{u2, u1} α β rα rβ}}, (Eq.{max (succ u2) (succ u1)} (forall (a : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) g)) -> (Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} α β rα rβ) f g)
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_inj RingHom.coe_injₓ'. -/
theorem coe_inj ⦃f g : α →+* β⦄ (h : (f : α → β) = g) : f = g :=
  FunLike.coe_injective h
#align ring_hom.coe_inj RingHom.coe_inj

/- warning: ring_hom.ext -> RingHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} {{f : RingHom.{u1, u2} α β rα rβ}} {{g : RingHom.{u1, u2} α β rα rβ}}, (forall (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) g x)) -> (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) f g)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} {{f : RingHom.{u2, u1} α β rα rβ}} {{g : RingHom.{u2, u1} α β rα rβ}}, (forall (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) g x)) -> (Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} α β rα rβ) f g)
Case conversion may be inaccurate. Consider using '#align ring_hom.ext RingHom.extₓ'. -/
@[ext]
theorem ext ⦃f g : α →+* β⦄ : (∀ x, f x = g x) → f = g :=
  FunLike.ext _ _
#align ring_hom.ext RingHom.ext

/- warning: ring_hom.ext_iff -> RingHom.ext_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} {f : RingHom.{u1, u2} α β rα rβ} {g : RingHom.{u1, u2} α β rα rβ}, Iff (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) f g) (forall (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) g x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} {f : RingHom.{u2, u1} α β rα rβ} {g : RingHom.{u2, u1} α β rα rβ}, Iff (Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} α β rα rβ) f g) (forall (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) g x))
Case conversion may be inaccurate. Consider using '#align ring_hom.ext_iff RingHom.ext_iffₓ'. -/
theorem ext_iff {f g : α →+* β} : f = g ↔ ∀ x, f x = g x :=
  FunLike.ext_iff
#align ring_hom.ext_iff RingHom.ext_iff

/- warning: ring_hom.mk_coe -> RingHom.mk_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ) (h₁ : Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (MulOneClass.toHasOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (MulOneClass.toHasOne.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))))))) (h₂ : forall (x : α) (y : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulOneClass.toHasMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (MulOneClass.toHasMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f y))) (h₃ : Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (AddZeroClass.toHasZero.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))))))) (h₄ : forall (x : α) (y : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (AddZeroClass.toHasAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (AddZeroClass.toHasAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f y))), Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (RingHom.mk.{u1, u2} α β rα rβ (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f) h₁ h₂ h₃ h₄) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ) (h₁ : Eq.{succ u1} β (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)))))) (h₂ : forall (x : α) (y : α), Eq.{succ u1} β (OneHom.toFun.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) h₁) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (MulOneClass.toMul.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) x y)) (HMul.hMul.{u1, u1, u1} β β β (instHMul.{u1} β (MulOneClass.toMul.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)))) (OneHom.toFun.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) h₁) x) (OneHom.toFun.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) h₁) y))) (h₃ : Eq.{succ u1} β (OneHom.toFun.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (MonoidHom.toOneHom.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (MonoidHom.mk.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) h₁) h₂)) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (AddZeroClass.toZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))))))) (OfNat.ofNat.{u1} β 0 (Zero.toOfNat0.{u1} β (AddZeroClass.toZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ)))))))) (h₄ : forall (x : α) (y : α), Eq.{succ u1} β (OneHom.toFun.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (MonoidHom.toOneHom.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (MonoidHom.mk.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) h₁) h₂)) (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))))) x y)) (HAdd.hAdd.{u1, u1, u1} β β β (instHAdd.{u1} β (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ)))))) (OneHom.toFun.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (MonoidHom.toOneHom.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (MonoidHom.mk.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) h₁) h₂)) x) (OneHom.toFun.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (MonoidHom.toOneHom.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (MonoidHom.mk.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) h₁) h₂)) y))), Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} α β rα rβ) (RingHom.mk.{u2, u1} α β rα rβ (MonoidHom.mk.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) h₁) h₂) h₃ h₄) f
Case conversion may be inaccurate. Consider using '#align ring_hom.mk_coe RingHom.mk_coeₓ'. -/
@[simp]
theorem mk_coe (f : α →+* β) (h₁ h₂ h₃ h₄) : RingHom.mk f h₁ h₂ h₃ h₄ = f :=
  ext fun _ => rfl
#align ring_hom.mk_coe RingHom.mk_coe

/- warning: ring_hom.coe_add_monoid_hom_injective -> RingHom.coe_addMonoidHom_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β}, Function.Injective.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (RingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (AddMonoidHom.{u1, u2} α β (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))) (AddMonoidHom.hasCoeT.{u1, u2, max u1 u2} α β (RingHom.{u1, u2} α β rα rβ) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.ringHomClass.{u1, u2} α β rα rβ))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β}, Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} α β rα rβ) (AddMonoidHom.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ))))) (fun (f : RingHom.{u2, u1} α β rα rβ) => AddMonoidHom.mk.{u2, u1} α β (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ)))) (ZeroHom.mk.{u2, u1} α β (AddZeroClass.toZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα))))) (AddZeroClass.toZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ))))) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => β) a) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα))))) (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) (instCoeTCAddMonoidHom_1.proof_1.{u1, u2, max u2 u1} α β (RingHom.{u2, u1} α β rα rβ) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)) f)) (instCoeTCAddMonoidHom_1.proof_2.{u1, u2, max u2 u1} α β (RingHom.{u2, u1} α β rα rβ) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α rα)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} β (NonAssocSemiring.toAddCommMonoidWithOne.{u1} β rβ)))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)) f))
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_add_monoid_hom_injective RingHom.coe_addMonoidHom_injectiveₓ'. -/
theorem coe_addMonoidHom_injective : Injective (coe : (α →+* β) → α →+ β) := fun f g h =>
  ext <| AddMonoidHom.congr_fun h
#align ring_hom.coe_add_monoid_hom_injective RingHom.coe_addMonoidHom_injective

/- warning: ring_hom.coe_monoid_hom_injective -> RingHom.coe_monoidHom_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β}, Function.Injective.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) ((fun (a : Sort.{max (succ u1) (succ u2)}) (b : Sort.{max (succ u2) (succ u1)}) [self : HasLiftT.{max (succ u1) (succ u2), max (succ u2) (succ u1)} a b] => self.0) (RingHom.{u1, u2} α β rα rβ) (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (HasLiftT.mk.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (CoeTCₓ.coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (RingHom.{u1, u2} α β rα rβ) (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))) (MonoidHom.hasCoeT.{u1, u2, max u1 u2} α β (RingHom.{u1, u2} α β rα rβ) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)) (RingHomClass.toMonoidHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.ringHomClass.{u1, u2} α β rα rβ))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β}, Function.Injective.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} α β rα rβ) (MonoidHom.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (fun (f : RingHom.{u2, u1} α β rα rβ) => MonoidHom.mk.{u2, u1} α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (OneHom.mk.{u2, u1} α β (MulOneClass.toOne.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toOne.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (FunLike.coe.{succ (max u2 u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (MulOneClass.toMul.{u2} α (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))) (MulOneClass.toMul.{u1} β (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ))) (MonoidHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (RingHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f) (instCoeTCMonoidHom.proof_1.{u1, u2, max u2 u1} α β (RingHom.{u2, u1} α β rα rβ) (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (RingHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)) f)) (instCoeTCMonoidHom.proof_2.{u1, u2, max u2 u1} α β (RingHom.{u2, u1} α β rα rβ) (MulZeroOneClass.toMulOneClass.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)) (MulZeroOneClass.toMulOneClass.{u1} β (NonAssocSemiring.toMulZeroOneClass.{u1} β rβ)) (RingHomClass.toMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)) f))
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_monoid_hom_injective RingHom.coe_monoidHom_injectiveₓ'. -/
theorem coe_monoidHom_injective : Injective (coe : (α →+* β) → α →* β) := fun f g h =>
  ext <| MonoidHom.congr_fun h
#align ring_hom.coe_monoid_hom_injective RingHom.coe_monoidHom_injective

/- warning: ring_hom.map_zero -> RingHom.map_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))))) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))))) (MulZeroOneClass.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))))) (NonAssocSemiring.toMulZeroOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα))))) rβ))))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_zero RingHom.map_zeroₓ'. -/
/-- Ring homomorphisms map zero to zero. -/
protected theorem map_zero (f : α →+* β) : f 0 = 0 :=
  map_zero f
#align ring_hom.map_zero RingHom.map_zero

/- warning: ring_hom.map_one -> RingHom.map_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα)))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα)))) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα)))) (NonAssocSemiring.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα)))) rβ)))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_one RingHom.map_oneₓ'. -/
/-- Ring homomorphisms map one to one. -/
protected theorem map_one (f : α →+* β) : f 1 = 1 :=
  map_one f
#align ring_hom.map_one RingHom.map_one

/- warning: ring_hom.map_add -> RingHom.map_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ) (a : α) (b : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)))) a b)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ) (a : α) (b : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)))) a b)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f (HAdd.hAdd.{u2, u2, u2} α α α (instHAdd.{u2} α (Distrib.toAdd.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)))) a b)) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) b) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (Distrib.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (NonUnitalNonAssocSemiring.toDistrib.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) rβ)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f b))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_add RingHom.map_addₓ'. -/
/-- Ring homomorphisms preserve addition. -/
protected theorem map_add (f : α →+* β) : ∀ a b, f (a + b) = f a + f b :=
  map_add f
#align ring_hom.map_add RingHom.map_add

/- warning: ring_hom.map_mul -> RingHom.map_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ) (a : α) (b : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)))) a b)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ) (a : α) (b : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα))) a b)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα))) a b)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) b) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (NonUnitalNonAssocSemiring.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) rβ))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u2, u1} α β rα rβ)))) f b))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_mul RingHom.map_mulₓ'. -/
/-- Ring homomorphisms preserve multiplication. -/
protected theorem map_mul (f : α →+* β) : ∀ a b, f (a * b) = f a * f b :=
  map_mul f
#align ring_hom.map_mul RingHom.map_mul

/-- Ring homomorphisms preserve `bit0`. -/
protected theorem map_bit0 (f : α →+* β) : ∀ a, f (bit0 a) = bit0 (f a) :=
  map_bit0 f
#align ring_hom.map_bit0 RingHom.map_bit0

/-- Ring homomorphisms preserve `bit1`. -/
protected theorem map_bit1 (f : α →+* β) : ∀ a, f (bit1 a) = bit1 (f a) :=
  map_bit1 f
#align ring_hom.map_bit1 RingHom.map_bit1

/- warning: ring_hom.map_ite_zero_one -> RingHom.map_ite_zero_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} {F : Type.{u3}} [_inst_1 : RingHomClass.{u3, u1, u2} F α β rα rβ] (f : F) (p : Prop) [_inst_2 : Decidable p], Eq.{succ u2} β (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F α (fun (_x : α) => β) (MulHomClass.toFunLike.{u3, u1, u2} F α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα))) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F α β rα rβ _inst_1)))) f (ite.{succ u1} α p _inst_2 (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))))) (ite.{succ u2} β p _inst_2 (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} {F : Type.{u3}} [_inst_1 : RingHomClass.{u3, u2, u1} F α β rα rβ] (f : F) (p : Prop) [_inst_2 : Decidable p], Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))))) (FunLike.coe.{succ u3, succ u2, succ u1} F α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{u3, u2, u1} F α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{u3, u2, u1} F α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{u3, u2, u1} F α β rα rβ _inst_1))) f (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))))) (ite.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))))) p _inst_2 (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))))) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))))) (MulZeroOneClass.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))))) (NonAssocSemiring.toMulZeroOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))))) rβ)))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))))) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))))) (NonAssocSemiring.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))))) rβ))))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_ite_zero_one RingHom.map_ite_zero_oneₓ'. -/
@[simp]
theorem map_ite_zero_one {F : Type _} [RingHomClass F α β] (f : F) (p : Prop) [Decidable p] :
    f (ite p 0 1) = ite p 0 1 := by split_ifs <;> simp [h]
#align ring_hom.map_ite_zero_one RingHom.map_ite_zero_one

/- warning: ring_hom.map_ite_one_zero -> RingHom.map_ite_one_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} {F : Type.{u3}} [_inst_1 : RingHomClass.{u3, u1, u2} F α β rα rβ] (f : F) (p : Prop) [_inst_2 : Decidable p], Eq.{succ u2} β (coeFn.{succ u3, max (succ u1) (succ u2)} F (fun (_x : F) => α -> β) (FunLike.hasCoeToFun.{succ u3, succ u1, succ u2} F α (fun (_x : α) => β) (MulHomClass.toFunLike.{u3, u1, u2} F α β (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα))) (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ))) (NonUnitalRingHomClass.toMulHomClass.{u3, u1, u2} F α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ) (RingHomClass.toNonUnitalRingHomClass.{u3, u1, u2} F α β rα rβ _inst_1)))) f (ite.{succ u1} α p _inst_2 (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)))))))) (ite.{succ u2} β p _inst_2 (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ)))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)))))))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} {F : Type.{u3}} [_inst_1 : RingHomClass.{u3, u2, u1} F α β rα rβ] (f : F) (p : Prop) [_inst_2 : Decidable p], Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) (FunLike.coe.{succ u3, succ u2, succ u1} F α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{u3, u2, u1} F α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{u3, u2, u1} F α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β rβ) (RingHomClass.toNonUnitalRingHomClass.{u3, u2, u1} F α β rα rβ _inst_1))) f (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) (ite.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) p _inst_2 (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) (NonAssocSemiring.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) rβ))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) (MulZeroOneClass.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) (NonAssocSemiring.toMulZeroOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (ite.{succ u2} α p _inst_2 (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (NonAssocSemiring.toOne.{u2} α rα))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α rα)))))) rβ)))))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_ite_one_zero RingHom.map_ite_one_zeroₓ'. -/
@[simp]
theorem map_ite_one_zero {F : Type _} [RingHomClass F α β] (f : F) (p : Prop) [Decidable p] :
    f (ite p 1 0) = ite p 1 0 := by split_ifs <;> simp [h]
#align ring_hom.map_ite_one_zero RingHom.map_ite_one_zero

/- warning: ring_hom.codomain_trivial_iff_map_one_eq_zero -> RingHom.codomain_trivial_iff_map_one_eq_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Iff (Eq.{succ u2} β (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))))) (Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Iff (Eq.{succ u2} β (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (MulZeroOneClass.toZero.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (NonAssocSemiring.toOne.{u2} β rβ)))) (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)))) f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) (MulZeroOneClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) (NonAssocSemiring.toMulZeroOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) rβ)))))
Case conversion may be inaccurate. Consider using '#align ring_hom.codomain_trivial_iff_map_one_eq_zero RingHom.codomain_trivial_iff_map_one_eq_zeroₓ'. -/
/-- `f : α →+* β` has a trivial codomain iff `f 1 = 0`. -/
theorem codomain_trivial_iff_map_one_eq_zero : (0 : β) = 1 ↔ f 1 = 0 := by rw [map_one, eq_comm]
#align ring_hom.codomain_trivial_iff_map_one_eq_zero RingHom.codomain_trivial_iff_map_one_eq_zero

/- warning: ring_hom.codomain_trivial_iff_range_trivial -> RingHom.codomain_trivial_iff_range_trivial is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Iff (Eq.{succ u2} β (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))))) (forall (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f x) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Iff (Eq.{succ u2} β (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (MulZeroOneClass.toZero.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (NonAssocSemiring.toOne.{u2} β rβ)))) (forall (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)))) f x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (MulZeroOneClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (NonAssocSemiring.toMulZeroOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) rβ)))))
Case conversion may be inaccurate. Consider using '#align ring_hom.codomain_trivial_iff_range_trivial RingHom.codomain_trivial_iff_range_trivialₓ'. -/
/-- `f : α →+* β` has a trivial codomain iff it has a trivial range. -/
theorem codomain_trivial_iff_range_trivial : (0 : β) = 1 ↔ ∀ x, f x = 0 :=
  f.codomain_trivial_iff_map_one_eq_zero.trans
    ⟨fun h x => by rw [← mul_one x, map_mul, h, mul_zero], fun h => h 1⟩
#align ring_hom.codomain_trivial_iff_range_trivial RingHom.codomain_trivial_iff_range_trivial

/- warning: ring_hom.codomain_trivial_iff_range_eq_singleton_zero -> RingHom.codomain_trivial_iff_range_eq_singleton_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Iff (Eq.{succ u2} β (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)))))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β rβ))))))) (Eq.{succ u2} (Set.{u2} β) (Set.range.{u2, succ u1} β α (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)) (Singleton.singleton.{u2, u2} β (Set.{u2} β) (Set.hasSingleton.{u2} β) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ))))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ), Iff (Eq.{succ u2} β (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (MulZeroOneClass.toZero.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ)))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (NonAssocSemiring.toOne.{u2} β rβ)))) (Eq.{succ u2} (Set.{u2} β) (Set.range.{u2, succ u1} β α (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)))) f)) (Singleton.singleton.{u2, u2} β (Set.{u2} β) (Set.instSingletonSet.{u2} β) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (MulZeroOneClass.toZero.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β rβ))))))
Case conversion may be inaccurate. Consider using '#align ring_hom.codomain_trivial_iff_range_eq_singleton_zero RingHom.codomain_trivial_iff_range_eq_singleton_zeroₓ'. -/
/-- `f : α →+* β` has a trivial codomain iff its range is `{0}`. -/
theorem codomain_trivial_iff_range_eq_singleton_zero : (0 : β) = 1 ↔ Set.range f = {0} :=
  f.codomain_trivial_iff_range_trivial.trans
    ⟨fun h =>
      Set.ext fun y => ⟨fun ⟨x, hx⟩ => by simp [← hx, h x], fun hy => ⟨0, by simpa using hy.symm⟩⟩,
      fun h x => Set.mem_singleton_iff.mp (h ▸ Set.mem_range_self x)⟩
#align
  ring_hom.codomain_trivial_iff_range_eq_singleton_zero RingHom.codomain_trivial_iff_range_eq_singleton_zero

/- warning: ring_hom.map_one_ne_zero -> RingHom.map_one_ne_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ) [_inst_1 : Nontrivial.{u2} β], Ne.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ))))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β} (f : RingHom.{u1, u2} α β rα rβ) [_inst_1 : Nontrivial.{u2} β], Ne.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u2} α β rα rβ)))) f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) (MulZeroOneClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) (NonAssocSemiring.toMulZeroOneClass.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (NonAssocSemiring.toOne.{u1} α rα)))) rβ))))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_one_ne_zero RingHom.map_one_ne_zeroₓ'. -/
/-- `f : α →+* β` doesn't map `1` to `0` if `β` is nontrivial -/
theorem map_one_ne_zero [Nontrivial β] : f 1 ≠ 0 :=
  mt f.codomain_trivial_iff_map_one_eq_zero.mpr zero_ne_one
#align ring_hom.map_one_ne_zero RingHom.map_one_ne_zero

#print RingHom.domain_nontrivial /-
/-- If there is a homomorphism `f : α →+* β` and `β` is nontrivial, then `α` is nontrivial. -/
theorem domain_nontrivial [Nontrivial β] : Nontrivial α :=
  ⟨⟨1, 0, mt (fun h => show f 1 = 0 by rw [h, map_zero]) f.map_one_ne_zero⟩⟩
#align ring_hom.domain_nontrivial RingHom.domain_nontrivial
-/

/- warning: ring_hom.codomain_trivial -> RingHom.codomain_trivial is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u2} β}, (RingHom.{u1, u2} α β rα rβ) -> (forall [h : Subsingleton.{succ u1} α], Subsingleton.{succ u2} β)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β}, (RingHom.{u2, u1} α β rα rβ) -> (forall [h : Subsingleton.{succ u2} α], Subsingleton.{succ u1} β)
Case conversion may be inaccurate. Consider using '#align ring_hom.codomain_trivial RingHom.codomain_trivialₓ'. -/
theorem codomain_trivial (f : α →+* β) [h : Subsingleton α] : Subsingleton β :=
  (subsingleton_or_nontrivial β).resolve_right fun _ =>
    not_nontrivial_iff_subsingleton.mpr h f.domain_nontrivial
#align ring_hom.codomain_trivial RingHom.codomain_trivial

end

/- warning: ring_hom.map_neg -> RingHom.map_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocRing.{u1} α] [_inst_2 : NonAssocRing.{u2} β] (f : RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) (x : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) (fun (_x : RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) f (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1)))) x)) (Neg.neg.{u2} β (SubNegMonoid.toHasNeg.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddGroupWithOne.toAddGroup.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) (fun (_x : RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) f x))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocRing.{u2} α] [_inst_2 : NonAssocRing.{u1} β] (f : RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (Neg.neg.{u2} α (AddGroupWithOne.toNeg.{u2} α (NonAssocRing.toAddGroupWithOne.{u2} α _inst_1)) x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2))))) f (Neg.neg.{u2} α (AddGroupWithOne.toNeg.{u2} α (NonAssocRing.toAddGroupWithOne.{u2} α _inst_1)) x)) (Neg.neg.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (AddGroupWithOne.toNeg.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (NonAssocRing.toAddGroupWithOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) _inst_2)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2))))) f x))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_neg RingHom.map_negₓ'. -/
/-- Ring homomorphisms preserve additive inverse. -/
protected theorem map_neg [NonAssocRing α] [NonAssocRing β] (f : α →+* β) (x : α) : f (-x) = -f x :=
  map_neg f x
#align ring_hom.map_neg RingHom.map_neg

/- warning: ring_hom.map_sub -> RingHom.map_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocRing.{u1} α] [_inst_2 : NonAssocRing.{u2} β] (f : RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) (x : α) (y : α), Eq.{succ u2} β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) (fun (_x : RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) f (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddGroupWithOne.toAddGroup.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α _inst_1))))) x y)) (HSub.hSub.{u2, u2, u2} β β β (instHSub.{u2} β (SubNegMonoid.toHasSub.{u2} β (AddGroup.toSubNegMonoid.{u2} β (AddGroupWithOne.toAddGroup.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β _inst_2))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) (fun (_x : RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) f x) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) (fun (_x : RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)) f y))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : NonAssocRing.{u2} α] [_inst_2 : NonAssocRing.{u1} β] (f : RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) (x : α) (y : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (AddGroupWithOne.toSub.{u2} α (NonAssocRing.toAddGroupWithOne.{u2} α _inst_1))) x y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2))))) f (HSub.hSub.{u2, u2, u2} α α α (instHSub.{u2} α (AddGroupWithOne.toSub.{u2} α (NonAssocRing.toAddGroupWithOne.{u2} α _inst_1))) x y)) (HSub.hSub.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) y) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (instHSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (AddGroupWithOne.toSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) (NonAssocRing.toAddGroupWithOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) x) _inst_2))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α _inst_1) (NonAssocRing.toNonAssocSemiring.{u1} β _inst_2))))) f y))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_sub RingHom.map_subₓ'. -/
/-- Ring homomorphisms preserve subtraction. -/
protected theorem map_sub [NonAssocRing α] [NonAssocRing β] (f : α →+* β) (x y : α) :
    f (x - y) = f x - f y :=
  map_sub f x y
#align ring_hom.map_sub RingHom.map_sub

/- warning: ring_hom.mk' -> RingHom.mk' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : NonAssocRing.{u2} β] (f : MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))), (forall (a : α) (b : α), Eq.{succ u2} β (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) (fun (_x : MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) => α -> β) (MonoidHom.hasCoeToFun.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) a b)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β _inst_2))))) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) (fun (_x : MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) => α -> β) (MonoidHom.hasCoeToFun.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) f a) (coeFn.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) (fun (_x : MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) => α -> β) (MonoidHom.hasCoeToFun.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) f b))) -> (RingHom.{u1, u2} α β _inst_1 (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : NonAssocSemiring.{u1} α] [_inst_2 : NonAssocRing.{u2} β] (f : MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))), (forall (a : α) (b : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) a b)) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) α β (MulOneClass.toMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1))) (MulOneClass.toMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2))) (MonoidHom.monoidHomClass.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))))) f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) a b)) (HAdd.hAdd.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) b) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (instHAdd.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (Distrib.toAdd.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (NonUnitalNonAssocSemiring.toDistrib.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (NonAssocRing.toNonUnitalNonAssocRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) _inst_2))))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) α β (MulOneClass.toMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1))) (MulOneClass.toMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2))) (MonoidHom.monoidHomClass.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))))) f a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) α β (MulOneClass.toMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1))) (MulOneClass.toMul.{u2} β (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) (MonoidHomClass.toMulHomClass.{max u1 u2, u1, u2} (MonoidHom.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))) α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2))) (MonoidHom.monoidHomClass.{u1, u2} α β (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α _inst_1)) (MulZeroOneClass.toMulOneClass.{u2} β (NonAssocSemiring.toMulZeroOneClass.{u2} β (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2)))))) f b))) -> (RingHom.{u1, u2} α β _inst_1 (NonAssocRing.toNonAssocSemiring.{u2} β _inst_2))
Case conversion may be inaccurate. Consider using '#align ring_hom.mk' RingHom.mk'ₓ'. -/
/-- Makes a ring homomorphism from a monoid homomorphism of rings which preserves addition. -/
def mk' [NonAssocSemiring α] [NonAssocRing β] (f : α →* β)
    (map_add : ∀ a b, f (a + b) = f a + f b) : α →+* β :=
  { AddMonoidHom.mk' f map_add, f with }
#align ring_hom.mk' RingHom.mk'

section Semiring

variable [Semiring α] [Semiring β]

/- warning: ring_hom.is_unit_map -> RingHom.is_unit_map is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Semiring.{u1} α] [_inst_2 : Semiring.{u2} β] (f : RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) {a : α}, (IsUnit.{u1} α (MonoidWithZero.toMonoid.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_1)) a) -> (IsUnit.{u2} β (MonoidWithZero.toMonoid.{u2} β (Semiring.toMonoidWithZero.{u2} β _inst_2)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) (fun (_x : RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) f a))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Semiring.{u2} α] [_inst_2 : Semiring.{u1} β] (f : RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) {a : α}, (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α _inst_1)) a) -> (IsUnit.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (MonoidWithZero.toMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) _inst_2)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (Semiring.toNonAssocSemiring.{u1} β _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (Semiring.toNonAssocSemiring.{u1} β _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2))))) f a))
Case conversion may be inaccurate. Consider using '#align ring_hom.is_unit_map RingHom.is_unit_mapₓ'. -/
theorem is_unit_map (f : α →+* β) {a : α} : IsUnit a → IsUnit (f a) :=
  IsUnit.map f
#align ring_hom.is_unit_map RingHom.is_unit_map

/- warning: ring_hom.map_dvd -> RingHom.map_dvd is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Semiring.{u1} α] [_inst_2 : Semiring.{u2} β] (f : RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) {a : α} {b : α}, (Dvd.Dvd.{u1} α (semigroupDvd.{u1} α (SemigroupWithZero.toSemigroup.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α (Semiring.toNonUnitalSemiring.{u1} α _inst_1)))) a b) -> (Dvd.Dvd.{u2} β (semigroupDvd.{u2} β (SemigroupWithZero.toSemigroup.{u2} β (NonUnitalSemiring.toSemigroupWithZero.{u2} β (Semiring.toNonUnitalSemiring.{u2} β _inst_2)))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) (fun (_x : RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) f a) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) (fun (_x : RingHom.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (Semiring.toNonAssocSemiring.{u1} α _inst_1) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) f b))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Semiring.{u2} α] [_inst_2 : Semiring.{u1} β] (f : RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) {a : α} {b : α}, (Dvd.dvd.{u2} α (semigroupDvd.{u2} α (SemigroupWithZero.toSemigroup.{u2} α (NonUnitalSemiring.toSemigroupWithZero.{u2} α (Semiring.toNonUnitalSemiring.{u2} α _inst_1)))) a b) -> (Dvd.dvd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (semigroupDvd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (SemigroupWithZero.toSemigroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (NonUnitalSemiring.toSemigroupWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) (Semiring.toNonUnitalSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) a) _inst_2)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (Semiring.toNonAssocSemiring.{u1} β _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (Semiring.toNonAssocSemiring.{u1} β _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2))))) f a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (Semiring.toNonAssocSemiring.{u1} β _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (Semiring.toNonAssocSemiring.{u1} β _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} α β (Semiring.toNonAssocSemiring.{u2} α _inst_1) (Semiring.toNonAssocSemiring.{u1} β _inst_2))))) f b))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_dvd RingHom.map_dvdₓ'. -/
protected theorem map_dvd (f : α →+* β) {a b : α} : a ∣ b → f a ∣ f b :=
  map_dvd f
#align ring_hom.map_dvd RingHom.map_dvd

end Semiring

#print RingHom.id /-
/-- The identity ring homomorphism from a semiring to itself. -/
def id (α : Type _) [NonAssocSemiring α] : α →+* α := by
  refine' { toFun := id.. } <;> intros <;> rfl
#align ring_hom.id RingHom.id
-/

include rα

instance : Inhabited (α →+* α) :=
  ⟨id α⟩

/- warning: ring_hom.id_apply -> RingHom.id_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonAssocSemiring.{u1} α] (x : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) (fun (_x : RingHom.{u1, u1} α α rα rα) => α -> α) (RingHom.hasCoeToFun.{u1, u1} α α rα rα) (RingHom.id.{u1} α rα) x) x
but is expected to have type
  forall {α : Type.{u1}} {rα : NonAssocSemiring.{u1} α} (x : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) x) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)))) (RingHom.id.{u1} α rα) x) x
Case conversion may be inaccurate. Consider using '#align ring_hom.id_apply RingHom.id_applyₓ'. -/
@[simp]
theorem id_apply (x : α) : RingHom.id α x = x :=
  rfl
#align ring_hom.id_apply RingHom.id_apply

/- warning: ring_hom.coe_add_monoid_hom_id -> RingHom.coe_add_monoid_hom_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonAssocSemiring.{u1} α], Eq.{succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (RingHom.{u1, u1} α α rα rα) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (HasLiftT.mk.{succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (CoeTCₓ.coe.{succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (AddMonoidHom.hasCoeT.{u1, u1, u1} α α (RingHom.{u1, u1} α α rα rα) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (RingHomClass.toAddMonoidHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.ringHomClass.{u1, u1} α α rα rα))))) (RingHom.id.{u1} α rα)) (AddMonoidHom.id.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))
but is expected to have type
  forall {α : Type.{u1}} {rα : NonAssocSemiring.{u1} α}, Eq.{succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (AddMonoidHom.mk.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (ZeroHom.mk.{u1, u1} α α (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (AddZeroClass.toZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (AddHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (RingHomClass.toAddMonoidHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)))) (RingHom.id.{u1} α rα)) (instCoeTCAddMonoidHom_1.proof_1.{u1, u1, u1} α α (RingHom.{u1, u1} α α rα rα) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (RingHomClass.toAddMonoidHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)) (RingHom.id.{u1} α rα))) (instCoeTCAddMonoidHom_1.proof_2.{u1, u1, u1} α α (RingHom.{u1, u1} α α rα rα) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))) (RingHomClass.toAddMonoidHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)) (RingHom.id.{u1} α rα))) (AddMonoidHom.id.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α rα)))))
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_add_monoid_hom_id RingHom.coe_add_monoid_hom_idₓ'. -/
@[simp]
theorem coe_add_monoid_hom_id : (id α : α →+ α) = AddMonoidHom.id α :=
  rfl
#align ring_hom.coe_add_monoid_hom_id RingHom.coe_add_monoid_hom_id

/- warning: ring_hom.coe_monoid_hom_id -> RingHom.coe_monoid_hom_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonAssocSemiring.{u1} α], Eq.{succ u1} (MonoidHom.{u1, u1} α α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (RingHom.{u1, u1} α α rα rα) (MonoidHom.{u1, u1} α α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (HasLiftT.mk.{succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) (MonoidHom.{u1, u1} α α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (CoeTCₓ.coe.{succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) (MonoidHom.{u1, u1} α α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MonoidHom.hasCoeT.{u1, u1, u1} α α (RingHom.{u1, u1} α α rα rα) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (RingHomClass.toMonoidHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.ringHomClass.{u1, u1} α α rα rα))))) (RingHom.id.{u1} α rα)) (MonoidHom.id.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))
but is expected to have type
  forall {α : Type.{u1}} {rα : NonAssocSemiring.{u1} α}, Eq.{succ u1} (MonoidHom.{u1, u1} α α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MonoidHom.mk.{u1, u1} α α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (OneHom.mk.{u1, u1} α α (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toOne.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) a) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (MulOneClass.toMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MulOneClass.toMul.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (RingHomClass.toMonoidHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)))) (RingHom.id.{u1} α rα)) (instCoeTCMonoidHom.proof_1.{u1, u1, u1} α α (RingHom.{u1, u1} α α rα rα) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (RingHomClass.toMonoidHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)) (RingHom.id.{u1} α rα))) (instCoeTCMonoidHom.proof_2.{u1, u1, u1} α α (RingHom.{u1, u1} α α rα rα) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)) (RingHomClass.toMonoidHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)) (RingHom.id.{u1} α rα))) (MonoidHom.id.{u1} α (MulZeroOneClass.toMulOneClass.{u1} α (NonAssocSemiring.toMulZeroOneClass.{u1} α rα)))
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_monoid_hom_id RingHom.coe_monoid_hom_idₓ'. -/
@[simp]
theorem coe_monoid_hom_id : (id α : α →* α) = MonoidHom.id α :=
  rfl
#align ring_hom.coe_monoid_hom_id RingHom.coe_monoid_hom_id

variable {rγ : NonAssocSemiring γ}

include rβ rγ

#print RingHom.comp /-
/-- Composition of ring homomorphisms is a ring homomorphism. -/
def comp (g : β →+* γ) (f : α →+* β) : α →+* γ :=
  { g.toNonUnitalRingHom.comp f.toNonUnitalRingHom with
    toFun := g ∘ f
    map_one' := by simp }
#align ring_hom.comp RingHom.comp
-/

/- warning: ring_hom.comp_assoc -> RingHom.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonAssocSemiring.{u1} α] [rβ : NonAssocSemiring.{u2} β] {rγ : NonAssocSemiring.{u3} γ} {δ : Type.{u4}} {rδ : NonAssocSemiring.{u4} δ} (f : RingHom.{u1, u2} α β rα rβ) (g : RingHom.{u2, u3} β γ rβ rγ) (h : RingHom.{u3, u4} γ δ rγ rδ), Eq.{max (succ u1) (succ u4)} (RingHom.{u1, u4} α δ rα rδ) (RingHom.comp.{u1, u2, u4} α β δ rα rβ rδ (RingHom.comp.{u2, u3, u4} β γ δ rβ rγ rδ h g) f) (RingHom.comp.{u1, u3, u4} α γ δ rα rγ rδ h (RingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g f))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {γ : Type.{u1}} {rα : NonAssocSemiring.{u3} α} {rβ : NonAssocSemiring.{u2} β} {rγ : NonAssocSemiring.{u1} γ} {δ : Type.{u4}} {rδ : NonAssocSemiring.{u4} δ} (f : RingHom.{u3, u2} α β rα rβ) (g : RingHom.{u2, u1} β γ rβ rγ) (h : RingHom.{u1, u4} γ δ rγ rδ), Eq.{max (succ u3) (succ u4)} (RingHom.{u3, u4} α δ rα rδ) (RingHom.comp.{u3, u2, u4} α β δ rα rβ rδ (RingHom.comp.{u2, u1, u4} β γ δ rβ rγ rδ h g) f) (RingHom.comp.{u3, u1, u4} α γ δ rα rγ rδ h (RingHom.comp.{u3, u2, u1} α β γ rα rβ rγ g f))
Case conversion may be inaccurate. Consider using '#align ring_hom.comp_assoc RingHom.comp_assocₓ'. -/
/-- Composition of semiring homomorphisms is associative. -/
theorem comp_assoc {δ} {rδ : NonAssocSemiring δ} (f : α →+* β) (g : β →+* γ) (h : γ →+* δ) :
    (h.comp g).comp f = h.comp (g.comp f) :=
  rfl
#align ring_hom.comp_assoc RingHom.comp_assoc

/- warning: ring_hom.coe_comp -> RingHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonAssocSemiring.{u1} α] [rβ : NonAssocSemiring.{u2} β] {rγ : NonAssocSemiring.{u3} γ} (hnp : RingHom.{u2, u3} β γ rβ rγ) (hmn : RingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u3)} ((fun (_x : RingHom.{u1, u3} α γ rα rγ) => α -> γ) (RingHom.comp.{u1, u2, u3} α β γ rα rβ rγ hnp hmn)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} α γ rα rγ) (fun (_x : RingHom.{u1, u3} α γ rα rγ) => α -> γ) (RingHom.hasCoeToFun.{u1, u3} α γ rα rγ) (RingHom.comp.{u1, u2, u3} α β γ rα rβ rγ hnp hmn)) (Function.comp.{succ u1, succ u2, succ u3} α β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingHom.{u2, u3} β γ rβ rγ) (fun (_x : RingHom.{u2, u3} β γ rβ rγ) => β -> γ) (RingHom.hasCoeToFun.{u2, u3} β γ rβ rγ) hnp) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) hmn))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u3} β} {rγ : NonAssocSemiring.{u2} γ} (hnp : RingHom.{u3, u2} β γ rβ rγ) (hmn : RingHom.{u1, u3} α β rα rβ), Eq.{max (succ u1) (succ u2)} (forall (a : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => γ) a) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} α γ rα rγ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => γ) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α γ rα rγ) α γ (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u2} γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} γ rγ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α γ rα rγ) α γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} γ rγ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α γ rα rγ) α γ rα rγ (RingHom.instRingHomClassRingHom.{u1, u2} α γ rα rγ)))) (RingHom.comp.{u1, u3, u2} α β γ rα rβ rγ hnp hmn)) (Function.comp.{succ u1, succ u3, succ u2} α β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} β γ rβ rγ) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => γ) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} β γ rβ rγ) β γ (NonUnitalNonAssocSemiring.toMul.{u3} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ)) (NonUnitalNonAssocSemiring.toMul.{u2} γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} γ rγ)) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} β γ rβ rγ) β γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} γ rγ) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (RingHom.instRingHomClassRingHom.{u3, u2} β γ rβ rγ)))) hnp) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (RingHom.{u1, u3} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (RingHom.{u1, u3} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u3} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u3} α β rα rβ)))) hmn))
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_comp RingHom.coe_compₓ'. -/
@[simp]
theorem coe_comp (hnp : β →+* γ) (hmn : α →+* β) : (hnp.comp hmn : α → γ) = hnp ∘ hmn :=
  rfl
#align ring_hom.coe_comp RingHom.coe_comp

/- warning: ring_hom.comp_apply -> RingHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonAssocSemiring.{u1} α] [rβ : NonAssocSemiring.{u2} β] {rγ : NonAssocSemiring.{u3} γ} (hnp : RingHom.{u2, u3} β γ rβ rγ) (hmn : RingHom.{u1, u2} α β rα rβ) (x : α), Eq.{succ u3} γ (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (RingHom.{u1, u3} α γ rα rγ) (fun (_x : RingHom.{u1, u3} α γ rα rγ) => α -> γ) (RingHom.hasCoeToFun.{u1, u3} α γ rα rγ) (RingHom.comp.{u1, u2, u3} α β γ rα rβ rγ hnp hmn) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingHom.{u2, u3} β γ rβ rγ) (fun (_x : RingHom.{u2, u3} β γ rβ rγ) => β -> γ) (RingHom.hasCoeToFun.{u2, u3} β γ rβ rγ) hnp (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) hmn x))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u3} β} {rγ : NonAssocSemiring.{u2} γ} (hnp : RingHom.{u3, u2} β γ rβ rγ) (hmn : RingHom.{u1, u3} α β rα rβ) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => γ) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (RingHom.{u1, u2} α γ rα rγ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => γ) _x) (MulHomClass.toFunLike.{max u1 u2, u1, u2} (RingHom.{u1, u2} α γ rα rγ) α γ (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u2} γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} γ rγ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α γ rα rγ) α γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} γ rγ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u2, u1, u2} (RingHom.{u1, u2} α γ rα rγ) α γ rα rγ (RingHom.instRingHomClassRingHom.{u1, u2} α γ rα rγ)))) (RingHom.comp.{u1, u3, u2} α β γ rα rβ rγ hnp hmn) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} β γ rβ rγ) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => γ) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} β γ rβ rγ) β γ (NonUnitalNonAssocSemiring.toMul.{u3} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ)) (NonUnitalNonAssocSemiring.toMul.{u2} γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} γ rγ)) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} β γ rβ rγ) β γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} γ rγ) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (RingHom.instRingHomClassRingHom.{u3, u2} β γ rβ rγ)))) hnp (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (RingHom.{u1, u3} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (RingHom.{u1, u3} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u3} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u3} α β rα rβ)))) hmn x))
Case conversion may be inaccurate. Consider using '#align ring_hom.comp_apply RingHom.comp_applyₓ'. -/
theorem comp_apply (hnp : β →+* γ) (hmn : α →+* β) (x : α) :
    (hnp.comp hmn : α → γ) x = hnp (hmn x) :=
  rfl
#align ring_hom.comp_apply RingHom.comp_apply

omit rγ

/- warning: ring_hom.comp_id -> RingHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [rα : NonAssocSemiring.{u1} α] [rβ : NonAssocSemiring.{u2} β] (f : RingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (RingHom.comp.{u1, u1, u2} α α β rα rα rβ f (RingHom.id.{u1} α rα)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ), Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} α β rα rβ) (RingHom.comp.{u2, u2, u1} α α β rα rα rβ f (RingHom.id.{u2} α rα)) f
Case conversion may be inaccurate. Consider using '#align ring_hom.comp_id RingHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : α →+* β) : f.comp (id α) = f :=
  ext fun x => rfl
#align ring_hom.comp_id RingHom.comp_id

/- warning: ring_hom.id_comp -> RingHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [rα : NonAssocSemiring.{u1} α] [rβ : NonAssocSemiring.{u2} β] (f : RingHom.{u1, u2} α β rα rβ), Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (RingHom.comp.{u1, u2, u2} α β β rα rβ rβ (RingHom.id.{u2} β rβ) f) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} {rα : NonAssocSemiring.{u2} α} {rβ : NonAssocSemiring.{u1} β} (f : RingHom.{u2, u1} α β rα rβ), Eq.{max (succ u2) (succ u1)} (RingHom.{u2, u1} α β rα rβ) (RingHom.comp.{u2, u1, u1} α β β rα rβ rβ (RingHom.id.{u1} β rβ) f) f
Case conversion may be inaccurate. Consider using '#align ring_hom.id_comp RingHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : α →+* β) : (id β).comp f = f :=
  ext fun x => rfl
#align ring_hom.id_comp RingHom.id_comp

omit rβ

instance : Monoid (α →+* α) where 
  one := id α
  mul := comp
  mul_one := comp_id
  one_mul := id_comp
  mul_assoc f g h := comp_assoc _ _ _

/- warning: ring_hom.one_def -> RingHom.one_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonAssocSemiring.{u1} α], Eq.{succ u1} (RingHom.{u1, u1} α α rα rα) (OfNat.ofNat.{u1} (RingHom.{u1, u1} α α rα rα) 1 (OfNat.mk.{u1} (RingHom.{u1, u1} α α rα rα) 1 (One.one.{u1} (RingHom.{u1, u1} α α rα rα) (MulOneClass.toHasOne.{u1} (RingHom.{u1, u1} α α rα rα) (Monoid.toMulOneClass.{u1} (RingHom.{u1, u1} α α rα rα) (RingHom.monoid.{u1} α rα)))))) (RingHom.id.{u1} α rα)
but is expected to have type
  forall {α : Type.{u1}} {rα : NonAssocSemiring.{u1} α}, Eq.{succ u1} (RingHom.{u1, u1} α α rα rα) (OfNat.ofNat.{u1} (RingHom.{u1, u1} α α rα rα) 1 (One.toOfNat1.{u1} (RingHom.{u1, u1} α α rα rα) (Monoid.toOne.{u1} (RingHom.{u1, u1} α α rα rα) (RingHom.instMonoidRingHom.{u1} α rα)))) (RingHom.id.{u1} α rα)
Case conversion may be inaccurate. Consider using '#align ring_hom.one_def RingHom.one_defₓ'. -/
theorem one_def : (1 : α →+* α) = id α :=
  rfl
#align ring_hom.one_def RingHom.one_def

/- warning: ring_hom.mul_def -> RingHom.mul_def is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonAssocSemiring.{u1} α] (f : RingHom.{u1, u1} α α rα rα) (g : RingHom.{u1, u1} α α rα rα), Eq.{succ u1} (RingHom.{u1, u1} α α rα rα) (HMul.hMul.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) (RingHom.{u1, u1} α α rα rα) (RingHom.{u1, u1} α α rα rα) (instHMul.{u1} (RingHom.{u1, u1} α α rα rα) (MulOneClass.toHasMul.{u1} (RingHom.{u1, u1} α α rα rα) (Monoid.toMulOneClass.{u1} (RingHom.{u1, u1} α α rα rα) (RingHom.monoid.{u1} α rα)))) f g) (RingHom.comp.{u1, u1, u1} α α α rα rα rα f g)
but is expected to have type
  forall {α : Type.{u1}} {rα : NonAssocSemiring.{u1} α} (f : RingHom.{u1, u1} α α rα rα) (g : RingHom.{u1, u1} α α rα rα), Eq.{succ u1} (RingHom.{u1, u1} α α rα rα) (HMul.hMul.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) (RingHom.{u1, u1} α α rα rα) (RingHom.{u1, u1} α α rα rα) (instHMul.{u1} (RingHom.{u1, u1} α α rα rα) (MulOneClass.toMul.{u1} (RingHom.{u1, u1} α α rα rα) (Monoid.toMulOneClass.{u1} (RingHom.{u1, u1} α α rα rα) (RingHom.instMonoidRingHom.{u1} α rα)))) f g) (RingHom.comp.{u1, u1, u1} α α α rα rα rα f g)
Case conversion may be inaccurate. Consider using '#align ring_hom.mul_def RingHom.mul_defₓ'. -/
theorem mul_def (f g : α →+* α) : f * g = f.comp g :=
  rfl
#align ring_hom.mul_def RingHom.mul_def

/- warning: ring_hom.coe_one -> RingHom.coe_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonAssocSemiring.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) (fun (_x : RingHom.{u1, u1} α α rα rα) => α -> α) (RingHom.hasCoeToFun.{u1, u1} α α rα rα) (OfNat.ofNat.{u1} (RingHom.{u1, u1} α α rα rα) 1 (OfNat.mk.{u1} (RingHom.{u1, u1} α α rα rα) 1 (One.one.{u1} (RingHom.{u1, u1} α α rα rα) (MulOneClass.toHasOne.{u1} (RingHom.{u1, u1} α α rα rα) (Monoid.toMulOneClass.{u1} (RingHom.{u1, u1} α α rα rα) (RingHom.monoid.{u1} α rα))))))) (id.{succ u1} α)
but is expected to have type
  forall {α : Type.{u1}} {rα : NonAssocSemiring.{u1} α}, Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)))) (OfNat.ofNat.{u1} (RingHom.{u1, u1} α α rα rα) 1 (One.toOfNat1.{u1} (RingHom.{u1, u1} α α rα rα) (Monoid.toOne.{u1} (RingHom.{u1, u1} α α rα rα) (RingHom.instMonoidRingHom.{u1} α rα))))) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_one RingHom.coe_oneₓ'. -/
@[simp]
theorem coe_one : ⇑(1 : α →+* α) = _root_.id :=
  rfl
#align ring_hom.coe_one RingHom.coe_one

/- warning: ring_hom.coe_mul -> RingHom.coe_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [rα : NonAssocSemiring.{u1} α] (f : RingHom.{u1, u1} α α rα rα) (g : RingHom.{u1, u1} α α rα rα), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) (fun (_x : RingHom.{u1, u1} α α rα rα) => α -> α) (RingHom.hasCoeToFun.{u1, u1} α α rα rα) (HMul.hMul.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) (RingHom.{u1, u1} α α rα rα) (RingHom.{u1, u1} α α rα rα) (instHMul.{u1} (RingHom.{u1, u1} α α rα rα) (MulOneClass.toHasMul.{u1} (RingHom.{u1, u1} α α rα rα) (Monoid.toMulOneClass.{u1} (RingHom.{u1, u1} α α rα rα) (RingHom.monoid.{u1} α rα)))) f g)) (Function.comp.{succ u1, succ u1, succ u1} α α α (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) (fun (_x : RingHom.{u1, u1} α α rα rα) => α -> α) (RingHom.hasCoeToFun.{u1, u1} α α rα rα) f) (coeFn.{succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) (fun (_x : RingHom.{u1, u1} α α rα rα) => α -> α) (RingHom.hasCoeToFun.{u1, u1} α α rα rα) g))
but is expected to have type
  forall {α : Type.{u1}} {rα : NonAssocSemiring.{u1} α} (f : RingHom.{u1, u1} α α rα rα) (g : RingHom.{u1, u1} α α rα rα), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)))) (HMul.hMul.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) (RingHom.{u1, u1} α α rα rα) (RingHom.{u1, u1} α α rα rα) (instHMul.{u1} (RingHom.{u1, u1} α α rα rα) (MulOneClass.toMul.{u1} (RingHom.{u1, u1} α α rα rα) (Monoid.toMulOneClass.{u1} (RingHom.{u1, u1} α α rα rα) (RingHom.instMonoidRingHom.{u1} α rα)))) f g)) (Function.comp.{succ u1, succ u1, succ u1} α α α (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)))) f) (FunLike.coe.{succ u1, succ u1, succ u1} (RingHom.{u1, u1} α α rα rα) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => α) _x) (MulHomClass.toFunLike.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalRingHomClass.toMulHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (RingHomClass.toNonUnitalRingHomClass.{u1, u1, u1} (RingHom.{u1, u1} α α rα rα) α α rα rα (RingHom.instRingHomClassRingHom.{u1, u1} α α rα rα)))) g))
Case conversion may be inaccurate. Consider using '#align ring_hom.coe_mul RingHom.coe_mulₓ'. -/
@[simp]
theorem coe_mul (f g : α →+* α) : ⇑(f * g) = f ∘ g :=
  rfl
#align ring_hom.coe_mul RingHom.coe_mul

include rβ rγ

/- warning: ring_hom.cancel_right -> RingHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonAssocSemiring.{u1} α] [rβ : NonAssocSemiring.{u2} β] {rγ : NonAssocSemiring.{u3} γ} {g₁ : RingHom.{u2, u3} β γ rβ rγ} {g₂ : RingHom.{u2, u3} β γ rβ rγ} {f : RingHom.{u1, u2} α β rα rβ}, (Function.Surjective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) (fun (_x : RingHom.{u1, u2} α β rα rβ) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β rα rβ) f)) -> (Iff (Eq.{max (succ u1) (succ u3)} (RingHom.{u1, u3} α γ rα rγ) (RingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g₁ f) (RingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g₂ f)) (Eq.{max (succ u2) (succ u3)} (RingHom.{u2, u3} β γ rβ rγ) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u3} β} {rγ : NonAssocSemiring.{u2} γ} {g₁ : RingHom.{u3, u2} β γ rβ rγ} {g₂ : RingHom.{u3, u2} β γ rβ rγ} {f : RingHom.{u1, u3} α β rα rβ}, (Function.Surjective.{succ u1, succ u3} α β (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (RingHom.{u1, u3} α β rα rβ) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u1 u3, u1, u3} (RingHom.{u1, u3} α β rα rβ) α β (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα)) (NonUnitalNonAssocSemiring.toMul.{u3} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ)) (NonUnitalRingHomClass.toMulHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} α β rα rβ) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α rα) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ) (RingHomClass.toNonUnitalRingHomClass.{max u1 u3, u1, u3} (RingHom.{u1, u3} α β rα rβ) α β rα rβ (RingHom.instRingHomClassRingHom.{u1, u3} α β rα rβ)))) f)) -> (Iff (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α γ rα rγ) (RingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g₁ f) (RingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g₂ f)) (Eq.{max (succ u3) (succ u2)} (RingHom.{u3, u2} β γ rβ rγ) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align ring_hom.cancel_right RingHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ : β →+* γ} {f : α →+* β} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => RingHom.ext <| hf.forall.2 (ext_iff.1 h), fun h => h ▸ rfl⟩
#align ring_hom.cancel_right RingHom.cancel_right

/- warning: ring_hom.cancel_left -> RingHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {γ : Type.{u3}} [rα : NonAssocSemiring.{u1} α] [rβ : NonAssocSemiring.{u2} β] {rγ : NonAssocSemiring.{u3} γ} {g : RingHom.{u2, u3} β γ rβ rγ} {f₁ : RingHom.{u1, u2} α β rα rβ} {f₂ : RingHom.{u1, u2} α β rα rβ}, (Function.Injective.{succ u2, succ u3} β γ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingHom.{u2, u3} β γ rβ rγ) (fun (_x : RingHom.{u2, u3} β γ rβ rγ) => β -> γ) (RingHom.hasCoeToFun.{u2, u3} β γ rβ rγ) g)) -> (Iff (Eq.{max (succ u1) (succ u3)} (RingHom.{u1, u3} α γ rα rγ) (RingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g f₁) (RingHom.comp.{u1, u2, u3} α β γ rα rβ rγ g f₂)) (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α β rα rβ) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u3}} {γ : Type.{u2}} {rα : NonAssocSemiring.{u1} α} {rβ : NonAssocSemiring.{u3} β} {rγ : NonAssocSemiring.{u2} γ} {g : RingHom.{u3, u2} β γ rβ rγ} {f₁ : RingHom.{u1, u3} α β rα rβ} {f₂ : RingHom.{u1, u3} α β rα rβ}, (Function.Injective.{succ u3, succ u2} β γ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (RingHom.{u3, u2} β γ rβ rγ) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => γ) _x) (MulHomClass.toFunLike.{max u3 u2, u3, u2} (RingHom.{u3, u2} β γ rβ rγ) β γ (NonUnitalNonAssocSemiring.toMul.{u3} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ)) (NonUnitalNonAssocSemiring.toMul.{u2} γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} γ rγ)) (NonUnitalRingHomClass.toMulHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} β γ rβ rγ) β γ (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} β rβ) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} γ rγ) (RingHomClass.toNonUnitalRingHomClass.{max u3 u2, u3, u2} (RingHom.{u3, u2} β γ rβ rγ) β γ rβ rγ (RingHom.instRingHomClassRingHom.{u3, u2} β γ rβ rγ)))) g)) -> (Iff (Eq.{max (succ u1) (succ u2)} (RingHom.{u1, u2} α γ rα rγ) (RingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g f₁) (RingHom.comp.{u1, u3, u2} α β γ rα rβ rγ g f₂)) (Eq.{max (succ u1) (succ u3)} (RingHom.{u1, u3} α β rα rβ) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align ring_hom.cancel_left RingHom.cancel_leftₓ'. -/
theorem cancel_left {g : β →+* γ} {f₁ f₂ : α →+* β} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => RingHom.ext fun x => hg <| by rw [← comp_apply, h, comp_apply], fun h => h ▸ rfl⟩
#align ring_hom.cancel_left RingHom.cancel_left

end RingHom

/- warning: function.injective.is_domain -> Function.Injective.isDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Ring.{u1} α] [_inst_2 : IsDomain.{u1} α (Ring.toSemiring.{u1} α _inst_1)] [_inst_3 : Ring.{u2} β] (f : RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))), (Function.Injective.{succ u2, succ u1} β α (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))) (fun (_x : RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))) => β -> α) (RingHom.hasCoeToFun.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α _inst_1))) f)) -> (IsDomain.{u2} β (Ring.toSemiring.{u2} β _inst_3))
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : Ring.{u2} α] [_inst_2 : IsDomain.{u2} α (Ring.toSemiring.{u2} α _inst_1)] [_inst_3 : Ring.{u1} β] (f : RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))), (Function.Injective.{succ u1, succ u2} β α (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => α) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))) β α (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_3)))) (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))) β α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_3))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1))) β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)) (RingHom.instRingHomClassRingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β _inst_3)) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α _inst_1)))))) f)) -> (IsDomain.{u1} β (Ring.toSemiring.{u1} β _inst_3))
Case conversion may be inaccurate. Consider using '#align function.injective.is_domain Function.Injective.isDomainₓ'. -/
/-- Pullback `is_domain` instance along an injective function. -/
protected theorem Function.Injective.isDomain [Ring α] [IsDomain α] [Ring β] (f : β →+* α)
    (hf : Injective f) : IsDomain β := by
  haveI := pullback_nonzero f f.map_zero f.map_one
  haveI := IsRightCancelMulZero.toNoZeroDivisors α
  haveI := hf.no_zero_divisors f f.map_zero f.map_mul
  exact NoZeroDivisors.toIsDomain β
#align function.injective.is_domain Function.Injective.isDomain

namespace AddMonoidHom

variable [CommRing α] [IsDomain α] [CommRing β] (f : β →+ α)

/- warning: add_monoid_hom.mk_ring_hom_of_mul_self_of_two_ne_zero -> AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : CommRing.{u1} α] [_inst_2 : IsDomain.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1))] [_inst_3 : CommRing.{u2} β] (f : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))), (forall (x : β), Eq.{succ u1} α (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β (CommRing.toRing.{u2} β _inst_3)))) x x)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f x))) -> (Ne.{succ u1} α (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (CommRing.toRing.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))))) -> (Eq.{succ u1} α (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))))))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))))) -> (RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : CommRing.{u1} α] [_inst_2 : IsDomain.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1))] [_inst_3 : CommRing.{u2} β] (f : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))), (forall (x : β), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (NonUnitalNonAssocRing.toMul.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))))) x x)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β α (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))) f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (NonUnitalNonAssocRing.toMul.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))))) x x)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (NonUnitalNonAssocRing.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (NonAssocRing.toNonUnitalNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (CommRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) _inst_1))))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β α (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))) f x) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β α (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))) f x))) -> (Ne.{succ u1} α (OfNat.ofNat.{u1} α 2 (instOfNat.{u1} α 2 (NonAssocRing.toNatCast.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommSemiring.toCommMonoidWithZero.{u1} α (CommRing.toCommSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (NonAssocRing.toOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β α (AddZeroClass.toAdd.{u2} β (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u1 u2, u2, u1} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_3))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (Ring.toAddGroupWithOne.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))) f (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (NonAssocRing.toOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (NonAssocRing.toOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (NonAssocRing.toOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (NonAssocRing.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (NonAssocRing.toOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (Ring.toNonAssocRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (NonAssocRing.toOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (CommRing.toRing.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (NonAssocRing.toOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) _inst_1)))))) -> (RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.mk_ring_hom_of_mul_self_of_two_ne_zero AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZeroₓ'. -/
/-- Make a ring homomorphism from an additive group homomorphism from a commutative ring to an
integral domain that commutes with self multiplication, assumes that two is nonzero and `1` is sent
to `1`. -/
def mkRingHomOfMulSelfOfTwoNeZero (h : ∀ x, f (x * x) = f x * f x) (h_two : (2 : α) ≠ 0)
    (h_one : f 1 = 1) : β →+* α :=
  { f with 
    map_one' := h_one
    map_mul' := fun x y => by 
      have hxy := h (x + y)
      rw [mul_add, add_mul, add_mul, f.map_add, f.map_add, f.map_add, f.map_add, h x, h y, add_mul,
        mul_add, mul_add, ← sub_eq_zero, add_comm, ← sub_sub, ← sub_sub, ← sub_sub, mul_comm y x,
        mul_comm (f y) (f x)] at hxy
      simp only [add_assoc, add_sub_assoc, add_sub_cancel'_right] at hxy
      rw [sub_sub, ← two_mul, ← add_sub_assoc, ← two_mul, ← mul_sub, mul_eq_zero, sub_eq_zero,
        or_iff_not_imp_left] at hxy
      exact hxy h_two }
#align
  add_monoid_hom.mk_ring_hom_of_mul_self_of_two_ne_zero AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero

/- warning: add_monoid_hom.coe_fn_mk_ring_hom_of_mul_self_of_two_ne_zero -> AddMonoidHom.coe_fn_mkRingHomOfMulSelfOfTwoNeZero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : CommRing.{u1} α] [_inst_2 : IsDomain.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1))] [_inst_3 : CommRing.{u2} β] (f : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (h : forall (x : β), Eq.{succ u1} α (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β (CommRing.toRing.{u2} β _inst_3)))) x x)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f x))) (h_two : Ne.{succ u1} α (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (CommRing.toRing.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))))) (h_one : Eq.{succ u1} α (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))))))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))))), Eq.{max (succ u2) (succ u1)} ((fun (_x : RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))) => β -> α) (AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero.{u1, u2} α β _inst_1 _inst_2 _inst_3 f h h_two h_one)) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (fun (_x : RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))) => β -> α) (RingHom.hasCoeToFun.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero.{u1, u2} α β _inst_1 _inst_2 _inst_3 f h h_two h_one)) (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : CommRing.{u2} α] [_inst_2 : IsDomain.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_1))] [_inst_3 : CommRing.{u1} β] (f : AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (h : forall (x : β), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (HMul.hMul.{u1, u1, u1} β β β (instHMul.{u1} β (NonUnitalNonAssocRing.toMul.{u1} β (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))))) x x)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))))) f (HMul.hMul.{u1, u1, u1} β β β (instHMul.{u1} β (NonUnitalNonAssocRing.toMul.{u1} β (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))))) x x)) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (NonUnitalNonAssocRing.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (NonAssocRing.toNonUnitalNonAssocRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (Ring.toNonAssocRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (CommRing.toRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) _inst_1))))) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))))) f x))) (h_two : Ne.{succ u2} α (OfNat.ofNat.{u2} α 2 (instOfNat.{u2} α 2 (NonAssocRing.toNatCast.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_1)))))) (h_one : Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))))) f (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (NonAssocRing.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (Ring.toNonAssocRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (CommRing.toRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) _inst_1)))))), Eq.{max (succ u2) (succ u1)} (forall (a : β), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => α) a) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : β) => α) _x) (MulHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) β α (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) β α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))))))) (AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero.{u2, u1} α β _inst_1 _inst_2 _inst_3 f h h_two h_one)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))))) f)
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.coe_fn_mk_ring_hom_of_mul_self_of_two_ne_zero AddMonoidHom.coe_fn_mkRingHomOfMulSelfOfTwoNeZeroₓ'. -/
@[simp]
theorem coe_fn_mkRingHomOfMulSelfOfTwoNeZero (h h_two h_one) :
    (f.mkRingHomOfMulSelfOfTwoNeZero h h_two h_one : β → α) = f :=
  rfl
#align
  add_monoid_hom.coe_fn_mk_ring_hom_of_mul_self_of_two_ne_zero AddMonoidHom.coe_fn_mkRingHomOfMulSelfOfTwoNeZero

/- warning: add_monoid_hom.coe_add_monoid_hom_mk_ring_hom_of_mul_self_of_two_ne_zero -> AddMonoidHom.coe_addMonoidHom_mkRingHomOfMulSelfOfTwoNeZero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : CommRing.{u1} α] [_inst_2 : IsDomain.{u1} α (Ring.toSemiring.{u1} α (CommRing.toRing.{u1} α _inst_1))] [_inst_3 : CommRing.{u2} β] (f : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (h : forall (x : β), Eq.{succ u1} α (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β (CommRing.toRing.{u2} β _inst_3)))) x x)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (Ring.toDistrib.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f x) (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f x))) (h_two : Ne.{succ u1} α (OfNat.ofNat.{u1} α 2 (OfNat.mk.{u1} α 2 (bit0.{u1} α (Distrib.toHasAdd.{u1} α (Ring.toDistrib.{u1} α (CommRing.toRing.{u1} α _inst_1))) (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))))) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonAssocRing.toNonUnitalNonAssocRing.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))))) (h_one : Eq.{succ u1} α (coeFn.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (fun (_x : AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) => β -> α) (AddMonoidHom.hasCoeToFun.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) f (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))))))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))))), Eq.{max (succ u1) (succ u2)} (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u1), max (succ u1) (succ u2)} a b] => self.0) (RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (HasLiftT.mk.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (CoeTCₓ.coe.{max (succ u2) (succ u1), max (succ u1) (succ u2)} (RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (AddMonoidHom.{u2, u1} β α (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))))))) (AddMonoidHom.hasCoeT.{u2, u1, max u2 u1} β α (RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (NonAssocRing.toAddGroupWithOne.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3)))))) (AddMonoid.toAddZeroClass.{u1} α (AddMonoidWithOne.toAddMonoid.{u1} α (AddGroupWithOne.toAddMonoidWithOne.{u1} α (NonAssocRing.toAddGroupWithOne.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))) β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1))) (RingHom.ringHomClass.{u2, u1} β α (NonAssocRing.toNonAssocSemiring.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (CommRing.toRing.{u1} α _inst_1)))))))) (AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero.{u1, u2} α β _inst_1 _inst_2 _inst_3 f h h_two h_one)) f
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : CommRing.{u2} α] [_inst_2 : IsDomain.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_1))] [_inst_3 : CommRing.{u1} β] (f : AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (h : forall (x : β), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (HMul.hMul.{u1, u1, u1} β β β (instHMul.{u1} β (NonUnitalNonAssocRing.toMul.{u1} β (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))))) x x)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))))) f (HMul.hMul.{u1, u1, u1} β β β (instHMul.{u1} β (NonUnitalNonAssocRing.toMul.{u1} β (NonAssocRing.toNonUnitalNonAssocRing.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))))) x x)) (HMul.hMul.{u2, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (instHMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (NonUnitalNonAssocRing.toMul.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (NonAssocRing.toNonUnitalNonAssocRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (Ring.toNonAssocRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) (CommRing.toRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) x) _inst_1))))) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))))) f x))) (h_two : Ne.{succ u2} α (OfNat.ofNat.{u2} α 2 (instOfNat.{u2} α 2 (NonAssocRing.toNatCast.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_1)))))) (h_one : Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β (fun (_x : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) _x) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.addMonoidHomClass.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))))) f (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) 1 (One.toOfNat1.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (NonAssocRing.toOne.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (Ring.toNonAssocRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (CommRing.toRing.{u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) (OfNat.ofNat.{u1} β 1 (One.toOfNat1.{u1} β (NonAssocRing.toOne.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) _inst_1)))))), Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHom.mk.{u1, u2} β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (ZeroHom.mk.{u1, u2} β α (AddZeroClass.toZero.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toZero.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (FunLike.coe.{succ (max u2 u1), succ u1, succ u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) β (fun (a : β) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : β) => α) a) (AddHomClass.toFunLike.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) β α (AddZeroClass.toAdd.{u1} β (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3)))))) (AddZeroClass.toAdd.{u2} α (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) β α (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))))))) (AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero.{u2, u1} α β _inst_1 _inst_2 _inst_3 f h h_two h_one)) (instCoeTCAddMonoidHom_1.proof_1.{u2, u1, max u2 u1} β α (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero.{u2, u1} α β _inst_1 _inst_2 _inst_3 f h h_two h_one))) (instCoeTCAddMonoidHom_1.proof_2.{u2, u1, max u2 u1} β α (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} β (AddMonoidWithOne.toAddMonoid.{u1} β (AddGroupWithOne.toAddMonoidWithOne.{u1} β (Ring.toAddGroupWithOne.{u1} β (CommRing.toRing.{u1} β _inst_3))))) (AddMonoid.toAddZeroClass.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (RingHomClass.toAddMonoidHomClass.{max u2 u1, u1, u2} (RingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1)))) β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))) (RingHom.instRingHomClassRingHom.{u1, u2} β α (NonAssocRing.toNonAssocSemiring.{u1} β (Ring.toNonAssocRing.{u1} β (CommRing.toRing.{u1} β _inst_3))) (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_1))))) (AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero.{u2, u1} α β _inst_1 _inst_2 _inst_3 f h h_two h_one))) f
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.coe_add_monoid_hom_mk_ring_hom_of_mul_self_of_two_ne_zero AddMonoidHom.coe_addMonoidHom_mkRingHomOfMulSelfOfTwoNeZeroₓ'. -/
@[simp]
theorem coe_addMonoidHom_mkRingHomOfMulSelfOfTwoNeZero (h h_two h_one) :
    (f.mkRingHomOfMulSelfOfTwoNeZero h h_two h_one : β →+ α) = f := by
  ext
  rfl
#align
  add_monoid_hom.coe_add_monoid_hom_mk_ring_hom_of_mul_self_of_two_ne_zero AddMonoidHom.coe_addMonoidHom_mkRingHomOfMulSelfOfTwoNeZero

end AddMonoidHom

