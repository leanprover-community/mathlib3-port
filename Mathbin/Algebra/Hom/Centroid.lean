/-
Copyright (c) 2022 Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies, Christopher Hoskin

! This file was ported from Lean 3 source module algebra.hom.centroid
! leanprover-community/mathlib commit 861a26926586cd46ff80264d121cdb6fa0e35cc1
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.GroupPower.Lemmas
import Mathbin.Algebra.Hom.GroupInstances

/-!
# Centroid homomorphisms

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Let `A` be a (non unital, non associative) algebra. The centroid of `A` is the set of linear maps
`T` on `A` such that `T` commutes with left and right multiplication, that is to say, for all `a`
and `b` in `A`,
$$
T(ab) = (Ta)b, T(ab) = a(Tb).
$$
In mathlib we call elements of the centroid "centroid homomorphisms" (`centroid_hom`) in keeping
with `add_monoid_hom` etc.

We use the `fun_like` design, so each type of morphisms has a companion typeclass which is meant to
be satisfied by itself and all stricter types.

## Types of morphisms

* `centroid_hom`: Maps which preserve left and right multiplication.

## Typeclasses

* `centroid_hom_class`

## References

* [Jacobson, Structure of Rings][Jacobson1956]
* [McCrimmon, A taste of Jordan algebras][mccrimmon2004]

## Tags

centroid
-/


open Function

variable {F α : Type _}

#print CentroidHom /-
-- Making `centroid_hom` an old structure will allow the lemma `to_add_monoid_hom_eq_coe`
-- to be true by `rfl`. After upgrading to Lean 4, this should no longer be needed
-- because eta for structures should provide the same result.
/-- The type of centroid homomorphisms from `α` to `α`. -/
structure CentroidHom (α : Type _) [NonUnitalNonAssocSemiring α] extends α →+ α where
  map_mul_left' (a b : α) : to_fun (a * b) = a * to_fun b
  map_mul_right' (a b : α) : to_fun (a * b) = to_fun a * b
#align centroid_hom CentroidHom
-/

attribute [nolint doc_blame] CentroidHom.toAddMonoidHom

#print CentroidHomClass /-
/-- `centroid_hom_class F α` states that `F` is a type of centroid homomorphisms.

You should extend this class when you extend `centroid_hom`. -/
class CentroidHomClass (F : Type _) (α : outParam <| Type _) [NonUnitalNonAssocSemiring α] extends
  AddMonoidHomClass F α α where
  map_mul_left (f : F) (a b : α) : f (a * b) = a * f b
  map_mul_right (f : F) (a b : α) : f (a * b) = f a * b
#align centroid_hom_class CentroidHomClass
-/

export CentroidHomClass (map_mul_left map_mul_right)

instance [NonUnitalNonAssocSemiring α] [CentroidHomClass F α] : CoeTC F (CentroidHom α) :=
  ⟨fun f =>
    { (f : α →+ α) with
      toFun := f
      map_mul_left' := map_mul_left f
      map_mul_right' := map_mul_right f }⟩

/-! ### Centroid homomorphisms -/


namespace CentroidHom

section NonUnitalNonAssocSemiring

variable [NonUnitalNonAssocSemiring α]

instance : CentroidHomClass (CentroidHom α) α
    where
  coe f := f.toFun
  coe_injective' f g h := by
    cases f
    cases g
    congr
  map_zero f := f.map_zero'
  map_add f := f.map_add'
  map_mul_left f := f.map_mul_left'
  map_mul_right f := f.map_mul_right'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`
directly. -/
instance : CoeFun (CentroidHom α) fun _ => α → α :=
  FunLike.hasCoeToFun

@[simp]
theorem toFun_eq_coe {f : CentroidHom α} : f.toFun = (f : α → α) :=
  rfl
#align centroid_hom.to_fun_eq_coe CentroidHom.toFun_eq_coe

/- warning: centroid_hom.ext -> CentroidHom.ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] {f : CentroidHom.{u1} α _inst_1} {g : CentroidHom.{u1} α _inst_1}, (forall (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f a) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) g a)) -> (Eq.{succ u1} (CentroidHom.{u1} α _inst_1) f g)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] {f : CentroidHom.{u1} α _inst_1} {g : CentroidHom.{u1} α _inst_1}, (forall (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) g a)) -> (Eq.{succ u1} (CentroidHom.{u1} α _inst_1) f g)
Case conversion may be inaccurate. Consider using '#align centroid_hom.ext CentroidHom.extₓ'. -/
@[ext]
theorem ext {f g : CentroidHom α} (h : ∀ a, f a = g a) : f = g :=
  FunLike.ext f g h
#align centroid_hom.ext CentroidHom.ext

/- warning: centroid_hom.coe_to_add_monoid_hom -> CentroidHom.coe_toAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (fun (_x : AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) => α -> α) (AddMonoidHom.hasCoeToFun.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (HasLiftT.mk.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CoeTCₓ.coe.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHom.hasCoeT.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.centroidHomClass.{u1} α _inst_1))))) f)) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoidHom.addMonoidHomClass.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))))) (AddMonoidHomClass.toAddMonoidHom.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)) f)) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f)
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_to_add_monoid_hom CentroidHom.coe_toAddMonoidHomₓ'. -/
@[simp, norm_cast]
theorem coe_toAddMonoidHom (f : CentroidHom α) : ⇑(f : α →+ α) = f :=
  rfl
#align centroid_hom.coe_to_add_monoid_hom CentroidHom.coe_toAddMonoidHom

/- warning: centroid_hom.to_add_monoid_hom_eq_coe -> CentroidHom.toAddMonoidHom_eq_coe is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CentroidHom.toAddMonoidHom.{u1} α _inst_1 f) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (HasLiftT.mk.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CoeTCₓ.coe.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHom.hasCoeT.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.centroidHomClass.{u1} α _inst_1))))) f)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CentroidHom.toAddMonoidHom.{u1} α _inst_1 f) (AddMonoidHomClass.toAddMonoidHom.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)) f)
Case conversion may be inaccurate. Consider using '#align centroid_hom.to_add_monoid_hom_eq_coe CentroidHom.toAddMonoidHom_eq_coeₓ'. -/
@[simp]
theorem toAddMonoidHom_eq_coe (f : CentroidHom α) : f.toAddMonoidHom = f :=
  rfl
#align centroid_hom.to_add_monoid_hom_eq_coe CentroidHom.toAddMonoidHom_eq_coe

/- warning: centroid_hom.coe_to_add_monoid_hom_injective -> CentroidHom.coe_toAddMonoidHom_injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Function.Injective.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (HasLiftT.mk.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CoeTCₓ.coe.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHom.hasCoeT.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.centroidHomClass.{u1} α _inst_1))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Function.Injective.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddMonoidHom.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_to_add_monoid_hom_injective CentroidHom.coe_toAddMonoidHom_injectiveₓ'. -/
theorem coe_toAddMonoidHom_injective : Injective (coe : CentroidHom α → α →+ α) := fun f g h =>
  ext fun a =>
    haveI := FunLike.congr_fun h a
    this
#align centroid_hom.coe_to_add_monoid_hom_injective CentroidHom.coe_toAddMonoidHom_injective

#print CentroidHom.toEnd /-
/-- Turn a centroid homomorphism into an additive monoid endomorphism. -/
def toEnd (f : CentroidHom α) : AddMonoid.End α :=
  (f : α →+ α)
#align centroid_hom.to_End CentroidHom.toEnd
-/

#print CentroidHom.toEnd_injective /-
theorem toEnd_injective : Injective (CentroidHom.toEnd : CentroidHom α → AddMonoid.End α) :=
  coe_to_add_monoid_hom_injective
#align centroid_hom.to_End_injective CentroidHom.toEnd_injective
-/

/- warning: centroid_hom.copy -> CentroidHom.copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (f' : α -> α), (Eq.{succ u1} (α -> α) f' (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f)) -> (CentroidHom.{u1} α _inst_1)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (f' : α -> α), (Eq.{succ u1} (α -> α) f' (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f)) -> (CentroidHom.{u1} α _inst_1)
Case conversion may be inaccurate. Consider using '#align centroid_hom.copy CentroidHom.copyₓ'. -/
/-- Copy of a `centroid_hom` with a new `to_fun` equal to the old one. Useful to fix
definitional equalities. -/
protected def copy (f : CentroidHom α) (f' : α → α) (h : f' = f) : CentroidHom α :=
  { f.toAddMonoidHom.copy f' <| h with
    toFun := f'
    map_mul_left' := fun a b => by simp_rw [h, map_mul_left]
    map_mul_right' := fun a b => by simp_rw [h, map_mul_right] }
#align centroid_hom.copy CentroidHom.copy

/- warning: centroid_hom.coe_copy -> CentroidHom.coe_copy is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (f' : α -> α) (h : Eq.{succ u1} (α -> α) f' (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f)), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (CentroidHom.copy.{u1} α _inst_1 f f' h)) f'
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (f' : α -> α) (h : Eq.{succ u1} (α -> α) f' (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f)), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (CentroidHom.copy.{u1} α _inst_1 f f' h)) f'
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_copy CentroidHom.coe_copyₓ'. -/
@[simp]
theorem coe_copy (f : CentroidHom α) (f' : α → α) (h : f' = f) : ⇑(f.copy f' h) = f' :=
  rfl
#align centroid_hom.coe_copy CentroidHom.coe_copy

/- warning: centroid_hom.copy_eq -> CentroidHom.copy_eq is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (f' : α -> α) (h : Eq.{succ u1} (α -> α) f' (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f)), Eq.{succ u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.copy.{u1} α _inst_1 f f' h) f
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (f' : α -> α) (h : Eq.{succ u1} (α -> α) f' (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f)), Eq.{succ u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.copy.{u1} α _inst_1 f f' h) f
Case conversion may be inaccurate. Consider using '#align centroid_hom.copy_eq CentroidHom.copy_eqₓ'. -/
theorem copy_eq (f : CentroidHom α) (f' : α → α) (h : f' = f) : f.copy f' h = f :=
  FunLike.ext' h
#align centroid_hom.copy_eq CentroidHom.copy_eq

variable (α)

#print CentroidHom.id /-
/-- `id` as a `centroid_hom`. -/
protected def id : CentroidHom α :=
  { AddMonoidHom.id α with
    map_mul_left' := fun _ _ => rfl
    map_mul_right' := fun _ _ => rfl }
#align centroid_hom.id CentroidHom.id
-/

instance : Inhabited (CentroidHom α) :=
  ⟨CentroidHom.id α⟩

/- warning: centroid_hom.coe_id -> CentroidHom.coe_id is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (CentroidHom.id.{u1} α _inst_1)) (id.{succ u1} α)
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (CentroidHom.id.{u1} α _inst_1)) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_id CentroidHom.coe_idₓ'. -/
@[simp, norm_cast]
theorem coe_id : ⇑(CentroidHom.id α) = id :=
  rfl
#align centroid_hom.coe_id CentroidHom.coe_id

/- warning: centroid_hom.coe_to_add_monoid_hom_id -> CentroidHom.toAddMonoidHom_id is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (HasLiftT.mk.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CoeTCₓ.coe.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHom.hasCoeT.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.centroidHomClass.{u1} α _inst_1))))) (CentroidHom.id.{u1} α _inst_1)) (AddMonoidHom.id.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))))
but is expected to have type
  forall (α : Type.{u1}) [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddMonoidHom.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)) (CentroidHom.id.{u1} α _inst_1)) (AddMonoidHom.id.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_to_add_monoid_hom_id CentroidHom.toAddMonoidHom_idₓ'. -/
@[simp, norm_cast]
theorem toAddMonoidHom_id : (CentroidHom.id α : α →+ α) = AddMonoidHom.id α :=
  rfl
#align centroid_hom.coe_to_add_monoid_hom_id CentroidHom.toAddMonoidHom_id

variable {α}

/- warning: centroid_hom.id_apply -> CentroidHom.id_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (CentroidHom.id.{u1} α _inst_1) a) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (CentroidHom.id.{u1} α _inst_1) a) a
Case conversion may be inaccurate. Consider using '#align centroid_hom.id_apply CentroidHom.id_applyₓ'. -/
@[simp]
theorem id_apply (a : α) : CentroidHom.id α a = a :=
  rfl
#align centroid_hom.id_apply CentroidHom.id_apply

#print CentroidHom.comp /-
/-- Composition of `centroid_hom`s as a `centroid_hom`. -/
def comp (g f : CentroidHom α) : CentroidHom α :=
  {
    g.toAddMonoidHom.comp
      f.toAddMonoidHom with
    map_mul_left' := fun a b => (congr_arg g <| f.map_mul_left' _ _).trans <| g.map_mul_left' _ _
    map_mul_right' := fun a b =>
      (congr_arg g <| f.map_mul_right' _ _).trans <| g.map_mul_right' _ _ }
#align centroid_hom.comp CentroidHom.comp
-/

/- warning: centroid_hom.coe_comp -> CentroidHom.coe_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (g : CentroidHom.{u1} α _inst_1) (f : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (CentroidHom.comp.{u1} α _inst_1 g f)) (Function.comp.{succ u1, succ u1, succ u1} α α α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) g) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (g : CentroidHom.{u1} α _inst_1) (f : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (CentroidHom.comp.{u1} α _inst_1 g f)) (Function.comp.{succ u1, succ u1, succ u1} α α α (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) g) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_comp CentroidHom.coe_compₓ'. -/
@[simp, norm_cast]
theorem coe_comp (g f : CentroidHom α) : ⇑(g.comp f) = g ∘ f :=
  rfl
#align centroid_hom.coe_comp CentroidHom.coe_comp

/- warning: centroid_hom.comp_apply -> CentroidHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (g : CentroidHom.{u1} α _inst_1) (f : CentroidHom.{u1} α _inst_1) (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (CentroidHom.comp.{u1} α _inst_1 g f) a) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) g (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (g : CentroidHom.{u1} α _inst_1) (f : CentroidHom.{u1} α _inst_1) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (CentroidHom.comp.{u1} α _inst_1 g f) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) g (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f a))
Case conversion may be inaccurate. Consider using '#align centroid_hom.comp_apply CentroidHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (g f : CentroidHom α) (a : α) : g.comp f a = g (f a) :=
  rfl
#align centroid_hom.comp_apply CentroidHom.comp_apply

/- warning: centroid_hom.coe_comp_add_monoid_hom -> CentroidHom.coe_comp_addMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (g : CentroidHom.{u1} α _inst_1) (f : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (HasLiftT.mk.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CoeTCₓ.coe.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHom.hasCoeT.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.centroidHomClass.{u1} α _inst_1))))) (CentroidHom.comp.{u1} α _inst_1 g f)) (AddMonoidHom.comp.{u1, u1, u1} α α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (HasLiftT.mk.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CoeTCₓ.coe.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHom.hasCoeT.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.centroidHomClass.{u1} α _inst_1))))) g) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (HasLiftT.mk.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CoeTCₓ.coe.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHom.hasCoeT.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.centroidHomClass.{u1} α _inst_1))))) f))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (g : CentroidHom.{u1} α _inst_1) (f : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (AddMonoidHom.{u1, u1} α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddMonoidHom.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)) (CentroidHom.comp.{u1} α _inst_1 g f)) (AddMonoidHom.comp.{u1, u1, u1} α α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoidHomClass.toAddMonoidHom.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)) g) (AddMonoidHomClass.toAddMonoidHom.{u1, u1, u1} α α (CentroidHom.{u1} α _inst_1) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)) f))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_comp_add_monoid_hom CentroidHom.coe_comp_addMonoidHomₓ'. -/
@[simp, norm_cast]
theorem coe_comp_addMonoidHom (g f : CentroidHom α) : (g.comp f : α →+ α) = (g : α →+ α).comp f :=
  rfl
#align centroid_hom.coe_comp_add_monoid_hom CentroidHom.coe_comp_addMonoidHom

#print CentroidHom.comp_assoc /-
@[simp]
theorem comp_assoc (h g f : CentroidHom α) : (h.comp g).comp f = h.comp (g.comp f) :=
  rfl
#align centroid_hom.comp_assoc CentroidHom.comp_assoc
-/

#print CentroidHom.comp_id /-
@[simp]
theorem comp_id (f : CentroidHom α) : f.comp (CentroidHom.id α) = f :=
  ext fun a => rfl
#align centroid_hom.comp_id CentroidHom.comp_id
-/

#print CentroidHom.id_comp /-
@[simp]
theorem id_comp (f : CentroidHom α) : (CentroidHom.id α).comp f = f :=
  ext fun a => rfl
#align centroid_hom.id_comp CentroidHom.id_comp
-/

/- warning: centroid_hom.cancel_right -> CentroidHom.cancel_right is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] {g₁ : CentroidHom.{u1} α _inst_1} {g₂ : CentroidHom.{u1} α _inst_1} {f : CentroidHom.{u1} α _inst_1}, (Function.Surjective.{succ u1, succ u1} α α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f)) -> (Iff (Eq.{succ u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.comp.{u1} α _inst_1 g₁ f) (CentroidHom.comp.{u1} α _inst_1 g₂ f)) (Eq.{succ u1} (CentroidHom.{u1} α _inst_1) g₁ g₂))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] {g₁ : CentroidHom.{u1} α _inst_1} {g₂ : CentroidHom.{u1} α _inst_1} {f : CentroidHom.{u1} α _inst_1}, (Function.Surjective.{succ u1, succ u1} α α (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f)) -> (Iff (Eq.{succ u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.comp.{u1} α _inst_1 g₁ f) (CentroidHom.comp.{u1} α _inst_1 g₂ f)) (Eq.{succ u1} (CentroidHom.{u1} α _inst_1) g₁ g₂))
Case conversion may be inaccurate. Consider using '#align centroid_hom.cancel_right CentroidHom.cancel_rightₓ'. -/
theorem cancel_right {g₁ g₂ f : CentroidHom α} (hf : Surjective f) :
    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=
  ⟨fun h => ext <| hf.forall.2 <| FunLike.ext_iff.1 h, congr_arg _⟩
#align centroid_hom.cancel_right CentroidHom.cancel_right

/- warning: centroid_hom.cancel_left -> CentroidHom.cancel_left is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] {g : CentroidHom.{u1} α _inst_1} {f₁ : CentroidHom.{u1} α _inst_1} {f₂ : CentroidHom.{u1} α _inst_1}, (Function.Injective.{succ u1, succ u1} α α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) g)) -> (Iff (Eq.{succ u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.comp.{u1} α _inst_1 g f₁) (CentroidHom.comp.{u1} α _inst_1 g f₂)) (Eq.{succ u1} (CentroidHom.{u1} α _inst_1) f₁ f₂))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] {g : CentroidHom.{u1} α _inst_1} {f₁ : CentroidHom.{u1} α _inst_1} {f₂ : CentroidHom.{u1} α _inst_1}, (Function.Injective.{succ u1, succ u1} α α (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) g)) -> (Iff (Eq.{succ u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.comp.{u1} α _inst_1 g f₁) (CentroidHom.comp.{u1} α _inst_1 g f₂)) (Eq.{succ u1} (CentroidHom.{u1} α _inst_1) f₁ f₂))
Case conversion may be inaccurate. Consider using '#align centroid_hom.cancel_left CentroidHom.cancel_leftₓ'. -/
theorem cancel_left {g f₁ f₂ : CentroidHom α} (hg : Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
#align centroid_hom.cancel_left CentroidHom.cancel_left

instance : Zero (CentroidHom α) :=
  ⟨{ (0 : α →+ α) with
      map_mul_left' := fun a b => (mul_zero _).symm
      map_mul_right' := fun a b => (zero_mul _).symm }⟩

instance : One (CentroidHom α) :=
  ⟨CentroidHom.id α⟩

instance : Add (CentroidHom α) :=
  ⟨fun f g =>
    {
      (f + g : α →+
          α) with
      map_mul_left' := fun a b => by simp [map_mul_left, mul_add]
      map_mul_right' := fun a b => by simp [map_mul_right, add_mul] }⟩

instance : Mul (CentroidHom α) :=
  ⟨comp⟩

#print CentroidHom.hasNsmul /-
instance hasNsmul : SMul ℕ (CentroidHom α) :=
  ⟨fun n f =>
    {
      (n • f :
        α →+
          α) with
      map_mul_left' := fun a b => by
        change n • f (a * b) = a * n • f b
        rw [map_mul_left f, ← mul_smul_comm]
      map_mul_right' := fun a b => by
        change n • f (a * b) = n • f a * b
        rw [map_mul_right f, ← smul_mul_assoc] }⟩
#align centroid_hom.has_nsmul CentroidHom.hasNsmul
-/

#print CentroidHom.hasNpowNat /-
instance hasNpowNat : Pow (CentroidHom α) ℕ :=
  ⟨fun f n =>
    {
      (f.toEnd ^ n :
        AddMonoid.End
          α) with
      map_mul_left' := fun a b => by
        induction' n with n ih
        · simp
        · rw [pow_succ]
          exact (congr_arg f.to_End ih).trans (f.map_mul_left' _ _)
      map_mul_right' := fun a b => by
        induction' n with n ih
        · simp
        · rw [pow_succ]
          exact (congr_arg f.to_End ih).trans (f.map_mul_right' _ _) }⟩
#align centroid_hom.has_npow_nat CentroidHom.hasNpowNat
-/

/- warning: centroid_hom.coe_zero -> CentroidHom.coe_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (OfNat.ofNat.{u1} (CentroidHom.{u1} α _inst_1) 0 (OfNat.mk.{u1} (CentroidHom.{u1} α _inst_1) 0 (Zero.zero.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasZero.{u1} α _inst_1))))) (OfNat.ofNat.{u1} (α -> α) 0 (OfNat.mk.{u1} (α -> α) 0 (Zero.zero.{u1} (α -> α) (Pi.instZero.{u1, u1} α (fun (ᾰ : α) => α) (fun (i : α) => MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α _inst_1))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (OfNat.ofNat.{u1} (CentroidHom.{u1} α _inst_1) 0 (Zero.toOfNat0.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instZeroCentroidHom.{u1} α _inst_1)))) (OfNat.ofNat.{u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) 0 (Zero.toOfNat0.{u1} (forall (a : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (Pi.instZero.{u1, u1} α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (fun (i : α) => MulZeroClass.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) _inst_1)))))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_zero CentroidHom.coe_zeroₓ'. -/
@[simp, norm_cast]
theorem coe_zero : ⇑(0 : CentroidHom α) = 0 :=
  rfl
#align centroid_hom.coe_zero CentroidHom.coe_zero

/- warning: centroid_hom.coe_one -> CentroidHom.coe_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (OfNat.ofNat.{u1} (CentroidHom.{u1} α _inst_1) 1 (OfNat.mk.{u1} (CentroidHom.{u1} α _inst_1) 1 (One.one.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasOne.{u1} α _inst_1))))) (id.{succ u1} α)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (OfNat.ofNat.{u1} (CentroidHom.{u1} α _inst_1) 1 (One.toOfNat1.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instOneCentroidHom.{u1} α _inst_1)))) (id.{succ u1} α)
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_one CentroidHom.coe_oneₓ'. -/
@[simp, norm_cast]
theorem coe_one : ⇑(1 : CentroidHom α) = id :=
  rfl
#align centroid_hom.coe_one CentroidHom.coe_one

/- warning: centroid_hom.coe_add -> CentroidHom.coe_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (g : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (HAdd.hAdd.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHAdd.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasAdd.{u1} α _inst_1)) f g)) (HAdd.hAdd.{u1, u1, u1} (α -> α) (α -> α) (α -> α) (instHAdd.{u1} (α -> α) (Pi.instAdd.{u1, u1} α (fun (ᾰ : α) => α) (fun (i : α) => Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α _inst_1)))) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) g))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (g : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHAdd.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instAddCentroidHom.{u1} α _inst_1)) f g)) (HAdd.hAdd.{u1, u1, u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (instHAdd.{u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (Pi.instAdd.{u1, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (fun (i : α) => Distrib.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (NonUnitalNonAssocSemiring.toDistrib.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) _inst_1)))) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) g))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_add CentroidHom.coe_addₓ'. -/
@[simp, norm_cast]
theorem coe_add (f g : CentroidHom α) : ⇑(f + g) = f + g :=
  rfl
#align centroid_hom.coe_add CentroidHom.coe_add

/- warning: centroid_hom.coe_mul -> CentroidHom.coe_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (g : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (HMul.hMul.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHMul.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasMul.{u1} α _inst_1)) f g)) (Function.comp.{succ u1, succ u1, succ u1} α α α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) g))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (g : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (HMul.hMul.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHMul.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instMulCentroidHom.{u1} α _inst_1)) f g)) (Function.comp.{succ u1, succ u1, succ u1} α α α (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) g))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_mul CentroidHom.coe_mulₓ'. -/
@[simp, norm_cast]
theorem coe_mul (f g : CentroidHom α) : ⇑(f * g) = f ∘ g :=
  rfl
#align centroid_hom.coe_mul CentroidHom.coe_mul

/- warning: centroid_hom.coe_nsmul -> CentroidHom.coe_nsmul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (n : Nat), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (SMul.smul.{0, u1} Nat (CentroidHom.{u1} α _inst_1) (CentroidHom.hasNsmul.{u1} α _inst_1) n f)) (SMul.smul.{0, u1} Nat (α -> α) (Pi.instSMul.{u1, u1, 0} α Nat (fun (ᾰ : α) => α) (fun (i : α) => AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) n (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (n : Nat), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (HSMul.hSMul.{0, u1, u1} Nat (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHSMul.{0, u1} Nat (CentroidHom.{u1} α _inst_1) (CentroidHom.hasNsmul.{u1} α _inst_1)) n f)) (HSMul.hSMul.{0, u1, u1} Nat (forall (a : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (instHSMul.{0, u1} Nat (forall (a : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (Pi.instSMul.{u1, u1, 0} α Nat (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (fun (i : α) => AddMonoid.SMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) _inst_1))))) n (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_nsmul CentroidHom.coe_nsmulₓ'. -/
-- Eligible for `dsimp`
@[simp, norm_cast, nolint simp_nf]
theorem coe_nsmul (f : CentroidHom α) (n : ℕ) : ⇑(n • f) = n • f :=
  rfl
#align centroid_hom.coe_nsmul CentroidHom.coe_nsmul

/- warning: centroid_hom.zero_apply -> CentroidHom.zero_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (OfNat.ofNat.{u1} (CentroidHom.{u1} α _inst_1) 0 (OfNat.mk.{u1} (CentroidHom.{u1} α _inst_1) 0 (Zero.zero.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasZero.{u1} α _inst_1)))) a) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α _inst_1)))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (OfNat.ofNat.{u1} (CentroidHom.{u1} α _inst_1) 0 (Zero.toOfNat0.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instZeroCentroidHom.{u1} α _inst_1))) a) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (MulZeroClass.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) _inst_1))))
Case conversion may be inaccurate. Consider using '#align centroid_hom.zero_apply CentroidHom.zero_applyₓ'. -/
@[simp]
theorem zero_apply (a : α) : (0 : CentroidHom α) a = 0 :=
  rfl
#align centroid_hom.zero_apply CentroidHom.zero_apply

/- warning: centroid_hom.one_apply -> CentroidHom.one_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (OfNat.ofNat.{u1} (CentroidHom.{u1} α _inst_1) 1 (OfNat.mk.{u1} (CentroidHom.{u1} α _inst_1) 1 (One.one.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasOne.{u1} α _inst_1)))) a) a
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (OfNat.ofNat.{u1} (CentroidHom.{u1} α _inst_1) 1 (One.toOfNat1.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instOneCentroidHom.{u1} α _inst_1))) a) a
Case conversion may be inaccurate. Consider using '#align centroid_hom.one_apply CentroidHom.one_applyₓ'. -/
@[simp]
theorem one_apply (a : α) : (1 : CentroidHom α) a = a :=
  rfl
#align centroid_hom.one_apply CentroidHom.one_apply

/- warning: centroid_hom.add_apply -> CentroidHom.add_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (g : CentroidHom.{u1} α _inst_1) (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (HAdd.hAdd.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHAdd.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasAdd.{u1} α _inst_1)) f g) a) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α _inst_1))) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f a) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) g a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (g : CentroidHom.{u1} α _inst_1) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHAdd.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instAddCentroidHom.{u1} α _inst_1)) f g) a) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (Distrib.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (NonUnitalNonAssocSemiring.toDistrib.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) _inst_1))) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) g a))
Case conversion may be inaccurate. Consider using '#align centroid_hom.add_apply CentroidHom.add_applyₓ'. -/
@[simp]
theorem add_apply (f g : CentroidHom α) (a : α) : (f + g) a = f a + g a :=
  rfl
#align centroid_hom.add_apply CentroidHom.add_apply

/- warning: centroid_hom.mul_apply -> CentroidHom.mul_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (g : CentroidHom.{u1} α _inst_1) (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (HMul.hMul.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHMul.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasMul.{u1} α _inst_1)) f g) a) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) g a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (g : CentroidHom.{u1} α _inst_1) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (HMul.hMul.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHMul.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instMulCentroidHom.{u1} α _inst_1)) f g) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) g a))
Case conversion may be inaccurate. Consider using '#align centroid_hom.mul_apply CentroidHom.mul_applyₓ'. -/
@[simp]
theorem mul_apply (f g : CentroidHom α) (a : α) : (f * g) a = f (g a) :=
  rfl
#align centroid_hom.mul_apply CentroidHom.mul_apply

/- warning: centroid_hom.nsmul_apply -> CentroidHom.nsmul_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (n : Nat) (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) (SMul.smul.{0, u1} Nat (CentroidHom.{u1} α _inst_1) (CentroidHom.hasNsmul.{u1} α _inst_1) n f) a) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) n (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) f a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (f : CentroidHom.{u1} α _inst_1) (n : Nat) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (HSMul.hSMul.{0, u1, u1} Nat (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHSMul.{0, u1} Nat (CentroidHom.{u1} α _inst_1) (CentroidHom.hasNsmul.{u1} α _inst_1)) n f) a) (HSMul.hSMul.{0, u1, u1} Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (instHSMul.{0, u1} Nat ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (AddMonoid.SMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) _inst_1)))) n (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) f a))
Case conversion may be inaccurate. Consider using '#align centroid_hom.nsmul_apply CentroidHom.nsmul_applyₓ'. -/
-- Eligible for `dsimp`
@[simp, nolint simp_nf]
theorem nsmul_apply (f : CentroidHom α) (n : ℕ) (a : α) : (n • f) a = n • f a :=
  rfl
#align centroid_hom.nsmul_apply CentroidHom.nsmul_apply

/- warning: centroid_hom.to_End_zero -> CentroidHom.toEnd_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CentroidHom.toEnd.{u1} α _inst_1 (OfNat.ofNat.{u1} (CentroidHom.{u1} α _inst_1) 0 (OfNat.mk.{u1} (CentroidHom.{u1} α _inst_1) 0 (Zero.zero.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasZero.{u1} α _inst_1))))) (OfNat.ofNat.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) 0 (OfNat.mk.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) 0 (Zero.zero.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (MulZeroClass.toHasZero.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.semiring.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α], Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CentroidHom.toEnd.{u1} α _inst_1 (OfNat.ofNat.{u1} (CentroidHom.{u1} α _inst_1) 0 (Zero.toOfNat0.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instZeroCentroidHom.{u1} α _inst_1)))) (OfNat.ofNat.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) 0 (Zero.toOfNat0.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (MonoidWithZero.toZero.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (Semiring.toMonoidWithZero.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.semiring.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align centroid_hom.to_End_zero CentroidHom.toEnd_zeroₓ'. -/
@[simp]
theorem toEnd_zero : (0 : CentroidHom α).toEnd = 0 :=
  rfl
#align centroid_hom.to_End_zero CentroidHom.toEnd_zero

/- warning: centroid_hom.to_End_add -> CentroidHom.toEnd_add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (x : CentroidHom.{u1} α _inst_1) (y : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CentroidHom.toEnd.{u1} α _inst_1 (HAdd.hAdd.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHAdd.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasAdd.{u1} α _inst_1)) x y)) (HAdd.hAdd.{u1, u1, u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (instHAdd.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (Distrib.toHasAdd.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.semiring.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))))))) (CentroidHom.toEnd.{u1} α _inst_1 x) (CentroidHom.toEnd.{u1} α _inst_1 y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (x : CentroidHom.{u1} α _inst_1) (y : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CentroidHom.toEnd.{u1} α _inst_1 (HAdd.hAdd.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHAdd.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instAddCentroidHom.{u1} α _inst_1)) x y)) (HAdd.hAdd.{u1, u1, u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (instHAdd.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (Distrib.toAdd.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.semiring.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))))))) (CentroidHom.toEnd.{u1} α _inst_1 x) (CentroidHom.toEnd.{u1} α _inst_1 y))
Case conversion may be inaccurate. Consider using '#align centroid_hom.to_End_add CentroidHom.toEnd_addₓ'. -/
@[simp]
theorem toEnd_add (x y : CentroidHom α) : (x + y).toEnd = x.toEnd + y.toEnd :=
  rfl
#align centroid_hom.to_End_add CentroidHom.toEnd_add

#print CentroidHom.toEnd_nsmul /-
theorem toEnd_nsmul (x : CentroidHom α) (n : ℕ) : (n • x).toEnd = n • x.toEnd :=
  rfl
#align centroid_hom.to_End_nsmul CentroidHom.toEnd_nsmul
-/

-- cf.`add_monoid_hom.add_comm_monoid`
instance : AddCommMonoid (CentroidHom α) :=
  coe_toAddMonoidHom_injective.AddCommMonoid _ toEnd_zero toEnd_add toEnd_nsmul

instance : NatCast (CentroidHom α) where natCast n := n • 1

/- warning: centroid_hom.coe_nat_cast -> CentroidHom.coe_nat_cast is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (n : Nat), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat (CentroidHom.{u1} α _inst_1) (HasLiftT.mk.{1, succ u1} Nat (CentroidHom.{u1} α _inst_1) (CoeTCₓ.coe.{1, succ u1} Nat (CentroidHom.{u1} α _inst_1) (Nat.castCoe.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasNatCast.{u1} α _inst_1)))) n)) (SMul.smul.{0, u1} Nat (α -> α) (Pi.instSMul.{u1, u1, 0} α Nat (fun (ᾰ : α) => α) (fun (i : α) => AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) n (id.{succ u1} α))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (n : Nat), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (Nat.cast.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instNatCastCentroidHom.{u1} α _inst_1) n)) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (HSMul.hSMul.{0, u1, u1} Nat (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHSMul.{0, u1} Nat (CentroidHom.{u1} α _inst_1) (CentroidHom.hasNsmul.{u1} α _inst_1)) n (CentroidHom.id.{u1} α _inst_1)))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_nat_cast CentroidHom.coe_nat_castₓ'. -/
@[simp, norm_cast]
theorem coe_nat_cast (n : ℕ) : ⇑(n : CentroidHom α) = n • id :=
  rfl
#align centroid_hom.coe_nat_cast CentroidHom.coe_nat_cast

/- warning: centroid_hom.nat_cast_apply -> CentroidHom.nat_cast_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (n : Nat) (m : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat (CentroidHom.{u1} α _inst_1) (HasLiftT.mk.{1, succ u1} Nat (CentroidHom.{u1} α _inst_1) (CoeTCₓ.coe.{1, succ u1} Nat (CentroidHom.{u1} α _inst_1) (Nat.castCoe.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasNatCast.{u1} α _inst_1)))) n) m) (SMul.smul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) n m)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (n : Nat) (m : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) m) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) (Nat.cast.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instNatCastCentroidHom.{u1} α _inst_1) n) m) (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α (AddMonoid.SMul.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) n m)
Case conversion may be inaccurate. Consider using '#align centroid_hom.nat_cast_apply CentroidHom.nat_cast_applyₓ'. -/
theorem nat_cast_apply (n : ℕ) (m : α) : (n : CentroidHom α) m = n • m :=
  rfl
#align centroid_hom.nat_cast_apply CentroidHom.nat_cast_apply

#print CentroidHom.toEnd_one /-
@[simp]
theorem toEnd_one : (1 : CentroidHom α).toEnd = 1 :=
  rfl
#align centroid_hom.to_End_one CentroidHom.toEnd_one
-/

/- warning: centroid_hom.to_End_mul -> CentroidHom.toEnd_mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (x : CentroidHom.{u1} α _inst_1) (y : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CentroidHom.toEnd.{u1} α _inst_1 (HMul.hMul.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHMul.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.hasMul.{u1} α _inst_1)) x y)) (HMul.hMul.{u1, u1, u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (instHMul.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (Distrib.toHasMul.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (NonUnitalNonAssocSemiring.toDistrib.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.semiring.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))))))) (CentroidHom.toEnd.{u1} α _inst_1 x) (CentroidHom.toEnd.{u1} α _inst_1 y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (x : CentroidHom.{u1} α _inst_1) (y : CentroidHom.{u1} α _inst_1), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (CentroidHom.toEnd.{u1} α _inst_1 (HMul.hMul.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (CentroidHom.{u1} α _inst_1) (instHMul.{u1} (CentroidHom.{u1} α _inst_1) (CentroidHom.instMulCentroidHom.{u1} α _inst_1)) x y)) (HMul.hMul.{u1, u1, u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (instHMul.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (NonUnitalNonAssocSemiring.toMul.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoid.End.semiring.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))))) (CentroidHom.toEnd.{u1} α _inst_1 x) (CentroidHom.toEnd.{u1} α _inst_1 y))
Case conversion may be inaccurate. Consider using '#align centroid_hom.to_End_mul CentroidHom.toEnd_mulₓ'. -/
@[simp]
theorem toEnd_mul (x y : CentroidHom α) : (x * y).toEnd = x.toEnd * y.toEnd :=
  rfl
#align centroid_hom.to_End_mul CentroidHom.toEnd_mul

#print CentroidHom.toEnd_pow /-
@[simp]
theorem toEnd_pow (x : CentroidHom α) (n : ℕ) : (x ^ n).toEnd = x.toEnd ^ n :=
  by
  ext
  rfl
#align centroid_hom.to_End_pow CentroidHom.toEnd_pow
-/

#print CentroidHom.toEnd_nat_cast /-
@[simp, norm_cast]
theorem toEnd_nat_cast (n : ℕ) : (n : CentroidHom α).toEnd = ↑n :=
  rfl
#align centroid_hom.to_End_nat_cast CentroidHom.toEnd_nat_cast
-/

-- cf `add_monoid.End.semiring`
instance : Semiring (CentroidHom α) :=
  toEnd_injective.Semiring _ toEnd_zero toEnd_one toEnd_add toEnd_mul toEnd_nsmul toEnd_pow
    toEnd_nat_cast

/- warning: centroid_hom.comp_mul_comm -> CentroidHom.comp_mul_comm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (T : CentroidHom.{u1} α _inst_1) (S : CentroidHom.{u1} α _inst_1) (a : α) (b : α), Eq.{succ u1} α (Function.comp.{succ u1, succ u1, succ u1} α α α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) T) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) S) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α _inst_1))) a b)) (Function.comp.{succ u1, succ u1, succ u1} α α α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) S) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α _inst_1) (fun (_x : CentroidHom.{u1} α _inst_1) => α -> α) (CentroidHom.hasCoeToFun.{u1} α _inst_1) T) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α _inst_1))) a b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocSemiring.{u1} α] (T : CentroidHom.{u1} α _inst_1) (S : CentroidHom.{u1} α _inst_1) (a : α) (b : α), Eq.{succ u1} α (Function.comp.{succ u1, succ u1, succ u1} α α α (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) T) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) S) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α _inst_1)) a b)) (Function.comp.{succ u1, succ u1, succ u1} α α α (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) S) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1)))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α _inst_1) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α _inst_1))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α _inst_1) α _inst_1 (CentroidHom.instCentroidHomClassCentroidHom.{u1} α _inst_1)))) T) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α _inst_1)) a b))
Case conversion may be inaccurate. Consider using '#align centroid_hom.comp_mul_comm CentroidHom.comp_mul_commₓ'. -/
theorem comp_mul_comm (T S : CentroidHom α) (a b : α) : (T ∘ S) (a * b) = (S ∘ T) (a * b) := by
  rw [comp_app, map_mul_right, map_mul_left, ← map_mul_right, ← map_mul_left]
#align centroid_hom.comp_mul_comm CentroidHom.comp_mul_comm

end NonUnitalNonAssocSemiring

section NonUnitalNonAssocRing

variable [NonUnitalNonAssocRing α]

/-- Negation of `centroid_hom`s as a `centroid_hom`. -/
instance : Neg (CentroidHom α) :=
  ⟨fun f =>
    { (-f : α →+ α) with
      map_mul_left' := by simp [map_mul_left]
      map_mul_right' := by simp [map_mul_right] }⟩

instance : Sub (CentroidHom α) :=
  ⟨fun f g =>
    {
      (f - g : α →+
          α) with
      map_mul_left' := fun a b => by simp [map_mul_left, mul_sub]
      map_mul_right' := fun a b => by simp [map_mul_right, sub_mul] }⟩

#print CentroidHom.hasZsmul /-
instance hasZsmul : SMul ℤ (CentroidHom α) :=
  ⟨fun n f =>
    {
      (n • f :
        α →+
          α) with
      map_mul_left' := fun a b => by
        change n • f (a * b) = a * n • f b
        rw [map_mul_left f, ← mul_smul_comm]
      map_mul_right' := fun a b => by
        change n • f (a * b) = n • f a * b
        rw [map_mul_right f, ← smul_mul_assoc] }⟩
#align centroid_hom.has_zsmul CentroidHom.hasZsmul
-/

instance : IntCast (CentroidHom α) where intCast z := z • 1

/- warning: centroid_hom.coe_int_cast -> CentroidHom.coe_int_cast is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (z : Int), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (HasLiftT.mk.{1, succ u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CoeTCₓ.coe.{1, succ u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (Int.castCoe.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasIntCast.{u1} α _inst_1)))) z)) (SMul.smul.{0, u1} Int (α -> α) (Pi.instSMul.{u1, u1, 0} α Int (fun (ᾰ : α) => α) (fun (i : α) => SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) z (id.{succ u1} α))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (z : Int), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Int.cast.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.instIntCastCentroidHomToNonUnitalNonAssocSemiring.{u1} α _inst_1) z)) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (a : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (HSMul.hSMul.{0, u1, u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (instHSMul.{0, u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasZsmul.{u1} α _inst_1)) z (CentroidHom.id.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_int_cast CentroidHom.coe_int_castₓ'. -/
@[simp, norm_cast]
theorem coe_int_cast (z : ℤ) : ⇑(z : CentroidHom α) = z • id :=
  rfl
#align centroid_hom.coe_int_cast CentroidHom.coe_int_cast

/- warning: centroid_hom.int_cast_apply -> CentroidHom.int_cast_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (z : Int) (m : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (HasLiftT.mk.{1, succ u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CoeTCₓ.coe.{1, succ u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (Int.castCoe.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasIntCast.{u1} α _inst_1)))) z) m) (SMul.smul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))) z m)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (z : Int) (m : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) m) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Int.cast.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.instIntCastCentroidHomToNonUnitalNonAssocSemiring.{u1} α _inst_1) z) m) (HSMul.hSMul.{0, u1, u1} Int α α (instHSMul.{0, u1} Int α (SubNegMonoid.SMulInt.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) z m)
Case conversion may be inaccurate. Consider using '#align centroid_hom.int_cast_apply CentroidHom.int_cast_applyₓ'. -/
theorem int_cast_apply (z : ℤ) (m : α) : (z : CentroidHom α) m = z • m :=
  rfl
#align centroid_hom.int_cast_apply CentroidHom.int_cast_apply

/- warning: centroid_hom.to_End_neg -> CentroidHom.toEnd_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (Neg.neg.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasNeg.{u1} α _inst_1) x)) (Neg.neg.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (SubNegMonoid.toHasNeg.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddGroup.toSubNegMonoid.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddGroupWithOne.toAddGroup.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (NonAssocRing.toAddGroupWithOne.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Ring.toNonAssocRing.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoid.End.ring.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) x))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (Neg.neg.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.instNegCentroidHomToNonUnitalNonAssocSemiring.{u1} α _inst_1) x)) (Neg.neg.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Ring.toNeg.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (instRingEndToAddZeroClassToAddMonoidToSubNegMonoidToAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) x))
Case conversion may be inaccurate. Consider using '#align centroid_hom.to_End_neg CentroidHom.toEnd_negₓ'. -/
@[simp]
theorem toEnd_neg (x : CentroidHom α) : (-x).toEnd = -x.toEnd :=
  rfl
#align centroid_hom.to_End_neg CentroidHom.toEnd_neg

/- warning: centroid_hom.to_End_sub -> CentroidHom.toEnd_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (y : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (HSub.hSub.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (instHSub.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasSub.{u1} α _inst_1)) x y)) (HSub.hSub.{u1, u1, u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (instHSub.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (SubNegMonoid.toHasSub.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddGroup.toSubNegMonoid.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddGroupWithOne.toAddGroup.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (NonAssocRing.toAddGroupWithOne.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Ring.toNonAssocRing.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoid.End.ring.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))))))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) x) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) y))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (y : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (HSub.hSub.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (instHSub.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.instSubCentroidHomToNonUnitalNonAssocSemiring.{u1} α _inst_1)) x y)) (HSub.hSub.{u1, u1, u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (instHSub.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Ring.toSub.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (instRingEndToAddZeroClassToAddMonoidToSubNegMonoidToAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) x) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) y))
Case conversion may be inaccurate. Consider using '#align centroid_hom.to_End_sub CentroidHom.toEnd_subₓ'. -/
@[simp]
theorem toEnd_sub (x y : CentroidHom α) : (x - y).toEnd = x.toEnd - y.toEnd :=
  rfl
#align centroid_hom.to_End_sub CentroidHom.toEnd_sub

/- warning: centroid_hom.to_End_zsmul -> CentroidHom.toEnd_zsmul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (n : Int), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (SMul.smul.{0, u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasZsmul.{u1} α _inst_1) n x)) (SMul.smul.{0, u1} Int (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (SubNegMonoid.SMulInt.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddGroup.toSubNegMonoid.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddGroupWithOne.toAddGroup.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (NonAssocRing.toAddGroupWithOne.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Ring.toNonAssocRing.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoid.End.ring.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))))) n (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) x))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (n : Int), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (HSMul.hSMul.{0, u1, u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (instHSMul.{0, u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasZsmul.{u1} α _inst_1)) n x)) (HSMul.hSMul.{0, u1, u1} Int (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (instHSMul.{0, u1} Int (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (SubNegMonoid.SMulInt.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddGroup.toSubNegMonoid.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddGroupWithOne.toAddGroup.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Ring.toAddGroupWithOne.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (instRingEndToAddZeroClassToAddMonoidToSubNegMonoidToAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))))) n (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) x))
Case conversion may be inaccurate. Consider using '#align centroid_hom.to_End_zsmul CentroidHom.toEnd_zsmulₓ'. -/
theorem toEnd_zsmul (x : CentroidHom α) (n : ℤ) : (n • x).toEnd = n • x.toEnd :=
  rfl
#align centroid_hom.to_End_zsmul CentroidHom.toEnd_zsmul

instance : AddCommGroup (CentroidHom α) :=
  toEnd_injective.AddCommGroup _ toEnd_zero toEnd_add toEnd_neg toEnd_sub toEnd_nsmul toEnd_zsmul

/- warning: centroid_hom.coe_neg -> CentroidHom.coe_neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (f : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (Neg.neg.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasNeg.{u1} α _inst_1) f)) (Neg.neg.{u1} (α -> α) (Pi.instNeg.{u1, u1} α (fun (ᾰ : α) => α) (fun (i : α) => SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) f))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (f : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Neg.neg.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.instNegCentroidHomToNonUnitalNonAssocSemiring.{u1} α _inst_1) f)) (Neg.neg.{u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (Pi.instNeg.{u1, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (fun (i : α) => NegZeroClass.toNeg.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) _inst_1))))))) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) f))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_neg CentroidHom.coe_negₓ'. -/
@[simp, norm_cast]
theorem coe_neg (f : CentroidHom α) : ⇑(-f) = -f :=
  rfl
#align centroid_hom.coe_neg CentroidHom.coe_neg

/- warning: centroid_hom.coe_sub -> CentroidHom.coe_sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (f : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (g : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)), Eq.{succ u1} (α -> α) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (HSub.hSub.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (instHSub.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasSub.{u1} α _inst_1)) f g)) (HSub.hSub.{u1, u1, u1} (α -> α) (α -> α) (α -> α) (instHSub.{u1} (α -> α) (Pi.instSub.{u1, u1} α (fun (ᾰ : α) => α) (fun (i : α) => SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))))) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) f) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) g))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (f : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (g : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)), Eq.{succ u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (instHSub.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.instSubCentroidHomToNonUnitalNonAssocSemiring.{u1} α _inst_1)) f g)) (HSub.hSub.{u1, u1, u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (instHSub.{u1} (forall (ᾰ : α), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (Pi.instSub.{u1, u1} α (fun (ᾰ : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) ᾰ) (fun (i : α) => SubNegMonoid.toSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) i) _inst_1)))))) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) f) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) g))
Case conversion may be inaccurate. Consider using '#align centroid_hom.coe_sub CentroidHom.coe_subₓ'. -/
@[simp, norm_cast]
theorem coe_sub (f g : CentroidHom α) : ⇑(f - g) = f - g :=
  rfl
#align centroid_hom.coe_sub CentroidHom.coe_sub

/- warning: centroid_hom.neg_apply -> CentroidHom.neg_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (f : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (Neg.neg.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasNeg.{u1} α _inst_1) f) a) (Neg.neg.{u1} α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) f a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (f : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Neg.neg.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.instNegCentroidHomToNonUnitalNonAssocSemiring.{u1} α _inst_1) f) a) (Neg.neg.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (NegZeroClass.toNeg.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (SubtractionCommMonoid.toSubtractionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (AddCommGroup.toDivisionAddCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) _inst_1)))))) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) f a))
Case conversion may be inaccurate. Consider using '#align centroid_hom.neg_apply CentroidHom.neg_applyₓ'. -/
@[simp]
theorem neg_apply (f : CentroidHom α) (a : α) : (-f) a = -f a :=
  rfl
#align centroid_hom.neg_apply CentroidHom.neg_apply

/- warning: centroid_hom.sub_apply -> CentroidHom.sub_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (f : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (g : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (a : α), Eq.{succ u1} α (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (HSub.hSub.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (instHSub.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasSub.{u1} α _inst_1)) f g) a) (HSub.hSub.{u1, u1, u1} α α α (instHSub.{u1} α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α (AddCommGroup.toAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))))) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) f a) (coeFn.{succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (fun (_x : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) => α -> α) (CentroidHom.hasCoeToFun.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) g a))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (f : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (g : CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (a : α), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (HSub.hSub.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (instHSub.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.instSubCentroidHomToNonUnitalNonAssocSemiring.{u1} α _inst_1)) f g) a) (HSub.hSub.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (instHSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (SubNegMonoid.toSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) (NonUnitalNonAssocRing.toAddCommGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) a) _inst_1))))) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) f a) (FunLike.coe.{succ u1, succ u1, succ u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : α) => α) _x) (AddHomClass.toFunLike.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddZeroClass.toAdd.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoidHomClass.toAddHomClass.{u1, u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)))) (CentroidHomClass.toAddMonoidHomClass.{u1, u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (CentroidHom.instCentroidHomClassCentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) g a))
Case conversion may be inaccurate. Consider using '#align centroid_hom.sub_apply CentroidHom.sub_applyₓ'. -/
@[simp]
theorem sub_apply (f g : CentroidHom α) (a : α) : (f - g) a = f a - g a :=
  rfl
#align centroid_hom.sub_apply CentroidHom.sub_apply

/- warning: centroid_hom.to_End_int_cast -> CentroidHom.toEnd_int_cast is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (z : Int), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (HasLiftT.mk.{1, succ u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CoeTCₓ.coe.{1, succ u1} Int (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (Int.castCoe.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.hasIntCast.{u1} α _inst_1)))) z)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (HasLiftT.mk.{1, succ u1} Int (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (CoeTCₓ.coe.{1, succ u1} Int (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Int.castCoe.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddGroupWithOne.toHasIntCast.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (NonAssocRing.toAddGroupWithOne.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Ring.toNonAssocRing.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (AddMonoid.End.ring.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1)))))))) z)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalNonAssocRing.{u1} α] (z : Int), Eq.{succ u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (CentroidHom.toEnd.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1) (Int.cast.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1)) (CentroidHom.instIntCastCentroidHomToNonUnitalNonAssocSemiring.{u1} α _inst_1) z)) (Int.cast.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (Ring.toIntCast.{u1} (AddMonoid.End.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α _inst_1))))) (instRingEndToAddZeroClassToAddMonoidToSubNegMonoidToAddGroup.{u1} α (NonUnitalNonAssocRing.toAddCommGroup.{u1} α _inst_1))) z)
Case conversion may be inaccurate. Consider using '#align centroid_hom.to_End_int_cast CentroidHom.toEnd_int_castₓ'. -/
@[simp, norm_cast]
theorem toEnd_int_cast (z : ℤ) : (z : CentroidHom α).toEnd = ↑z :=
  rfl
#align centroid_hom.to_End_int_cast CentroidHom.toEnd_int_cast

instance : Ring (CentroidHom α) :=
  toEnd_injective.Ring _ toEnd_zero toEnd_one toEnd_add toEnd_mul toEnd_neg toEnd_sub toEnd_nsmul
    toEnd_zsmul toEnd_pow toEnd_nat_cast toEnd_int_cast

end NonUnitalNonAssocRing

section NonUnitalRing

variable [NonUnitalRing α]

/- warning: centroid_hom.comm_ring -> CentroidHom.commRing is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : NonUnitalRing.{u1} α], (forall (a : α) (b : α), (forall (r : α), Eq.{succ u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))) a r) b) (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))))) -> (Or (Eq.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))))) (Eq.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1)))))))))) -> (CommRing.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : NonUnitalRing.{u1} α], (forall (a : α) (b : α), (forall (r : α), Eq.{succ u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocRing.toMul.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))) a r) b) (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α (NonUnitalRing.toNonUnitalSemiring.{u1} α _inst_1)))))) -> (Or (Eq.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α (NonUnitalRing.toNonUnitalSemiring.{u1} α _inst_1)))))) (Eq.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (SemigroupWithZero.toZero.{u1} α (NonUnitalSemiring.toSemigroupWithZero.{u1} α (NonUnitalRing.toNonUnitalSemiring.{u1} α _inst_1)))))))) -> (CommRing.{u1} (CentroidHom.{u1} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} α (NonUnitalRing.toNonUnitalNonAssocRing.{u1} α _inst_1))))
Case conversion may be inaccurate. Consider using '#align centroid_hom.comm_ring CentroidHom.commRingₓ'. -/
-- See note [reducible non instances]
/-- A prime associative ring has commutative centroid. -/
@[reducible]
def commRing (h : ∀ a b : α, (∀ r : α, a * r * b = 0) → a = 0 ∨ b = 0) : CommRing (CentroidHom α) :=
  { CentroidHom.ring with
    mul_comm := fun f g => by
      ext
      refine' sub_eq_zero.1 ((or_self_iff _).1 <| h _ _ fun r => _)
      rw [mul_assoc, sub_mul, sub_eq_zero, ← map_mul_right, ← map_mul_right, coe_mul, coe_mul,
        comp_mul_comm] }
#align centroid_hom.comm_ring CentroidHom.commRing

end NonUnitalRing

end CentroidHom

