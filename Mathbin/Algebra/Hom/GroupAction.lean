/-
Copyright (c) 2020 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau

! This file was ported from Lean 3 source module algebra.hom.group_action
! leanprover-community/mathlib commit d6fad0e5bf2d6f48da9175d25c3dc5706b3834ce
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.GroupRingAction.Basic
import Mathbin.Algebra.Module.Basic

/-!
# Equivariant homomorphisms

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main definitions

* `mul_action_hom M X Y`, the type of equivariant functions from `X` to `Y`, where `M` is a monoid
  that acts on the types `X` and `Y`.
* `distrib_mul_action_hom M A B`, the type of equivariant additive monoid homomorphisms
  from `A` to `B`, where `M` is a monoid that acts on the additive monoids `A` and `B`.
* `mul_semiring_action_hom M R S`, the type of equivariant ring homomorphisms
  from `R` to `S`, where `M` is a monoid that acts on the rings `R` and `S`.

The above types have corresponding classes:
* `smul_hom_class F M X Y` states that `F` is a type of bundled `X → Y` homs
  preserving scalar multiplication by `M`
* `distrib_mul_action_hom_class F M A B` states that `F` is a type of bundled `A → B` homs
  preserving the additive monoid structure and scalar multiplication by `M`
* `mul_semiring_action_hom_class F M R S` states that `F` is a type of bundled `R → S` homs
  preserving the ring structure and scalar multiplication by `M`

## Notations

* `X →[M] Y` is `mul_action_hom M X Y`.
* `A →+[M] B` is `distrib_mul_action_hom M A B`.
* `R →+*[M] S` is `mul_semiring_action_hom M R S`.

-/


assert_not_exists Submonoid

variable (M' : Type _)

variable (X : Type _) [SMul M' X]

variable (Y : Type _) [SMul M' Y]

variable (Z : Type _) [SMul M' Z]

variable (M : Type _) [Monoid M]

variable (A : Type _) [AddMonoid A] [DistribMulAction M A]

variable (A' : Type _) [AddGroup A'] [DistribMulAction M A']

variable (B : Type _) [AddMonoid B] [DistribMulAction M B]

variable (B' : Type _) [AddGroup B'] [DistribMulAction M B']

variable (C : Type _) [AddMonoid C] [DistribMulAction M C]

variable (R : Type _) [Semiring R] [MulSemiringAction M R]

variable (R' : Type _) [Ring R'] [MulSemiringAction M R']

variable (S : Type _) [Semiring S] [MulSemiringAction M S]

variable (S' : Type _) [Ring S'] [MulSemiringAction M S']

variable (T : Type _) [Semiring T] [MulSemiringAction M T]

#print MulActionHom /-
/-- Equivariant functions. -/
@[nolint has_nonempty_instance]
structure MulActionHom where
  toFun : X → Y
  map_smul' : ∀ (m : M') (x : X), to_fun (m • x) = m • to_fun x
#align mul_action_hom MulActionHom
-/

-- mathport name: mul_action_hom
notation:25 X " →[" M:25 "] " Y:0 => MulActionHom M X Y

#print SMulHomClass /-
/-- `smul_hom_class F M X Y` states that `F` is a type of morphisms preserving
scalar multiplication by `M`.

You should extend this class when you extend `mul_action_hom`. -/
class SMulHomClass (F : Type _) (M X Y : outParam <| Type _) [SMul M X] [SMul M Y] extends
  FunLike F X fun _ => Y where
  map_smul : ∀ (f : F) (c : M) (x : X), f (c • x) = c • f x
#align smul_hom_class SMulHomClass
-/

-- `M` becomes a metavariable but it's an `out_param` so it's not a problem.
attribute [nolint dangerous_instance] SMulHomClass.toFunLike

export SMulHomClass (map_smul)

attribute [simp] map_smul

namespace MulActionHom

instance : CoeFun (X →[M'] Y) fun _ => X → Y :=
  ⟨MulActionHom.toFun⟩

instance : SMulHomClass (X →[M'] Y) M' X Y
    where
  coe := MulActionHom.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
  map_smul := MulActionHom.map_smul'

variable {M M' X Y}

/- warning: mul_action_hom.map_smul -> MulActionHom.map_smul is a dubious translation:
lean 3 declaration is
  forall {M' : Type.{u1}} {X : Type.{u2}} [_inst_1 : SMul.{u1, u2} M' X] {Y : Type.{u3}} [_inst_2 : SMul.{u1, u3} M' Y] (f : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (m : M') (x : X), Eq.{succ u3} Y (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (fun (_x : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) => X -> Y) ([anonymous].{u1, u2, u3} M' X _inst_1 Y _inst_2) f (SMul.smul.{u1, u2} M' X _inst_1 m x)) (SMul.smul.{u1, u3} M' Y _inst_2 m (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (fun (_x : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) => X -> Y) ([anonymous].{u1, u2, u3} M' X _inst_1 Y _inst_2) f x))
but is expected to have type
  forall {M' : Type.{u3}} {X : Type.{u2}} [_inst_1 : SMul.{u3, u2} M' X] {Y : Type.{u1}} [_inst_2 : SMul.{u3, u1} M' Y] (f : MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) (m : M') (x : X), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) (HSMul.hSMul.{u3, u2, u2} M' X X (instHSMul.{u3, u2} M' X _inst_1) m x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) M' X Y _inst_1 _inst_2 (instSMulHomClassMulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2)) f (HSMul.hSMul.{u3, u2, u2} M' X X (instHSMul.{u3, u2} M' X _inst_1) m x)) (HSMul.hSMul.{u3, u1, u1} M' ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) x) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) x) (instHSMul.{u3, u1} M' ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) x) _inst_2) m (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) M' X Y _inst_1 _inst_2 (instSMulHomClassMulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2)) f x))
Case conversion may be inaccurate. Consider using '#align mul_action_hom.map_smul MulActionHom.map_smulₓ'. -/
protected theorem map_smul (f : X →[M'] Y) (m : M') (x : X) : f (m • x) = m • f x :=
  map_smul _ _ _
#align mul_action_hom.map_smul MulActionHom.map_smul

/- warning: mul_action_hom.ext -> MulActionHom.ext is a dubious translation:
lean 3 declaration is
  forall {M' : Type.{u1}} {X : Type.{u2}} [_inst_1 : SMul.{u1, u2} M' X] {Y : Type.{u3}} [_inst_2 : SMul.{u1, u3} M' Y] {f : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2} {g : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2}, (forall (x : X), Eq.{succ u3} Y (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (fun (_x : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) => X -> Y) ([anonymous].{u1, u2, u3} M' X _inst_1 Y _inst_2) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (fun (_x : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) => X -> Y) ([anonymous].{u1, u2, u3} M' X _inst_1 Y _inst_2) g x)) -> (Eq.{max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) f g)
but is expected to have type
  forall {M' : Type.{u3}} {X : Type.{u2}} [_inst_1 : SMul.{u3, u2} M' X] {Y : Type.{u1}} [_inst_2 : SMul.{u3, u1} M' Y] {f : MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2} {g : MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2}, (forall (x : X), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) M' X Y _inst_1 _inst_2 (instSMulHomClassMulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2)) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) M' X Y _inst_1 _inst_2 (instSMulHomClassMulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2)) g x)) -> (Eq.{max (succ u2) (succ u1)} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) f g)
Case conversion may be inaccurate. Consider using '#align mul_action_hom.ext MulActionHom.extₓ'. -/
@[ext]
theorem ext : ∀ {f g : X →[M'] Y}, (∀ x, f x = g x) → f = g :=
  FunLike.ext
#align mul_action_hom.ext MulActionHom.ext

/- warning: mul_action_hom.ext_iff -> MulActionHom.ext_iff is a dubious translation:
lean 3 declaration is
  forall {M' : Type.{u1}} {X : Type.{u2}} [_inst_1 : SMul.{u1, u2} M' X] {Y : Type.{u3}} [_inst_2 : SMul.{u1, u3} M' Y] {f : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2} {g : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2}, Iff (Eq.{max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) f g) (forall (x : X), Eq.{succ u3} Y (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (fun (_x : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) => X -> Y) ([anonymous].{u1, u2, u3} M' X _inst_1 Y _inst_2) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (fun (_x : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) => X -> Y) ([anonymous].{u1, u2, u3} M' X _inst_1 Y _inst_2) g x))
but is expected to have type
  forall {M' : Type.{u3}} {X : Type.{u2}} [_inst_1 : SMul.{u3, u2} M' X] {Y : Type.{u1}} [_inst_2 : SMul.{u3, u1} M' Y] {f : MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2} {g : MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2}, Iff (Eq.{max (succ u2) (succ u1)} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) f g) (forall (x : X), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) M' X Y _inst_1 _inst_2 (instSMulHomClassMulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2)) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) M' X Y _inst_1 _inst_2 (instSMulHomClassMulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2)) g x))
Case conversion may be inaccurate. Consider using '#align mul_action_hom.ext_iff MulActionHom.ext_iffₓ'. -/
theorem ext_iff {f g : X →[M'] Y} : f = g ↔ ∀ x, f x = g x :=
  FunLike.ext_iff
#align mul_action_hom.ext_iff MulActionHom.ext_iff

/- warning: mul_action_hom.congr_fun -> MulActionHom.congr_fun is a dubious translation:
lean 3 declaration is
  forall {M' : Type.{u1}} {X : Type.{u2}} [_inst_1 : SMul.{u1, u2} M' X] {Y : Type.{u3}} [_inst_2 : SMul.{u1, u3} M' Y] {f : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2} {g : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2}, (Eq.{max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) f g) -> (forall (x : X), Eq.{succ u3} Y (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (fun (_x : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) => X -> Y) ([anonymous].{u1, u2, u3} M' X _inst_1 Y _inst_2) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (fun (_x : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) => X -> Y) ([anonymous].{u1, u2, u3} M' X _inst_1 Y _inst_2) g x))
but is expected to have type
  forall {M' : Type.{u3}} {X : Type.{u2}} [_inst_1 : SMul.{u3, u2} M' X] {Y : Type.{u1}} [_inst_2 : SMul.{u3, u1} M' Y] {f : MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2} {g : MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2}, (Eq.{max (succ u2) (succ u1)} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) f g) -> (forall (x : X), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) M' X Y _inst_1 _inst_2 (instSMulHomClassMulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2)) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) M' X Y _inst_1 _inst_2 (instSMulHomClassMulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2)) g x))
Case conversion may be inaccurate. Consider using '#align mul_action_hom.congr_fun MulActionHom.congr_funₓ'. -/
protected theorem congr_fun {f g : X →[M'] Y} (h : f = g) (x : X) : f x = g x :=
  FunLike.congr_fun h _
#align mul_action_hom.congr_fun MulActionHom.congr_fun

variable (M M') {X}

#print MulActionHom.id /-
/-- The identity map as an equivariant map. -/
protected def id : X →[M'] X :=
  ⟨id, fun _ _ => rfl⟩
#align mul_action_hom.id MulActionHom.id
-/

#print MulActionHom.id_apply /-
@[simp]
theorem id_apply (x : X) : MulActionHom.id M' x = x :=
  rfl
#align mul_action_hom.id_apply MulActionHom.id_apply
-/

variable {M M' X Y Z}

#print MulActionHom.comp /-
/-- Composition of two equivariant maps. -/
def comp (g : Y →[M'] Z) (f : X →[M'] Y) : X →[M'] Z :=
  ⟨g ∘ f, fun m x =>
    calc
      g (f (m • x)) = g (m • f x) := by rw [f.map_smul]
      _ = m • g (f x) := g.map_smul _ _
      ⟩
#align mul_action_hom.comp MulActionHom.comp
-/

/- warning: mul_action_hom.comp_apply -> MulActionHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {M' : Type.{u1}} {X : Type.{u2}} [_inst_1 : SMul.{u1, u2} M' X] {Y : Type.{u3}} [_inst_2 : SMul.{u1, u3} M' Y] {Z : Type.{u4}} [_inst_3 : SMul.{u1, u4} M' Z] (g : MulActionHom.{u1, u3, u4} M' Y _inst_2 Z _inst_3) (f : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (x : X), Eq.{succ u4} Z (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (MulActionHom.{u1, u2, u4} M' X _inst_1 Z _inst_3) (fun (_x : MulActionHom.{u1, u2, u4} M' X _inst_1 Z _inst_3) => X -> Z) ([anonymous].{u1, u2, u4} M' X _inst_1 Z _inst_3) (MulActionHom.comp.{u1, u2, u3, u4} M' X _inst_1 Y _inst_2 Z _inst_3 g f) x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (MulActionHom.{u1, u3, u4} M' Y _inst_2 Z _inst_3) (fun (_x : MulActionHom.{u1, u3, u4} M' Y _inst_2 Z _inst_3) => Y -> Z) ([anonymous].{u1, u3, u4} M' Y _inst_2 Z _inst_3) g (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (fun (_x : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) => X -> Y) ([anonymous].{u1, u2, u3} M' X _inst_1 Y _inst_2) f x))
but is expected to have type
  forall {M' : Type.{u4}} {X : Type.{u1}} [_inst_1 : SMul.{u4, u1} M' X] {Y : Type.{u3}} [_inst_2 : SMul.{u4, u3} M' Y] {Z : Type.{u2}} [_inst_3 : SMul.{u4, u2} M' Z] (g : MulActionHom.{u4, u3, u2} M' Y _inst_2 Z _inst_3) (f : MulActionHom.{u4, u1, u3} M' X _inst_1 Y _inst_2) (x : X), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Z) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MulActionHom.{u4, u1, u2} M' X _inst_1 Z _inst_3) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Z) _x) (SMulHomClass.toFunLike.{max u1 u2, u4, u1, u2} (MulActionHom.{u4, u1, u2} M' X _inst_1 Z _inst_3) M' X Z _inst_1 _inst_3 (instSMulHomClassMulActionHom.{u4, u1, u2} M' X _inst_1 Z _inst_3)) (MulActionHom.comp.{u4, u1, u3, u2} M' X _inst_1 Y _inst_2 Z _inst_3 g f) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MulActionHom.{u4, u3, u2} M' Y _inst_2 Z _inst_3) Y (fun (_x : Y) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : Y) => Z) _x) (SMulHomClass.toFunLike.{max u3 u2, u4, u3, u2} (MulActionHom.{u4, u3, u2} M' Y _inst_2 Z _inst_3) M' Y Z _inst_2 _inst_3 (instSMulHomClassMulActionHom.{u4, u3, u2} M' Y _inst_2 Z _inst_3)) g (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (MulActionHom.{u4, u1, u3} M' X _inst_1 Y _inst_2) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : X) => Y) _x) (SMulHomClass.toFunLike.{max u1 u3, u4, u1, u3} (MulActionHom.{u4, u1, u3} M' X _inst_1 Y _inst_2) M' X Y _inst_1 _inst_2 (instSMulHomClassMulActionHom.{u4, u1, u3} M' X _inst_1 Y _inst_2)) f x))
Case conversion may be inaccurate. Consider using '#align mul_action_hom.comp_apply MulActionHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (g : Y →[M'] Z) (f : X →[M'] Y) (x : X) : g.comp f x = g (f x) :=
  rfl
#align mul_action_hom.comp_apply MulActionHom.comp_apply

/- warning: mul_action_hom.id_comp -> MulActionHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {M' : Type.{u1}} {X : Type.{u2}} [_inst_1 : SMul.{u1, u2} M' X] {Y : Type.{u3}} [_inst_2 : SMul.{u1, u3} M' Y] (f : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2), Eq.{max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (MulActionHom.comp.{u1, u2, u3, u3} M' X _inst_1 Y _inst_2 Y _inst_2 (MulActionHom.id.{u1, u3} M' Y _inst_2) f) f
but is expected to have type
  forall {M' : Type.{u3}} {X : Type.{u2}} [_inst_1 : SMul.{u3, u2} M' X] {Y : Type.{u1}} [_inst_2 : SMul.{u3, u1} M' Y] (f : MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2), Eq.{max (succ u2) (succ u1)} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) (MulActionHom.comp.{u3, u2, u1, u1} M' X _inst_1 Y _inst_2 Y _inst_2 (MulActionHom.id.{u3, u1} M' Y _inst_2) f) f
Case conversion may be inaccurate. Consider using '#align mul_action_hom.id_comp MulActionHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : X →[M'] Y) : (MulActionHom.id M').comp f = f :=
  ext fun x => by rw [comp_apply, id_apply]
#align mul_action_hom.id_comp MulActionHom.id_comp

/- warning: mul_action_hom.comp_id -> MulActionHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {M' : Type.{u1}} {X : Type.{u2}} [_inst_1 : SMul.{u1, u2} M' X] {Y : Type.{u3}} [_inst_2 : SMul.{u1, u3} M' Y] (f : MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2), Eq.{max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M' X _inst_1 Y _inst_2) (MulActionHom.comp.{u1, u2, u2, u3} M' X _inst_1 X _inst_1 Y _inst_2 f (MulActionHom.id.{u1, u2} M' X _inst_1)) f
but is expected to have type
  forall {M' : Type.{u3}} {X : Type.{u2}} [_inst_1 : SMul.{u3, u2} M' X] {Y : Type.{u1}} [_inst_2 : SMul.{u3, u1} M' Y] (f : MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2), Eq.{max (succ u2) (succ u1)} (MulActionHom.{u3, u2, u1} M' X _inst_1 Y _inst_2) (MulActionHom.comp.{u3, u2, u2, u1} M' X _inst_1 X _inst_1 Y _inst_2 f (MulActionHom.id.{u3, u2} M' X _inst_1)) f
Case conversion may be inaccurate. Consider using '#align mul_action_hom.comp_id MulActionHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : X →[M'] Y) : f.comp (MulActionHom.id M') = f :=
  ext fun x => by rw [comp_apply, id_apply]
#align mul_action_hom.comp_id MulActionHom.comp_id

variable {A B}

/- warning: mul_action_hom.inverse -> MulActionHom.inverse is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] (f : MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (g : B -> A), (Function.LeftInverse.{succ u2, succ u3} A B g (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (fun (_x : MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) => A -> B) ([anonymous].{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) f)) -> (Function.RightInverse.{succ u2, succ u3} A B g (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (fun (_x : MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) => A -> B) ([anonymous].{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) f)) -> (MulActionHom.{u1, u3, u2} M B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10))) A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] (f : MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toSMul.{u1, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u1, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (g : B -> A), (Function.LeftInverse.{succ u2, succ u3} A B g (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toSMul.{u1, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u1, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u3, u1, u2, u3} (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toSMul.{u1, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u1, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) M A B (SMulZeroClass.toSMul.{u1, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u1, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10))) (instSMulHomClassMulActionHom.{u1, u2, u3} M A (SMulZeroClass.toSMul.{u1, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u1, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10))))) f)) -> (Function.RightInverse.{succ u2, succ u3} A B g (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toSMul.{u1, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u1, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u3, u1, u2, u3} (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toSMul.{u1, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u1, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) M A B (SMulZeroClass.toSMul.{u1, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u1, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10))) (instSMulHomClassMulActionHom.{u1, u2, u3} M A (SMulZeroClass.toSMul.{u1, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u1, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10))))) f)) -> (MulActionHom.{u1, u3, u2} M B (SMulZeroClass.toSMul.{u1, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10))) A (SMulZeroClass.toSMul.{u1, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))))
Case conversion may be inaccurate. Consider using '#align mul_action_hom.inverse MulActionHom.inverseₓ'. -/
/-- The inverse of a bijective equivariant map is equivariant. -/
@[simps]
def inverse (f : A →[M] B) (g : B → A) (h₁ : Function.LeftInverse g f)
    (h₂ : Function.RightInverse g f) : B →[M] A
    where
  toFun := g
  map_smul' m x :=
    calc
      g (m • x) = g (m • f (g x)) := by rw [h₂]
      _ = g (f (m • g x)) := by rw [f.map_smul]
      _ = m • g x := by rw [h₁]
      
#align mul_action_hom.inverse MulActionHom.inverse

end MulActionHom

#print DistribMulActionHom /-
/-- Equivariant additive monoid homomorphisms. -/
structure DistribMulActionHom extends A →[M] B, A →+ B
#align distrib_mul_action_hom DistribMulActionHom
-/

/-- Reinterpret an equivariant additive monoid homomorphism as an additive monoid homomorphism. -/
add_decl_doc DistribMulActionHom.toAddMonoidHom

/-- Reinterpret an equivariant additive monoid homomorphism as an equivariant function. -/
add_decl_doc DistribMulActionHom.toMulActionHom

-- mathport name: «expr →+[ ] »
notation:25 A " →+[" M:25 "] " B:0 => DistribMulActionHom M A B

#print DistribMulActionHomClass /-
/-- `distrib_mul_action_hom_class F M A B` states that `F` is a type of morphisms preserving
the additive monoid structure and scalar multiplication by `M`.

You should extend this class when you extend `distrib_mul_action_hom`. -/
class DistribMulActionHomClass (F : Type _) (M A B : outParam <| Type _) [Monoid M] [AddMonoid A]
  [AddMonoid B] [DistribMulAction M A] [DistribMulAction M B] extends SMulHomClass F M A B,
  AddMonoidHomClass F A B
#align distrib_mul_action_hom_class DistribMulActionHomClass
-/

-- `M` becomes a metavariable but it's an `out_param` so it's not a problem.
attribute [nolint dangerous_instance] DistribMulActionHomClass.toAddMonoidHomClass

namespace DistribMulActionHom

/- warning: distrib_mul_action_hom.has_coe clashes with [anonymous] -> [anonymous]
warning: distrib_mul_action_hom.has_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u_5}) [_inst_4 : Monoid.{u_5} M] (A : Type.{u_6}) [_inst_5 : AddMonoid.{u_6} A] [_inst_6 : DistribMulAction.{u_5, u_6} M A _inst_4 _inst_5] (B : Type.{u_8}) [_inst_9 : AddMonoid.{u_8} B] [_inst_10 : DistribMulAction.{u_5, u_8} M B _inst_4 _inst_9], Coe.{max (succ u_6) (succ u_8), max (succ u_8) (succ u_6)} (DistribMulActionHom.{u_5, u_6, u_8} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u_6, u_8} A B (AddMonoid.toAddZeroClass.{u_6} A _inst_5) (AddMonoid.toAddZeroClass.{u_8} B _inst_9))
but is expected to have type
  forall {M : Type.{u}} {_inst_4 : Type.{v}}, (Nat -> M -> _inst_4) -> Nat -> (List.{u} M) -> (List.{v} _inst_4)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.has_coe [anonymous]ₓ'. -/
instance [anonymous] : Coe (A →+[M] B) (A →+ B) :=
  ⟨toAddMonoidHom⟩
#align distrib_mul_action_hom.has_coe [anonymous]

/- warning: distrib_mul_action_hom.has_coe' clashes with [anonymous] -> [anonymous]
warning: distrib_mul_action_hom.has_coe' -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u_5}) [_inst_4 : Monoid.{u_5} M] (A : Type.{u_6}) [_inst_5 : AddMonoid.{u_6} A] [_inst_6 : DistribMulAction.{u_5, u_6} M A _inst_4 _inst_5] (B : Type.{u_8}) [_inst_9 : AddMonoid.{u_8} B] [_inst_10 : DistribMulAction.{u_5, u_8} M B _inst_4 _inst_9], Coe.{max (succ u_6) (succ u_8), max (succ u_6) (succ u_8)} (DistribMulActionHom.{u_5, u_6, u_8} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u_5, u_6, u_8} M A (SMulZeroClass.toHasSmul.{u_5, u_6} M A (AddZeroClass.toHasZero.{u_6} A (AddMonoid.toAddZeroClass.{u_6} A _inst_5)) (DistribSMul.toSmulZeroClass.{u_5, u_6} M A (AddMonoid.toAddZeroClass.{u_6} A _inst_5) (DistribMulAction.toDistribSMul.{u_5, u_6} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u_5, u_8} M B (AddZeroClass.toHasZero.{u_8} B (AddMonoid.toAddZeroClass.{u_8} B _inst_9)) (DistribSMul.toSmulZeroClass.{u_5, u_8} M B (AddMonoid.toAddZeroClass.{u_8} B _inst_9) (DistribMulAction.toDistribSMul.{u_5, u_8} M B _inst_4 _inst_9 _inst_10))))
but is expected to have type
  forall {M : Type.{u}} {_inst_4 : Type.{v}}, (Nat -> M -> _inst_4) -> Nat -> (List.{u} M) -> (List.{v} _inst_4)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.has_coe' [anonymous]ₓ'. -/
instance [anonymous] : Coe (A →+[M] B) (A →[M] B) :=
  ⟨toMulActionHom⟩
#align distrib_mul_action_hom.has_coe' [anonymous]

instance : CoeFun (A →+[M] B) fun _ => A → B :=
  ⟨toFun⟩

instance : DistribMulActionHomClass (A →+[M] B) M A B
    where
  coe := DistribMulActionHom.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
  map_smul := DistribMulActionHom.map_smul'
  map_zero := DistribMulActionHom.map_zero'
  map_add := DistribMulActionHom.map_add'

variable {M A B}

/- warning: distrib_mul_action_hom.to_fun_eq_coe -> DistribMulActionHom.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{max (succ u2) (succ u3)} (A -> B) (DistribMulActionHom.toFun.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10 f) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f)
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{max (succ u2) (succ u1)} (A -> B) (MulActionHom.toFun.{u3, u2, u1} M A (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHom.toMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10 f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (f : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) f) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.to_fun_eq_coe DistribMulActionHom.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe (f : A →+[M] B) : f.toFun = ⇑f :=
  rfl
#align distrib_mul_action_hom.to_fun_eq_coe DistribMulActionHom.toFun_eq_coe

/- warning: distrib_mul_action_hom.coe_fn_coe -> DistribMulActionHom.coe_fn_coe is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{max (succ u2) (succ u3)} ((fun (_x : AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) => A -> B) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u3) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u3) (succ u2)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (AddMonoidHom.hasCoeT.{u2, u3, max u2 u3} A B (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulActionHomClass.toAddMonoidHomClass.{max u2 u3, u1, u2, u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.distribMulActionHomClass.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))))) f)) (coeFn.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (fun (_x : AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) => A -> B) (AddMonoidHom.hasCoeToFun.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u3) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u3) (succ u2)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (AddMonoidHom.hasCoeT.{u2, u3, max u2 u3} A B (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulActionHomClass.toAddMonoidHomClass.{max u2 u3, u1, u2, u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.distribMulActionHomClass.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))))) f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f)
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{max (succ u2) (succ u1)} (forall (a : A), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : A) => B) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AddMonoidHom.{u2, u1} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u1} B _inst_9)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.398 : A) => B) _x) (AddHomClass.toFunLike.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u1} B _inst_9)) A B (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (AddZeroClass.toAdd.{u1} B (AddMonoid.toAddZeroClass.{u1} B _inst_9)) (AddMonoidHomClass.toAddHomClass.{max u2 u1, u2, u1} (AddMonoidHom.{u2, u1} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u1} B _inst_9)) A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u1} B _inst_9) (AddMonoidHom.addMonoidHomClass.{u2, u1} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u1} B _inst_9)))) (AddMonoidHomClass.toAddMonoidHom.{u2, u1, max u2 u1} A B (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulActionHomClass.toAddMonoidHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.coe_fn_coe DistribMulActionHom.coe_fn_coeₓ'. -/
@[norm_cast]
theorem coe_fn_coe (f : A →+[M] B) : ((f : A →+ B) : A → B) = f :=
  rfl
#align distrib_mul_action_hom.coe_fn_coe DistribMulActionHom.coe_fn_coe

/- warning: distrib_mul_action_hom.coe_fn_coe' -> DistribMulActionHom.coe_fn_coe' is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{max (succ u2) (succ u3)} ((fun (_x : MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) => A -> B) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)))) f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (fun (_x : MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) => A -> B) ([anonymous].{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)))) f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f)
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{max (succ u2) (succ u1)} (forall (a : A), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulActionHom.{u3, u2, u1} M A (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10)))) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulActionHom.{u3, u2, u1} M A (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10)))) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (instSMulHomClassMulActionHom.{u3, u2, u1} M A (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))))) (SMulHomClass.toMulActionHom.{u2, u1, u3, max u2 u1} A B M (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.coe_fn_coe' DistribMulActionHom.coe_fn_coe'ₓ'. -/
@[norm_cast]
theorem coe_fn_coe' (f : A →+[M] B) : ((f : A →[M] B) : A → B) = f :=
  rfl
#align distrib_mul_action_hom.coe_fn_coe' DistribMulActionHom.coe_fn_coe'

/- warning: distrib_mul_action_hom.ext -> DistribMulActionHom.ext is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] {f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10} {g : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10}, (forall (x : A), Eq.{succ u3} B (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) g x)) -> (Eq.{max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f g)
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] {f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10} {g : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10}, (forall (x : A), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) g x)) -> (Eq.{max (succ u2) (succ u1)} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f g)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.ext DistribMulActionHom.extₓ'. -/
@[ext]
theorem ext : ∀ {f g : A →+[M] B}, (∀ x, f x = g x) → f = g :=
  FunLike.ext
#align distrib_mul_action_hom.ext DistribMulActionHom.ext

/- warning: distrib_mul_action_hom.ext_iff -> DistribMulActionHom.ext_iff is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] {f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10} {g : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10}, Iff (Eq.{max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f g) (forall (x : A), Eq.{succ u3} B (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) g x))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] {f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10} {g : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10}, Iff (Eq.{max (succ u2) (succ u1)} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f g) (forall (x : A), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) g x))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.ext_iff DistribMulActionHom.ext_iffₓ'. -/
theorem ext_iff {f g : A →+[M] B} : f = g ↔ ∀ x, f x = g x :=
  FunLike.ext_iff
#align distrib_mul_action_hom.ext_iff DistribMulActionHom.ext_iff

/- warning: distrib_mul_action_hom.congr_fun -> DistribMulActionHom.congr_fun is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] {f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10} {g : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10}, (Eq.{max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f g) -> (forall (x : A), Eq.{succ u3} B (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) g x))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] {f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10} {g : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10}, (Eq.{max (succ u2) (succ u1)} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f g) -> (forall (x : A), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) g x))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.congr_fun DistribMulActionHom.congr_funₓ'. -/
protected theorem congr_fun {f g : A →+[M] B} (h : f = g) (x : A) : f x = g x :=
  FunLike.congr_fun h _
#align distrib_mul_action_hom.congr_fun DistribMulActionHom.congr_fun

/- warning: distrib_mul_action_hom.to_mul_action_hom_injective -> DistribMulActionHom.toMulActionHom_injective is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] {f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10} {g : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10}, (Eq.{max (succ u2) (succ u3)} (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)))) f) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (MulActionHom.{u1, u2, u3} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10)))) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)))) g)) -> (Eq.{max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f g)
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] {f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10} {g : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10}, (Eq.{max (succ u2) (succ u1)} (MulActionHom.{u3, u2, u1} M A (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) B (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10)))) (SMulHomClass.toMulActionHom.{u2, u1, u3, max u2 u1} A B M (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)) f) (SMulHomClass.toMulActionHom.{u2, u1, u3, max u2 u1} A B M (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)) g)) -> (Eq.{max (succ u2) (succ u1)} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f g)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.to_mul_action_hom_injective DistribMulActionHom.toMulActionHom_injectiveₓ'. -/
theorem toMulActionHom_injective {f g : A →+[M] B} (h : (f : A →[M] B) = (g : A →[M] B)) : f = g :=
  by
  ext a
  exact MulActionHom.congr_fun h a
#align distrib_mul_action_hom.to_mul_action_hom_injective DistribMulActionHom.toMulActionHom_injective

/- warning: distrib_mul_action_hom.to_add_monoid_hom_injective -> DistribMulActionHom.toAddMonoidHom_injective is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] {f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10} {g : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10}, (Eq.{max (succ u3) (succ u2)} (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u3) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u3) (succ u2)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (AddMonoidHom.hasCoeT.{u2, u3, max u2 u3} A B (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulActionHomClass.toAddMonoidHomClass.{max u2 u3, u1, u2, u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.distribMulActionHomClass.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))))) f) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u3) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u3) (succ u2)} a b] => self.0) (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoidHom.{u2, u3} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (AddMonoidHom.hasCoeT.{u2, u3, max u2 u3} A B (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulActionHomClass.toAddMonoidHomClass.{max u2 u3, u1, u2, u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.distribMulActionHomClass.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))))) g)) -> (Eq.{max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f g)
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] {f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10} {g : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10}, (Eq.{max (succ u2) (succ u1)} (AddMonoidHom.{u2, u1} A B (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u1} B _inst_9)) (AddMonoidHomClass.toAddMonoidHom.{u2, u1, max u2 u1} A B (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulActionHomClass.toAddMonoidHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)) f) (AddMonoidHomClass.toAddMonoidHom.{u2, u1, max u2 u1} A B (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (AddMonoid.toAddZeroClass.{u2} A _inst_5) (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulActionHomClass.toAddMonoidHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)) g)) -> (Eq.{max (succ u2) (succ u1)} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f g)
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.to_add_monoid_hom_injective DistribMulActionHom.toAddMonoidHom_injectiveₓ'. -/
theorem toAddMonoidHom_injective {f g : A →+[M] B} (h : (f : A →+ B) = (g : A →+ B)) : f = g :=
  by
  ext a
  exact AddMonoidHom.congr_fun h a
#align distrib_mul_action_hom.to_add_monoid_hom_injective DistribMulActionHom.toAddMonoidHom_injective

/- warning: distrib_mul_action_hom.map_zero -> DistribMulActionHom.map_zero is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{succ u3} B (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)))))) (OfNat.ofNat.{u3} B 0 (OfNat.mk.{u3} B 0 (Zero.zero.{u3} B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)))))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A _inst_5)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A _inst_5)))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A _inst_5)))) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A _inst_5)))) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) (OfNat.ofNat.{u2} A 0 (Zero.toOfNat0.{u2} A (AddMonoid.toZero.{u2} A _inst_5)))) _inst_9)))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.map_zero DistribMulActionHom.map_zeroₓ'. -/
protected theorem map_zero (f : A →+[M] B) : f 0 = 0 :=
  map_zero _
#align distrib_mul_action_hom.map_zero DistribMulActionHom.map_zero

/- warning: distrib_mul_action_hom.map_add -> DistribMulActionHom.map_add is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (x : A) (y : A), Eq.{succ u3} B (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toHasAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5))) x y)) (HAdd.hAdd.{u3, u3, u3} B B B (instHAdd.{u3} B (AddZeroClass.toHasAdd.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f y))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (x : A) (y : A), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5))) x y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f (HAdd.hAdd.{u2, u2, u2} A A A (instHAdd.{u2} A (AddZeroClass.toAdd.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5))) x y)) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) y) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) (AddZeroClass.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) _inst_9))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f y))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.map_add DistribMulActionHom.map_addₓ'. -/
protected theorem map_add (f : A →+[M] B) (x y : A) : f (x + y) = f x + f y :=
  map_add _ _ _
#align distrib_mul_action_hom.map_add DistribMulActionHom.map_add

/- warning: distrib_mul_action_hom.map_neg -> DistribMulActionHom.map_neg is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] (A' : Type.{u2}) [_inst_7 : AddGroup.{u2} A'] [_inst_8 : DistribMulAction.{u1, u2} M A' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))] (B' : Type.{u3}) [_inst_11 : AddGroup.{u3} B'] [_inst_12 : DistribMulAction.{u1, u3} M B' _inst_4 (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11))] (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) (x : A'), Eq.{succ u3} B' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) => A' -> B') ([anonymous].{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) f (Neg.neg.{u2} A' (SubNegMonoid.toHasNeg.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) x)) (Neg.neg.{u3} B' (SubNegMonoid.toHasNeg.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) => A' -> B') ([anonymous].{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) f x))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] (A' : Type.{u2}) [_inst_7 : AddGroup.{u2} A'] [_inst_8 : DistribMulAction.{u3, u2} M A' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))] (B' : Type.{u1}) [_inst_11 : AddGroup.{u1} B'] [_inst_12 : DistribMulAction.{u3, u1} M B' _inst_4 (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))] (f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) (x : A'), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') (Neg.neg.{u2} A' (NegZeroClass.toNeg.{u2} A' (SubNegZeroMonoid.toNegZeroClass.{u2} A' (SubtractionMonoid.toSubNegZeroMonoid.{u2} A' (AddGroup.toSubtractionMonoid.{u2} A' _inst_7)))) x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) A' (fun (_x : A') => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) M A' B' (SMulZeroClass.toSMul.{u3, u2} M A' (AddMonoid.toZero.{u2} A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) (DistribSMul.toSMulZeroClass.{u3, u2} M A' (AddMonoid.toAddZeroClass.{u2} A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) (DistribMulAction.toDistribSMul.{u3, u2} M A' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8))) (SMulZeroClass.toSMul.{u3, u1} M B' (AddMonoid.toZero.{u1} B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))) (DistribSMul.toSMulZeroClass.{u3, u1} M B' (AddMonoid.toAddZeroClass.{u1} B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))) (DistribMulAction.toDistribSMul.{u3, u1} M B' _inst_4 (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) M A' B' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_8 _inst_12 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12))) f (Neg.neg.{u2} A' (NegZeroClass.toNeg.{u2} A' (SubNegZeroMonoid.toNegZeroClass.{u2} A' (SubtractionMonoid.toSubNegZeroMonoid.{u2} A' (AddGroup.toSubtractionMonoid.{u2} A' _inst_7)))) x)) (Neg.neg.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') x) (NegZeroClass.toNeg.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') x) (SubNegZeroMonoid.toNegZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') x) (SubtractionMonoid.toSubNegZeroMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') x) (AddGroup.toSubtractionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') x) _inst_11)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) A' (fun (_x : A') => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) M A' B' (SMulZeroClass.toSMul.{u3, u2} M A' (AddMonoid.toZero.{u2} A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) (DistribSMul.toSMulZeroClass.{u3, u2} M A' (AddMonoid.toAddZeroClass.{u2} A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) (DistribMulAction.toDistribSMul.{u3, u2} M A' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8))) (SMulZeroClass.toSMul.{u3, u1} M B' (AddMonoid.toZero.{u1} B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))) (DistribSMul.toSMulZeroClass.{u3, u1} M B' (AddMonoid.toAddZeroClass.{u1} B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))) (DistribMulAction.toDistribSMul.{u3, u1} M B' _inst_4 (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) M A' B' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_8 _inst_12 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12))) f x))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.map_neg DistribMulActionHom.map_negₓ'. -/
protected theorem map_neg (f : A' →+[M] B') (x : A') : f (-x) = -f x :=
  map_neg _ _
#align distrib_mul_action_hom.map_neg DistribMulActionHom.map_neg

/- warning: distrib_mul_action_hom.map_sub -> DistribMulActionHom.map_sub is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] (A' : Type.{u2}) [_inst_7 : AddGroup.{u2} A'] [_inst_8 : DistribMulAction.{u1, u2} M A' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))] (B' : Type.{u3}) [_inst_11 : AddGroup.{u3} B'] [_inst_12 : DistribMulAction.{u1, u3} M B' _inst_4 (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11))] (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) (x : A') (y : A'), Eq.{succ u3} B' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) => A' -> B') ([anonymous].{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) f (HSub.hSub.{u2, u2, u2} A' A' A' (instHSub.{u2} A' (SubNegMonoid.toHasSub.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) x y)) (HSub.hSub.{u3, u3, u3} B' B' B' (instHSub.{u3} B' (SubNegMonoid.toHasSub.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) => A' -> B') ([anonymous].{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) => A' -> B') ([anonymous].{u1, u2, u3} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u3} B' (AddGroup.toSubNegMonoid.{u3} B' _inst_11)) _inst_12) f y))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] (A' : Type.{u2}) [_inst_7 : AddGroup.{u2} A'] [_inst_8 : DistribMulAction.{u3, u2} M A' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))] (B' : Type.{u1}) [_inst_11 : AddGroup.{u1} B'] [_inst_12 : DistribMulAction.{u3, u1} M B' _inst_4 (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))] (f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) (x : A') (y : A'), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') (HSub.hSub.{u2, u2, u2} A' A' A' (instHSub.{u2} A' (SubNegMonoid.toSub.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) x y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) A' (fun (_x : A') => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) M A' B' (SMulZeroClass.toSMul.{u3, u2} M A' (AddMonoid.toZero.{u2} A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) (DistribSMul.toSMulZeroClass.{u3, u2} M A' (AddMonoid.toAddZeroClass.{u2} A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) (DistribMulAction.toDistribSMul.{u3, u2} M A' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8))) (SMulZeroClass.toSMul.{u3, u1} M B' (AddMonoid.toZero.{u1} B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))) (DistribSMul.toSMulZeroClass.{u3, u1} M B' (AddMonoid.toAddZeroClass.{u1} B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))) (DistribMulAction.toDistribSMul.{u3, u1} M B' _inst_4 (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) M A' B' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_8 _inst_12 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12))) f (HSub.hSub.{u2, u2, u2} A' A' A' (instHSub.{u2} A' (SubNegMonoid.toSub.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) x y)) (HSub.hSub.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') x) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') y) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') x) (instHSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') x) (SubNegMonoid.toSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') x) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') x) _inst_11))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) A' (fun (_x : A') => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) M A' B' (SMulZeroClass.toSMul.{u3, u2} M A' (AddMonoid.toZero.{u2} A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) (DistribSMul.toSMulZeroClass.{u3, u2} M A' (AddMonoid.toAddZeroClass.{u2} A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) (DistribMulAction.toDistribSMul.{u3, u2} M A' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8))) (SMulZeroClass.toSMul.{u3, u1} M B' (AddMonoid.toZero.{u1} B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))) (DistribSMul.toSMulZeroClass.{u3, u1} M B' (AddMonoid.toAddZeroClass.{u1} B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))) (DistribMulAction.toDistribSMul.{u3, u1} M B' _inst_4 (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) M A' B' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_8 _inst_12 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) A' (fun (_x : A') => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A') => B') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) M A' B' (SMulZeroClass.toSMul.{u3, u2} M A' (AddMonoid.toZero.{u2} A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) (DistribSMul.toSMulZeroClass.{u3, u2} M A' (AddMonoid.toAddZeroClass.{u2} A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7))) (DistribMulAction.toDistribSMul.{u3, u2} M A' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8))) (SMulZeroClass.toSMul.{u3, u1} M B' (AddMonoid.toZero.{u1} B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))) (DistribSMul.toSMulZeroClass.{u3, u1} M B' (AddMonoid.toAddZeroClass.{u1} B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11))) (DistribMulAction.toDistribSMul.{u3, u1} M B' _inst_4 (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12) M A' B' _inst_4 (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_8 _inst_12 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A' (SubNegMonoid.toAddMonoid.{u2} A' (AddGroup.toSubNegMonoid.{u2} A' _inst_7)) _inst_8 B' (SubNegMonoid.toAddMonoid.{u1} B' (AddGroup.toSubNegMonoid.{u1} B' _inst_11)) _inst_12))) f y))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.map_sub DistribMulActionHom.map_subₓ'. -/
protected theorem map_sub (f : A' →+[M] B') (x y : A') : f (x - y) = f x - f y :=
  map_sub _ _ _
#align distrib_mul_action_hom.map_sub DistribMulActionHom.map_sub

/- warning: distrib_mul_action_hom.map_smul -> DistribMulActionHom.map_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (m : M) (x : A), Eq.{succ u3} B (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f (SMul.smul.{u1, u2} M A (SMulZeroClass.toHasSmul.{u1, u2} M A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A _inst_5)) (DistribSMul.toSmulZeroClass.{u1, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u2} M A _inst_4 _inst_5 _inst_6))) m x)) (SMul.smul.{u1, u3} M B (SMulZeroClass.toHasSmul.{u1, u3} M B (AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9)) (DistribSMul.toSmulZeroClass.{u1, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u3} M B _inst_4 _inst_9 _inst_10))) m (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f x))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (m : M) (x : A), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) (HSMul.hSMul.{u3, u2, u2} M A A (instHSMul.{u3, u2} M A (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6)))) m x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f (HSMul.hSMul.{u3, u2, u2} M A A (instHSMul.{u3, u2} M A (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6)))) m x)) (HSMul.hSMul.{u3, u1, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) (instHSMul.{u3, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) (SMulZeroClass.toSMul.{u3, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) x) _inst_4 _inst_9 _inst_10)))) m (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u3, u2} M A (AddMonoid.toZero.{u2} A _inst_5) (DistribSMul.toSMulZeroClass.{u3, u2} M A (AddMonoid.toAddZeroClass.{u2} A _inst_5) (DistribMulAction.toDistribSMul.{u3, u2} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u3, u1} M B (AddMonoid.toZero.{u1} B _inst_9) (DistribSMul.toSMulZeroClass.{u3, u1} M B (AddMonoid.toAddZeroClass.{u1} B _inst_9) (DistribMulAction.toDistribSMul.{u3, u1} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f x))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.map_smul DistribMulActionHom.map_smulₓ'. -/
protected theorem map_smul (f : A →+[M] B) (m : M) (x : A) : f (m • x) = m • f x :=
  map_smul _ _ _
#align distrib_mul_action_hom.map_smul DistribMulActionHom.map_smul

variable (M) {A}

#print DistribMulActionHom.id /-
/-- The identity map as an equivariant additive monoid homomorphism. -/
protected def id : A →+[M] A :=
  ⟨id, fun _ _ => rfl, rfl, fun _ _ => rfl⟩
#align distrib_mul_action_hom.id DistribMulActionHom.id
-/

#print DistribMulActionHom.id_apply /-
@[simp]
theorem id_apply (x : A) : DistribMulActionHom.id M x = x :=
  rfl
#align distrib_mul_action_hom.id_apply DistribMulActionHom.id_apply
-/

variable {M A B C}

instance : Zero (A →+[M] B) :=
  ⟨{ (0 : A →+ B) with map_smul' := by simp }⟩

instance : One (A →+[M] A) :=
  ⟨DistribMulActionHom.id M⟩

/- warning: distrib_mul_action_hom.coe_zero -> DistribMulActionHom.coe_zero is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9], Eq.{max (succ u2) (succ u3)} ((fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) (OfNat.ofNat.{max u2 u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) 0 (OfNat.mk.{max u2 u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) 0 (Zero.zero.{max u2 u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (DistribMulActionHom.hasZero.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (OfNat.ofNat.{max u2 u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) 0 (OfNat.mk.{max u2 u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) 0 (Zero.zero.{max u2 u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (DistribMulActionHom.hasZero.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))))) (OfNat.ofNat.{max u2 u3} ((fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) (Zero.zero.{max u2 u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (DistribMulActionHom.hasZero.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) 0 (OfNat.mk.{max u2 u3} ((fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) (Zero.zero.{max u2 u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (DistribMulActionHom.hasZero.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) 0 (Zero.zero.{max u2 u3} ((fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) (Zero.zero.{max u2 u3} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (DistribMulActionHom.hasZero.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) (Pi.instZero.{u2, u3} A (fun (ᾰ : A) => B) (fun (i : A) => AddZeroClass.toHasZero.{u3} B (AddMonoid.toAddZeroClass.{u3} B _inst_9))))))
but is expected to have type
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u3}} [_inst_5 : AddMonoid.{u3} A] [_inst_6 : DistribMulAction.{u1, u3} M A _inst_4 _inst_5] {B : Type.{u2}} [_inst_9 : AddMonoid.{u2} B] [_inst_10 : DistribMulAction.{u1, u2} M B _inst_4 _inst_9], Eq.{max (succ u3) (succ u2)} (forall (a : A), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) a) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (DistribMulActionHom.{u1, u3, u2} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u3 u2, u1, u3, u2} (DistribMulActionHom.{u1, u3, u2} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u1, u3} M A (AddMonoid.toZero.{u3} A _inst_5) (DistribSMul.toSMulZeroClass.{u1, u3} M A (AddMonoid.toAddZeroClass.{u3} A _inst_5) (DistribMulAction.toDistribSMul.{u1, u3} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u1, u2} M B (AddMonoid.toZero.{u2} B _inst_9) (DistribSMul.toSMulZeroClass.{u1, u2} M B (AddMonoid.toAddZeroClass.{u2} B _inst_9) (DistribMulAction.toDistribSMul.{u1, u2} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u3 u2, u1, u3, u2} (DistribMulActionHom.{u1, u3, u2} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u1, u3, u2} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) (OfNat.ofNat.{max u3 u2} (DistribMulActionHom.{u1, u3, u2} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) 0 (Zero.toOfNat0.{max u3 u2} (DistribMulActionHom.{u1, u3, u2} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (DistribMulActionHom.instZeroDistribMulActionHom.{u1, u3, u2} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10)))) (OfNat.ofNat.{max u3 u2} (forall (a : A), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) a) 0 (Zero.toOfNat0.{max u3 u2} (forall (a : A), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) a) (Pi.instZero.{u3, u2} A (fun (a : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) a) (fun (i : A) => AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) i) _inst_9))))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.coe_zero DistribMulActionHom.coe_zeroₓ'. -/
@[simp]
theorem coe_zero : ((0 : A →+[M] B) : A → B) = 0 :=
  rfl
#align distrib_mul_action_hom.coe_zero DistribMulActionHom.coe_zero

#print DistribMulActionHom.coe_one /-
@[simp]
theorem coe_one : ((1 : A →+[M] A) : A → A) = id :=
  rfl
#align distrib_mul_action_hom.coe_one DistribMulActionHom.coe_one
-/

#print DistribMulActionHom.zero_apply /-
theorem zero_apply (a : A) : (0 : A →+[M] B) a = 0 :=
  rfl
#align distrib_mul_action_hom.zero_apply DistribMulActionHom.zero_apply
-/

#print DistribMulActionHom.one_apply /-
theorem one_apply (a : A) : (1 : A →+[M] A) a = a :=
  rfl
#align distrib_mul_action_hom.one_apply DistribMulActionHom.one_apply
-/

instance : Inhabited (A →+[M] B) :=
  ⟨0⟩

#print DistribMulActionHom.comp /-
/-- Composition of two equivariant additive monoid homomorphisms. -/
def comp (g : B →+[M] C) (f : A →+[M] B) : A →+[M] C :=
  { MulActionHom.comp (g : B →[M] C) (f : A →[M] B),
    AddMonoidHom.comp (g : B →+ C) (f : A →+ B) with }
#align distrib_mul_action_hom.comp DistribMulActionHom.comp
-/

/- warning: distrib_mul_action_hom.comp_apply -> DistribMulActionHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] {C : Type.{u4}} [_inst_13 : AddMonoid.{u4} C] [_inst_14 : DistribMulAction.{u1, u4} M C _inst_4 _inst_13] (g : DistribMulActionHom.{u1, u3, u4} M _inst_4 B _inst_9 _inst_10 C _inst_13 _inst_14) (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (x : A), Eq.{succ u4} C (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (DistribMulActionHom.{u1, u2, u4} M _inst_4 A _inst_5 _inst_6 C _inst_13 _inst_14) (fun (_x : DistribMulActionHom.{u1, u2, u4} M _inst_4 A _inst_5 _inst_6 C _inst_13 _inst_14) => A -> C) ([anonymous].{u1, u2, u4} M _inst_4 A _inst_5 _inst_6 C _inst_13 _inst_14) (DistribMulActionHom.comp.{u1, u2, u3, u4} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10 C _inst_13 _inst_14 g f) x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (DistribMulActionHom.{u1, u3, u4} M _inst_4 B _inst_9 _inst_10 C _inst_13 _inst_14) (fun (_x : DistribMulActionHom.{u1, u3, u4} M _inst_4 B _inst_9 _inst_10 C _inst_13 _inst_14) => B -> C) ([anonymous].{u1, u3, u4} M _inst_4 B _inst_9 _inst_10 C _inst_13 _inst_14) g (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) => A -> B) ([anonymous].{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) f x))
but is expected to have type
  forall {M : Type.{u4}} [_inst_4 : Monoid.{u4} M] {A : Type.{u1}} [_inst_5 : AddMonoid.{u1} A] [_inst_6 : DistribMulAction.{u4, u1} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u4, u3} M B _inst_4 _inst_9] {C : Type.{u2}} [_inst_13 : AddMonoid.{u2} C] [_inst_14 : DistribMulAction.{u4, u2} M C _inst_4 _inst_13] (g : DistribMulActionHom.{u4, u3, u2} M _inst_4 B _inst_9 _inst_10 C _inst_13 _inst_14) (f : DistribMulActionHom.{u4, u1, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (x : A), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => C) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (DistribMulActionHom.{u4, u1, u2} M _inst_4 A _inst_5 _inst_6 C _inst_13 _inst_14) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => C) _x) (SMulHomClass.toFunLike.{max u1 u2, u4, u1, u2} (DistribMulActionHom.{u4, u1, u2} M _inst_4 A _inst_5 _inst_6 C _inst_13 _inst_14) M A C (SMulZeroClass.toSMul.{u4, u1} M A (AddMonoid.toZero.{u1} A _inst_5) (DistribSMul.toSMulZeroClass.{u4, u1} M A (AddMonoid.toAddZeroClass.{u1} A _inst_5) (DistribMulAction.toDistribSMul.{u4, u1} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u4, u2} M C (AddMonoid.toZero.{u2} C _inst_13) (DistribSMul.toSMulZeroClass.{u4, u2} M C (AddMonoid.toAddZeroClass.{u2} C _inst_13) (DistribMulAction.toDistribSMul.{u4, u2} M C _inst_4 _inst_13 _inst_14))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u2, u4, u1, u2} (DistribMulActionHom.{u4, u1, u2} M _inst_4 A _inst_5 _inst_6 C _inst_13 _inst_14) M A C _inst_4 _inst_5 _inst_13 _inst_6 _inst_14 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u4, u1, u2} M _inst_4 A _inst_5 _inst_6 C _inst_13 _inst_14))) (DistribMulActionHom.comp.{u4, u1, u3, u2} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10 C _inst_13 _inst_14 g f) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (DistribMulActionHom.{u4, u3, u2} M _inst_4 B _inst_9 _inst_10 C _inst_13 _inst_14) B (fun (_x : B) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : B) => C) _x) (SMulHomClass.toFunLike.{max u3 u2, u4, u3, u2} (DistribMulActionHom.{u4, u3, u2} M _inst_4 B _inst_9 _inst_10 C _inst_13 _inst_14) M B C (SMulZeroClass.toSMul.{u4, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u4, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u4, u3} M B _inst_4 _inst_9 _inst_10))) (SMulZeroClass.toSMul.{u4, u2} M C (AddMonoid.toZero.{u2} C _inst_13) (DistribSMul.toSMulZeroClass.{u4, u2} M C (AddMonoid.toAddZeroClass.{u2} C _inst_13) (DistribMulAction.toDistribSMul.{u4, u2} M C _inst_4 _inst_13 _inst_14))) (DistribMulActionHomClass.toSMulHomClass.{max u3 u2, u4, u3, u2} (DistribMulActionHom.{u4, u3, u2} M _inst_4 B _inst_9 _inst_10 C _inst_13 _inst_14) M B C _inst_4 _inst_9 _inst_13 _inst_10 _inst_14 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u4, u3, u2} M _inst_4 B _inst_9 _inst_10 C _inst_13 _inst_14))) g (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (DistribMulActionHom.{u4, u1, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : A) => B) _x) (SMulHomClass.toFunLike.{max u1 u3, u4, u1, u3} (DistribMulActionHom.{u4, u1, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B (SMulZeroClass.toSMul.{u4, u1} M A (AddMonoid.toZero.{u1} A _inst_5) (DistribSMul.toSMulZeroClass.{u4, u1} M A (AddMonoid.toAddZeroClass.{u1} A _inst_5) (DistribMulAction.toDistribSMul.{u4, u1} M A _inst_4 _inst_5 _inst_6))) (SMulZeroClass.toSMul.{u4, u3} M B (AddMonoid.toZero.{u3} B _inst_9) (DistribSMul.toSMulZeroClass.{u4, u3} M B (AddMonoid.toAddZeroClass.{u3} B _inst_9) (DistribMulAction.toDistribSMul.{u4, u3} M B _inst_4 _inst_9 _inst_10))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u3, u4, u1, u3} (DistribMulActionHom.{u4, u1, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) M A B _inst_4 _inst_5 _inst_9 _inst_6 _inst_10 (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u4, u1, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10))) f x))
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.comp_apply DistribMulActionHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (g : B →+[M] C) (f : A →+[M] B) (x : A) : g.comp f x = g (f x) :=
  rfl
#align distrib_mul_action_hom.comp_apply DistribMulActionHom.comp_apply

/- warning: distrib_mul_action_hom.id_comp -> DistribMulActionHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (DistribMulActionHom.comp.{u1, u2, u3, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10 B _inst_9 _inst_10 (DistribMulActionHom.id.{u1, u3} M _inst_4 B _inst_9 _inst_10) f) f
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{max (succ u2) (succ u1)} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (DistribMulActionHom.comp.{u3, u2, u1, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10 B _inst_9 _inst_10 (DistribMulActionHom.id.{u3, u1} M _inst_4 B _inst_9 _inst_10) f) f
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.id_comp DistribMulActionHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : A →+[M] B) : (DistribMulActionHom.id M).comp f = f :=
  ext fun x => by rw [comp_apply, id_apply]
#align distrib_mul_action_hom.id_comp DistribMulActionHom.id_comp

/- warning: distrib_mul_action_hom.comp_id -> DistribMulActionHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u1, u2} M A _inst_4 _inst_5] {B : Type.{u3}} [_inst_9 : AddMonoid.{u3} B] [_inst_10 : DistribMulAction.{u1, u3} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (DistribMulActionHom.comp.{u1, u2, u2, u3} M _inst_4 A _inst_5 _inst_6 A _inst_5 _inst_6 B _inst_9 _inst_10 f (DistribMulActionHom.id.{u1, u2} M _inst_4 A _inst_5 _inst_6)) f
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {A : Type.{u2}} [_inst_5 : AddMonoid.{u2} A] [_inst_6 : DistribMulAction.{u3, u2} M A _inst_4 _inst_5] {B : Type.{u1}} [_inst_9 : AddMonoid.{u1} B] [_inst_10 : DistribMulAction.{u3, u1} M B _inst_4 _inst_9] (f : DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10), Eq.{max (succ u2) (succ u1)} (DistribMulActionHom.{u3, u2, u1} M _inst_4 A _inst_5 _inst_6 B _inst_9 _inst_10) (DistribMulActionHom.comp.{u3, u2, u2, u1} M _inst_4 A _inst_5 _inst_6 A _inst_5 _inst_6 B _inst_9 _inst_10 f (DistribMulActionHom.id.{u3, u2} M _inst_4 A _inst_5 _inst_6)) f
Case conversion may be inaccurate. Consider using '#align distrib_mul_action_hom.comp_id DistribMulActionHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : A →+[M] B) : f.comp (DistribMulActionHom.id M) = f :=
  ext fun x => by rw [comp_apply, id_apply]
#align distrib_mul_action_hom.comp_id DistribMulActionHom.comp_id

#print DistribMulActionHom.inverse /-
/-- The inverse of a bijective `distrib_mul_action_hom` is a `distrib_mul_action_hom`. -/
@[simps]
def inverse (f : A →+[M] B) (g : B → A) (h₁ : Function.LeftInverse g f)
    (h₂ : Function.RightInverse g f) : B →+[M] A :=
  { (f : A →+ B).inverse g h₁ h₂, (f : A →[M] B).inverse g h₁ h₂ with toFun := g }
#align distrib_mul_action_hom.inverse DistribMulActionHom.inverse
-/

section Semiring

variable {R M'} [AddMonoid M'] [DistribMulAction R M']

#print DistribMulActionHom.ext_ring /-
@[ext]
theorem ext_ring {f g : R →+[R] M'} (h : f 1 = g 1) : f = g :=
  by
  ext x
  rw [← mul_one x, ← smul_eq_mul R, f.map_smul, g.map_smul, h]
#align distrib_mul_action_hom.ext_ring DistribMulActionHom.ext_ring
-/

#print DistribMulActionHom.ext_ring_iff /-
theorem ext_ring_iff {f g : R →+[R] M'} : f = g ↔ f 1 = g 1 :=
  ⟨fun h => h ▸ rfl, ext_ring⟩
#align distrib_mul_action_hom.ext_ring_iff DistribMulActionHom.ext_ring_iff
-/

end Semiring

end DistribMulActionHom

#print MulSemiringActionHom /-
/-- Equivariant ring homomorphisms. -/
@[nolint has_nonempty_instance]
structure MulSemiringActionHom extends R →+[M] S, R →+* S
#align mul_semiring_action_hom MulSemiringActionHom
-/

/-- Reinterpret an equivariant ring homomorphism as a ring homomorphism. -/
add_decl_doc MulSemiringActionHom.toRingHom

/-- Reinterpret an equivariant ring homomorphism as an equivariant additive monoid homomorphism. -/
add_decl_doc MulSemiringActionHom.toDistribMulActionHom

-- mathport name: «expr →+*[ ] »
notation:25 R " →+*[" M:25 "] " S:0 => MulSemiringActionHom M R S

#print MulSemiringActionHomClass /-
/-- `mul_semiring_action_hom_class F M R S` states that `F` is a type of morphisms preserving
the ring structure and scalar multiplication by `M`.

You should extend this class when you extend `mul_semiring_action_hom`. -/
class MulSemiringActionHomClass (F : Type _) (M R S : outParam <| Type _) [Monoid M] [Semiring R]
  [Semiring S] [DistribMulAction M R] [DistribMulAction M S] extends
  DistribMulActionHomClass F M R S, RingHomClass F R S
#align mul_semiring_action_hom_class MulSemiringActionHomClass
-/

-- `M` becomes a metavariable but it's an `out_param` so it's not a problem.
attribute [nolint dangerous_instance] MulSemiringActionHomClass.toRingHomClass

namespace MulSemiringActionHom

/- warning: mul_semiring_action_hom.has_coe clashes with [anonymous] -> [anonymous]
warning: mul_semiring_action_hom.has_coe -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u_5}) [_inst_4 : Monoid.{u_5} M] (R : Type.{u_11}) [_inst_15 : Semiring.{u_11} R] [_inst_16 : MulSemiringAction.{u_5, u_11} M R _inst_4 _inst_15] (S : Type.{u_13}) [_inst_19 : Semiring.{u_13} S] [_inst_20 : MulSemiringAction.{u_5, u_13} M S _inst_4 _inst_19], Coe.{max (succ u_11) (succ u_13), max (succ u_11) (succ u_13)} (MulSemiringActionHom.{u_5, u_11, u_13} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (RingHom.{u_11, u_13} R S (Semiring.toNonAssocSemiring.{u_11} R _inst_15) (Semiring.toNonAssocSemiring.{u_13} S _inst_19))
but is expected to have type
  forall {M : Type.{u}} {_inst_4 : Type.{v}}, (Nat -> M -> _inst_4) -> Nat -> (List.{u} M) -> (List.{v} _inst_4)
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.has_coe [anonymous]ₓ'. -/
instance [anonymous] : Coe (R →+*[M] S) (R →+* S) :=
  ⟨toRingHom⟩
#align mul_semiring_action_hom.has_coe [anonymous]

/- warning: mul_semiring_action_hom.has_coe' clashes with [anonymous] -> [anonymous]
warning: mul_semiring_action_hom.has_coe' -> [anonymous] is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u_5}) [_inst_4 : Monoid.{u_5} M] (R : Type.{u_11}) [_inst_15 : Semiring.{u_11} R] [_inst_16 : MulSemiringAction.{u_5, u_11} M R _inst_4 _inst_15] (S : Type.{u_13}) [_inst_19 : Semiring.{u_13} S] [_inst_20 : MulSemiringAction.{u_5, u_13} M S _inst_4 _inst_19], Coe.{max (succ u_11) (succ u_13), max (succ u_11) (succ u_13)} (MulSemiringActionHom.{u_5, u_11, u_13} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (DistribMulActionHom.{u_5, u_11, u_13} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u_11} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u_11} R (NonAssocSemiring.toAddCommMonoidWithOne.{u_11} R (Semiring.toNonAssocSemiring.{u_11} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u_5, u_11} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u_13} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u_13} S (NonAssocSemiring.toAddCommMonoidWithOne.{u_13} S (Semiring.toNonAssocSemiring.{u_13} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u_5, u_13} M S _inst_4 _inst_19 _inst_20))
but is expected to have type
  forall {M : Type.{u}} {_inst_4 : Type.{v}}, (Nat -> M -> _inst_4) -> Nat -> (List.{u} M) -> (List.{v} _inst_4)
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.has_coe' [anonymous]ₓ'. -/
instance [anonymous] : Coe (R →+*[M] S) (R →+[M] S) :=
  ⟨toDistribMulActionHom⟩
#align mul_semiring_action_hom.has_coe' [anonymous]

instance : CoeFun (R →+*[M] S) fun _ => R → S :=
  ⟨fun c => c.toFun⟩

instance : MulSemiringActionHomClass (R →+*[M] S) M R S
    where
  coe := MulSemiringActionHom.toFun
  coe_injective' f g h := by cases f <;> cases g <;> congr
  map_smul := MulSemiringActionHom.map_smul'
  map_zero := MulSemiringActionHom.map_zero'
  map_add := MulSemiringActionHom.map_add'
  map_one := MulSemiringActionHom.map_one'
  map_mul := MulSemiringActionHom.map_mul'

variable {M R S}

/- warning: mul_semiring_action_hom.coe_fn_coe -> MulSemiringActionHom.coe_fn_coe is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{max (succ u2) (succ u3)} ((fun (_x : RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19)) => R -> S) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19)) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19)) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19)) (RingHom.hasCoeT.{max u2 u3, u2, u3} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19) (MulSemiringActionHomClass.toRingHomClass.{max u2 u3, u1, u2, u3} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.mulSemiringActionHomClass.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20))))) f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19)) (fun (_x : RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19)) => R -> S) (RingHom.hasCoeToFun.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19)) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19)) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (RingHom.{u2, u3} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19)) (RingHom.hasCoeT.{max u2 u3, u2, u3} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u3} S _inst_19) (MulSemiringActionHomClass.toRingHomClass.{max u2 u3, u1, u2, u3} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.mulSemiringActionHomClass.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20))))) f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f)
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{max (succ u2) (succ u1)} (forall (a : R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u1} S _inst_19)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2528 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u1} S _inst_19)) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))) (NonUnitalNonAssocSemiring.toMul.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u1} S _inst_19)) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u1} S _inst_19)) R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u1} S _inst_19) (RingHom.instRingHomClassRingHom.{u2, u1} R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (RingHomClass.toRingHom.{max u2 u1, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R S (Semiring.toNonAssocSemiring.{u2} R _inst_15) (Semiring.toNonAssocSemiring.{u1} S _inst_19) (MulSemiringActionHomClass.toRingHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f)
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.coe_fn_coe MulSemiringActionHom.coe_fn_coeₓ'. -/
@[norm_cast]
theorem coe_fn_coe (f : R →+*[M] S) : ((f : R →+* S) : R → S) = f :=
  rfl
#align mul_semiring_action_hom.coe_fn_coe MulSemiringActionHom.coe_fn_coe

/- warning: mul_semiring_action_hom.coe_fn_coe' -> MulSemiringActionHom.coe_fn_coe' is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{max (succ u2) (succ u3)} ((fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) => R -> S) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) (fun (_x : DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (DistribMulActionHom.{u1, u2, u3} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f)
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{max (succ u2) (succ u1)} (forall (a : R), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (DistribMulActionHom.{u3, u2, u1} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (DistribMulActionHom.instDistribMulActionHomClassDistribMulActionHom.{u3, u2, u1} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toDistribMulActionHom.{u3, u2, u1, max u2 u1} M _inst_4 R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)) f)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f)
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.coe_fn_coe' MulSemiringActionHom.coe_fn_coe'ₓ'. -/
@[norm_cast]
theorem coe_fn_coe' (f : R →+*[M] S) : ((f : R →+[M] S) : R → S) = f :=
  rfl
#align mul_semiring_action_hom.coe_fn_coe' MulSemiringActionHom.coe_fn_coe'

/- warning: mul_semiring_action_hom.ext -> MulSemiringActionHom.ext is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] {f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20} {g : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20}, (forall (x : R), Eq.{succ u3} S (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) g x)) -> (Eq.{max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f g)
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] {f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20} {g : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20}, (forall (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) g x)) -> (Eq.{max (succ u2) (succ u1)} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f g)
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.ext MulSemiringActionHom.extₓ'. -/
@[ext]
theorem ext : ∀ {f g : R →+*[M] S}, (∀ x, f x = g x) → f = g :=
  FunLike.ext
#align mul_semiring_action_hom.ext MulSemiringActionHom.ext

/- warning: mul_semiring_action_hom.ext_iff -> MulSemiringActionHom.ext_iff is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] {f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20} {g : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20}, Iff (Eq.{max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f g) (forall (x : R), Eq.{succ u3} S (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) g x))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] {f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20} {g : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20}, Iff (Eq.{max (succ u2) (succ u1)} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f g) (forall (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) g x))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.ext_iff MulSemiringActionHom.ext_iffₓ'. -/
theorem ext_iff {f g : R →+*[M] S} : f = g ↔ ∀ x, f x = g x :=
  FunLike.ext_iff
#align mul_semiring_action_hom.ext_iff MulSemiringActionHom.ext_iff

/- warning: mul_semiring_action_hom.map_zero -> MulSemiringActionHom.map_zero is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{succ u3} S (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f (OfNat.ofNat.{u2} R 0 (OfNat.mk.{u2} R 0 (Zero.zero.{u2} R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))))))) (OfNat.ofNat.{u3} S 0 (OfNat.mk.{u3} S 0 (Zero.zero.{u3} S (MulZeroClass.toHasZero.{u3} S (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))))))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_15))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_15))))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_15))))) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_15))))) (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_15))))) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_15))))) _inst_19))))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.map_zero MulSemiringActionHom.map_zeroₓ'. -/
protected theorem map_zero (f : R →+*[M] S) : f 0 = 0 :=
  map_zero _
#align mul_semiring_action_hom.map_zero MulSemiringActionHom.map_zero

/- warning: mul_semiring_action_hom.map_add -> MulSemiringActionHom.map_add is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (x : R) (y : R), Eq.{succ u3} S (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toHasAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) x y)) (HAdd.hAdd.{u3, u3, u3} S S S (instHAdd.{u3} S (Distrib.toHasAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f y))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (x : R) (y : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) x y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) x y)) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) y) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (Distrib.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (NonUnitalNonAssocSemiring.toDistrib.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) _inst_19))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f y))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.map_add MulSemiringActionHom.map_addₓ'. -/
protected theorem map_add (f : R →+*[M] S) (x y : R) : f (x + y) = f x + f y :=
  map_add _ _ _
#align mul_semiring_action_hom.map_add MulSemiringActionHom.map_add

/- warning: mul_semiring_action_hom.map_neg -> MulSemiringActionHom.map_neg is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] (R' : Type.{u2}) [_inst_17 : Ring.{u2} R'] [_inst_18 : MulSemiringAction.{u1, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17)] (S' : Type.{u3}) [_inst_21 : Ring.{u3} S'] [_inst_22 : MulSemiringAction.{u1, u3} M S' _inst_4 (Ring.toSemiring.{u3} S' _inst_21)] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) (x : R'), Eq.{succ u3} S' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) => R' -> S') ([anonymous].{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) f (Neg.neg.{u2} R' (SubNegMonoid.toHasNeg.{u2} R' (AddGroup.toSubNegMonoid.{u2} R' (AddGroupWithOne.toAddGroup.{u2} R' (NonAssocRing.toAddGroupWithOne.{u2} R' (Ring.toNonAssocRing.{u2} R' _inst_17))))) x)) (Neg.neg.{u3} S' (SubNegMonoid.toHasNeg.{u3} S' (AddGroup.toSubNegMonoid.{u3} S' (AddGroupWithOne.toAddGroup.{u3} S' (NonAssocRing.toAddGroupWithOne.{u3} S' (Ring.toNonAssocRing.{u3} S' _inst_21))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) => R' -> S') ([anonymous].{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) f x))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] (R' : Type.{u2}) [_inst_17 : Ring.{u2} R'] [_inst_18 : MulSemiringAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17)] (S' : Type.{u1}) [_inst_21 : Ring.{u1} S'] [_inst_22 : MulSemiringAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21)] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (x : R'), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') (Neg.neg.{u2} R' (Ring.toNeg.{u2} R' _inst_17) x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) R' (fun (_x : R') => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' (SMulZeroClass.toSMul.{u3, u2} M R' (AddMonoid.toZero.{u2} R' (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17)))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R' (AddMonoid.toAddZeroClass.{u2} R' (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17)))))) (DistribMulAction.toDistribSMul.{u3, u2} M R' _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18)))) (SMulZeroClass.toSMul.{u3, u1} M S' (AddMonoid.toZero.{u1} S' (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21)))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S' (AddMonoid.toAddZeroClass.{u1} S' (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21)))))) (DistribMulAction.toDistribSMul.{u3, u1} M S' _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21))))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17))))) (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) (Ring.toSemiring.{u1} S' _inst_21) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22)))) f (Neg.neg.{u2} R' (Ring.toNeg.{u2} R' _inst_17) x)) (Neg.neg.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') x) (Ring.toNeg.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') x) _inst_21) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) R' (fun (_x : R') => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' (SMulZeroClass.toSMul.{u3, u2} M R' (AddMonoid.toZero.{u2} R' (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17)))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R' (AddMonoid.toAddZeroClass.{u2} R' (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17)))))) (DistribMulAction.toDistribSMul.{u3, u2} M R' _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18)))) (SMulZeroClass.toSMul.{u3, u1} M S' (AddMonoid.toZero.{u1} S' (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21)))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S' (AddMonoid.toAddZeroClass.{u1} S' (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21)))))) (DistribMulAction.toDistribSMul.{u3, u1} M S' _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21))))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17))))) (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) (Ring.toSemiring.{u1} S' _inst_21) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22)))) f x))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.map_neg MulSemiringActionHom.map_negₓ'. -/
protected theorem map_neg (f : R' →+*[M] S') (x : R') : f (-x) = -f x :=
  map_neg _ _
#align mul_semiring_action_hom.map_neg MulSemiringActionHom.map_neg

/- warning: mul_semiring_action_hom.map_sub -> MulSemiringActionHom.map_sub is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] (R' : Type.{u2}) [_inst_17 : Ring.{u2} R'] [_inst_18 : MulSemiringAction.{u1, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17)] (S' : Type.{u3}) [_inst_21 : Ring.{u3} S'] [_inst_22 : MulSemiringAction.{u1, u3} M S' _inst_4 (Ring.toSemiring.{u3} S' _inst_21)] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) (x : R') (y : R'), Eq.{succ u3} S' (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) => R' -> S') ([anonymous].{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) f (HSub.hSub.{u2, u2, u2} R' R' R' (instHSub.{u2} R' (SubNegMonoid.toHasSub.{u2} R' (AddGroup.toSubNegMonoid.{u2} R' (AddGroupWithOne.toAddGroup.{u2} R' (NonAssocRing.toAddGroupWithOne.{u2} R' (Ring.toNonAssocRing.{u2} R' _inst_17)))))) x y)) (HSub.hSub.{u3, u3, u3} S' S' S' (instHSub.{u3} S' (SubNegMonoid.toHasSub.{u3} S' (AddGroup.toSubNegMonoid.{u3} S' (AddGroupWithOne.toAddGroup.{u3} S' (NonAssocRing.toAddGroupWithOne.{u3} S' (Ring.toNonAssocRing.{u3} S' _inst_21)))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) => R' -> S') ([anonymous].{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) => R' -> S') ([anonymous].{u1, u2, u3} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u3} S' _inst_21) _inst_22) f y))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] (R' : Type.{u2}) [_inst_17 : Ring.{u2} R'] [_inst_18 : MulSemiringAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17)] (S' : Type.{u1}) [_inst_21 : Ring.{u1} S'] [_inst_22 : MulSemiringAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21)] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (x : R') (y : R'), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') (HSub.hSub.{u2, u2, u2} R' R' R' (instHSub.{u2} R' (Ring.toSub.{u2} R' _inst_17)) x y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) R' (fun (_x : R') => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' (SMulZeroClass.toSMul.{u3, u2} M R' (AddMonoid.toZero.{u2} R' (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17)))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R' (AddMonoid.toAddZeroClass.{u2} R' (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17)))))) (DistribMulAction.toDistribSMul.{u3, u2} M R' _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18)))) (SMulZeroClass.toSMul.{u3, u1} M S' (AddMonoid.toZero.{u1} S' (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21)))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S' (AddMonoid.toAddZeroClass.{u1} S' (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21)))))) (DistribMulAction.toDistribSMul.{u3, u1} M S' _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21))))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17))))) (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) (Ring.toSemiring.{u1} S' _inst_21) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22)))) f (HSub.hSub.{u2, u2, u2} R' R' R' (instHSub.{u2} R' (Ring.toSub.{u2} R' _inst_17)) x y)) (HSub.hSub.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') x) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') y) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') x) (instHSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') x) (Ring.toSub.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') x) _inst_21)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) R' (fun (_x : R') => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' (SMulZeroClass.toSMul.{u3, u2} M R' (AddMonoid.toZero.{u2} R' (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17)))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R' (AddMonoid.toAddZeroClass.{u2} R' (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17)))))) (DistribMulAction.toDistribSMul.{u3, u2} M R' _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18)))) (SMulZeroClass.toSMul.{u3, u1} M S' (AddMonoid.toZero.{u1} S' (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21)))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S' (AddMonoid.toAddZeroClass.{u1} S' (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21)))))) (DistribMulAction.toDistribSMul.{u3, u1} M S' _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21))))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17))))) (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) (Ring.toSemiring.{u1} S' _inst_21) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22)))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) R' (fun (_x : R') => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R') => S') _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' (SMulZeroClass.toSMul.{u3, u2} M R' (AddMonoid.toZero.{u2} R' (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17)))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R' (AddMonoid.toAddZeroClass.{u2} R' (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17)))))) (DistribMulAction.toDistribSMul.{u3, u2} M R' _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18)))) (SMulZeroClass.toSMul.{u3, u1} M S' (AddMonoid.toZero.{u1} S' (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21)))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S' (AddMonoid.toAddZeroClass.{u1} S' (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21)))))) (DistribMulAction.toDistribSMul.{u3, u1} M S' _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21))))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R' (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R' (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R' (Semiring.toNonAssocSemiring.{u2} R' (Ring.toSemiring.{u2} R' _inst_17))))) (AddMonoidWithOne.toAddMonoid.{u1} S' (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S' (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S' (Semiring.toNonAssocSemiring.{u1} S' (Ring.toSemiring.{u1} S' _inst_21))))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22) M R' S' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) (Ring.toSemiring.{u1} S' _inst_21) (MulSemiringAction.toDistribMulAction.{u3, u2} M R' _inst_4 (Ring.toSemiring.{u2} R' _inst_17) _inst_18) (MulSemiringAction.toDistribMulAction.{u3, u1} M S' _inst_4 (Ring.toSemiring.{u1} S' _inst_21) _inst_22) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R' (Ring.toSemiring.{u2} R' _inst_17) _inst_18 S' (Ring.toSemiring.{u1} S' _inst_21) _inst_22)))) f y))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.map_sub MulSemiringActionHom.map_subₓ'. -/
protected theorem map_sub (f : R' →+*[M] S') (x y : R') : f (x - y) = f x - f y :=
  map_sub _ _ _
#align mul_semiring_action_hom.map_sub MulSemiringActionHom.map_sub

/- warning: mul_semiring_action_hom.map_one -> MulSemiringActionHom.map_one is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{succ u3} S (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))))))) (OfNat.ofNat.{u3} S 1 (OfNat.mk.{u3} S 1 (One.one.{u3} S (AddMonoidWithOne.toOne.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))))))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_15)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_15)))) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_15)))) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_15)))) (Semiring.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_15)))) _inst_19)))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.map_one MulSemiringActionHom.map_oneₓ'. -/
protected theorem map_one (f : R →+*[M] S) : f 1 = 1 :=
  map_one _
#align mul_semiring_action_hom.map_one MulSemiringActionHom.map_one

/- warning: mul_semiring_action_hom.map_mul -> MulSemiringActionHom.map_mul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (x : R) (y : R), Eq.{succ u3} S (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (Distrib.toHasMul.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) x y)) (HMul.hMul.{u3, u3, u3} S S S (instHMul.{u3} S (Distrib.toHasMul.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f y))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (x : R) (y : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) x y)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) x y)) (HMul.hMul.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) y) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (instHMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (NonUnitalNonAssocSemiring.toMul.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) _inst_19)))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f y))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.map_mul MulSemiringActionHom.map_mulₓ'. -/
protected theorem map_mul (f : R →+*[M] S) (x y : R) : f (x * y) = f x * f y :=
  map_mul _ _ _
#align mul_semiring_action_hom.map_mul MulSemiringActionHom.map_mul

/- warning: mul_semiring_action_hom.map_smul -> MulSemiringActionHom.map_smul is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (m : M) (x : R), Eq.{succ u3} S (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f (SMul.smul.{u1, u2} M R (SMulZeroClass.toHasSmul.{u1, u2} M R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))))) (DistribSMul.toSmulZeroClass.{u1, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u1, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u1, u2} M R _inst_4 _inst_15 _inst_16)))) m x)) (SMul.smul.{u1, u3} M S (SMulZeroClass.toHasSmul.{u1, u3} M S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))))) (DistribSMul.toSmulZeroClass.{u1, u3} M S (AddMonoid.toAddZeroClass.{u3} S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19))))) (DistribMulAction.toDistribSMul.{u1, u3} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u1, u3} M S _inst_4 _inst_19 _inst_20)))) m (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f x))
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (m : M) (x : R), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) (HSMul.hSMul.{u3, u2, u2} M R R (instHSMul.{u3, u2} M R (SMulZeroClass.toSMul.{u3, u2} M R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_15)) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16))))) m x)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f (HSMul.hSMul.{u3, u2, u2} M R R (instHSMul.{u3, u2} M R (SMulZeroClass.toSMul.{u3, u2} M R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_15)) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16))))) m x)) (HSMul.hSMul.{u3, u1, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (instHSMul.{u3, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (SMulZeroClass.toSMul.{u3, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) _inst_19)) (DistribSMul.toSMulZeroClass.{u3, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (AddMonoidWithOne.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) x) _inst_4 _inst_19 _inst_20))))) m (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u3, u2} M R (AddMonoid.toZero.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u3, u2} M R (AddMonoid.toAddZeroClass.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15))))) (DistribMulAction.toDistribSMul.{u3, u2} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u3, u1} M S (AddMonoid.toZero.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u3, u1} M S (AddMonoid.toAddZeroClass.{u1} S (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19))))) (DistribMulAction.toDistribSMul.{u3, u1} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u1} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} S (NonAssocSemiring.toAddCommMonoidWithOne.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u2 u1, u3, u2, u1} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u3, u2} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u3, u1} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f x))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.map_smul MulSemiringActionHom.map_smulₓ'. -/
protected theorem map_smul (f : R →+*[M] S) (m : M) (x : R) : f (m • x) = m • f x :=
  map_smul _ _ _
#align mul_semiring_action_hom.map_smul MulSemiringActionHom.map_smul

variable (M) {R}

#print MulSemiringActionHom.id /-
/-- The identity map as an equivariant ring homomorphism. -/
protected def id : R →+*[M] R :=
  ⟨id, fun _ _ => rfl, rfl, fun _ _ => rfl, rfl, fun _ _ => rfl⟩
#align mul_semiring_action_hom.id MulSemiringActionHom.id
-/

#print MulSemiringActionHom.id_apply /-
@[simp]
theorem id_apply (x : R) : MulSemiringActionHom.id M x = x :=
  rfl
#align mul_semiring_action_hom.id_apply MulSemiringActionHom.id_apply
-/

variable {M R S T}

#print MulSemiringActionHom.comp /-
/-- Composition of two equivariant additive monoid homomorphisms. -/
def comp (g : S →+*[M] T) (f : R →+*[M] S) : R →+*[M] T :=
  { DistribMulActionHom.comp (g : S →+[M] T) (f : R →+[M] S),
    RingHom.comp (g : S →+* T) (f : R →+* S) with }
#align mul_semiring_action_hom.comp MulSemiringActionHom.comp
-/

/- warning: mul_semiring_action_hom.comp_apply -> MulSemiringActionHom.comp_apply is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] {T : Type.{u4}} [_inst_23 : Semiring.{u4} T] [_inst_24 : MulSemiringAction.{u1, u4} M T _inst_4 _inst_23] (g : MulSemiringActionHom.{u1, u3, u4} M _inst_4 S _inst_19 _inst_20 T _inst_23 _inst_24) (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (x : R), Eq.{succ u4} T (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (MulSemiringActionHom.{u1, u2, u4} M _inst_4 R _inst_15 _inst_16 T _inst_23 _inst_24) (fun (_x : MulSemiringActionHom.{u1, u2, u4} M _inst_4 R _inst_15 _inst_16 T _inst_23 _inst_24) => R -> T) ([anonymous].{u1, u2, u4} M _inst_4 R _inst_15 _inst_16 T _inst_23 _inst_24) (MulSemiringActionHom.comp.{u1, u2, u3, u4} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20 T _inst_23 _inst_24 g f) x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (MulSemiringActionHom.{u1, u3, u4} M _inst_4 S _inst_19 _inst_20 T _inst_23 _inst_24) (fun (_x : MulSemiringActionHom.{u1, u3, u4} M _inst_4 S _inst_19 _inst_20 T _inst_23 _inst_24) => S -> T) ([anonymous].{u1, u3, u4} M _inst_4 S _inst_19 _inst_20 T _inst_23 _inst_24) g (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (fun (_x : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) => R -> S) ([anonymous].{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) f x))
but is expected to have type
  forall {M : Type.{u4}} [_inst_4 : Monoid.{u4} M] {R : Type.{u1}} [_inst_15 : Semiring.{u1} R] [_inst_16 : MulSemiringAction.{u4, u1} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u4, u3} M S _inst_4 _inst_19] {T : Type.{u2}} [_inst_23 : Semiring.{u2} T] [_inst_24 : MulSemiringAction.{u4, u2} M T _inst_4 _inst_23] (g : MulSemiringActionHom.{u4, u3, u2} M _inst_4 S _inst_19 _inst_20 T _inst_23 _inst_24) (f : MulSemiringActionHom.{u4, u1, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (x : R), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => T) x) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (MulSemiringActionHom.{u4, u1, u2} M _inst_4 R _inst_15 _inst_16 T _inst_23 _inst_24) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => T) _x) (SMulHomClass.toFunLike.{max u1 u2, u4, u1, u2} (MulSemiringActionHom.{u4, u1, u2} M _inst_4 R _inst_15 _inst_16 T _inst_23 _inst_24) M R T (SMulZeroClass.toSMul.{u4, u1} M R (AddMonoid.toZero.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u4, u1} M R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_15))))) (DistribMulAction.toDistribSMul.{u4, u1} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u4, u1} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u4, u2} M T (AddMonoid.toZero.{u2} T (AddMonoidWithOne.toAddMonoid.{u2} T (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} T (NonAssocSemiring.toAddCommMonoidWithOne.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_23))))) (DistribSMul.toSMulZeroClass.{u4, u2} M T (AddMonoid.toAddZeroClass.{u2} T (AddMonoidWithOne.toAddMonoid.{u2} T (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} T (NonAssocSemiring.toAddCommMonoidWithOne.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_23))))) (DistribMulAction.toDistribSMul.{u4, u2} M T _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} T (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} T (NonAssocSemiring.toAddCommMonoidWithOne.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_23)))) (MulSemiringAction.toDistribMulAction.{u4, u2} M T _inst_4 _inst_23 _inst_24)))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u2, u4, u1, u2} (MulSemiringActionHom.{u4, u1, u2} M _inst_4 R _inst_15 _inst_16 T _inst_23 _inst_24) M R T _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u2} T (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} T (NonAssocSemiring.toAddCommMonoidWithOne.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_23)))) (MulSemiringAction.toDistribMulAction.{u4, u1} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u4, u2} M T _inst_4 _inst_23 _inst_24) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u1 u2, u4, u1, u2} (MulSemiringActionHom.{u4, u1, u2} M _inst_4 R _inst_15 _inst_16 T _inst_23 _inst_24) M R T _inst_4 _inst_15 _inst_23 (MulSemiringAction.toDistribMulAction.{u4, u1} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u4, u2} M T _inst_4 _inst_23 _inst_24) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u4, u1, u2} M _inst_4 R _inst_15 _inst_16 T _inst_23 _inst_24)))) (MulSemiringActionHom.comp.{u4, u1, u3, u2} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20 T _inst_23 _inst_24 g f) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (MulSemiringActionHom.{u4, u3, u2} M _inst_4 S _inst_19 _inst_20 T _inst_23 _inst_24) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : S) => T) _x) (SMulHomClass.toFunLike.{max u3 u2, u4, u3, u2} (MulSemiringActionHom.{u4, u3, u2} M _inst_4 S _inst_19 _inst_20 T _inst_23 _inst_24) M S T (SMulZeroClass.toSMul.{u4, u3} M S (AddMonoid.toZero.{u3} S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u4, u3} M S (AddMonoid.toAddZeroClass.{u3} S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19))))) (DistribMulAction.toDistribSMul.{u4, u3} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u4, u3} M S _inst_4 _inst_19 _inst_20)))) (SMulZeroClass.toSMul.{u4, u2} M T (AddMonoid.toZero.{u2} T (AddMonoidWithOne.toAddMonoid.{u2} T (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} T (NonAssocSemiring.toAddCommMonoidWithOne.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_23))))) (DistribSMul.toSMulZeroClass.{u4, u2} M T (AddMonoid.toAddZeroClass.{u2} T (AddMonoidWithOne.toAddMonoid.{u2} T (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} T (NonAssocSemiring.toAddCommMonoidWithOne.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_23))))) (DistribMulAction.toDistribSMul.{u4, u2} M T _inst_4 (AddMonoidWithOne.toAddMonoid.{u2} T (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} T (NonAssocSemiring.toAddCommMonoidWithOne.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_23)))) (MulSemiringAction.toDistribMulAction.{u4, u2} M T _inst_4 _inst_23 _inst_24)))) (DistribMulActionHomClass.toSMulHomClass.{max u3 u2, u4, u3, u2} (MulSemiringActionHom.{u4, u3, u2} M _inst_4 S _inst_19 _inst_20 T _inst_23 _inst_24) M S T _inst_4 (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (AddMonoidWithOne.toAddMonoid.{u2} T (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} T (NonAssocSemiring.toAddCommMonoidWithOne.{u2} T (Semiring.toNonAssocSemiring.{u2} T _inst_23)))) (MulSemiringAction.toDistribMulAction.{u4, u3} M S _inst_4 _inst_19 _inst_20) (MulSemiringAction.toDistribMulAction.{u4, u2} M T _inst_4 _inst_23 _inst_24) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u3 u2, u4, u3, u2} (MulSemiringActionHom.{u4, u3, u2} M _inst_4 S _inst_19 _inst_20 T _inst_23 _inst_24) M S T _inst_4 _inst_19 _inst_23 (MulSemiringAction.toDistribMulAction.{u4, u3} M S _inst_4 _inst_19 _inst_20) (MulSemiringAction.toDistribMulAction.{u4, u2} M T _inst_4 _inst_23 _inst_24) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u4, u3, u2} M _inst_4 S _inst_19 _inst_20 T _inst_23 _inst_24)))) g (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (MulSemiringActionHom.{u4, u1, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2250 : R) => S) _x) (SMulHomClass.toFunLike.{max u1 u3, u4, u1, u3} (MulSemiringActionHom.{u4, u1, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S (SMulZeroClass.toSMul.{u4, u1} M R (AddMonoid.toZero.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_15))))) (DistribSMul.toSMulZeroClass.{u4, u1} M R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_15))))) (DistribMulAction.toDistribSMul.{u4, u1} M R _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_15)))) (MulSemiringAction.toDistribMulAction.{u4, u1} M R _inst_4 _inst_15 _inst_16)))) (SMulZeroClass.toSMul.{u4, u3} M S (AddMonoid.toZero.{u3} S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19))))) (DistribSMul.toSMulZeroClass.{u4, u3} M S (AddMonoid.toAddZeroClass.{u3} S (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19))))) (DistribMulAction.toDistribSMul.{u4, u3} M S _inst_4 (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u4, u3} M S _inst_4 _inst_19 _inst_20)))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u3, u4, u1, u3} (MulSemiringActionHom.{u4, u1, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 (AddMonoidWithOne.toAddMonoid.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_15)))) (AddMonoidWithOne.toAddMonoid.{u3} S (AddCommMonoidWithOne.toAddMonoidWithOne.{u3} S (NonAssocSemiring.toAddCommMonoidWithOne.{u3} S (Semiring.toNonAssocSemiring.{u3} S _inst_19)))) (MulSemiringAction.toDistribMulAction.{u4, u1} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u4, u3} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHomClass.toDistribMulActionHomClass.{max u1 u3, u4, u1, u3} (MulSemiringActionHom.{u4, u1, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) M R S _inst_4 _inst_15 _inst_19 (MulSemiringAction.toDistribMulAction.{u4, u1} M R _inst_4 _inst_15 _inst_16) (MulSemiringAction.toDistribMulAction.{u4, u3} M S _inst_4 _inst_19 _inst_20) (MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction.{u4, u1, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20)))) f x))
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.comp_apply MulSemiringActionHom.comp_applyₓ'. -/
@[simp]
theorem comp_apply (g : S →+*[M] T) (f : R →+*[M] S) (x : R) : g.comp f x = g (f x) :=
  rfl
#align mul_semiring_action_hom.comp_apply MulSemiringActionHom.comp_apply

/- warning: mul_semiring_action_hom.id_comp -> MulSemiringActionHom.id_comp is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (MulSemiringActionHom.comp.{u1, u2, u3, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20 S _inst_19 _inst_20 (MulSemiringActionHom.id.{u1, u3} M _inst_4 S _inst_19 _inst_20) f) f
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{max (succ u2) (succ u1)} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (MulSemiringActionHom.comp.{u3, u2, u1, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20 S _inst_19 _inst_20 (MulSemiringActionHom.id.{u3, u1} M _inst_4 S _inst_19 _inst_20) f) f
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.id_comp MulSemiringActionHom.id_compₓ'. -/
@[simp]
theorem id_comp (f : R →+*[M] S) : (MulSemiringActionHom.id M).comp f = f :=
  ext fun x => by rw [comp_apply, id_apply]
#align mul_semiring_action_hom.id_comp MulSemiringActionHom.id_comp

/- warning: mul_semiring_action_hom.comp_id -> MulSemiringActionHom.comp_id is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} [_inst_4 : Monoid.{u1} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u1, u2} M R _inst_4 _inst_15] {S : Type.{u3}} [_inst_19 : Semiring.{u3} S] [_inst_20 : MulSemiringAction.{u1, u3} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{max (succ u2) (succ u3)} (MulSemiringActionHom.{u1, u2, u3} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (MulSemiringActionHom.comp.{u1, u2, u2, u3} M _inst_4 R _inst_15 _inst_16 R _inst_15 _inst_16 S _inst_19 _inst_20 f (MulSemiringActionHom.id.{u1, u2} M _inst_4 R _inst_15 _inst_16)) f
but is expected to have type
  forall {M : Type.{u3}} [_inst_4 : Monoid.{u3} M] {R : Type.{u2}} [_inst_15 : Semiring.{u2} R] [_inst_16 : MulSemiringAction.{u3, u2} M R _inst_4 _inst_15] {S : Type.{u1}} [_inst_19 : Semiring.{u1} S] [_inst_20 : MulSemiringAction.{u3, u1} M S _inst_4 _inst_19] (f : MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20), Eq.{max (succ u2) (succ u1)} (MulSemiringActionHom.{u3, u2, u1} M _inst_4 R _inst_15 _inst_16 S _inst_19 _inst_20) (MulSemiringActionHom.comp.{u3, u2, u2, u1} M _inst_4 R _inst_15 _inst_16 R _inst_15 _inst_16 S _inst_19 _inst_20 f (MulSemiringActionHom.id.{u3, u2} M _inst_4 R _inst_15 _inst_16)) f
Case conversion may be inaccurate. Consider using '#align mul_semiring_action_hom.comp_id MulSemiringActionHom.comp_idₓ'. -/
@[simp]
theorem comp_id (f : R →+*[M] S) : f.comp (MulSemiringActionHom.id M) = f :=
  ext fun x => by rw [comp_apply, id_apply]
#align mul_semiring_action_hom.comp_id MulSemiringActionHom.comp_id

end MulSemiringActionHom

