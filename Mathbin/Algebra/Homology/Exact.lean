/-
Copyright (c) 2020 Markus Himmel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Himmel

! This file was ported from Lean 3 source module algebra.homology.exact
! leanprover-community/mathlib commit 3feb151caefe53df080ca6ca67a0c6685cfd1b82
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Homology.ImageToKernel

/-!
# Exact sequences

In a category with zero morphisms, images, and equalizers we say that `f : A ⟶ B` and `g : B ⟶ C`
are exact if `f ≫ g = 0` and the natural map `image f ⟶ kernel g` is an epimorphism.

In any preadditive category this is equivalent to the homology at `B` vanishing.

However in general it is weaker than other reasonable definitions of exactness,
particularly that
1. the inclusion map `image.ι f` is a kernel of `g` or
2. `image f ⟶ kernel g` is an isomorphism or
3. `image_subobject f = kernel_subobject f`.
However when the category is abelian, these all become equivalent;
these results are found in `category_theory/abelian/exact.lean`.

# Main results
* Suppose that cokernels exist and that `f` and `g` are exact.
  If `s` is any kernel fork over `g` and `t` is any cokernel cofork over `f`,
  then `fork.ι s ≫ cofork.π t = 0`.
* Precomposing the first morphism with an epimorphism retains exactness.
  Postcomposing the second morphism with a monomorphism retains exactness.
* If `f` and `g` are exact and `i` is an isomorphism,
  then `f ≫ i.hom` and `i.inv ≫ g` are also exact.

# Future work
* Short exact sequences, split exact sequences, the splitting lemma (maybe only for abelian
  categories?)
* Two adjacent maps in a chain complex are exact iff the homology vanishes

-/


universe v v₂ u u₂

open CategoryTheory

open CategoryTheory.Limits

variable {V : Type u} [Category.{v} V]

variable [HasImages V]

namespace CategoryTheory

#print CategoryTheory.Exact /-
-- One nice feature of this definition is that we have
-- `epi f → exact g h → exact (f ≫ g) h` and `exact f g → mono h → exact f (g ≫ h)`,
-- which do not necessarily hold in a non-abelian category with the usual definition of `exact`.
/-- Two morphisms `f : A ⟶ B`, `g : B ⟶ C` are called exact if `w : f ≫ g = 0` and the natural map
`image_to_kernel f g w : image_subobject f ⟶ kernel_subobject g` is an epimorphism.

In any preadditive category, this is equivalent to `w : f ≫ g = 0` and `homology f g w ≅ 0`.

In an abelian category, this is equivalent to `image_to_kernel f g w` being an isomorphism,
and hence equivalent to the usual definition,
`image_subobject f = kernel_subobject g`.
-/
structure Exact [HasZeroMorphisms V] [HasKernels V] {A B C : V} (f : A ⟶ B) (g : B ⟶ C) : Prop where
  w : f ≫ g = 0
  Epi : Epi (imageToKernel f g w)
#align category_theory.exact CategoryTheory.Exact
-/

-- This works as an instance even though `exact` itself is not a class, as long as the goal is
-- literally of the form `epi (image_to_kernel f g h.w)` (where `h : exact f g`). If the proof of
-- `f ≫ g = 0` looks different, we are out of luck and have to add the instance by hand.
attribute [instance] exact.epi

attribute [reassoc.1] exact.w

section

variable [HasZeroObject V] [Preadditive V] [HasKernels V] [HasCokernels V]

open ZeroObject

#print CategoryTheory.Preadditive.exact_iff_homology_zero /-
/-- In any preadditive category,
composable morphisms `f g` are exact iff they compose to zero and the homology vanishes.
-/
theorem Preadditive.exact_iff_homology_zero {A B C : V} (f : A ⟶ B) (g : B ⟶ C) :
    Exact f g ↔ ∃ w : f ≫ g = 0, Nonempty (homology f g w ≅ 0) :=
  ⟨fun h => ⟨h.w, ⟨cokernel.ofEpi _⟩⟩, fun h =>
    by
    obtain ⟨w, ⟨i⟩⟩ := h
    exact ⟨w, preadditive.epi_of_cokernel_zero ((cancel_mono i.hom).mp (by ext))⟩⟩
#align category_theory.preadditive.exact_iff_homology_zero CategoryTheory.Preadditive.exact_iff_homology_zero
-/

#print CategoryTheory.Preadditive.exact_of_iso_of_exact /-
theorem Preadditive.exact_of_iso_of_exact {A₁ B₁ C₁ A₂ B₂ C₂ : V} (f₁ : A₁ ⟶ B₁) (g₁ : B₁ ⟶ C₁)
    (f₂ : A₂ ⟶ B₂) (g₂ : B₂ ⟶ C₂) (α : Arrow.mk f₁ ≅ Arrow.mk f₂) (β : Arrow.mk g₁ ≅ Arrow.mk g₂)
    (p : α.Hom.right = β.Hom.left) (h : Exact f₁ g₁) : Exact f₂ g₂ :=
  by
  rw [preadditive.exact_iff_homology_zero] at h⊢
  rcases h with ⟨w₁, ⟨i⟩⟩
  suffices w₂ : f₂ ≫ g₂ = 0; exact ⟨w₂, ⟨(homology.mapIso w₁ w₂ α β p).symm.trans i⟩⟩
  rw [← cancel_epi α.hom.left, ← cancel_mono β.inv.right, comp_zero, zero_comp, ← w₁]
  simp only [← arrow.mk_hom f₁, ← arrow.left_hom_inv_right α.hom, ← arrow.mk_hom g₁, ←
    arrow.left_hom_inv_right β.hom, p]
  simp only [arrow.mk_hom, is_iso.inv_hom_id_assoc, category.assoc, ← arrow.inv_right,
    is_iso.iso.inv_hom]
#align category_theory.preadditive.exact_of_iso_of_exact CategoryTheory.Preadditive.exact_of_iso_of_exact
-/

#print CategoryTheory.Preadditive.exact_of_iso_of_exact' /-
/-- A reformulation of `preadditive.exact_of_iso_of_exact` that does not involve the arrow
category. -/
theorem Preadditive.exact_of_iso_of_exact' {A₁ B₁ C₁ A₂ B₂ C₂ : V} (f₁ : A₁ ⟶ B₁) (g₁ : B₁ ⟶ C₁)
    (f₂ : A₂ ⟶ B₂) (g₂ : B₂ ⟶ C₂) (α : A₁ ≅ A₂) (β : B₁ ≅ B₂) (γ : C₁ ≅ C₂)
    (hsq₁ : α.Hom ≫ f₂ = f₁ ≫ β.Hom) (hsq₂ : β.Hom ≫ g₂ = g₁ ≫ γ.Hom) (h : Exact f₁ g₁) :
    Exact f₂ g₂ :=
  Preadditive.exact_of_iso_of_exact f₁ g₁ f₂ g₂ (Arrow.isoMk α β hsq₁) (Arrow.isoMk β γ hsq₂) rfl h
#align category_theory.preadditive.exact_of_iso_of_exact' CategoryTheory.Preadditive.exact_of_iso_of_exact'
-/

#print CategoryTheory.Preadditive.exact_iff_exact_of_iso /-
theorem Preadditive.exact_iff_exact_of_iso {A₁ B₁ C₁ A₂ B₂ C₂ : V} (f₁ : A₁ ⟶ B₁) (g₁ : B₁ ⟶ C₁)
    (f₂ : A₂ ⟶ B₂) (g₂ : B₂ ⟶ C₂) (α : Arrow.mk f₁ ≅ Arrow.mk f₂) (β : Arrow.mk g₁ ≅ Arrow.mk g₂)
    (p : α.Hom.right = β.Hom.left) : Exact f₁ g₁ ↔ Exact f₂ g₂ :=
  ⟨Preadditive.exact_of_iso_of_exact _ _ _ _ _ _ p,
    Preadditive.exact_of_iso_of_exact _ _ _ _ α.symm β.symm
      (by
        rw [← cancel_mono α.hom.right]
        simp only [iso.symm_hom, ← comma.comp_right, α.inv_hom_id]
        simp only [p, ← comma.comp_left, arrow.id_right, arrow.id_left, iso.inv_hom_id]
        rfl)⟩
#align category_theory.preadditive.exact_iff_exact_of_iso CategoryTheory.Preadditive.exact_iff_exact_of_iso
-/

end

section

variable [HasZeroMorphisms V] [HasKernels V]

#print CategoryTheory.comp_eq_zero_of_image_eq_kernel /-
theorem comp_eq_zero_of_image_eq_kernel {A B C : V} (f : A ⟶ B) (g : B ⟶ C)
    (p : imageSubobject f = kernelSubobject g) : f ≫ g = 0 :=
  by
  rw [← image_subobject_arrow_comp f, category.assoc]
  convert comp_zero
  rw [p]
  simp
#align category_theory.comp_eq_zero_of_image_eq_kernel CategoryTheory.comp_eq_zero_of_image_eq_kernel
-/

/- warning: category_theory.image_to_kernel_is_iso_of_image_eq_kernel -> CategoryTheory.imageToKernel_isIso_of_image_eq_kernel is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_3] {A : V} {B : V} {C : V} (f : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (g : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (p : Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.Limits.imageSubobject.{u1, u2} V _inst_1 A B f (CategoryTheory.Limits.HasImages.hasImage.{u1, u2} V _inst_1 _inst_2 A B f)) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 _inst_4 B C g))), CategoryTheory.IsIso.{u1, u2} V _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 B)))) (CategoryTheory.Limits.imageSubobject.{u1, u2} V _inst_1 A B f (CategoryTheory.Limits.HasImages.hasImage.{u1, u2} V _inst_1 _inst_2 A B f))) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 B)))) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 _inst_4 B C g))) (imageToKernel.{u1, u2} V _inst_1 _inst_3 A B C f (CategoryTheory.Limits.HasImages.hasImage.{u1, u2} V _inst_1 _inst_2 A B f) g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 _inst_4 B C g) (CategoryTheory.comp_eq_zero_of_image_eq_kernel.{u1, u2} V _inst_1 _inst_2 _inst_3 _inst_4 A B C f g p))
but is expected to have type
  forall {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_3] {A : V} {B : V} {C : V} (f : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (g : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (p : Eq.{max (succ u2) (succ u1)} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.Limits.imageSubobject.{u1, u2} V _inst_1 A B f (CategoryTheory.Limits.HasImages.has_image.{u1, u2} V _inst_1 _inst_2 A B f)) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 _inst_4 B C g))), CategoryTheory.IsIso.{u1, u2} V _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 B)) (CategoryTheory.Limits.imageSubobject.{u1, u2} V _inst_1 A B f (CategoryTheory.Limits.HasImages.has_image.{u1, u2} V _inst_1 _inst_2 A B f))) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 B)) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 _inst_4 B C g))) (imageToKernel.{u1, u2} V _inst_1 _inst_3 A B C f (CategoryTheory.Limits.HasImages.has_image.{u1, u2} V _inst_1 _inst_2 A B f) g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 _inst_4 B C g) (CategoryTheory.comp_eq_zero_of_image_eq_kernel.{u1, u2} V _inst_1 _inst_2 _inst_3 _inst_4 A B C f g p))
Case conversion may be inaccurate. Consider using '#align category_theory.image_to_kernel_is_iso_of_image_eq_kernel CategoryTheory.imageToKernel_isIso_of_image_eq_kernelₓ'. -/
theorem imageToKernel_isIso_of_image_eq_kernel {A B C : V} (f : A ⟶ B) (g : B ⟶ C)
    (p : imageSubobject f = kernelSubobject g) :
    IsIso (imageToKernel f g (comp_eq_zero_of_image_eq_kernel f g p)) :=
  by
  refine' ⟨⟨subobject.of_le _ _ p.ge, _⟩⟩
  dsimp [imageToKernel]
  simp only [subobject.of_le_comp_of_le, subobject.of_le_refl]
  simp
#align category_theory.image_to_kernel_is_iso_of_image_eq_kernel CategoryTheory.imageToKernel_isIso_of_image_eq_kernel

#print CategoryTheory.exact_of_image_eq_kernel /-
-- We'll prove the converse later, when `V` is abelian.
theorem exact_of_image_eq_kernel {A B C : V} (f : A ⟶ B) (g : B ⟶ C)
    (p : imageSubobject f = kernelSubobject g) : Exact f g :=
  { w := comp_eq_zero_of_image_eq_kernel f g p
    Epi := by
      haveI := image_to_kernel_is_iso_of_image_eq_kernel f g p
      infer_instance }
#align category_theory.exact_of_image_eq_kernel CategoryTheory.exact_of_image_eq_kernel
-/

end

variable {A B C D : V} {f : A ⟶ B} {g : B ⟶ C} {h : C ⟶ D}

attribute [local instance] epi_comp

section

variable [HasZeroMorphisms V] [HasEqualizers V]

#print CategoryTheory.exact_comp_hom_inv_comp /-
theorem exact_comp_hom_inv_comp (i : B ≅ D) (h : Exact f g) : Exact (f ≫ i.Hom) (i.inv ≫ g) :=
  by
  refine' ⟨by simp [h.w], _⟩
  rw [imageToKernel_comp_hom_inv_comp]
  haveI := h.epi
  infer_instance
#align category_theory.exact_comp_hom_inv_comp CategoryTheory.exact_comp_hom_inv_comp
-/

#print CategoryTheory.exact_comp_inv_hom_comp /-
theorem exact_comp_inv_hom_comp (i : D ≅ B) (h : Exact f g) : Exact (f ≫ i.inv) (i.Hom ≫ g) :=
  exact_comp_hom_inv_comp i.symm h
#align category_theory.exact_comp_inv_hom_comp CategoryTheory.exact_comp_inv_hom_comp
-/

#print CategoryTheory.exact_comp_hom_inv_comp_iff /-
theorem exact_comp_hom_inv_comp_iff (i : B ≅ D) : Exact (f ≫ i.Hom) (i.inv ≫ g) ↔ Exact f g :=
  ⟨fun h => by simpa using exact_comp_inv_hom_comp i h, exact_comp_hom_inv_comp i⟩
#align category_theory.exact_comp_hom_inv_comp_iff CategoryTheory.exact_comp_hom_inv_comp_iff
-/

#print CategoryTheory.exact_epi_comp /-
theorem exact_epi_comp (hgh : Exact g h) [Epi f] : Exact (f ≫ g) h :=
  by
  refine' ⟨by simp [hgh.w], _⟩
  rw [imageToKernel_comp_left]
  infer_instance
#align category_theory.exact_epi_comp CategoryTheory.exact_epi_comp
-/

#print CategoryTheory.exact_iso_comp /-
@[simp]
theorem exact_iso_comp [IsIso f] : Exact (f ≫ g) h ↔ Exact g h :=
  ⟨fun w => by
    rw [← is_iso.inv_hom_id_assoc f g]
    exact exact_epi_comp w, fun w => exact_epi_comp w⟩
#align category_theory.exact_iso_comp CategoryTheory.exact_iso_comp
-/

#print CategoryTheory.exact_comp_mono /-
theorem exact_comp_mono (hfg : Exact f g) [Mono h] : Exact f (g ≫ h) :=
  by
  refine' ⟨by simp [hfg.w_assoc], _⟩
  rw [imageToKernel_comp_right f g h hfg.w]
  infer_instance
#align category_theory.exact_comp_mono CategoryTheory.exact_comp_mono
-/

#print CategoryTheory.exact_comp_mono_iff /-
/-- The dual of this lemma is only true when `V` is abelian, see `abelian.exact_epi_comp_iff`. -/
theorem exact_comp_mono_iff [Mono h] : Exact f (g ≫ h) ↔ Exact f g :=
  by
  refine'
    ⟨fun hfg => ⟨zero_of_comp_mono h (by rw [category.assoc, hfg.1]), _⟩, fun h =>
      exact_comp_mono h⟩
  rw [← (iso.eq_comp_inv _).1 (imageToKernel_comp_mono _ _ h hfg.1)]
  haveI := hfg.2; infer_instance
#align category_theory.exact_comp_mono_iff CategoryTheory.exact_comp_mono_iff
-/

#print CategoryTheory.exact_comp_iso /-
@[simp]
theorem exact_comp_iso [IsIso h] : Exact f (g ≫ h) ↔ Exact f g :=
  exact_comp_mono_iff
#align category_theory.exact_comp_iso CategoryTheory.exact_comp_iso
-/

/- warning: category_theory.exact_kernel_subobject_arrow -> CategoryTheory.exact_kernelSubobject_arrow is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] {A : V} {B : V} {f : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B} [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasEqualizers.{u1, u2} V _inst_1], CategoryTheory.Exact.{u1, u2} V _inst_1 _inst_2 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 A)))) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 A B _inst_3 f (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) A B f))) A B (CategoryTheory.Subobject.arrow.{u1, u2} V _inst_1 A (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 A B _inst_3 f (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) A B f))) f
but is expected to have type
  forall {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] {A : V} {B : V} {f : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B} [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasEqualizers.{u1, u2} V _inst_1], CategoryTheory.Exact.{u1, u2} V _inst_1 _inst_2 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 A))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 A) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 A))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 A)) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 A B _inst_3 f (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) A B f))) A B (CategoryTheory.Subobject.arrow.{u1, u2} V _inst_1 A (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 A B _inst_3 f (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) A B f))) f
Case conversion may be inaccurate. Consider using '#align category_theory.exact_kernel_subobject_arrow CategoryTheory.exact_kernelSubobject_arrowₓ'. -/
theorem exact_kernelSubobject_arrow : Exact (kernelSubobject f).arrow f :=
  by
  refine' ⟨by simp, _⟩
  apply @is_iso.epi_of_iso _ _ _ _ _ _
  exact
    ⟨⟨factor_thru_image_subobject _, by
        ext
        simp, by
        ext
        simp⟩⟩
#align category_theory.exact_kernel_subobject_arrow CategoryTheory.exact_kernelSubobject_arrow

#print CategoryTheory.exact_kernel_ι /-
theorem exact_kernel_ι : Exact (kernel.ι f) f :=
  by
  rw [← kernel_subobject_arrow', exact_iso_comp]
  exact exact_kernel_subobject_arrow
#align category_theory.exact_kernel_ι CategoryTheory.exact_kernel_ι
-/

instance (h : Exact f g) : Epi (factorThruKernelSubobject g f h.w) :=
  by
  rw [← factorThruImageSubobject_comp_imageToKernel]
  apply epi_comp

instance (h : Exact f g) : Epi (kernel.lift g f h.w) :=
  by
  rw [← factor_thru_kernel_subobject_comp_kernel_subobject_iso]
  apply epi_comp

variable (A)

/- warning: category_theory.kernel_subobject_arrow_eq_zero_of_exact_zero_left -> CategoryTheory.kernelSubobject_arrow_eq_zero_of_exact_zero_left is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] (A : V) {B : V} {C : V} {g : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C} [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasEqualizers.{u1, u2} V _inst_1], (CategoryTheory.Exact.{u1, u2} V _inst_1 _inst_2 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) A B C (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 A B)))) g) -> (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 B)))) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) B) (CategoryTheory.Subobject.arrow.{u1, u2} V _inst_1 B (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 B)))) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) B) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 B)))) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) B) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 B)))) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 B)))) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) B)))))
but is expected to have type
  forall {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] (A : V) {B : V} {C : V} {g : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C} [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasEqualizers.{u1, u2} V _inst_1], (CategoryTheory.Exact.{u1, u2} V _inst_1 _inst_2 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) A B C (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 A B))) g) -> (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 B)) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) B) (CategoryTheory.Subobject.arrow.{u1, u2} V _inst_1 B (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 B)) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 B)) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 B) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 B))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 B)) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 B C _inst_3 g (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) B C g))) B))))
Case conversion may be inaccurate. Consider using '#align category_theory.kernel_subobject_arrow_eq_zero_of_exact_zero_left CategoryTheory.kernelSubobject_arrow_eq_zero_of_exact_zero_leftₓ'. -/
theorem kernelSubobject_arrow_eq_zero_of_exact_zero_left (h : Exact (0 : A ⟶ B) g) :
    (kernelSubobject g).arrow = 0 :=
  by
  rw [← cancel_epi (imageToKernel (0 : A ⟶ B) g h.w), ←
    cancel_epi (factor_thru_image_subobject (0 : A ⟶ B))]
  simp
#align category_theory.kernel_subobject_arrow_eq_zero_of_exact_zero_left CategoryTheory.kernelSubobject_arrow_eq_zero_of_exact_zero_left

#print CategoryTheory.kernel_ι_eq_zero_of_exact_zero_left /-
theorem kernel_ι_eq_zero_of_exact_zero_left (h : Exact (0 : A ⟶ B) g) : kernel.ι g = 0 :=
  by
  rw [← kernel_subobject_arrow']
  simp [kernel_subobject_arrow_eq_zero_of_exact_zero_left A h]
#align category_theory.kernel_ι_eq_zero_of_exact_zero_left CategoryTheory.kernel_ι_eq_zero_of_exact_zero_left
-/

#print CategoryTheory.exact_zero_left_of_mono /-
theorem exact_zero_left_of_mono [HasZeroObject V] [Mono g] : Exact (0 : A ⟶ B) g :=
  ⟨by simp, imageToKernel_epi_of_zero_of_mono _⟩
#align category_theory.exact_zero_left_of_mono CategoryTheory.exact_zero_left_of_mono
-/

end

section HasCokernels

variable [HasZeroMorphisms V] [HasEqualizers V] [HasCokernels V] (f g)

#print CategoryTheory.kernel_comp_cokernel /-
@[simp, reassoc.1]
theorem kernel_comp_cokernel (h : Exact f g) : kernel.ι g ≫ cokernel.π f = 0 :=
  by
  rw [← kernel_subobject_arrow', category.assoc]
  convert comp_zero
  apply zero_of_epi_comp (imageToKernel f g h.w) _
  rw [imageToKernel_arrow_assoc, ← image_subobject_arrow, category.assoc, ← iso.eq_inv_comp]
  ext
  simp
#align category_theory.kernel_comp_cokernel CategoryTheory.kernel_comp_cokernel
-/

#print CategoryTheory.comp_eq_zero_of_exact /-
theorem comp_eq_zero_of_exact (h : Exact f g) {X Y : V} {ι : X ⟶ B} (hι : ι ≫ g = 0) {π : B ⟶ Y}
    (hπ : f ≫ π = 0) : ι ≫ π = 0 := by
  rw [← kernel.lift_ι _ _ hι, ← cokernel.π_desc _ _ hπ, category.assoc,
    kernel_comp_cokernel_assoc _ _ h, zero_comp, comp_zero]
#align category_theory.comp_eq_zero_of_exact CategoryTheory.comp_eq_zero_of_exact
-/

/- warning: category_theory.fork_ι_comp_cofork_π -> CategoryTheory.fork_ι_comp_cofork_π is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] {A : V} {B : V} {C : V} (f : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (g : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasEqualizers.{u1, u2} V _inst_1] [_inst_5 : CategoryTheory.Limits.HasCokernels.{u1, u2} V _inst_1 _inst_3], (CategoryTheory.Exact.{u1, u2} V _inst_1 _inst_2 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) A B C f g) -> (forall (s : CategoryTheory.Limits.KernelFork.{u1, u2} V _inst_1 _inst_3 B C g) (t : CategoryTheory.Limits.CokernelCofork.{u1, u2} V _inst_1 _inst_3 A B f), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 B C))))) s)) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 A B))))) t)) CategoryTheory.Limits.WalkingParallelPair.one)) (CategoryTheory.CategoryStruct.comp.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 B C))))) s)) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 B C))))) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 A B))))) t)) CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.Limits.Fork.ι.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 B C)))) s) (CategoryTheory.Limits.Cofork.π.{u1, u2} V _inst_1 A B f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 A B)))) t)) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 B C))) s)) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 A B))) t)) CategoryTheory.Limits.WalkingParallelPair.one)) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 B C))) s)) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 A B))) t)) CategoryTheory.Limits.WalkingParallelPair.one)) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 B C))) s)) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 A B))) t)) CategoryTheory.Limits.WalkingParallelPair.one)) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 B C))) s)) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Functor.obj.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Functor.obj.{u1, u1, u2, max u1 u2} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (Zero.zero.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, u2} V _inst_1 _inst_3 A B))) t)) CategoryTheory.Limits.WalkingParallelPair.one))))))
but is expected to have type
  forall {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] {A : V} {B : V} {C : V} (f : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (g : Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasEqualizers.{u1, u2} V _inst_1] [_inst_5 : CategoryTheory.Limits.HasCokernels.{u1, u2} V _inst_1 _inst_3], (CategoryTheory.Exact.{u1, u2} V _inst_1 _inst_2 _inst_3 (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_3 _inst_4) A B C f g) -> (forall (s : CategoryTheory.Limits.KernelFork.{u1, u2} V _inst_1 _inst_3 B C g) (t : CategoryTheory.Limits.CokernelCofork.{u1, u2} V _inst_1 _inst_3 A B f), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1)) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 B C)))) s))) CategoryTheory.Limits.WalkingParallelPair.zero) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 A B)))) t))) CategoryTheory.Limits.WalkingParallelPair.one)) (CategoryTheory.CategoryStruct.comp.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1)) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 B C)))) s))) CategoryTheory.Limits.WalkingParallelPair.zero) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 B C))))) CategoryTheory.Limits.WalkingParallelPair.zero) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 A B)))) t))) CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.Limits.Fork.ι.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 B C))) s) (CategoryTheory.Limits.Cofork.π.{u1, u2} V _inst_1 A B f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 A B))) t)) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1)) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 B C)))) s))) CategoryTheory.Limits.WalkingParallelPair.zero) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 A B)))) t))) CategoryTheory.Limits.WalkingParallelPair.one)) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1)) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 B C)))) s))) CategoryTheory.Limits.WalkingParallelPair.zero) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 A B)))) t))) CategoryTheory.Limits.WalkingParallelPair.one)) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1)) (CategoryTheory.Limits.Cone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 B C g (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) B C) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 B C)))) s))) CategoryTheory.Limits.WalkingParallelPair.zero) (Prefunctor.obj.{1, succ u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.CategoryStruct.toQuiver.{0, 0} CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Category.toCategoryStruct.{0, 0} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory)) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (Prefunctor.obj.{succ u1, succ u1, u2, max u1 u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, max u2 u1} V _inst_1 (CategoryTheory.Functor.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.category.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1) (CategoryTheory.Functor.const.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1)) (CategoryTheory.Limits.Cocone.pt.{0, u1, 0, u2} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory V _inst_1 (CategoryTheory.Limits.parallelPair.{u1, u2} V _inst_1 A B f (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) A B) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, u2} V _inst_1 _inst_3 A B)))) t))) CategoryTheory.Limits.WalkingParallelPair.one)))))
Case conversion may be inaccurate. Consider using '#align category_theory.fork_ι_comp_cofork_π CategoryTheory.fork_ι_comp_cofork_πₓ'. -/
@[simp, reassoc.1]
theorem fork_ι_comp_cofork_π (h : Exact f g) (s : KernelFork g) (t : CokernelCofork f) :
    Fork.ι s ≫ Cofork.π t = 0 :=
  comp_eq_zero_of_exact f g h (KernelFork.condition s) (CokernelCofork.condition t)
#align category_theory.fork_ι_comp_cofork_π CategoryTheory.fork_ι_comp_cofork_π

end HasCokernels

section

variable [HasZeroObject V]

open ZeroObject

section

variable [HasZeroMorphisms V] [HasKernels V]

#print CategoryTheory.exact_of_zero /-
theorem exact_of_zero {A C : V} (f : A ⟶ 0) (g : 0 ⟶ C) : Exact f g :=
  by
  obtain rfl : f = 0 := by ext
  obtain rfl : g = 0 := by ext
  fconstructor
  · simp
  · exact imageToKernel_epi_of_zero_of_mono 0
#align category_theory.exact_of_zero CategoryTheory.exact_of_zero
-/

#print CategoryTheory.exact_zero_mono /-
theorem exact_zero_mono {B C : V} (f : B ⟶ C) [Mono f] : Exact (0 : 0 ⟶ B) f :=
  ⟨by simp, inferInstance⟩
#align category_theory.exact_zero_mono CategoryTheory.exact_zero_mono
-/

#print CategoryTheory.exact_epi_zero /-
theorem exact_epi_zero {A B : V} (f : A ⟶ B) [Epi f] : Exact f (0 : B ⟶ 0) :=
  ⟨by simp, inferInstance⟩
#align category_theory.exact_epi_zero CategoryTheory.exact_epi_zero
-/

end

section

variable [Preadditive V]

#print CategoryTheory.mono_iff_exact_zero_left /-
theorem mono_iff_exact_zero_left [HasKernels V] {B C : V} (f : B ⟶ C) :
    Mono f ↔ Exact (0 : 0 ⟶ B) f :=
  ⟨fun h => exact_zero_mono _, fun h =>
    Preadditive.mono_of_kernel_iso_zero
      ((kernelSubobjectIso f).symm ≪≫ isoZeroOfEpiZero (by simpa using h.epi))⟩
#align category_theory.mono_iff_exact_zero_left CategoryTheory.mono_iff_exact_zero_left
-/

#print CategoryTheory.epi_iff_exact_zero_right /-
theorem epi_iff_exact_zero_right [HasEqualizers V] {A B : V} (f : A ⟶ B) :
    Epi f ↔ Exact f (0 : B ⟶ 0) :=
  ⟨fun h => exact_epi_zero _, fun h => by
    have e₁ := h.epi
    rw [imageToKernel_zero_right] at e₁
    have e₂ :
      epi
        (((image_subobject f).arrow ≫ inv (kernel_subobject 0).arrow) ≫
          (kernel_subobject 0).arrow) :=
      @epi_comp _ _ _ _ _ _ e₁ _ _
    rw [category.assoc, is_iso.inv_hom_id, category.comp_id] at e₂
    rw [← image_subobject_arrow] at e₂
    skip
    haveI : epi (image.ι f) := epi_of_epi (image_subobject_iso f).Hom (image.ι f)
    apply epi_of_epi_image⟩
#align category_theory.epi_iff_exact_zero_right CategoryTheory.epi_iff_exact_zero_right
-/

end

end

namespace Functor

variable [HasZeroMorphisms V] [HasKernels V] {W : Type u₂} [Category.{v₂} W]

variable [HasImages W] [HasZeroMorphisms W] [HasKernels W]

#print CategoryTheory.Functor.ReflectsExactSequences /-
/-- A functor reflects exact sequences if any composable pair of morphisms that is mapped to an
    exact pair is itself exact. -/
class ReflectsExactSequences (F : V ⥤ W) where
  reflects : ∀ {A B C : V} (f : A ⟶ B) (g : B ⟶ C), Exact (F.map f) (F.map g) → Exact f g
#align category_theory.functor.reflects_exact_sequences CategoryTheory.Functor.ReflectsExactSequences
-/

/- warning: category_theory.functor.exact_of_exact_map -> CategoryTheory.Functor.exact_of_exact_map is a dubious translation:
lean 3 declaration is
  forall {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} V] [_inst_2 : CategoryTheory.Limits.HasImages.{u1, u3} V _inst_1] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasKernels.{u1, u3} V _inst_1 _inst_3] {W : Type.{u4}} [_inst_5 : CategoryTheory.Category.{u2, u4} W] [_inst_6 : CategoryTheory.Limits.HasImages.{u2, u4} W _inst_5] [_inst_7 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} W _inst_5] [_inst_8 : CategoryTheory.Limits.HasKernels.{u2, u4} W _inst_5 _inst_7] (F : CategoryTheory.Functor.{u1, u2, u3, u4} V _inst_1 W _inst_5) [_inst_9 : CategoryTheory.Functor.ReflectsExactSequences.{u1, u2, u3, u4} V _inst_1 _inst_2 _inst_3 _inst_4 W _inst_5 _inst_6 _inst_7 _inst_8 F] {A : V} {B : V} {C : V} {f : Quiver.Hom.{succ u1, u3} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} V (CategoryTheory.Category.toCategoryStruct.{u1, u3} V _inst_1)) A B} {g : Quiver.Hom.{succ u1, u3} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} V (CategoryTheory.Category.toCategoryStruct.{u1, u3} V _inst_1)) B C}, (CategoryTheory.Exact.{u2, u4} W _inst_5 _inst_6 _inst_7 _inst_8 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} V _inst_1 W _inst_5 F A) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} V _inst_1 W _inst_5 F B) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} V _inst_1 W _inst_5 F C) (CategoryTheory.Functor.map.{u1, u2, u3, u4} V _inst_1 W _inst_5 F A B f) (CategoryTheory.Functor.map.{u1, u2, u3, u4} V _inst_1 W _inst_5 F B C g)) -> (CategoryTheory.Exact.{u1, u3} V _inst_1 _inst_2 _inst_3 _inst_4 A B C f g)
but is expected to have type
  forall {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} V] [_inst_2 : CategoryTheory.Limits.HasImages.{u1, u3} V _inst_1] [_inst_3 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u3} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasKernels.{u1, u3} V _inst_1 _inst_3] {W : Type.{u4}} [_inst_5 : CategoryTheory.Category.{u2, u4} W] [_inst_6 : CategoryTheory.Limits.HasImages.{u2, u4} W _inst_5] [_inst_7 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u4} W _inst_5] [_inst_8 : CategoryTheory.Limits.HasKernels.{u2, u4} W _inst_5 _inst_7] (F : CategoryTheory.Functor.{u1, u2, u3, u4} V _inst_1 W _inst_5) [_inst_9 : CategoryTheory.Functor.ReflectsExactSequences.{u1, u2, u3, u4} V _inst_1 _inst_2 _inst_3 _inst_4 W _inst_5 _inst_6 _inst_7 _inst_8 F] {A : V} {B : V} {C : V} {f : Quiver.Hom.{succ u1, u3} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} V (CategoryTheory.Category.toCategoryStruct.{u1, u3} V _inst_1)) A B} {g : Quiver.Hom.{succ u1, u3} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} V (CategoryTheory.Category.toCategoryStruct.{u1, u3} V _inst_1)) B C}, (CategoryTheory.Exact.{u2, u4} W _inst_5 _inst_6 _inst_7 _inst_8 (Prefunctor.obj.{succ u1, succ u2, u3, u4} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} V (CategoryTheory.Category.toCategoryStruct.{u1, u3} V _inst_1)) W (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} W (CategoryTheory.Category.toCategoryStruct.{u2, u4} W _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} V _inst_1 W _inst_5 F) A) (Prefunctor.obj.{succ u1, succ u2, u3, u4} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} V (CategoryTheory.Category.toCategoryStruct.{u1, u3} V _inst_1)) W (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} W (CategoryTheory.Category.toCategoryStruct.{u2, u4} W _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} V _inst_1 W _inst_5 F) B) (Prefunctor.obj.{succ u1, succ u2, u3, u4} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} V (CategoryTheory.Category.toCategoryStruct.{u1, u3} V _inst_1)) W (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} W (CategoryTheory.Category.toCategoryStruct.{u2, u4} W _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} V _inst_1 W _inst_5 F) C) (Prefunctor.map.{succ u1, succ u2, u3, u4} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} V (CategoryTheory.Category.toCategoryStruct.{u1, u3} V _inst_1)) W (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} W (CategoryTheory.Category.toCategoryStruct.{u2, u4} W _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} V _inst_1 W _inst_5 F) A B f) (Prefunctor.map.{succ u1, succ u2, u3, u4} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} V (CategoryTheory.Category.toCategoryStruct.{u1, u3} V _inst_1)) W (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} W (CategoryTheory.Category.toCategoryStruct.{u2, u4} W _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} V _inst_1 W _inst_5 F) B C g)) -> (CategoryTheory.Exact.{u1, u3} V _inst_1 _inst_2 _inst_3 _inst_4 A B C f g)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.exact_of_exact_map CategoryTheory.Functor.exact_of_exact_mapₓ'. -/
theorem exact_of_exact_map (F : V ⥤ W) [ReflectsExactSequences F] {A B C : V} {f : A ⟶ B}
    {g : B ⟶ C} (hfg : Exact (F.map f) (F.map g)) : Exact f g :=
  ReflectsExactSequences.reflects f g hfg
#align category_theory.functor.exact_of_exact_map CategoryTheory.Functor.exact_of_exact_map

end Functor

end CategoryTheory

