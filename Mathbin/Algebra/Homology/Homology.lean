/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module algebra.homology.homology
! leanprover-community/mathlib commit 8eb9c42d4d34c77f6ee84ea766ae4070233a973c
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Homology.ImageToKernel
import Mathbin.Algebra.Homology.HomologicalComplex
import Mathbin.CategoryTheory.GradedObject

/-!
# The homology of a complex

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Given `C : homological_complex V c`, we have `C.cycles i` and `C.boundaries i`,
both defined as subobjects of `C.X i`.

We show these are functorial with respect to chain maps,
as `C.cycles_map f i` and `C.boundaries_map f i`.

As a consequence we construct `homology_functor i : homological_complex V c ⥤ V`,
computing the `i`-th homology.
-/


universe v u

open CategoryTheory CategoryTheory.Limits

variable {ι : Type _}

variable {V : Type u} [Category.{v} V] [HasZeroMorphisms V]

variable {c : ComplexShape ι} (C : HomologicalComplex V c)

open Classical ZeroObject

noncomputable section

namespace HomologicalComplex

section Cycles

variable [HasKernels V]

#print HomologicalComplex.cycles /-
/-- The cycles at index `i`, as a subobject. -/
abbrev cycles (i : ι) : Subobject (C.pt i) :=
  kernelSubobject (C.dFrom i)
#align homological_complex.cycles HomologicalComplex.cycles
-/

/- warning: homological_complex.cycles_eq_kernel_subobject -> HomologicalComplex.cycles_eq_kernelSubobject is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] {i : ι} {j : ι}, (ComplexShape.Rel.{u3} ι c i j) -> (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C _inst_3 i) (CategoryTheory.Limits.kernelSubobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j) _inst_2 (HomologicalComplex.d.{u1, u2, u3} ι V _inst_1 _inst_2 c C i j) (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_2 _inst_3 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u1, u2, u3} ι V _inst_1 _inst_2 c C i j))))
but is expected to have type
  forall {ι : Type.{u1}} {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} V _inst_1] {c : ComplexShape.{u1} ι} (C : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasKernels.{u2, u3} V _inst_1 _inst_2] {i : ι} {j : ι}, (ComplexShape.Rel.{u1} ι c i j) -> (Eq.{max (succ u3) (succ u2)} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C _inst_3 i) (CategoryTheory.Limits.kernelSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j) _inst_2 (HomologicalComplex.d.{u2, u3, u1} ι V _inst_1 _inst_2 c C i j) (CategoryTheory.Limits.HasKernels.has_limit.{u2, u3} V _inst_1 _inst_2 _inst_3 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u2, u3, u1} ι V _inst_1 _inst_2 c C i j))))
Case conversion may be inaccurate. Consider using '#align homological_complex.cycles_eq_kernel_subobject HomologicalComplex.cycles_eq_kernelSubobjectₓ'. -/
theorem cycles_eq_kernelSubobject {i j : ι} (r : c.Rel i j) :
    C.cycles i = kernelSubobject (C.d i j) :=
  C.kernel_from_eq_kernel r
#align homological_complex.cycles_eq_kernel_subobject HomologicalComplex.cycles_eq_kernelSubobject

/- warning: homological_complex.cycles_iso_kernel -> HomologicalComplex.cyclesIsoKernel is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] {i : ι} {j : ι}, (ComplexShape.Rel.{u3} ι c i j) -> (CategoryTheory.Iso.{u1, u2} V _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C _inst_3 i)) (CategoryTheory.Limits.kernel.{u1, u2} V _inst_1 _inst_2 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u1, u2, u3} ι V _inst_1 _inst_2 c C i j) (HomologicalComplex.cyclesIsoKernel._proof_1.{u2, u3, u1} ι V _inst_1 _inst_2 c C _inst_3 i j)))
but is expected to have type
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] {i : ι} {j : ι}, (ComplexShape.Rel.{u3} ι c i j) -> (CategoryTheory.Iso.{u1, u2} V _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C _inst_3 i)) (CategoryTheory.Limits.kernel.{u1, u2} V _inst_1 _inst_2 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u1, u2, u3} ι V _inst_1 _inst_2 c C i j) (CategoryTheory.Limits.HasKernels.has_limit.{u1, u2} V _inst_1 _inst_2 _inst_3 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u1, u2, u3} ι V _inst_1 _inst_2 c C i j))))
Case conversion may be inaccurate. Consider using '#align homological_complex.cycles_iso_kernel HomologicalComplex.cyclesIsoKernelₓ'. -/
/-- The underlying object of `C.cycles i` is isomorphic to `kernel (C.d i j)`,
for any `j` such that `rel i j`.
-/
def cyclesIsoKernel {i j : ι} (r : c.Rel i j) : (C.cycles i : V) ≅ kernel (C.d i j) :=
  Subobject.isoOfEq _ _ (C.cycles_eq_kernelSubobject r) ≪≫ kernelSubobjectIso (C.d i j)
#align homological_complex.cycles_iso_kernel HomologicalComplex.cyclesIsoKernel

/- warning: homological_complex.cycles_eq_top -> HomologicalComplex.cycles_eq_top is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] {i : ι}, (Not (ComplexShape.Rel.{u3} ι c i (ComplexShape.next.{u3} ι c i))) -> (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C _inst_3 i) (Top.top.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (OrderTop.toHasTop.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.Subobject.partialOrder.{u2, u1} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)))) (CategoryTheory.Subobject.orderTop.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)))))
but is expected to have type
  forall {ι : Type.{u1}} {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} V _inst_1] {c : ComplexShape.{u1} ι} (C : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasKernels.{u2, u3} V _inst_1 _inst_2] {i : ι}, (Not (ComplexShape.Rel.{u1} ι c i (ComplexShape.next.{u1} ι c i))) -> (Eq.{max (succ u3) (succ u2)} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C _inst_3 i) (Top.top.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (OrderTop.toTop.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (Preorder.toLE.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)))) (CategoryTheory.Subobject.orderTop.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)))))
Case conversion may be inaccurate. Consider using '#align homological_complex.cycles_eq_top HomologicalComplex.cycles_eq_topₓ'. -/
theorem cycles_eq_top {i} (h : ¬c.Rel i (c.next i)) : C.cycles i = ⊤ :=
  by
  rw [eq_top_iff]
  apply le_kernel_subobject
  rw [C.d_from_eq_zero h, comp_zero]
#align homological_complex.cycles_eq_top HomologicalComplex.cycles_eq_top

end Cycles

section Boundaries

variable [HasImages V]

#print HomologicalComplex.boundaries /-
/-- The boundaries at index `i`, as a subobject. -/
abbrev boundaries (C : HomologicalComplex V c) (j : ι) : Subobject (C.pt j) :=
  imageSubobject (C.dTo j)
#align homological_complex.boundaries HomologicalComplex.boundaries
-/

/- warning: homological_complex.boundaries_eq_image_subobject -> HomologicalComplex.boundaries_eq_imageSubobject is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasEqualizers.{u1, u2} V _inst_1] {i : ι} {j : ι}, (ComplexShape.Rel.{u3} ι c i j) -> (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C j) (CategoryTheory.Limits.imageSubobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u1, u2, u3} ι V _inst_1 _inst_2 c C i j) (CategoryTheory.Limits.HasImages.hasImage.{u1, u2} V _inst_1 _inst_3 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u1, u2, u3} ι V _inst_1 _inst_2 c C i j))))
but is expected to have type
  forall {ι : Type.{u1}} {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} V _inst_1] {c : ComplexShape.{u1} ι} (C : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasImages.{u2, u3} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasEqualizers.{u2, u3} V _inst_1] {i : ι} {j : ι}, (ComplexShape.Rel.{u1} ι c i j) -> (Eq.{max (succ u3) (succ u2)} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j)) (HomologicalComplex.boundaries.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_3 C j) (CategoryTheory.Limits.imageSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u2, u3, u1} ι V _inst_1 _inst_2 c C i j) (CategoryTheory.Limits.HasImages.has_image.{u2, u3} V _inst_1 _inst_3 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u2, u3, u1} ι V _inst_1 _inst_2 c C i j))))
Case conversion may be inaccurate. Consider using '#align homological_complex.boundaries_eq_image_subobject HomologicalComplex.boundaries_eq_imageSubobjectₓ'. -/
theorem boundaries_eq_imageSubobject [HasEqualizers V] {i j : ι} (r : c.Rel i j) :
    C.boundaries j = imageSubobject (C.d i j) :=
  C.image_to_eq_image r
#align homological_complex.boundaries_eq_image_subobject HomologicalComplex.boundaries_eq_imageSubobject

/- warning: homological_complex.boundaries_iso_image -> HomologicalComplex.boundariesIsoImage is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasEqualizers.{u1, u2} V _inst_1] {i : ι} {j : ι}, (ComplexShape.Rel.{u3} ι c i j) -> (CategoryTheory.Iso.{u1, u2} V _inst_1 ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j))))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C j)) (CategoryTheory.Limits.image.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u1, u2, u3} ι V _inst_1 _inst_2 c C i j) (HomologicalComplex.boundariesIsoImage._proof_1.{u2, u3, u1} ι V _inst_1 _inst_2 c C _inst_3 i j)))
but is expected to have type
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasEqualizers.{u1, u2} V _inst_1] {i : ι} {j : ι}, (ComplexShape.Rel.{u3} ι c i j) -> (CategoryTheory.Iso.{u1, u2} V _inst_1 (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C j)) (CategoryTheory.Limits.image.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u1, u2, u3} ι V _inst_1 _inst_2 c C i j) (CategoryTheory.Limits.HasImages.has_image.{u1, u2} V _inst_1 _inst_3 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C j) (HomologicalComplex.d.{u1, u2, u3} ι V _inst_1 _inst_2 c C i j))))
Case conversion may be inaccurate. Consider using '#align homological_complex.boundaries_iso_image HomologicalComplex.boundariesIsoImageₓ'. -/
/-- The underlying object of `C.boundaries j` is isomorphic to `image (C.d i j)`,
for any `i` such that `rel i j`.
-/
def boundariesIsoImage [HasEqualizers V] {i j : ι} (r : c.Rel i j) :
    (C.boundaries j : V) ≅ image (C.d i j) :=
  Subobject.isoOfEq _ _ (C.boundaries_eq_imageSubobject r) ≪≫ imageSubobjectIso (C.d i j)
#align homological_complex.boundaries_iso_image HomologicalComplex.boundariesIsoImage

/- warning: homological_complex.boundaries_eq_bot -> HomologicalComplex.boundaries_eq_bot is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroObject.{u1, u2} V _inst_1] {j : ι}, (Not (ComplexShape.Rel.{u3} ι c (ComplexShape.prev.{u3} ι c j) j)) -> (Eq.{succ (max u2 u1)} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C j) (Bot.bot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (OrderBot.toHasBot.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)) (CategoryTheory.Subobject.partialOrder.{u2, u1} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)))) (CategoryTheory.Subobject.orderBot.{u1, u2} V _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u1, u2} V _inst_1 _inst_4) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u1, u2} V _inst_1 _inst_4) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C j)))))
but is expected to have type
  forall {ι : Type.{u1}} {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} V _inst_1] {c : ComplexShape.{u1} ι} (C : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) [_inst_3 : CategoryTheory.Limits.HasImages.{u2, u3} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasZeroObject.{u2, u3} V _inst_1] {j : ι}, (Not (ComplexShape.Rel.{u1} ι c (ComplexShape.prev.{u1} ι c j) j)) -> (Eq.{max (succ u3) (succ u2)} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j)) (HomologicalComplex.boundaries.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_3 C j) (Bot.bot.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j)) (OrderBot.toBot.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j)) (Preorder.toLE.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j)))) (CategoryTheory.Subobject.orderBot.{u2, u3} V _inst_1 (CategoryTheory.Limits.HasZeroObject.hasInitial.{u2, u3} V _inst_1 _inst_4) (CategoryTheory.Limits.HasZeroObject.initialMonoClass.{u2, u3} V _inst_1 _inst_4) (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C j)))))
Case conversion may be inaccurate. Consider using '#align homological_complex.boundaries_eq_bot HomologicalComplex.boundaries_eq_botₓ'. -/
theorem boundaries_eq_bot [HasZeroObject V] {j} (h : ¬c.Rel (c.prev j) j) : C.boundaries j = ⊥ :=
  by
  rw [eq_bot_iff]
  refine' image_subobject_le _ 0 _
  rw [C.d_to_eq_zero h, zero_comp]
#align homological_complex.boundaries_eq_bot HomologicalComplex.boundaries_eq_bot

end Boundaries

section

variable [HasKernels V] [HasImages V]

/- warning: homological_complex.boundaries_le_cycles -> HomologicalComplex.boundaries_le_cycles is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] [_inst_4 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (i : ι), LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.Subobject.partialOrder.{u2, u1} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 C i) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C _inst_3 i)
but is expected to have type
  forall {ι : Type.{u1}} {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} V _inst_1] {c : ComplexShape.{u1} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u2, u3} V _inst_1 _inst_2] [_inst_4 : CategoryTheory.Limits.HasImages.{u2, u3} V _inst_1] (C : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (i : ι), LE.le.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (Preorder.toLE.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)))) (HomologicalComplex.boundaries.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_4 C i) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C _inst_3 i)
Case conversion may be inaccurate. Consider using '#align homological_complex.boundaries_le_cycles HomologicalComplex.boundaries_le_cyclesₓ'. -/
theorem boundaries_le_cycles (C : HomologicalComplex V c) (i : ι) : C.boundaries i ≤ C.cycles i :=
  image_le_kernel _ _ (C.dTo_comp_dFrom i)
#align homological_complex.boundaries_le_cycles HomologicalComplex.boundaries_le_cycles

/- warning: homological_complex.boundaries_to_cycles -> HomologicalComplex.boundariesToCycles is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] [_inst_4 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (i : ι), Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i))))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 C i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C _inst_3 i))
but is expected to have type
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] [_inst_4 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (i : ι), Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 C i)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C i))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C _inst_3 i))
Case conversion may be inaccurate. Consider using '#align homological_complex.boundaries_to_cycles HomologicalComplex.boundariesToCyclesₓ'. -/
/-- The canonical map from `boundaries i` to `cycles i`.
-/
abbrev boundariesToCycles (C : HomologicalComplex V c) (i : ι) :
    (C.boundaries i : V) ⟶ (C.cycles i : V) :=
  imageToKernel _ _ (C.dTo_comp_dFrom i)
#align homological_complex.boundaries_to_cycles HomologicalComplex.boundariesToCycles

/- warning: homological_complex.image_to_kernel_as_boundaries_to_cycles -> HomologicalComplex.imageToKernel_as_boundariesToCycles is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] [_inst_4 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] (C : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (i : ι) (h : LE.le.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (Preorder.toHasLe.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.Subobject.partialOrder.{u2, u1} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 C i) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C _inst_3 i)), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i))))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 C i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C _inst_3 i))) (CategoryTheory.Subobject.ofLE.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 C i) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C _inst_3 i) h) (HomologicalComplex.boundariesToCycles.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 _inst_4 C i)
but is expected to have type
  forall {ι : Type.{u1}} {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} V _inst_1] {c : ComplexShape.{u1} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u2, u3} V _inst_1 _inst_2] [_inst_4 : CategoryTheory.Limits.HasImages.{u2, u3} V _inst_1] (C : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (i : ι) (h : LE.le.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (Preorder.toLE.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)))) (HomologicalComplex.boundaries.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_4 C i) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C _inst_3 i)), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i))) (HomologicalComplex.boundaries.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_4 C i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C _inst_3 i))) (CategoryTheory.Subobject.ofLE.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C i) (HomologicalComplex.boundaries.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_4 C i) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C _inst_3 i) h) (HomologicalComplex.boundariesToCycles.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_3 _inst_4 C i)
Case conversion may be inaccurate. Consider using '#align homological_complex.image_to_kernel_as_boundaries_to_cycles HomologicalComplex.imageToKernel_as_boundariesToCyclesₓ'. -/
/-- Prefer `boundaries_to_cycles`. -/
@[simp]
theorem imageToKernel_as_boundariesToCycles (C : HomologicalComplex V c) (i : ι) (h) :
    (C.boundaries i).of_le (C.cycles i) h = C.boundariesToCycles i :=
  rfl
#align homological_complex.image_to_kernel_as_boundaries_to_cycles HomologicalComplex.imageToKernel_as_boundariesToCycles

variable [HasCokernels V]

#print HomologicalComplex.homology /-
/-- The homology of a complex at index `i`.
-/
abbrev homology (C : HomologicalComplex V c) (i : ι) : V :=
  homology (C.dTo i) (C.dFrom i) (C.dTo_comp_dFrom i)
#align homological_complex.homology HomologicalComplex.homology
-/

#print HomologicalComplex.homologyIso /-
/-- The `j`th homology of a homological complex (as kernel of 'the differential from `Cⱼ`' modulo
the image of 'the differential to `Cⱼ`') is isomorphic to the kernel of `d : Cⱼ → Cₖ` modulo
the image of `d : Cᵢ → Cⱼ` when `rel i j` and `rel j k`. -/
def homologyIso (C : HomologicalComplex V c) {i j k : ι} (hij : c.Rel i j) (hjk : c.Rel j k) :
    C.homology j ≅ homology (C.d i j) (C.d j k) (C.d_comp_d i j k) :=
  homology.mapIso _ _
    (Arrow.isoMk (C.xPrevIso hij) (Iso.refl _) <| by dsimp <;> rw [C.d_to_eq hij, category.comp_id])
    (Arrow.isoMk (Iso.refl _) (C.xNextIso hjk) <| by
      dsimp <;> rw [C.d_from_comp_X_next_iso hjk, category.id_comp])
    rfl
#align homological_complex.homology_iso HomologicalComplex.homologyIso
-/

end

end HomologicalComplex

#print ChainComplex.homologyZeroIso /-
/-- The 0th homology of a chain complex is isomorphic to the cokernel of `d : C₁ ⟶ C₀`. -/
def ChainComplex.homologyZeroIso [HasKernels V] [HasImages V] [HasCokernels V]
    (C : ChainComplex V ℕ) [Epi (factorThruImage (C.d 1 0))] : C.homology 0 ≅ cokernel (C.d 1 0) :=
  (homology.mapIso _ _
        (Arrow.isoMk (C.xPrevIso rfl) (Iso.refl _) <| by
            rw [C.d_to_eq rfl] <;> exact (category.comp_id _).symm :
          Arrow.mk (C.dTo 0) ≅ Arrow.mk (C.d 1 0))
        (Arrow.isoMk (Iso.refl _) (Iso.refl _) <| by
            simp [C.d_from_eq_zero fun h : _ = _ =>
                one_ne_zero <| by rwa [ChainComplex.next_nat_zero] at h] :
          Arrow.mk (C.dFrom 0) ≅ Arrow.mk 0)
        rfl).trans <|
    homologyOfZeroRight _
#align chain_complex.homology_zero_iso ChainComplex.homologyZeroIso
-/

#print CochainComplex.homologyZeroIso /-
/-- The 0th cohomology of a cochain complex is isomorphic to the kernel of `d : C₀ → C₁`. -/
def CochainComplex.homologyZeroIso [HasZeroObject V] [HasKernels V] [HasImages V] [HasCokernels V]
    (C : CochainComplex V ℕ) : C.homology 0 ≅ kernel (C.d 0 1) :=
  (homology.mapIso _ _
          (Arrow.isoMk (C.xPrevIsoSelf (by rw [CochainComplex.prev_nat_zero] <;> exact one_ne_zero))
              (Iso.refl _) (by simp) :
            Arrow.mk (C.dTo 0) ≅ Arrow.mk 0)
          (Arrow.isoMk (Iso.refl _) (C.xNextIso rfl) (by simp) :
            Arrow.mk (C.dFrom 0) ≅ Arrow.mk (C.d 0 1)) <|
        by simpa).trans <|
    homologyOfZeroLeft _
#align cochain_complex.homology_zero_iso CochainComplex.homologyZeroIso
-/

#print ChainComplex.homologySuccIso /-
/-- The `n + 1`th homology of a chain complex (as kernel of 'the differential from `Cₙ₊₁`' modulo
the image of 'the differential to `Cₙ₊₁`') is isomorphic to the kernel of `d : Cₙ₊₁ → Cₙ` modulo
the image of `d : Cₙ₊₂ → Cₙ₊₁`. -/
def ChainComplex.homologySuccIso [HasKernels V] [HasImages V] [HasCokernels V]
    (C : ChainComplex V ℕ) (n : ℕ) :
    C.homology (n + 1) ≅ homology (C.d (n + 2) (n + 1)) (C.d (n + 1) n) (C.d_comp_d _ _ _) :=
  C.homologyIso rfl rfl
#align chain_complex.homology_succ_iso ChainComplex.homologySuccIso
-/

#print CochainComplex.homologySuccIso /-
/-- The `n + 1`th cohomology of a cochain complex (as kernel of 'the differential from `Cₙ₊₁`'
modulo the image of 'the differential to `Cₙ₊₁`') is isomorphic to the kernel of `d : Cₙ₊₁ → Cₙ₊₂`
modulo the image of `d : Cₙ → Cₙ₊₁`. -/
def CochainComplex.homologySuccIso [HasKernels V] [HasImages V] [HasCokernels V]
    (C : CochainComplex V ℕ) (n : ℕ) :
    C.homology (n + 1) ≅ homology (C.d n (n + 1)) (C.d (n + 1) (n + 2)) (C.d_comp_d _ _ _) :=
  C.homologyIso rfl rfl
#align cochain_complex.homology_succ_iso CochainComplex.homologySuccIso
-/

open HomologicalComplex

/-! Computing the cycles is functorial. -/


section

variable [HasKernels V]

variable {C₁ C₂ C₃ : HomologicalComplex V c} (f : C₁ ⟶ C₂)

/- warning: cycles_map -> cyclesMap is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] {C₁ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} {C₂ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c}, (Quiver.Hom.{succ (max u3 u1), max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (HomologicalComplex.CategoryTheory.category.{u1, u2, u3} ι V _inst_1 _inst_2 c))) C₁ C₂) -> (forall (i : ι), Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ _inst_3 i)))
but is expected to have type
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] {C₁ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} {C₂ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c}, (Quiver.Hom.{max (succ u1) (succ u3), max (max u2 u1) u3} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3, max (max u2 u1) u3} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u1 u3, max (max u2 u1) u3} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (HomologicalComplex.instCategoryHomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c))) C₁ C₂) -> (forall (i : ι), Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ _inst_3 i)))
Case conversion may be inaccurate. Consider using '#align cycles_map cyclesMapₓ'. -/
/-- The morphism between cycles induced by a chain map.
-/
abbrev cyclesMap (f : C₁ ⟶ C₂) (i : ι) : (C₁.cycles i : V) ⟶ (C₂.cycles i : V) :=
  Subobject.factorThru _ ((C₁.cycles i).arrow ≫ f.f i) (kernelSubobject_factors _ _ (by simp))
#align cycles_map cyclesMap

/- warning: cycles_map_arrow -> cyclesMap_arrow is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] {C₁ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} {C₂ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} (f : Quiver.Hom.{succ (max u3 u1), max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (HomologicalComplex.CategoryTheory.category.{u1, u2, u3} ι V _inst_1 _inst_2 c))) C₁ C₂) (i : ι), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.CategoryStruct.comp.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ _inst_3 i)) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i) (cyclesMap.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C₁ C₂ f i) (CategoryTheory.Subobject.arrow.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ _inst_3 i))) (CategoryTheory.CategoryStruct.comp.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i) (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i) (CategoryTheory.Subobject.arrow.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (HomologicalComplex.Hom.f.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ C₂ f i))
but is expected to have type
  forall {ι : Type.{u1}} {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} V _inst_1] {c : ComplexShape.{u1} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u2, u3} V _inst_1 _inst_2] {C₁ : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c} {C₂ : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c} (f : Quiver.Hom.{max (succ u2) (succ u1), max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c))) C₁ C₂) (i : ι), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.CategoryStruct.comp.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ _inst_3 i)) (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i) (cyclesMap.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_3 C₁ C₂ f i) (CategoryTheory.Subobject.arrow.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ _inst_3 i))) (CategoryTheory.CategoryStruct.comp.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i) (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i) (CategoryTheory.Subobject.arrow.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (HomologicalComplex.Hom.f.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ C₂ f i))
Case conversion may be inaccurate. Consider using '#align cycles_map_arrow cyclesMap_arrowₓ'. -/
@[simp, reassoc.1, elementwise]
theorem cyclesMap_arrow (f : C₁ ⟶ C₂) (i : ι) :
    cyclesMap f i ≫ (C₂.cycles i).arrow = (C₁.cycles i).arrow ≫ f.f i := by simp
#align cycles_map_arrow cyclesMap_arrow

/- warning: cycles_map_id -> cyclesMap_id is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] {C₁ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} (i : ι), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i))) (cyclesMap.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C₁ C₁ (CategoryTheory.CategoryStruct.id.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (HomologicalComplex.CategoryTheory.category.{u1, u2, u3} ι V _inst_1 _inst_2 c)) C₁) i) (CategoryTheory.CategoryStruct.id.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i)))
but is expected to have type
  forall {ι : Type.{u1}} {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} V _inst_1] {c : ComplexShape.{u1} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u2, u3} V _inst_1 _inst_2] {C₁ : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c} (i : ι), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ _inst_3 i))) (cyclesMap.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_3 C₁ C₁ (CategoryTheory.CategoryStruct.id.{max u2 u1, max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c)) C₁) i) (CategoryTheory.CategoryStruct.id.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ _inst_3 i)))
Case conversion may be inaccurate. Consider using '#align cycles_map_id cyclesMap_idₓ'. -/
@[simp]
theorem cyclesMap_id (i : ι) : cyclesMap (𝟙 C₁) i = 𝟙 _ :=
  by
  dsimp only [cyclesMap]
  simp
#align cycles_map_id cyclesMap_id

/- warning: cycles_map_comp -> cyclesMap_comp is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u1, u2} V _inst_1 _inst_2] {C₁ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} {C₂ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} {C₃ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} (f : Quiver.Hom.{succ (max u3 u1), max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (HomologicalComplex.CategoryTheory.category.{u1, u2, u3} ι V _inst_1 _inst_2 c))) C₁ C₂) (g : Quiver.Hom.{succ (max u3 u1), max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (HomologicalComplex.CategoryTheory.category.{u1, u2, u3} ι V _inst_1 _inst_2 c))) C₂ C₃) (i : ι), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ _inst_3 i))) (cyclesMap.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C₁ C₃ (CategoryTheory.CategoryStruct.comp.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (HomologicalComplex.CategoryTheory.category.{u1, u2, u3} ι V _inst_1 _inst_2 c)) C₁ C₂ C₃ f g) i) (CategoryTheory.CategoryStruct.comp.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ _inst_3 i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₃ _inst_3 i)) (cyclesMap.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C₁ C₂ f i) (cyclesMap.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C₂ C₃ g i))
but is expected to have type
  forall {ι : Type.{u1}} {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} V _inst_1] {c : ComplexShape.{u1} ι} [_inst_3 : CategoryTheory.Limits.HasKernels.{u2, u3} V _inst_1 _inst_2] {C₁ : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c} {C₂ : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c} {C₃ : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c} (f : Quiver.Hom.{max (succ u2) (succ u1), max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c))) C₁ C₂) (g : Quiver.Hom.{max (succ u2) (succ u1), max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c))) C₂ C₃) (i : ι), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ _inst_3 i))) (cyclesMap.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_3 C₁ C₃ (CategoryTheory.CategoryStruct.comp.{max u1 u2, max (max u1 u3) u2} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u1 u2, max (max u1 u3) u2} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c)) C₁ C₂ C₃ f g) i) (CategoryTheory.CategoryStruct.comp.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ _inst_3 i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ _inst_3 i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₃ _inst_3 i)) (cyclesMap.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_3 C₁ C₂ f i) (cyclesMap.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_3 C₂ C₃ g i))
Case conversion may be inaccurate. Consider using '#align cycles_map_comp cyclesMap_compₓ'. -/
@[simp]
theorem cyclesMap_comp (f : C₁ ⟶ C₂) (g : C₂ ⟶ C₃) (i : ι) :
    cyclesMap (f ≫ g) i = cyclesMap f i ≫ cyclesMap g i :=
  by
  dsimp only [cyclesMap]
  simp [subobject.factor_thru_right]
#align cycles_map_comp cyclesMap_comp

variable (V c)

#print cyclesFunctor /-
/-- Cycles as a functor. -/
@[simps]
def cyclesFunctor (i : ι) : HomologicalComplex V c ⥤ V
    where
  obj C := C.cycles i
  map C₁ C₂ f := cyclesMap f i
#align cycles_functor cyclesFunctor
-/

end

/-! Computing the boundaries is functorial. -/


section

variable [HasImages V] [HasImageMaps V]

variable {C₁ C₂ C₃ : HomologicalComplex V c} (f : C₁ ⟶ C₂)

/- warning: boundaries_map -> boundariesMap is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasImageMaps.{u1, u2} V _inst_1 _inst_3] {C₁ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} {C₂ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c}, (Quiver.Hom.{succ (max u3 u1), max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (HomologicalComplex.CategoryTheory.category.{u1, u2, u3} ι V _inst_1 _inst_2 c))) C₁ C₂) -> (forall (i : ι), Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C₁ i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i))))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C₂ i)))
but is expected to have type
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasImageMaps.{u1, u2} V _inst_1 _inst_3] {C₁ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} {C₂ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c}, (Quiver.Hom.{max (succ u1) (succ u3), max (max u2 u1) u3} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u1 u3, max (max u2 u1) u3} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u1 u3, max (max u2 u1) u3} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (HomologicalComplex.instCategoryHomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c))) C₁ C₂) -> (forall (i : ι), Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C₁ i)) (Prefunctor.obj.{max (succ u2) (succ u1), succ u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, u1, max u2 u1, u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u2 u1} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u1, u2} V _inst_1 (HomologicalComplex.X.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_3 C₂ i)))
Case conversion may be inaccurate. Consider using '#align boundaries_map boundariesMapₓ'. -/
/-- The morphism between boundaries induced by a chain map.
-/
abbrev boundariesMap (f : C₁ ⟶ C₂) (i : ι) : (C₁.boundaries i : V) ⟶ (C₂.boundaries i : V) :=
  imageSubobjectMap (f.sqTo i)
#align boundaries_map boundariesMap

variable (V c)

#print boundariesFunctor /-
/-- Boundaries as a functor. -/
@[simps]
def boundariesFunctor (i : ι) : HomologicalComplex V c ⥤ V
    where
  obj C := C.boundaries i
  map C₁ C₂ f := imageSubobjectMap (f.sqTo i)
#align boundaries_functor boundariesFunctor
-/

end

section

/-! The `boundaries_to_cycles` morphisms are natural. -/


variable [HasEqualizers V] [HasImages V] [HasImageMaps V]

variable {C₁ C₂ : HomologicalComplex V c} (f : C₁ ⟶ C₂)

/- warning: boundaries_to_cycles_naturality -> boundariesToCycles_naturality is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u3}} {V : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u1, u2} V _inst_1] {c : ComplexShape.{u3} ι} [_inst_3 : CategoryTheory.Limits.HasEqualizers.{u1, u2} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasImages.{u1, u2} V _inst_1] [_inst_5 : CategoryTheory.Limits.HasImageMaps.{u1, u2} V _inst_1 _inst_4] {C₁ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} {C₂ : HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c} (f : Quiver.Hom.{succ (max u3 u1), max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u3 u1, max u2 u3 u1} (HomologicalComplex.{u1, u2, u3} ι V _inst_1 _inst_2 c) (HomologicalComplex.CategoryTheory.category.{u1, u2, u3} ι V _inst_1 _inst_2 c))) C₁ C₂) (i : ι), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} V (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 C₁ i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_2 _inst_3) i))) (CategoryTheory.CategoryStruct.comp.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 C₁ i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i))))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 C₂ i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_2 _inst_3) i)) (boundariesMap.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 _inst_5 C₁ C₂ f i) (HomologicalComplex.boundariesToCycles.{u1, u2, u3} ι V _inst_1 _inst_2 c (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_2 _inst_3) _inst_4 C₂ i)) (CategoryTheory.CategoryStruct.comp.{u1, u2} V (CategoryTheory.Category.toCategoryStruct.{u1, u2} V _inst_1) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.boundaries.{u1, u2, u3} ι V _inst_1 _inst_2 c _inst_4 C₁ i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₁ (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_2 _inst_3) i)) ((fun (a : Type.{max u2 u1}) (b : Type.{u2}) [self : HasLiftT.{succ (max u2 u1), succ u2} a b] => self.0) (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (HasLiftT.mk.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CoeTCₓ.coe.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (coeBase.{succ (max u2 u1), succ u2} (CategoryTheory.Subobject.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i)) V (CategoryTheory.Subobject.hasCoe.{u1, u2} V _inst_1 (HomologicalComplex.x.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ i))))) (HomologicalComplex.cycles.{u1, u2, u3} ι V _inst_1 _inst_2 c C₂ (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_2 _inst_3) i)) (HomologicalComplex.boundariesToCycles.{u1, u2, u3} ι V _inst_1 _inst_2 c (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_2 _inst_3) _inst_4 C₁ i) (cyclesMap.{u1, u2, u3} ι V _inst_1 _inst_2 c (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u1, u2} V _inst_1 _inst_2 _inst_3) C₁ C₂ f i))
but is expected to have type
  forall {ι : Type.{u1}} {V : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} V] [_inst_2 : CategoryTheory.Limits.HasZeroMorphisms.{u2, u3} V _inst_1] {c : ComplexShape.{u1} ι} [_inst_3 : CategoryTheory.Limits.HasEqualizers.{u2, u3} V _inst_1] [_inst_4 : CategoryTheory.Limits.HasImages.{u2, u3} V _inst_1] [_inst_5 : CategoryTheory.Limits.HasImageMaps.{u2, u3} V _inst_1 _inst_4] {C₁ : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c} {C₂ : HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c} (f : Quiver.Hom.{max (succ u2) (succ u1), max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (max u3 u2) u1} (HomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c) (HomologicalComplex.instCategoryHomologicalComplex.{u2, u3, u1} ι V _inst_1 _inst_2 c))) C₁ C₂) (i : ι), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.boundaries.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_4 C₁ i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u2, u3} V _inst_1 _inst_2 _inst_3) i))) (CategoryTheory.CategoryStruct.comp.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.boundaries.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_4 C₁ i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i))) (HomologicalComplex.boundaries.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_4 C₂ i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u2, u3} V _inst_1 _inst_2 _inst_3) i)) (boundariesMap.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_4 _inst_5 C₁ C₂ f i) (HomologicalComplex.boundariesToCycles.{u2, u3, u1} ι V _inst_1 _inst_2 c (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u2, u3} V _inst_1 _inst_2 _inst_3) _inst_4 C₂ i)) (CategoryTheory.CategoryStruct.comp.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.boundaries.{u2, u3, u1} ι V _inst_1 _inst_2 c _inst_4 C₁ i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₁ (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u2, u3} V _inst_1 _inst_2 _inst_3) i)) (Prefunctor.obj.{max (succ u3) (succ u2), succ u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))))) V (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} V (CategoryTheory.Category.toCategoryStruct.{u2, u3} V _inst_1)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u2, max u3 u2, u3} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (Preorder.smallCategory.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Subobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)) (CategoryTheory.instPartialOrderSubobject.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i)))) V _inst_1 (CategoryTheory.Subobject.underlying.{u2, u3} V _inst_1 (HomologicalComplex.X.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ i))) (HomologicalComplex.cycles.{u2, u3, u1} ι V _inst_1 _inst_2 c C₂ (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u2, u3} V _inst_1 _inst_2 _inst_3) i)) (HomologicalComplex.boundariesToCycles.{u2, u3, u1} ι V _inst_1 _inst_2 c (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u2, u3} V _inst_1 _inst_2 _inst_3) _inst_4 C₁ i) (cyclesMap.{u2, u3, u1} ι V _inst_1 _inst_2 c (CategoryTheory.Limits.hasKernels_of_hasEqualizers.{u2, u3} V _inst_1 _inst_2 _inst_3) C₁ C₂ f i))
Case conversion may be inaccurate. Consider using '#align boundaries_to_cycles_naturality boundariesToCycles_naturalityₓ'. -/
@[simp, reassoc.1]
theorem boundariesToCycles_naturality (i : ι) :
    boundariesMap f i ≫ C₂.boundariesToCycles i = C₁.boundariesToCycles i ≫ cyclesMap f i :=
  by
  ext
  simp
#align boundaries_to_cycles_naturality boundariesToCycles_naturality

variable (V c)

#print boundariesToCyclesNatTrans /-
/-- The natural transformation from the boundaries functor to the cycles functor. -/
@[simps]
def boundariesToCyclesNatTrans (i : ι) : boundariesFunctor V c i ⟶ cyclesFunctor V c i
    where
  app C := C.boundariesToCycles i
  naturality' C₁ C₂ f := boundariesToCycles_naturality f i
#align boundaries_to_cycles_nat_trans boundariesToCyclesNatTrans
-/

#print homologyFunctor /-
/-- The `i`-th homology, as a functor to `V`. -/
@[simps]
def homologyFunctor [HasCokernels V] (i : ι) : HomologicalComplex V c ⥤ V
    where
  -- It would be nice if we could just write
  -- `cokernel (boundaries_to_cycles_nat_trans V c i)`
  -- here, but universe implementation details get in the way...
  obj C := C.homology i
  map C₁ C₂ f := homology.map _ _ (f.sqTo i) (f.sqFrom i) rfl
  map_id' := by
    intros ; ext1
    simp only [homology.π_map, kernel_subobject_map_id, hom.sq_from_id, category.id_comp,
      category.comp_id]
  map_comp' := by
    intros ; ext1
    simp only [hom.sq_from_comp, kernel_subobject_map_comp, homology.π_map_assoc, homology.π_map,
      category.assoc]
#align homology_functor homologyFunctor
-/

#print gradedHomologyFunctor /-
/-- The homology functor from `ι`-indexed complexes to `ι`-graded objects in `V`. -/
@[simps]
def gradedHomologyFunctor [HasCokernels V] : HomologicalComplex V c ⥤ GradedObject ι V
    where
  obj C i := C.homology i
  map C C' f i := (homologyFunctor V c i).map f
  map_id' := by
    intros ; ext
    simp only [pi.id_apply, homology.π_map, homologyFunctor_map, kernel_subobject_map_id,
      hom.sq_from_id, category.id_comp, category.comp_id]
  map_comp' := by
    intros ; ext
    simp only [hom.sq_from_comp, kernel_subobject_map_comp, homology.π_map_assoc, pi.comp_apply,
      homology.π_map, homologyFunctor_map, category.assoc]
#align graded_homology_functor gradedHomologyFunctor
-/

end

