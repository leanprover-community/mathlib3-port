/-
Copyright (c) 2018 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin

! This file was ported from Lean 3 source module algebra.category.Group.basic
! leanprover-community/mathlib commit cb3ceec8485239a61ed51d944cb9a95b68c6bafc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Category.Mon.Basic
import Mathbin.CategoryTheory.Endomorphism

/-!
# Category instances for group, add_group, comm_group, and add_comm_group.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We introduce the bundled categories:
* `Group`
* `AddGroup`
* `CommGroup`
* `AddCommGroup`
along with the relevant forgetful functors between them, and to the bundled monoid categories.
-/


universe u v

open CategoryTheory

#print GroupCat /-
/-- The category of groups and group morphisms. -/
@[to_additive AddGroupCat]
def GroupCat : Type (u + 1) :=
  Bundled Group
#align Group GroupCat
#align AddGroup AddGroupCat
-/

/-- The category of additive groups and group morphisms -/
add_decl_doc AddGroupCat

namespace GroupCat

@[to_additive]
instance : BundledHom.ParentProjection Group.toMonoid :=
  ⟨⟩

deriving instance LargeCategory, ConcreteCategory for GroupCat

attribute [to_additive] GroupCat.largeCategory GroupCat.concreteCategory

@[to_additive]
instance : CoeSort GroupCat (Type _) :=
  Bundled.hasCoeToSort

#print GroupCat.of /-
/-- Construct a bundled `Group` from the underlying type and typeclass. -/
@[to_additive]
def of (X : Type u) [Group X] : GroupCat :=
  Bundled.of X
#align Group.of GroupCat.of
#align AddGroup.of AddGroupCat.of
-/

/-- Construct a bundled `AddGroup` from the underlying type and typeclass. -/
add_decl_doc AddGroupCat.of

#print GroupCat.ofHom /-
/-- Typecheck a `monoid_hom` as a morphism in `Group`. -/
@[to_additive]
def ofHom {X Y : Type u} [Group X] [Group Y] (f : X →* Y) : of X ⟶ of Y :=
  f
#align Group.of_hom GroupCat.ofHom
#align AddGroup.of_hom AddGroupCat.ofHom
-/

/-- Typecheck a `add_monoid_hom` as a morphism in `AddGroup`. -/
add_decl_doc AddGroupCat.ofHom

/- warning: Group.of_hom_apply -> GroupCat.ofHom_apply is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u1}} [_inst_1 : Group.{u1} X] [_inst_2 : Group.{u1} Y] (f : MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2)))) (x : X), Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} Y _inst_2)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) (GroupCat.of.{u1} X _inst_1) (GroupCat.of.{u1} Y _inst_2)) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} X _inst_1)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} X _inst_1)) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} Y _inst_2)) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} Y _inst_2)) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} X _inst_1)) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} Y _inst_2))) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} X _inst_1)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} X _inst_1)) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} Y _inst_2)) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) (GroupCat.of.{u1} Y _inst_2)) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2))))) (GroupCat.ofHom.{u1} X Y _inst_1 _inst_2 f) x) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2)))) (fun (_x : MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2)))) => X -> Y) (MonoidHom.hasCoeToFun.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2)))) f x)
but is expected to have type
  forall {X : Type.{u1}} {Y : Type.{u1}} [_inst_1 : Group.{u1} X] [_inst_2 : Group.{u1} Y] (f : MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2)))) (x : X), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} X _inst_1))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} Y _inst_2)))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (fun (_x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} X _inst_1))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} Y _inst_2)))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} X _inst_1)))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} Y _inst_2)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} X _inst_1))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} Y _inst_2)))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} X _inst_1))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} Y _inst_2))))) (MonoidHom.monoidHomClass.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} X _inst_1)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} X _inst_1))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} (GroupCat.of.{u1} Y _inst_2)) (GroupCat.instGroupα.{u1} (GroupCat.of.{u1} Y _inst_2)))))))) (GroupCat.ofHom.{u1} X Y _inst_1 _inst_2 f) x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2)))) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : X) => Y) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2)))) X Y (MulOneClass.toMul.{u1} X (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1)))) (MulOneClass.toMul.{u1} Y (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2)))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2)))) X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2))) (MonoidHom.monoidHomClass.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X _inst_1))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y _inst_2)))))) f x)
Case conversion may be inaccurate. Consider using '#align Group.of_hom_apply GroupCat.ofHom_applyₓ'. -/
@[simp, to_additive]
theorem ofHom_apply {X Y : Type _} [Group X] [Group Y] (f : X →* Y) (x : X) : ofHom f x = f x :=
  rfl
#align Group.of_hom_apply GroupCat.ofHom_apply
#align AddGroup.of_hom_apply AddGroupCat.ofHom_apply

@[to_additive]
instance (G : GroupCat) : Group G :=
  G.str

#print GroupCat.coe_of /-
@[simp, to_additive]
theorem coe_of (R : Type u) [Group R] : (GroupCat.of R : Type u) = R :=
  rfl
#align Group.coe_of GroupCat.coe_of
#align AddGroup.coe_of AddGroupCat.coe_of
-/

@[to_additive]
instance : Inhabited GroupCat :=
  ⟨GroupCat.of PUnit⟩

#print GroupCat.ofUnique /-
@[to_additive]
instance ofUnique (G : Type _) [Group G] [i : Unique G] : Unique (GroupCat.of G) :=
  i
#align Group.of_unique GroupCat.ofUnique
#align AddGroup.of_unique AddGroupCat.ofUnique
-/

/- warning: Group.one_apply -> GroupCat.one_apply is a dubious translation:
lean 3 declaration is
  forall (G : GroupCat.{u1}) (H : GroupCat.{u1}) (g : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} G), Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) G H) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} G))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} H)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} G))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} H)))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) G H) 1 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) G H) 1 (One.one.{u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) G H) (MonoidHom.hasOne.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} G))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} H))))))) g) (OfNat.ofNat.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) 1 (OfNat.mk.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) 1 (One.one.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (MulOneClass.toHasOne.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (GroupCat.group.{u1} H))))))))
but is expected to have type
  forall (G : GroupCat.{u1}) (H : GroupCat.{u1}) (g : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) g) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (fun (_x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H)))) (MonoidHom.monoidHomClass.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} instGroupCatLargeCategory.{u1})) G H) 1 (One.toOfNat1.{u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} instGroupCatLargeCategory.{u1})) G H) (GroupCat.instOneHomGroupCatToQuiverToCategoryStructInstGroupCatLargeCategory.{u1} G H))) g) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) g) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) g) (InvOneClass.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) g) (DivInvOneMonoid.toInvOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) g) (DivisionMonoid.toDivInvOneMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) g) (Group.toDivisionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) g) (GroupCat.instGroupα.{u1} H)))))))
Case conversion may be inaccurate. Consider using '#align Group.one_apply GroupCat.one_applyₓ'. -/
@[simp, to_additive]
theorem one_apply (G H : GroupCat) (g : G) : (1 : G ⟶ H) g = 1 :=
  rfl
#align Group.one_apply GroupCat.one_apply
#align AddGroup.zero_apply AddGroupCat.zero_apply

/- warning: Group.ext -> GroupCat.ext is a dubious translation:
lean 3 declaration is
  forall (G : GroupCat.{u1}) (H : GroupCat.{u1}) (f₁ : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) G H) (f₂ : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) G H), (forall (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G), Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) G H) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} G))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} H)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} G))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} H)))) f₁ x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) G H) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} G))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} H)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} G))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} H)))) f₂ x)) -> (Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) G H) f₁ f₂)
but is expected to have type
  forall {G : GroupCat.{u1}} {H : GroupCat.{u1}} {f₁ : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} instGroupCatLargeCategory.{u1})) G H} {f₂ : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} instGroupCatLargeCategory.{u1})) G H}, (forall (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (fun (_x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H)))) (MonoidHom.monoidHomClass.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))))) f₁ x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (fun (_x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H)))) (MonoidHom.monoidHomClass.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} G) (GroupCat.instGroupα.{u1} G)))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} H) (GroupCat.instGroupα.{u1} H))))))) f₂ x)) -> (Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} instGroupCatLargeCategory.{u1})) G H) f₁ f₂)
Case conversion may be inaccurate. Consider using '#align Group.ext GroupCat.extₓ'. -/
@[ext, to_additive]
theorem ext (G H : GroupCat) (f₁ f₂ : G ⟶ H) (w : ∀ x, f₁ x = f₂ x) : f₁ = f₂ :=
  by
  ext1
  apply w
#align Group.ext GroupCat.ext
#align AddGroup.ext AddGroupCat.ext

#print GroupCat.hasForgetToMonCat /-
@[to_additive has_forget_to_AddMon]
instance hasForgetToMonCat : HasForget₂ GroupCat MonCat :=
  BundledHom.forget₂ _ _
#align Group.has_forget_to_Mon GroupCat.hasForgetToMonCat
#align AddGroup.has_forget_to_AddMon AddGroupCat.hasForgetToAddMonCat
-/

@[to_additive]
instance : Coe GroupCat.{u} MonCat.{u} where coe := (forget₂ GroupCat MonCat).obj

end GroupCat

#print CommGroupCat /-
/-- The category of commutative groups and group morphisms. -/
@[to_additive AddCommGroupCat]
def CommGroupCat : Type (u + 1) :=
  Bundled CommGroup
#align CommGroup CommGroupCat
#align AddCommGroup AddCommGroupCat
-/

/-- The category of additive commutative groups and group morphisms. -/
add_decl_doc AddCommGroupCat

#print Ab /-
/-- `Ab` is an abbreviation for `AddCommGroup`, for the sake of mathematicians' sanity. -/
abbrev Ab :=
  AddCommGroupCat
#align Ab Ab
-/

namespace CommGroupCat

@[to_additive]
instance : BundledHom.ParentProjection CommGroup.toGroup :=
  ⟨⟩

deriving instance LargeCategory, ConcreteCategory for CommGroupCat

attribute [to_additive] CommGroupCat.largeCategory CommGroupCat.concreteCategory

@[to_additive]
instance : CoeSort CommGroupCat (Type _) :=
  Bundled.hasCoeToSort

#print CommGroupCat.of /-
/-- Construct a bundled `CommGroup` from the underlying type and typeclass. -/
@[to_additive]
def of (G : Type u) [CommGroup G] : CommGroupCat :=
  Bundled.of G
#align CommGroup.of CommGroupCat.of
#align AddCommGroup.of AddCommGroupCat.of
-/

/-- Construct a bundled `AddCommGroup` from the underlying type and typeclass. -/
add_decl_doc AddCommGroupCat.of

#print CommGroupCat.ofHom /-
/-- Typecheck a `monoid_hom` as a morphism in `CommGroup`. -/
@[to_additive]
def ofHom {X Y : Type u} [CommGroup X] [CommGroup Y] (f : X →* Y) : of X ⟶ of Y :=
  f
#align CommGroup.of_hom CommGroupCat.ofHom
#align AddCommGroup.of_hom AddCommGroupCat.ofHom
-/

/-- Typecheck a `add_monoid_hom` as a morphism in `AddCommGroup`. -/
add_decl_doc AddCommGroupCat.ofHom

/- warning: CommGroup.of_hom_apply -> CommGroupCat.ofHom_apply is a dubious translation:
lean 3 declaration is
  forall {X : Type.{u1}} {Y : Type.{u1}} [_inst_1 : CommGroup.{u1} X] [_inst_2 : CommGroup.{u1} Y] (f : MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2))))) (x : X), Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} Y _inst_2)) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) (CommGroupCat.of.{u1} X _inst_1) (CommGroupCat.of.{u1} Y _inst_2)) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} X _inst_1)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} X _inst_1)) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} X _inst_1)) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1))))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} Y _inst_2)) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} Y _inst_2)) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} Y _inst_2)) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} X _inst_1)) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} Y _inst_2))) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} X _inst_1)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} X _inst_1)) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} X _inst_1)) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1))))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} Y _inst_2)) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} Y _inst_2)) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) (CommGroupCat.of.{u1} Y _inst_2)) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)))))) (CommGroupCat.ofHom.{u1} X Y _inst_1 _inst_2 f) x) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2))))) (fun (_x : MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2))))) => X -> Y) (MonoidHom.hasCoeToFun.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2))))) f x)
but is expected to have type
  forall {X : Type.{u1}} {Y : Type.{u1}} [_inst_1 : CommGroup.{u1} X] [_inst_2 : CommGroup.{u1} Y] (f : MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2))))) (x : X), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} X _inst_1)))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} Y _inst_2))))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (fun (_x : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} X _inst_1)))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} Y _inst_2))))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} X _inst_1))))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} Y _inst_2))))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} X _inst_1)))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} Y _inst_2))))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} X _inst_1)))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} Y _inst_2)))))) (MonoidHom.monoidHomClass.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} X _inst_1)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} X _inst_1)))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} (CommGroupCat.of.{u1} Y _inst_2)) (CommGroupCat.commGroupInstance.{u1} (CommGroupCat.of.{u1} Y _inst_2))))))))) (CommGroupCat.ofHom.{u1} X Y _inst_1 _inst_2 f) x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2))))) X (fun (_x : X) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : X) => Y) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2))))) X Y (MulOneClass.toMul.{u1} X (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1))))) (MulOneClass.toMul.{u1} Y (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2))))) X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2)))) (MonoidHom.monoidHomClass.{u1, u1} X Y (Monoid.toMulOneClass.{u1} X (DivInvMonoid.toMonoid.{u1} X (Group.toDivInvMonoid.{u1} X (CommGroup.toGroup.{u1} X _inst_1)))) (Monoid.toMulOneClass.{u1} Y (DivInvMonoid.toMonoid.{u1} Y (Group.toDivInvMonoid.{u1} Y (CommGroup.toGroup.{u1} Y _inst_2))))))) f x)
Case conversion may be inaccurate. Consider using '#align CommGroup.of_hom_apply CommGroupCat.ofHom_applyₓ'. -/
@[simp, to_additive]
theorem ofHom_apply {X Y : Type _} [CommGroup X] [CommGroup Y] (f : X →* Y) (x : X) :
    ofHom f x = f x :=
  rfl
#align CommGroup.of_hom_apply CommGroupCat.ofHom_apply
#align AddCommGroup.of_hom_apply AddCommGroupCat.ofHom_apply

#print CommGroupCat.commGroupInstance /-
@[to_additive]
instance commGroupInstance (G : CommGroupCat) : CommGroup G :=
  G.str
#align CommGroup.comm_group_instance CommGroupCat.commGroupInstance
#align AddCommGroup.add_comm_group_instance AddCommGroupCat.addCommGroupInstance
-/

#print CommGroupCat.coe_of /-
@[simp, to_additive]
theorem coe_of (R : Type u) [CommGroup R] : (CommGroupCat.of R : Type u) = R :=
  rfl
#align CommGroup.coe_of CommGroupCat.coe_of
#align AddCommGroup.coe_of AddCommGroupCat.coe_of
-/

@[to_additive]
instance : Inhabited CommGroupCat :=
  ⟨CommGroupCat.of PUnit⟩

#print CommGroupCat.ofUnique /-
@[to_additive]
instance ofUnique (G : Type _) [CommGroup G] [i : Unique G] : Unique (CommGroupCat.of G) :=
  i
#align CommGroup.of_unique CommGroupCat.ofUnique
#align AddCommGroup.of_unique AddCommGroupCat.ofUnique
-/

/- warning: CommGroup.one_apply -> CommGroupCat.one_apply is a dubious translation:
lean 3 declaration is
  forall (G : CommGroupCat.{u1}) (H : CommGroupCat.{u1}) (g : coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} G), Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) G H) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} G)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} H))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} G)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} H))))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) G H) 1 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) G H) 1 (One.one.{u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) G H) (MonoidHom.hasOne.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} G)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} H)))))))) g) (OfNat.ofNat.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) 1 (OfNat.mk.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) 1 (One.one.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (MulOneClass.toHasOne.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CommGroupCat.commGroupInstance.{u1} H)))))))))
but is expected to have type
  forall (G : CommGroupCat.{u1}) (H : CommGroupCat.{u1}) (g : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) g) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (fun (_x : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G)))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H))))) (MonoidHom.monoidHomClass.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))))) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} instCommGroupCatLargeCategory.{u1})) G H) 1 (One.toOfNat1.{u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} instCommGroupCatLargeCategory.{u1})) G H) (CommGroupCat.instOneHomCommGroupCatToQuiverToCategoryStructInstCommGroupCatLargeCategory.{u1} G H))) g) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) g) 1 (One.toOfNat1.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) g) (InvOneClass.toOne.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) g) (DivInvOneMonoid.toInvOneClass.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) g) (DivisionMonoid.toDivInvOneMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) g) (DivisionCommMonoid.toDivisionMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) g) (CommGroup.toDivisionCommMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) g) (CommGroupCat.commGroupInstance.{u1} H))))))))
Case conversion may be inaccurate. Consider using '#align CommGroup.one_apply CommGroupCat.one_applyₓ'. -/
@[simp, to_additive]
theorem one_apply (G H : CommGroupCat) (g : G) : (1 : G ⟶ H) g = 1 :=
  rfl
#align CommGroup.one_apply CommGroupCat.one_apply
#align AddCommGroup.zero_apply AddCommGroupCat.zero_apply

/- warning: CommGroup.ext -> CommGroupCat.ext is a dubious translation:
lean 3 declaration is
  forall (G : CommGroupCat.{u1}) (H : CommGroupCat.{u1}) (f₁ : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) G H) (f₂ : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) G H), (forall (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G), Eq.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) G H) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} G)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} H))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} G)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} H))))) f₁ x) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) G H) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} G)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} H))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) G) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} G)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) H) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} H))))) f₂ x)) -> (Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) G H) f₁ f₂)
but is expected to have type
  forall {G : CommGroupCat.{u1}} {H : CommGroupCat.{u1}} {f₁ : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} instCommGroupCatLargeCategory.{u1})) G H} {f₂ : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} instCommGroupCatLargeCategory.{u1})) G H}, (forall (x : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (fun (_x : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G)))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H))))) (MonoidHom.monoidHomClass.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))))) f₁ x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (fun (_x : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) => CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G)))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H))))) (MonoidHom.monoidHomClass.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} G) (CommGroupCat.commGroupInstance.{u1} G))))) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} H) (CommGroupCat.commGroupInstance.{u1} H)))))))) f₂ x)) -> (Eq.{succ u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} instCommGroupCatLargeCategory.{u1})) G H) f₁ f₂)
Case conversion may be inaccurate. Consider using '#align CommGroup.ext CommGroupCat.extₓ'. -/
@[ext, to_additive]
theorem ext (G H : CommGroupCat) (f₁ f₂ : G ⟶ H) (w : ∀ x, f₁ x = f₂ x) : f₁ = f₂ :=
  by
  ext1
  apply w
#align CommGroup.ext CommGroupCat.ext
#align AddCommGroup.ext AddCommGroupCat.ext

#print CommGroupCat.hasForgetToGroup /-
@[to_additive has_forget_to_AddGroup]
instance hasForgetToGroup : HasForget₂ CommGroupCat GroupCat :=
  BundledHom.forget₂ _ _
#align CommGroup.has_forget_to_Group CommGroupCat.hasForgetToGroup
#align AddCommGroup.has_forget_to_AddGroup AddCommGroupCat.hasForgetToAddGroup
-/

@[to_additive]
instance : Coe CommGroupCat.{u} GroupCat.{u} where coe := (forget₂ CommGroupCat GroupCat).obj

#print CommGroupCat.hasForgetToCommMonCat /-
@[to_additive has_forget_to_AddCommMon]
instance hasForgetToCommMonCat : HasForget₂ CommGroupCat CommMonCat :=
  InducedCategory.hasForget₂ fun G : CommGroupCat => CommMonCat.of G
#align CommGroup.has_forget_to_CommMon CommGroupCat.hasForgetToCommMonCat
#align AddCommGroup.has_forget_to_AddCommMon AddCommGroupCat.hasForgetToAddCommMonCat
-/

@[to_additive]
instance : Coe CommGroupCat.{u} CommMonCat.{u} where coe := (forget₂ CommGroupCat CommMonCat).obj

end CommGroupCat

-- This example verifies an improvement possible in Lean 3.8.
-- Before that, to have `monoid_hom.map_map` usable by `simp` here,
-- we had to mark all the concrete category `has_coe_to_sort` instances reducible.
-- Now, it just works.
@[to_additive]
example {R S : CommGroupCat} (i : R ⟶ S) (r : R) (h : r = 1) : i r = 1 := by simp [h]

namespace AddCommGroupCat

/- warning: AddCommGroup.as_hom -> AddCommGroupCat.asHom is a dubious translation:
lean 3 declaration is
  forall {G : AddCommGroupCat.{0}}, (coeSort.{2, 2} AddCommGroupCat.{0} Type AddCommGroupCat.hasCoeToSort.{0} G) -> (Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.addCommGroup) G)
but is expected to have type
  forall {G : AddCommGroupCat.{0}}, (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) -> (Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} instAddCommGroupCatLargeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt) G)
Case conversion may be inaccurate. Consider using '#align AddCommGroup.as_hom AddCommGroupCat.asHomₓ'. -/
-- Note that because `ℤ : Type 0`, this forces `G : AddCommGroup.{0}`,
-- so we write this explicitly to be clear.
-- TODO generalize this, requiring a `ulift_instances.lean` file
/-- Any element of an abelian group gives a unique morphism from `ℤ` sending
`1` to that element. -/
def asHom {G : AddCommGroupCat.{0}} (g : G) : AddCommGroupCat.of ℤ ⟶ G :=
  zmultiplesHom G g
#align AddCommGroup.as_hom AddCommGroupCat.asHom

/- warning: AddCommGroup.as_hom_apply -> AddCommGroupCat.asHom_apply is a dubious translation:
lean 3 declaration is
  forall {G : AddCommGroupCat.{0}} (g : coeSort.{2, 2} AddCommGroupCat.{0} Type AddCommGroupCat.hasCoeToSort.{0} G) (i : Int), Eq.{1} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (coeFn.{1, 1} (Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.addCommGroup) G) (fun (_x : AddMonoidHom.{0, 0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.addCommGroup))))) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} G))))) => (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) -> (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G)) (AddMonoidHom.hasCoeToFun.{0, 0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.addCommGroup))))) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} G))))) (AddCommGroupCat.asHom G g) i) (SMul.smul.{0, 0} Int (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (SubNegMonoid.SMulInt.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddGroup.toSubNegMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddCommGroupCat.addCommGroupInstance.{0} G)))) i g)
but is expected to have type
  forall {G : AddCommGroupCat.{0}} (g : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (i : Int), Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) => CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) i) (FunLike.coe.{1, 1, 1} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (fun (_x : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) => CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) _x) (AddHomClass.toFunLike.{0, 0, 0} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddZeroClass.toAdd.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt))))))) (AddZeroClass.toAdd.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (AddMonoidHomClass.toAddHomClass.{0, 0, 0} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G))))) (AddMonoidHom.addMonoidHomClass.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))))) (AddCommGroupCat.asHom G g) i) (HSMul.hSMul.{0, 0, 0} Int (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (instHSMul.{0, 0} Int (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.SMulInt.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G))))) i g)
Case conversion may be inaccurate. Consider using '#align AddCommGroup.as_hom_apply AddCommGroupCat.asHom_applyₓ'. -/
@[simp]
theorem asHom_apply {G : AddCommGroupCat.{0}} (g : G) (i : ℤ) : (asHom g) i = i • g :=
  rfl
#align AddCommGroup.as_hom_apply AddCommGroupCat.asHom_apply

/- warning: AddCommGroup.as_hom_injective -> AddCommGroupCat.asHom_injective is a dubious translation:
lean 3 declaration is
  forall {G : AddCommGroupCat.{0}}, Function.Injective.{1, 1} (coeSort.{2, 2} AddCommGroupCat.{0} Type AddCommGroupCat.hasCoeToSort.{0} G) (Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.addCommGroup) G) (AddCommGroupCat.asHom G)
but is expected to have type
  forall {G : AddCommGroupCat.{0}}, Function.Injective.{1, 1} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} instAddCommGroupCatLargeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt) G) (AddCommGroupCat.asHom G)
Case conversion may be inaccurate. Consider using '#align AddCommGroup.as_hom_injective AddCommGroupCat.asHom_injectiveₓ'. -/
theorem asHom_injective {G : AddCommGroupCat.{0}} : Function.Injective (@asHom G) := fun h k w => by
  convert congr_arg (fun k : AddCommGroupCat.of ℤ ⟶ G => (k : ℤ → G) (1 : ℤ)) w <;> simp
#align AddCommGroup.as_hom_injective AddCommGroupCat.asHom_injective

/- warning: AddCommGroup.int_hom_ext -> AddCommGroupCat.int_hom_ext is a dubious translation:
lean 3 declaration is
  forall {G : AddCommGroupCat.{0}} (f : Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.addCommGroup) G) (g : Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.addCommGroup) G), (Eq.{1} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (coeFn.{1, 1} (Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.addCommGroup) G) (fun (_x : AddMonoidHom.{0, 0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.addCommGroup))))) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} G))))) => (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) -> (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G)) (AddMonoidHom.hasCoeToFun.{0, 0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.addCommGroup))))) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} G))))) f (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne)))) (coeFn.{1, 1} (Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.addCommGroup) G) (fun (_x : AddMonoidHom.{0, 0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.addCommGroup))))) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} G))))) => (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) -> (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G)) (AddMonoidHom.hasCoeToFun.{0, 0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) (AddCommGroupCat.of.{0} Int Int.addCommGroup)) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.addCommGroup))))) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} G))))) g (OfNat.ofNat.{0} Int 1 (OfNat.mk.{0} Int 1 (One.one.{0} Int Int.hasOne))))) -> (Eq.{1} (Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.addCommGroup) G) f g)
but is expected to have type
  forall {G : AddCommGroupCat.{0}} (f : Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} instAddCommGroupCatLargeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt) G) (g : Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} instAddCommGroupCatLargeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt) G), (Eq.{1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) => CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (FunLike.coe.{1, 1, 1} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (fun (_x : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) => CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) _x) (AddHomClass.toFunLike.{0, 0, 0} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddZeroClass.toAdd.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt))))))) (AddZeroClass.toAdd.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (AddMonoidHomClass.toAddHomClass.{0, 0, 0} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G))))) (AddMonoidHom.addMonoidHomClass.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))))) f (OfNat.ofNat.{0} Int 1 (instOfNatInt 1))) (FunLike.coe.{1, 1, 1} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (fun (_x : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) => CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) _x) (AddHomClass.toFunLike.{0, 0, 0} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddZeroClass.toAdd.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt))))))) (AddZeroClass.toAdd.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (AddMonoidHomClass.toAddHomClass.{0, 0, 0} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G))))) (AddMonoidHom.addMonoidHomClass.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)) (AddCommGroupCat.addCommGroupInstance.{0} (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt)))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))))) g (OfNat.ofNat.{0} Int 1 (instOfNatInt 1)))) -> (Eq.{1} (Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} instAddCommGroupCatLargeCategory.{0})) (AddCommGroupCat.of.{0} Int Int.instAddCommGroupInt) G) f g)
Case conversion may be inaccurate. Consider using '#align AddCommGroup.int_hom_ext AddCommGroupCat.int_hom_extₓ'. -/
@[ext]
theorem int_hom_ext {G : AddCommGroupCat.{0}} (f g : AddCommGroupCat.of ℤ ⟶ G)
    (w : f (1 : ℤ) = g (1 : ℤ)) : f = g :=
  AddMonoidHom.ext_int w
#align AddCommGroup.int_hom_ext AddCommGroupCat.int_hom_ext

/- warning: AddCommGroup.injective_of_mono -> AddCommGroupCat.injective_of_mono is a dubious translation:
lean 3 declaration is
  forall {G : AddCommGroupCat.{0}} {H : AddCommGroupCat.{0}} (f : Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0})) G H) [_inst_1 : CategoryTheory.Mono.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0} G H f], Function.Injective.{1, 1} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) H) (coeFn.{1, 1} (Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} AddCommGroupCat.largeCategory.{0})) G H) (fun (_x : AddMonoidHom.{0, 0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) H) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} G)))) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) H) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) H) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) H) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} H))))) => (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) -> (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) H)) (AddMonoidHom.hasCoeToFun.{0, 0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) H) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) G) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} G)))) (AddMonoid.toAddZeroClass.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) H) (AddGroup.toAddMonoid.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) H) (AddCommGroup.toAddGroup.{0} (coeSort.{2, 2} (CategoryTheory.Bundled.{0, 0} AddCommGroup.{0}) Type (CategoryTheory.Bundled.hasCoeToSort.{0, 0} AddCommGroup.{0}) H) (CategoryTheory.Bundled.str.{0, 0} AddCommGroup.{0} H))))) f)
but is expected to have type
  forall {G : AddCommGroupCat.{0}} {H : AddCommGroupCat.{0}} (f : Quiver.Hom.{1, 1} AddCommGroupCat.{0} (CategoryTheory.CategoryStruct.toQuiver.{0, 1} AddCommGroupCat.{0} (CategoryTheory.Category.toCategoryStruct.{0, 1} AddCommGroupCat.{0} instAddCommGroupCatLargeCategory.{0})) G H) [_inst_1 : CategoryTheory.Mono.{0, 1} AddCommGroupCat.{0} instAddCommGroupCatLargeCategory.{0} G H f], Function.Injective.{1, 1} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (FunLike.coe.{1, 1, 1} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroupCat.addCommGroupInstance.{0} H)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (fun (_x : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) => CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) _x) (AddHomClass.toFunLike.{0, 0, 0} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroupCat.addCommGroupInstance.{0} H)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddZeroClass.toAdd.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G)))))) (AddZeroClass.toAdd.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroupCat.addCommGroupInstance.{0} H)))))) (AddMonoidHomClass.toAddHomClass.{0, 0, 0} (AddMonoidHom.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroupCat.addCommGroupInstance.{0} H)))))) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroupCat.addCommGroupInstance.{0} H))))) (AddMonoidHom.addMonoidHomClass.{0, 0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} G) (AddCommGroupCat.addCommGroupInstance.{0} G))))) (AddMonoid.toAddZeroClass.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (SubNegMonoid.toAddMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddGroup.toSubNegMonoid.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroup.toAddGroup.{0} (CategoryTheory.Bundled.α.{0, 0} AddCommGroup.{0} H) (AddCommGroupCat.addCommGroupInstance.{0} H)))))))) f)
Case conversion may be inaccurate. Consider using '#align AddCommGroup.injective_of_mono AddCommGroupCat.injective_of_monoₓ'. -/
-- TODO: this argument should be generalised to the situation where
-- the forgetful functor is representable.
theorem injective_of_mono {G H : AddCommGroupCat.{0}} (f : G ⟶ H) [Mono f] : Function.Injective f :=
  fun g₁ g₂ h =>
  by
  have t0 : as_hom g₁ ≫ f = as_hom g₂ ≫ f := by
    ext
    simpa [as_hom_apply] using h
  have t1 : as_hom g₁ = as_hom g₂ := (cancel_mono _).1 t0
  apply as_hom_injective t1
#align AddCommGroup.injective_of_mono AddCommGroupCat.injective_of_mono

end AddCommGroupCat

/- warning: mul_equiv.to_Group_iso -> MulEquiv.toGroupCatIso is a dubious translation:
lean 3 declaration is
  forall {X : GroupCat.{u1}} {Y : GroupCat.{u1}}, (MulEquiv.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (GroupCat.group.{u1} X))))) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (GroupCat.group.{u1} Y)))))) -> (CategoryTheory.Iso.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} X Y)
but is expected to have type
  forall {X : GroupCat.{u1}} {Y : GroupCat.{u1}}, (MulEquiv.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (GroupCat.instGroupα.{u1} X))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (GroupCat.instGroupα.{u1} Y)))))) -> (CategoryTheory.Iso.{u1, succ u1} GroupCat.{u1} instGroupCatLargeCategory.{u1} X Y)
Case conversion may be inaccurate. Consider using '#align mul_equiv.to_Group_iso MulEquiv.toGroupCatIsoₓ'. -/
/-- Build an isomorphism in the category `Group` from a `mul_equiv` between `group`s. -/
@[to_additive AddEquiv.toAddGroupCatIso, simps]
def MulEquiv.toGroupCatIso {X Y : GroupCat} (e : X ≃* Y) : X ≅ Y
    where
  Hom := e.toMonoidHom
  inv := e.symm.toMonoidHom
#align mul_equiv.to_Group_iso MulEquiv.toGroupCatIso
#align add_equiv.to_AddGroup_iso AddEquiv.toAddGroupCatIso

/-- Build an isomorphism in the category `AddGroup` from an `add_equiv` between `add_group`s. -/
add_decl_doc AddEquiv.toAddGroupCatIso

/- warning: mul_equiv.to_CommGroup_iso -> MulEquiv.toCommGroupCatIso is a dubious translation:
lean 3 declaration is
  forall {X : CommGroupCat.{u1}} {Y : CommGroupCat.{u1}}, (MulEquiv.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (CommGroupCat.commGroupInstance.{u1} X)))))) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (CommGroupCat.commGroupInstance.{u1} Y))))))) -> (CategoryTheory.Iso.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} X Y)
but is expected to have type
  forall {X : CommGroupCat.{u1}} {Y : CommGroupCat.{u1}}, (MulEquiv.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (CommGroupCat.commGroupInstance.{u1} X)))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (CommGroupCat.commGroupInstance.{u1} Y))))))) -> (CategoryTheory.Iso.{u1, succ u1} CommGroupCat.{u1} instCommGroupCatLargeCategory.{u1} X Y)
Case conversion may be inaccurate. Consider using '#align mul_equiv.to_CommGroup_iso MulEquiv.toCommGroupCatIsoₓ'. -/
/-- Build an isomorphism in the category `CommGroup` from a `mul_equiv` between `comm_group`s. -/
@[to_additive AddEquiv.toAddCommGroupCatIso, simps]
def MulEquiv.toCommGroupCatIso {X Y : CommGroupCat} (e : X ≃* Y) : X ≅ Y
    where
  Hom := e.toMonoidHom
  inv := e.symm.toMonoidHom
#align mul_equiv.to_CommGroup_iso MulEquiv.toCommGroupCatIso
#align add_equiv.to_AddCommGroup_iso AddEquiv.toAddCommGroupCatIso

/-- Build an isomorphism in the category `AddCommGroup` from a `add_equiv` between
`add_comm_group`s. -/
add_decl_doc AddEquiv.toAddCommGroupCatIso

namespace CategoryTheory.Iso

/- warning: category_theory.iso.Group_iso_to_mul_equiv -> CategoryTheory.Iso.groupIsoToMulEquiv is a dubious translation:
lean 3 declaration is
  forall {X : GroupCat.{u1}} {Y : GroupCat.{u1}}, (CategoryTheory.Iso.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} X Y) -> (MulEquiv.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (GroupCat.group.{u1} X))))) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (GroupCat.group.{u1} Y))))))
but is expected to have type
  forall {X : GroupCat.{u1}} {Y : GroupCat.{u1}}, (CategoryTheory.Iso.{u1, succ u1} GroupCat.{u1} instGroupCatLargeCategory.{u1} X Y) -> (MulEquiv.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (GroupCat.instGroupα.{u1} X))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (GroupCat.instGroupα.{u1} Y))))))
Case conversion may be inaccurate. Consider using '#align category_theory.iso.Group_iso_to_mul_equiv CategoryTheory.Iso.groupIsoToMulEquivₓ'. -/
/-- Build a `mul_equiv` from an isomorphism in the category `Group`. -/
@[to_additive AddGroup_iso_to_add_equiv
      "Build an `add_equiv` from an isomorphism in the category\n`AddGroup`.",
  simps]
def groupIsoToMulEquiv {X Y : GroupCat} (i : X ≅ Y) : X ≃* Y :=
  i.Hom.toMulEquiv i.inv i.hom_inv_id i.inv_hom_id
#align category_theory.iso.Group_iso_to_mul_equiv CategoryTheory.Iso.groupIsoToMulEquiv
#align category_theory.iso.AddGroup_iso_to_add_equiv CategoryTheory.Iso.addGroupIsoToAddEquiv

/- warning: category_theory.iso.CommGroup_iso_to_mul_equiv -> CategoryTheory.Iso.commGroupIsoToMulEquiv is a dubious translation:
lean 3 declaration is
  forall {X : CommGroupCat.{u1}} {Y : CommGroupCat.{u1}}, (CategoryTheory.Iso.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} X Y) -> (MulEquiv.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (CommGroupCat.commGroupInstance.{u1} X)))))) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (CommGroupCat.commGroupInstance.{u1} Y)))))))
but is expected to have type
  forall {X : CommGroupCat.{u1}} {Y : CommGroupCat.{u1}}, (CategoryTheory.Iso.{u1, succ u1} CommGroupCat.{u1} instCommGroupCatLargeCategory.{u1} X Y) -> (MulEquiv.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (CommGroupCat.commGroupInstance.{u1} X)))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (CommGroupCat.commGroupInstance.{u1} Y)))))))
Case conversion may be inaccurate. Consider using '#align category_theory.iso.CommGroup_iso_to_mul_equiv CategoryTheory.Iso.commGroupIsoToMulEquivₓ'. -/
/-- Build a `mul_equiv` from an isomorphism in the category `CommGroup`. -/
@[to_additive AddCommGroup_iso_to_add_equiv
      "Build an `add_equiv` from an isomorphism\nin the category `AddCommGroup`.",
  simps]
def commGroupIsoToMulEquiv {X Y : CommGroupCat} (i : X ≅ Y) : X ≃* Y :=
  i.Hom.toMulEquiv i.inv i.hom_inv_id i.inv_hom_id
#align category_theory.iso.CommGroup_iso_to_mul_equiv CategoryTheory.Iso.commGroupIsoToMulEquiv
#align category_theory.iso.AddCommGroup_iso_to_add_equiv CategoryTheory.Iso.addCommGroupIsoToAddEquiv

end CategoryTheory.Iso

/- warning: mul_equiv_iso_Group_iso -> mulEquivIsoGroupIso is a dubious translation:
lean 3 declaration is
  forall {X : GroupCat.{u1}} {Y : GroupCat.{u1}}, CategoryTheory.Iso.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} (MulEquiv.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} X) (GroupCat.group.{u1} X))))) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} Y) (GroupCat.group.{u1} Y)))))) (CategoryTheory.Iso.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} X Y)
but is expected to have type
  forall {X : GroupCat.{u1}} {Y : GroupCat.{u1}}, CategoryTheory.Iso.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} (MulEquiv.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} X) (GroupCat.instGroupα.{u1} X))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} Y) (GroupCat.instGroupα.{u1} Y)))))) (CategoryTheory.Iso.{u1, succ u1} GroupCat.{u1} instGroupCatLargeCategory.{u1} X Y)
Case conversion may be inaccurate. Consider using '#align mul_equiv_iso_Group_iso mulEquivIsoGroupIsoₓ'. -/
/-- multiplicative equivalences between `group`s are the same as (isomorphic to) isomorphisms
in `Group` -/
@[to_additive addEquivIsoAddGroupIso
      "additive equivalences between `add_group`s are the same\nas (isomorphic to) isomorphisms in `AddGroup`"]
def mulEquivIsoGroupIso {X Y : GroupCat.{u}} : X ≃* Y ≅ X ≅ Y
    where
  Hom e := e.toGroupCatIso
  inv i := i.groupIsoToMulEquiv
#align mul_equiv_iso_Group_iso mulEquivIsoGroupIso
#align add_equiv_iso_AddGroup_iso addEquivIsoAddGroupIso

/- warning: mul_equiv_iso_CommGroup_iso -> mulEquivIsoCommGroupIso is a dubious translation:
lean 3 declaration is
  forall {X : CommGroupCat.{u1}} {Y : CommGroupCat.{u1}}, CategoryTheory.Iso.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} (MulEquiv.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} X) (CommGroupCat.commGroupInstance.{u1} X)))))) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.hasCoeToSort.{u1} Y) (CommGroupCat.commGroupInstance.{u1} Y))))))) (CategoryTheory.Iso.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} X Y)
but is expected to have type
  forall {X : CommGroupCat.{u1}} {Y : CommGroupCat.{u1}}, CategoryTheory.Iso.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} (MulEquiv.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} X) (CommGroupCat.commGroupInstance.{u1} X)))))) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} Y) (CommGroupCat.commGroupInstance.{u1} Y))))))) (CategoryTheory.Iso.{u1, succ u1} CommGroupCat.{u1} instCommGroupCatLargeCategory.{u1} X Y)
Case conversion may be inaccurate. Consider using '#align mul_equiv_iso_CommGroup_iso mulEquivIsoCommGroupIsoₓ'. -/
/-- multiplicative equivalences between `comm_group`s are the same as (isomorphic to) isomorphisms
in `CommGroup` -/
@[to_additive addEquivIsoAddCommGroupIso
      "additive equivalences between `add_comm_group`s are\nthe same as (isomorphic to) isomorphisms in `AddCommGroup`"]
def mulEquivIsoCommGroupIso {X Y : CommGroupCat.{u}} : X ≃* Y ≅ X ≅ Y
    where
  Hom e := e.toCommGroupCatIso
  inv i := i.commGroupIsoToMulEquiv
#align mul_equiv_iso_CommGroup_iso mulEquivIsoCommGroupIso
#align add_equiv_iso_AddCommGroup_iso addEquivIsoAddCommGroupIso

namespace CategoryTheory.Aut

/- warning: category_theory.Aut.iso_perm -> CategoryTheory.Aut.isoPerm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}}, CategoryTheory.Iso.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} (GroupCat.of.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (CategoryTheory.Aut.group.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α)) (GroupCat.of.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))
but is expected to have type
  forall {α : Type.{u1}}, CategoryTheory.Iso.{u1, succ u1} GroupCat.{u1} instGroupCatLargeCategory.{u1} (GroupCat.of.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (CategoryTheory.Aut.instGroupAut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α)) (GroupCat.of.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α))
Case conversion may be inaccurate. Consider using '#align category_theory.Aut.iso_perm CategoryTheory.Aut.isoPermₓ'. -/
/-- The (bundled) group of automorphisms of a type is isomorphic to the (bundled) group
of permutations. -/
def isoPerm {α : Type u} : GroupCat.of (Aut α) ≅ GroupCat.of (Equiv.Perm α)
    where
  Hom := ⟨fun g => g.toEquiv, by tidy, by tidy⟩
  inv := ⟨fun g => g.toIso, by tidy, by tidy⟩
#align category_theory.Aut.iso_perm CategoryTheory.Aut.isoPerm

/- warning: category_theory.Aut.mul_equiv_perm -> CategoryTheory.Aut.mulEquivPerm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}}, MulEquiv.{u1, u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (Equiv.Perm.{succ u1} α) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} (GroupCat.of.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (CategoryTheory.Aut.group.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} (GroupCat.of.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (CategoryTheory.Aut.group.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α))) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} (GroupCat.of.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (CategoryTheory.Aut.group.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α))) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} (GroupCat.of.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (CategoryTheory.Aut.group.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α))) (GroupCat.group.{u1} (GroupCat.of.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (CategoryTheory.Aut.group.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α))))))) (MulOneClass.toHasMul.{u1} (Equiv.Perm.{succ u1} α) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)))))
but is expected to have type
  forall {α : Type.{u1}}, MulEquiv.{u1, u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (Equiv.Perm.{succ u1} α) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α) (CategoryTheory.Aut.instGroupAut.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} α))))) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} α) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} α) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} α) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} α) (Equiv.Perm.permGroup.{u1} α)))))
Case conversion may be inaccurate. Consider using '#align category_theory.Aut.mul_equiv_perm CategoryTheory.Aut.mulEquivPermₓ'. -/
/-- The (unbundled) group of automorphisms of a type is `mul_equiv` to the (unbundled) group
of permutations. -/
def mulEquivPerm {α : Type u} : Aut α ≃* Equiv.Perm α :=
  isoPerm.groupIsoToMulEquiv
#align category_theory.Aut.mul_equiv_perm CategoryTheory.Aut.mulEquivPerm

end CategoryTheory.Aut

#print GroupCat.forget_reflects_isos /-
@[to_additive]
instance GroupCat.forget_reflects_isos : ReflectsIsomorphisms (forget GroupCat.{u})
    where reflects X Y f _ := by
    skip
    let i := as_iso ((forget GroupCat).map f)
    let e : X ≃* Y := { f, i.to_equiv with }
    exact ⟨(is_iso.of_iso e.to_Group_iso).1⟩
#align Group.forget_reflects_isos GroupCat.forget_reflects_isos
#align AddGroup.forget_reflects_isos AddGroupCat.forget_reflects_isos
-/

#print CommGroupCat.forget_reflects_isos /-
@[to_additive]
instance CommGroupCat.forget_reflects_isos : ReflectsIsomorphisms (forget CommGroupCat.{u})
    where reflects X Y f _ := by
    skip
    let i := as_iso ((forget CommGroupCat).map f)
    let e : X ≃* Y := { f, i.to_equiv with }
    exact ⟨(is_iso.of_iso e.to_CommGroup_iso).1⟩
#align CommGroup.forget_reflects_isos CommGroupCat.forget_reflects_isos
#align AddCommGroup.forget_reflects_isos AddCommGroupCat.forget_reflects_isos
-/

