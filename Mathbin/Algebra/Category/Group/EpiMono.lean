/-
Copyright (c) 2022 Jujian Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jujian Zhang

! This file was ported from Lean 3 source module algebra.category.Group.epi_mono
! leanprover-community/mathlib commit 70fd9563a21e7b963887c9360bd29b2393e6225a
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Category.Group.EquivalenceGroupAddGroup
import Mathbin.GroupTheory.QuotientGroup

/-!
# Monomorphisms and epimorphisms in `Group`
In this file, we prove monomorphisms in category of group are injective homomorphisms and
epimorphisms are surjective homomorphisms.
-/


noncomputable section

universe u v

namespace MonoidHom

open QuotientGroup

variable {A : Type u} {B : Type v}

section

variable [Group A] [Group B]

/- warning: monoid_hom.ker_eq_bot_of_cancel -> MonoidHom.ker_eq_bot_of_cancel is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : Group.{u1} A] [_inst_2 : Group.{u2} B] {f : MonoidHom.{u1, u2} A B (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2)))}, (forall (u : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) A (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Subgroup.toGroup.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))))) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1)))) (v : MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) A (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Subgroup.toGroup.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))))) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1)))), (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) B (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Subgroup.toGroup.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2)))) (MonoidHom.comp.{u1, u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) A B (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Subgroup.toGroup.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))))) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f u) (MonoidHom.comp.{u1, u1, u2} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) A B (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Subgroup.toGroup.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))))) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f v)) -> (Eq.{succ u1} (MonoidHom.{u1, u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) A (Monoid.toMulOneClass.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Group.toDivInvMonoid.{u1} (coeSort.{succ u1, succ (succ u1)} (Subgroup.{u1} A _inst_1) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.setLike.{u1} A _inst_1)) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f)) (Subgroup.toGroup.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))))) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1)))) u v)) -> (Eq.{succ u1} (Subgroup.{u1} A _inst_1) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f) (Bot.bot.{u1} (Subgroup.{u1} A _inst_1) (Subgroup.hasBot.{u1} A _inst_1)))
but is expected to have type
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : Group.{u1} A] [_inst_2 : Group.{u2} B] {f : MonoidHom.{u1, u2} A B (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2)))}, (forall (u : MonoidHom.{u1, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subgroup.{u1} A _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.instSetLikeSubgroup.{u1} A _inst_1)) x (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) A (Submonoid.toMulOneClass.{u1} A (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Subgroup.toSubmonoid.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1)))) (v : MonoidHom.{u1, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subgroup.{u1} A _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.instSetLikeSubgroup.{u1} A _inst_1)) x (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) A (Submonoid.toMulOneClass.{u1} A (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Subgroup.toSubmonoid.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1)))), (Eq.{max (succ u1) (succ u2)} (MonoidHom.{u1, u2} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subgroup.{u1} A _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.instSetLikeSubgroup.{u1} A _inst_1)) x (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) B (Submonoid.toMulOneClass.{u1} A (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Subgroup.toSubmonoid.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2)))) (MonoidHom.comp.{u1, u1, u2} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subgroup.{u1} A _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.instSetLikeSubgroup.{u1} A _inst_1)) x (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) A B (Submonoid.toMulOneClass.{u1} A (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Subgroup.toSubmonoid.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f u) (MonoidHom.comp.{u1, u1, u2} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subgroup.{u1} A _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.instSetLikeSubgroup.{u1} A _inst_1)) x (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) A B (Submonoid.toMulOneClass.{u1} A (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Subgroup.toSubmonoid.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f v)) -> (Eq.{succ u1} (MonoidHom.{u1, u1} (Subtype.{succ u1} A (fun (x : A) => Membership.mem.{u1, u1} A (Subgroup.{u1} A _inst_1) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} A _inst_1) A (Subgroup.instSetLikeSubgroup.{u1} A _inst_1)) x (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) A (Submonoid.toMulOneClass.{u1} A (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1))) (Subgroup.toSubmonoid.{u1} A _inst_1 (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f))) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A _inst_1)))) u v)) -> (Eq.{succ u1} (Subgroup.{u1} A _inst_1) (MonoidHom.ker.{u1, u2} A _inst_1 B (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B _inst_2))) f) (Bot.bot.{u1} (Subgroup.{u1} A _inst_1) (Subgroup.instBotSubgroup.{u1} A _inst_1)))
Case conversion may be inaccurate. Consider using '#align monoid_hom.ker_eq_bot_of_cancel MonoidHom.ker_eq_bot_of_cancelₓ'. -/
@[to_additive AddMonoidHom.ker_eq_bot_of_cancel]
theorem ker_eq_bot_of_cancel {f : A →* B} (h : ∀ u v : f.ker →* A, f.comp u = f.comp v → u = v) :
    f.ker = ⊥ := by simpa using _root_.congr_arg range (h f.ker.subtype 1 (by tidy))
#align monoid_hom.ker_eq_bot_of_cancel MonoidHom.ker_eq_bot_of_cancel
#align add_monoid_hom.ker_eq_bot_of_cancel AddMonoidHom.ker_eq_bot_of_cancel

end

section

variable [CommGroup A] [CommGroup B]

/- warning: monoid_hom.range_eq_top_of_cancel -> MonoidHom.range_eq_top_of_cancel is a dubious translation:
lean 3 declaration is
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommGroup.{u1} A] [_inst_2 : CommGroup.{u2} B] {f : MonoidHom.{u1, u2} A B (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A (CommGroup.toGroup.{u1} A _inst_1)))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2))))}, (forall (u : MonoidHom.{u2, u2} B (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f))))))) (v : MonoidHom.{u2, u2} B (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f))))))), (Eq.{max (succ u2) (succ u1)} (MonoidHom.{u1, u2} A (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A (CommGroup.toGroup.{u1} A _inst_1)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f))))))) (MonoidHom.comp.{u1, u2, u2} A B (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A (CommGroup.toGroup.{u1} A _inst_1)))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)))))) u f) (MonoidHom.comp.{u1, u2, u2} A B (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A (CommGroup.toGroup.{u1} A _inst_1)))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)))))) v f)) -> (Eq.{succ u2} (MonoidHom.{u2, u2} B (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.Subgroup.hasQuotient.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f))))))) u v)) -> (Eq.{succ u2} (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Top.top.{u2} (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (Subgroup.hasTop.{u2} B (CommGroup.toGroup.{u2} B _inst_2))))
but is expected to have type
  forall {A : Type.{u1}} {B : Type.{u2}} [_inst_1 : CommGroup.{u1} A] [_inst_2 : CommGroup.{u2} B] {f : MonoidHom.{u1, u2} A B (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A (CommGroup.toGroup.{u1} A _inst_1)))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2))))}, (forall (u : MonoidHom.{u2, u2} B (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f))))))) (v : MonoidHom.{u2, u2} B (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f))))))), (Eq.{max (succ u1) (succ u2)} (MonoidHom.{u1, u2} A (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A (CommGroup.toGroup.{u1} A _inst_1)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f))))))) (MonoidHom.comp.{u1, u2, u2} A B (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A (CommGroup.toGroup.{u1} A _inst_1)))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)))))) u f) (MonoidHom.comp.{u1, u2, u2} A B (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u1} A (DivInvMonoid.toMonoid.{u1} A (Group.toDivInvMonoid.{u1} A (CommGroup.toGroup.{u1} A _inst_1)))) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)))))) v f)) -> (Eq.{succ u2} (MonoidHom.{u2, u2} B (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Monoid.toMulOneClass.{u2} B (DivInvMonoid.toMonoid.{u2} B (Group.toDivInvMonoid.{u2} B (CommGroup.toGroup.{u2} B _inst_2)))) (Monoid.toMulOneClass.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (DivInvMonoid.toMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (Group.toDivInvMonoid.{u2} (HasQuotient.Quotient.{u2, u2} B (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (QuotientGroup.instHasQuotientSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f)) (QuotientGroup.Quotient.group.{u2} B (CommGroup.toGroup.{u2} B _inst_2) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Subgroup.normal_of_comm.{u2} B _inst_2 (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f))))))) u v)) -> (Eq.{succ u2} (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (MonoidHom.range.{u1, u2} A (CommGroup.toGroup.{u1} A _inst_1) B (CommGroup.toGroup.{u2} B _inst_2) f) (Top.top.{u2} (Subgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2)) (Subgroup.instTopSubgroup.{u2} B (CommGroup.toGroup.{u2} B _inst_2))))
Case conversion may be inaccurate. Consider using '#align monoid_hom.range_eq_top_of_cancel MonoidHom.range_eq_top_of_cancelₓ'. -/
@[to_additive AddMonoidHom.range_eq_top_of_cancel]
theorem range_eq_top_of_cancel {f : A →* B}
    (h : ∀ u v : B →* B ⧸ f.range, u.comp f = v.comp f → u = v) : f.range = ⊤ :=
  by
  specialize h 1 (QuotientGroup.mk' _) _
  · ext1
    simp only [one_apply, coe_comp, coe_mk', Function.comp_apply]
    rw [show (1 : B ⧸ f.range) = (1 : B) from QuotientGroup.mk_one _, QuotientGroup.eq, inv_one,
      one_mul]
    exact ⟨x, rfl⟩
  replace h : (QuotientGroup.mk' _).ker = (1 : B →* B ⧸ f.range).ker := by rw [h]
  rwa [ker_one, QuotientGroup.ker_mk'] at h
#align monoid_hom.range_eq_top_of_cancel MonoidHom.range_eq_top_of_cancel
#align add_monoid_hom.range_eq_top_of_cancel AddMonoidHom.range_eq_top_of_cancel

end

end MonoidHom

section

open CategoryTheory

namespace GroupCat

variable {A B : GroupCat.{u}} (f : A ⟶ B)

/- warning: Group.ker_eq_bot_of_mono -> GroupCat.ker_eq_bot_of_mono is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) [_inst_1 : CategoryTheory.Mono.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f], Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A)) (MonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} B))) f) (Bot.bot.{u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A)) (Subgroup.hasBot.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A)))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) [_inst_1 : CategoryTheory.Mono.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f], Eq.{succ u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A)) (MonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) ((fun {α : Type.{u1}} (h : Group.{u1} α) => DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α h)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} B))) f) (Bot.bot.{u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A)) (Subgroup.instBotSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A)))
Case conversion may be inaccurate. Consider using '#align Group.ker_eq_bot_of_mono GroupCat.ker_eq_bot_of_monoₓ'. -/
@[to_additive AddGroupCat.ker_eq_bot_of_mono]
theorem ker_eq_bot_of_mono [Mono f] : f.ker = ⊥ :=
  MonoidHom.ker_eq_bot_of_cancel fun u v =>
    (@cancel_mono _ _ _ _ _ f _ (show GroupCat.of f.ker ⟶ A from u) _).1
#align Group.ker_eq_bot_of_mono GroupCat.ker_eq_bot_of_mono
#align AddGroup.ker_eq_bot_of_mono AddGroupCat.ker_eq_bot_of_mono

/- warning: Group.mono_iff_ker_eq_bot -> GroupCat.mono_iff_ker_eq_bot is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Mono.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f) (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A)) (MonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} B))) f) (Bot.bot.{u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A)) (Subgroup.hasBot.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A))))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Mono.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f) (Eq.{succ u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A)) (MonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) ((fun {α : Type.{u1}} (h : Group.{u1} α) => DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α h)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} B))) f) (Bot.bot.{u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A)) (Subgroup.instBotSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A))))
Case conversion may be inaccurate. Consider using '#align Group.mono_iff_ker_eq_bot GroupCat.mono_iff_ker_eq_botₓ'. -/
@[to_additive AddGroupCat.mono_iff_ker_eq_bot]
theorem mono_iff_ker_eq_bot : Mono f ↔ f.ker = ⊥ :=
  ⟨fun h => @ker_eq_bot_of_mono f h, fun h =>
    ConcreteCategory.mono_of_injective _ <| (MonoidHom.ker_eq_bot_iff f).1 h⟩
#align Group.mono_iff_ker_eq_bot GroupCat.mono_iff_ker_eq_bot
#align AddGroup.mono_iff_ker_eq_bot AddGroupCat.mono_iff_ker_eq_bot

/- warning: Group.mono_iff_injective -> GroupCat.mono_iff_injective is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Mono.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f) (Function.Injective.{succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} A))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} B)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} A))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} B)))) f))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Mono.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f) (Function.Injective.{succ u1, succ u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} A) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeFun.coe.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (fun (_x : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) => (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} A) -> (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B)) (GroupCat.instCoeFunHomGroupCatToQuiverToCategoryStructLargeCategoryForAllCoeTypeInstCoeSortGroupCatType.{u1} A B) f))
Case conversion may be inaccurate. Consider using '#align Group.mono_iff_injective GroupCat.mono_iff_injectiveₓ'. -/
@[to_additive AddGroupCat.mono_iff_injective]
theorem mono_iff_injective : Mono f ↔ Function.Injective f :=
  Iff.trans (mono_iff_ker_eq_bot f) <| MonoidHom.ker_eq_bot_iff f
#align Group.mono_iff_injective GroupCat.mono_iff_injective
#align AddGroup.mono_iff_injective AddGroupCat.mono_iff_injective

namespace SurjectiveOfEpiAuxs

-- mathport name: exprX
local notation "X" => Set.range (Function.swap leftCoset f.range.carrier)

#print GroupCat.SurjectiveOfEpiAuxs.XWithInfinity /-
/-- Define `X'` to be the set of all left cosets with an extra point at "infinity".
-/
@[nolint has_nonempty_instance]
inductive XWithInfinity
  | from_coset : Set.range (Function.swap leftCoset f.range.carrier) → X_with_infinity
  | infinity : X_with_infinity
#align Group.surjective_of_epi_auxs.X_with_infinity GroupCat.SurjectiveOfEpiAuxs.XWithInfinity
-/

open XWithInfinity Equiv.Perm

open Coset

-- mathport name: exprX'
local notation "X'" => XWithInfinity f

-- mathport name: «expr∞»
local notation "∞" => XWithInfinity.infinity

-- mathport name: exprSX'
local notation "SX'" => Equiv.Perm X'

instance : SMul B X'
    where smul b x :=
    match x with
    | from_coset y =>
      fromCoset
        ⟨b *l y, by
          rw [← Subtype.val_eq_coe, ← y.2.choose_spec, leftCoset_assoc]
          use b * y.2.some⟩
    | ∞ => ∞

/- warning: Group.surjective_of_epi_auxs.mul_smul -> GroupCat.SurjectiveOfEpiAuxs.mul_smul is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (b : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (b' : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (x : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f), Eq.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (SMul.smul.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.hasSmul.{u1} A B f) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))))) b b') x) (SMul.smul.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.hasSmul.{u1} A B f) b (SMul.smul.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.hasSmul.{u1} A B f) b' x))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (b : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (b' : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (x : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f), Eq.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (HSMul.hSMul.{u1, u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (instHSMul.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.instSMulCoeGroupCatTypeInstCoeSortGroupCatTypeXWithInfinity.{u1} A B f)) (HMul.hMul.{u1, u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (instHMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (MulOneClass.toMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))))) b b') x) (HSMul.hSMul.{u1, u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (instHSMul.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.instSMulCoeGroupCatTypeInstCoeSortGroupCatTypeXWithInfinity.{u1} A B f)) b (HSMul.hSMul.{u1, u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (instHSMul.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.instSMulCoeGroupCatTypeInstCoeSortGroupCatTypeXWithInfinity.{u1} A B f)) b' x))
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.mul_smul GroupCat.SurjectiveOfEpiAuxs.mul_smulₓ'. -/
theorem mul_smul (b b' : B) (x : X') : (b * b') • x = b • b' • x :=
  match x with
  | from_coset y => by
    change from_coset _ = from_coset _
    simp only [← Subtype.val_eq_coe, leftCoset_assoc]
  | ∞ => rfl
#align Group.surjective_of_epi_auxs.mul_smul GroupCat.SurjectiveOfEpiAuxs.mul_smul

/- warning: Group.surjective_of_epi_auxs.one_smul -> GroupCat.SurjectiveOfEpiAuxs.one_smul is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f), Eq.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (SMul.smul.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.hasSmul.{u1} A B f) (OfNat.ofNat.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) 1 (OfNat.mk.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) 1 (One.one.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (MulOneClass.toHasOne.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))))))) x) x
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f), Eq.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (HSMul.hSMul.{u1, u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (instHSMul.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.instSMulCoeGroupCatTypeInstCoeSortGroupCatTypeXWithInfinity.{u1} A B f)) (OfNat.ofNat.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) 1 (One.toOfNat1.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (InvOneClass.toOne.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvOneMonoid.toInvOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivisionMonoid.toDivInvOneMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivisionMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B))))))) x) x
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.one_smul GroupCat.SurjectiveOfEpiAuxs.one_smulₓ'. -/
theorem one_smul (x : X') : (1 : B) • x = x :=
  match x with
  | from_coset y => by
    change from_coset _ = from_coset _
    simp only [← Subtype.val_eq_coe, one_leftCoset, Subtype.ext_iff_val]
  | ∞ => rfl
#align Group.surjective_of_epi_auxs.one_smul GroupCat.SurjectiveOfEpiAuxs.one_smul

/- warning: Group.surjective_of_epi_auxs.from_coset_eq_of_mem_range -> GroupCat.SurjectiveOfEpiAuxs.fromCoset_eq_of_mem_range is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) {b : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B}, (Membership.Mem.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Subgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))) b (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) -> (Eq.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) b (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) (Exists.intro.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) b (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)))) b (rfl.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) b))))) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) (Exists.intro.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) (OfNat.ofNat.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) 1 (OfNat.mk.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) 1 (One.one.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasOne.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))))) (one_leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)))))))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) {b : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B}, (Membership.mem.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Subgroup.instSetLikeSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))) b (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)) -> (Eq.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) b (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))) (Exists.intro.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) b (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))) b (rfl.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) b))))) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) (Exists.intro.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))) (OfNat.ofNat.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) 1 (One.toOfNat1.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (InvOneClass.toOne.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvOneMonoid.toInvOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivisionMonoid.toDivInvOneMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivisionMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))))) (one_leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))))))
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.from_coset_eq_of_mem_range GroupCat.SurjectiveOfEpiAuxs.fromCoset_eq_of_mem_rangeₓ'. -/
theorem fromCoset_eq_of_mem_range {b : B} (hb : b ∈ f.range) :
    fromCoset ⟨b *l f.range.carrier, ⟨b, rfl⟩⟩ =
      fromCoset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩ :=
  by
  congr
  change b *l f.range = f.range
  nth_rw 2 [show (f.range : Set B) = 1 *l f.range from (one_leftCoset _).symm]
  rw [leftCoset_eq_iff, mul_one]
  exact Subgroup.inv_mem _ hb
#align Group.surjective_of_epi_auxs.from_coset_eq_of_mem_range GroupCat.SurjectiveOfEpiAuxs.fromCoset_eq_of_mem_range

/- warning: Group.surjective_of_epi_auxs.from_coset_ne_of_nin_range -> GroupCat.SurjectiveOfEpiAuxs.fromCoset_ne_of_nin_range is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) {b : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B}, (Not (Membership.Mem.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Subgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))) b (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) -> (Ne.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) b (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) (Exists.intro.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) b (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)))) b (rfl.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) b))))) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) (Exists.intro.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) (OfNat.ofNat.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) 1 (OfNat.mk.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) 1 (One.one.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasOne.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))))) (one_leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)))))))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) {b : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B}, (Not (Membership.mem.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Subgroup.instSetLikeSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))) b (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))) -> (Ne.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) b (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))) (Exists.intro.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) b (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))) b (rfl.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) b))))) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) (Exists.intro.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))) (OfNat.ofNat.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) 1 (One.toOfNat1.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (InvOneClass.toOne.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvOneMonoid.toInvOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivisionMonoid.toDivInvOneMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivisionMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))))) (one_leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))))))
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.from_coset_ne_of_nin_range GroupCat.SurjectiveOfEpiAuxs.fromCoset_ne_of_nin_rangeₓ'. -/
theorem fromCoset_ne_of_nin_range {b : B} (hb : b ∉ f.range) :
    fromCoset ⟨b *l f.range.carrier, ⟨b, rfl⟩⟩ ≠
      fromCoset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩ :=
  by
  intro r
  simp only [Subtype.mk_eq_mk] at r
  change b *l f.range = f.range at r
  nth_rw 2 [show (f.range : Set B) = 1 *l f.range from (one_leftCoset _).symm] at r
  rw [leftCoset_eq_iff, mul_one] at r
  exact hb (inv_inv b ▸ Subgroup.inv_mem _ r)
#align Group.surjective_of_epi_auxs.from_coset_ne_of_nin_range GroupCat.SurjectiveOfEpiAuxs.fromCoset_ne_of_nin_range

instance : DecidableEq X' :=
  Classical.decEq _

#print GroupCat.SurjectiveOfEpiAuxs.tau /-
/-- Let `τ` be the permutation on `X'` exchanging `f.range` and the point at infinity.
-/
noncomputable def tau : SX' :=
  Equiv.swap (fromCoset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩) ∞
#align Group.surjective_of_epi_auxs.tau GroupCat.SurjectiveOfEpiAuxs.tau
-/

-- mathport name: exprτ
local notation "τ" => tau f

#print GroupCat.SurjectiveOfEpiAuxs.τ_apply_infinity /-
theorem τ_apply_infinity : τ ∞ = fromCoset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩ :=
  Equiv.swap_apply_right _ _
#align Group.surjective_of_epi_auxs.τ_apply_infinity GroupCat.SurjectiveOfEpiAuxs.τ_apply_infinity
-/

/- warning: Group.surjective_of_epi_auxs.τ_apply_from_coset clashes with Group.surjective_of_epi_auxs.τ_apply_fromCoset -> GroupCat.SurjectiveOfEpiAuxs.τ_apply_fromCoset
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.τ_apply_from_coset GroupCat.SurjectiveOfEpiAuxs.τ_apply_fromCosetₓ'. -/
#print GroupCat.SurjectiveOfEpiAuxs.τ_apply_fromCoset /-
theorem τ_apply_fromCoset : τ (fromCoset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩) = ∞ :=
  Equiv.swap_apply_left _ _
#align Group.surjective_of_epi_auxs.τ_apply_from_coset GroupCat.SurjectiveOfEpiAuxs.τ_apply_fromCoset
-/

theorem τ_apply_from_coset' (x : B) (hx : x ∈ f.range) :
    τ (fromCoset ⟨x *l f.range.carrier, ⟨x, rfl⟩⟩) = ∞ :=
  (fromCoset_eq_of_mem_range _ hx).symm ▸ τ_apply_fromCoset _
#align Group.surjective_of_epi_auxs.τ_apply_from_coset' GroupCat.SurjectiveOfEpiAuxs.τ_apply_from_coset'

/- warning: Group.surjective_of_epi_auxs.τ_symm_apply_from_coset clashes with Group.surjective_of_epi_auxs.τ_symm_apply_fromCoset -> GroupCat.SurjectiveOfEpiAuxs.τ_symm_apply_fromCoset
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.τ_symm_apply_from_coset GroupCat.SurjectiveOfEpiAuxs.τ_symm_apply_fromCosetₓ'. -/
#print GroupCat.SurjectiveOfEpiAuxs.τ_symm_apply_fromCoset /-
theorem τ_symm_apply_fromCoset :
    (Equiv.symm τ) (fromCoset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩) = ∞ := by
  rw [tau, Equiv.symm_swap, Equiv.swap_apply_left]
#align Group.surjective_of_epi_auxs.τ_symm_apply_from_coset GroupCat.SurjectiveOfEpiAuxs.τ_symm_apply_fromCoset
-/

#print GroupCat.SurjectiveOfEpiAuxs.τ_symm_apply_infinity /-
theorem τ_symm_apply_infinity :
    (Equiv.symm τ) ∞ = fromCoset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩ := by
  rw [tau, Equiv.symm_swap, Equiv.swap_apply_right]
#align Group.surjective_of_epi_auxs.τ_symm_apply_infinity GroupCat.SurjectiveOfEpiAuxs.τ_symm_apply_infinity
-/

#print GroupCat.SurjectiveOfEpiAuxs.g /-
/-- Let `g : B ⟶ S(X')` be defined as such that, for any `β : B`, `g(β)` is the function sending
point at infinity to point at infinity and sending coset `y` to `β *l y`.
-/
def g : B →* SX'
    where
  toFun β :=
    { toFun := fun x => β • x
      invFun := fun x => β⁻¹ • x
      left_inv := fun x => by
        dsimp only
        rw [← mul_smul, mul_left_inv, one_smul]
      right_inv := fun x => by
        dsimp only
        rw [← mul_smul, mul_right_inv, one_smul] }
  map_one' := by
    ext
    simp [one_smul]
  map_mul' b1 b2 := by
    ext
    simp [mul_smul]
#align Group.surjective_of_epi_auxs.G GroupCat.SurjectiveOfEpiAuxs.g
-/

-- mathport name: exprg
local notation "g" => g f

#print GroupCat.SurjectiveOfEpiAuxs.h /-
/-- Define `h : B ⟶ S(X')` to be `τ g τ⁻¹`
-/
def h : B →* SX' where
  toFun β := (τ.symm.trans (g β)).trans τ
  map_one' := by
    ext
    simp
  map_mul' b1 b2 := by
    ext
    simp
#align Group.surjective_of_epi_auxs.H GroupCat.SurjectiveOfEpiAuxs.h
-/

-- mathport name: exprh
local notation "h" => h f

/-!
The strategy is the following: assuming `epi f`
* prove that `f.range = {x | h x = g x}`;
* thus `f ≫ h = f ≫ g` so that `h = g`;
* but if `f` is not surjective, then some `x ∉ f.range`, then `h x ≠ g x` at the coset `f.range`.
-/


/- warning: Group.surjective_of_epi_auxs.g_apply_from_coset clashes with Group.surjective_of_epi_auxs.g_apply_fromCoset -> GroupCat.SurjectiveOfEpiAuxs.g_apply_fromCoset
warning: Group.surjective_of_epi_auxs.g_apply_from_coset -> GroupCat.SurjectiveOfEpiAuxs.g_apply_fromCoset is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (y : coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))), Eq.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (fun (_x : Equiv.{succ u1, succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) => (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) -> (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.hasCoeToFun.{succ u1, succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) => (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) -> (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f))) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (GroupCat.SurjectiveOfEpiAuxs.g.{u1} A B f) x) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f y)) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSubtype.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))))))) y)) (Subtype.casesOn.{0, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (fun (y : coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSubtype.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))))))) y)) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) y (fun (y_val : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (y_property : Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) y_val (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) => Exists.dcases_on.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) y_val) (fun (y_property : Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) y_val (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSubtype.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))))))) (Subtype.mk.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) y_val y_property))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) y_property (fun (y_property_w : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y_property_h : Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w) y_val) => Eq.drec.{0, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w) (fun (y_val : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (y_property_h : Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w) y_val) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSubtype.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))))))) (Subtype.mk.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) y_val (Exists.intro.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) y_val) y_property_w y_property_h)))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (id.{0} (forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (y_property_w : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B), (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) -> (Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSubtype.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))))))) (Subtype.mk.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w) (Exists.intro.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w)) y_property_w (rfl.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w)))))) (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)))))) (fun {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (y_property_w : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y_val : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Eq.mpr.{0} (Exists.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w)))) True (id_tag Tactic.IdTag.simp (Eq.{1} Prop (Exists.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w)))) True) (Eq.trans.{1} Prop (Exists.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w)))) (Exists.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) x y_property_w) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) True ((fun (p : (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) -> Prop) (p_1 : (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) -> Prop) (e_1 : Eq.{succ u1} ((coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) -> Prop) p p_1) => congr_arg.{succ u1, 1} ((coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) -> Prop) Prop p p_1 (Exists.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) e_1) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w))) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) x y_property_w) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)))) (funext.{succ u1, 1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Prop) (fun (x_1 : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) x_1) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w))) (fun (x_1 : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) x_1) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) x y_property_w) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)))) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => (fun (a : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (a_1 : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (e_1 : Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) a a_1) (ᾰ : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (ᾰ_1 : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (e_2 : Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) ᾰ ᾰ_1) => congr.{succ u1, 1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) Prop (Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) a) (Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) a_1) ᾰ ᾰ_1 (congr_arg.{succ u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) ((Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) -> Prop) a a_1 (Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) e_1) e_2) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (rfl.{succ u1} ((fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) y (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) x (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y_property_w)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) x y_property_w) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) (leftCoset_assoc.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toSemigroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) x y_property_w)))) (propext (Exists.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (a : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) ((fun (a : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) a) a) ((fun (a : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) a) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) x y_property_w)))) True ((fun {α : Type.{u1}} {β : Type.{u1}} (f : α -> β) (a' : α) => iff_true_intro (Exists.{succ u1} α (fun (a : α) => Eq.{succ u1} β (f a) (f a'))) (exists_apply_eq_apply.{succ u1, succ u1} α β f a')) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (a : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) a) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) x y_property_w))))) trivial) A B f x y_property_w y_val) y_val y_property_h)))))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (y : Set.Elem.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))), Eq.{succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) => GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f y)) (FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) x) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (fun (_x : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) => GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (fun (_x : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (MulOneClass.toMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B))))) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f))))) (MonoidHom.monoidHomClass.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))))) (GroupCat.SurjectiveOfEpiAuxs.g.{u1} A B f) x) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f y)) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) x (Subtype.val.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) y)) (Eq.mpr.{0} (Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) x (Subtype.val.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) y)) (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y_1 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y_1) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) x (Subtype.val.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) y)))) (id.{0} (Eq.{1} Prop (Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) x (Subtype.val.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) y)) (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y_1 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y_1) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) x (Subtype.val.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) y))))) (Mathlib.Data.Set.Image._auxLemma.18.{succ u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) x (Subtype.val.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) y)))) (Subtype.casesOn.{0, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (fun (h : Set.Elem.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) => Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) x (Subtype.val.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) h)))) y (fun (val : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (property : Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) val (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) => Exists.casesOn.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) val) (fun (h : Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) val (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) => Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) x (Subtype.val.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (Subtype.mk.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) val h))))) property (fun (w : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (h : Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) w) val) => Eq.rec.{0, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) w) (fun (val : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (h : Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) w) val) => Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) x (Subtype.val.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (Subtype.mk.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) val (Exists.intro.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) val) w h)))))) (of_eq_true (Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (x_1 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) x_1) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) x (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) w (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))))) (Eq.trans.{1} Prop (Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (x_1 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) x_1) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) x (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) w (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))))) (Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (x_1 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) x_1) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (HMul.hMul.{u1, u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (instHMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))))) x w) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) True (congrArg.{succ u1, 1} ((CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) -> Prop) Prop (fun (x_1 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) x_1) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) x (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) w (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (fun (x_1 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) x_1) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (HMul.hMul.{u1, u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (instHMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))))) x w) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))) (Exists.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (funext.{succ u1, 1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Prop) (fun (x_1 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) x_1) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) x (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) w (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (fun (x_1 : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) x_1) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (HMul.hMul.{u1, u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (instHMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))))) x w) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => congrArg.{succ u1, 1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) Prop (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) x (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) w (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (HMul.hMul.{u1, u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (instHMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))))) x w) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))) (Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y)) (leftCoset_assoc.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) x w)))) (Std.Logic._auxLemma.52.{succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (a : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) a) (HMul.hMul.{u1, u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (instHMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Semigroup.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toSemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))))) x w)))) val h))))))
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.g_apply_from_coset GroupCat.SurjectiveOfEpiAuxs.g_apply_fromCosetₓ'. -/
theorem g_apply_fromCoset (x : B) (y : X) : (g x) (fromCoset y) = fromCoset ⟨x *l y, by tidy⟩ :=
  rfl
#align Group.surjective_of_epi_auxs.g_apply_from_coset GroupCat.SurjectiveOfEpiAuxs.g_apply_fromCoset

#print GroupCat.SurjectiveOfEpiAuxs.g_apply_infinity /-
theorem g_apply_infinity (x : B) : (g x) ∞ = ∞ :=
  rfl
#align Group.surjective_of_epi_auxs.g_apply_infinity GroupCat.SurjectiveOfEpiAuxs.g_apply_infinity
-/

/- warning: Group.surjective_of_epi_auxs.h_apply_infinity -> GroupCat.SurjectiveOfEpiAuxs.h_apply_infinity is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B), (Membership.Mem.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Subgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))) x (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) -> (Eq.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (fun (_x : Equiv.{succ u1, succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) => (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) -> (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.hasCoeToFun.{succ u1, succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) => (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) -> (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f))) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (GroupCat.SurjectiveOfEpiAuxs.h.{u1} A B f) x) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.infinity.{u1} A B f)) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.infinity.{u1} A B f))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B), (Membership.mem.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Subgroup.instSetLikeSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))) x (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) => GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.infinity.{u1} A B f)) (FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) x) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (fun (_x : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) => GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (fun (_x : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (MulOneClass.toMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B))))) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f))))) (MonoidHom.monoidHomClass.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))))) (GroupCat.SurjectiveOfEpiAuxs.h.{u1} A B f) x) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.infinity.{u1} A B f)) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.infinity.{u1} A B f))
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.h_apply_infinity GroupCat.SurjectiveOfEpiAuxs.h_apply_infinityₓ'. -/
theorem h_apply_infinity (x : B) (hx : x ∈ f.range) : (h x) ∞ = ∞ :=
  by
  simp only [H, MonoidHom.coe_mk, Equiv.toFun_as_coe, Equiv.coe_trans, Function.comp_apply]
  rw [τ_symm_apply_infinity, g_apply_from_coset]
  simpa only [← Subtype.val_eq_coe] using τ_apply_from_coset' f x hx
#align Group.surjective_of_epi_auxs.h_apply_infinity GroupCat.SurjectiveOfEpiAuxs.h_apply_infinity

/- warning: Group.surjective_of_epi_auxs.h_apply_from_coset clashes with Group.surjective_of_epi_auxs.h_apply_fromCoset -> GroupCat.SurjectiveOfEpiAuxs.h_apply_fromCoset
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.h_apply_from_coset GroupCat.SurjectiveOfEpiAuxs.h_apply_fromCosetₓ'. -/
#print GroupCat.SurjectiveOfEpiAuxs.h_apply_fromCoset /-
theorem h_apply_fromCoset (x : B) :
    (h x) (fromCoset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩) =
      fromCoset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩ :=
  by simp [H, τ_symm_apply_from_coset, g_apply_infinity, τ_apply_infinity]
#align Group.surjective_of_epi_auxs.h_apply_from_coset GroupCat.SurjectiveOfEpiAuxs.h_apply_fromCoset
-/

theorem h_apply_from_coset' (x : B) (b : B) (hb : b ∈ f.range) :
    (h x) (fromCoset ⟨b *l f.range.carrier, ⟨b, rfl⟩⟩) =
      fromCoset ⟨b *l f.range.carrier, ⟨b, rfl⟩⟩ :=
  (fromCoset_eq_of_mem_range _ hb).symm ▸ h_apply_fromCoset f x
#align Group.surjective_of_epi_auxs.h_apply_from_coset' GroupCat.SurjectiveOfEpiAuxs.h_apply_from_coset'

/- warning: Group.surjective_of_epi_auxs.h_apply_from_coset_nin_range clashes with Group.surjective_of_epi_auxs.h_apply_fromCoset_nin_range -> GroupCat.SurjectiveOfEpiAuxs.h_apply_fromCoset_nin_range
warning: Group.surjective_of_epi_auxs.h_apply_from_coset_nin_range -> GroupCat.SurjectiveOfEpiAuxs.h_apply_fromCoset_nin_range is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B), (Membership.Mem.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Subgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))) x (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) -> (forall (b : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B), (Not (Membership.Mem.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Subgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))) b (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) -> (Eq.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (coeFn.{succ u1, succ u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (fun (_x : Equiv.{succ u1, succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) => (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) -> (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.hasCoeToFun.{succ u1, succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) => (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) -> (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f))) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (GroupCat.SurjectiveOfEpiAuxs.h.{u1} A B f) x) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) b (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) (Exists.intro.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) b (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)))) b (rfl.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) b)))))) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Membership.Mem.{u1, u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Set.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) (Set.hasMem.{u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B))) x (Set.range.{u1, succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))))) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) x b) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) (Exists.intro.{succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (y : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) y) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) x b) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)))) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) x b) (rfl.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Function.swap.{succ u1, succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (y : Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) => Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (leftCoset.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) (HMul.hMul.{u1, u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (instHMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (MulOneClass.toHasMul.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)))))) x b))))))))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B), (Membership.mem.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Subgroup.instSetLikeSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))) x (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)) -> (forall (b : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B), (Not (Membership.mem.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Subgroup.instSetLikeSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))) b (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) => GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) b (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))) (Exists.intro.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) b (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))) b (rfl.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) b)))))) (FunLike.coe.{succ u1, succ u1, succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) x) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (fun (_x : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) => GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (fun (_x : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (MulOneClass.toMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B))))) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f))))) (MonoidHom.monoidHomClass.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))))) (GroupCat.SurjectiveOfEpiAuxs.h.{u1} A B f) x) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) b (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))) (Exists.intro.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) b (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))) b (rfl.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) b)))))) (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.{u1} A B f (Subtype.mk.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Membership.mem.{u1, u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Set.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) (Set.instMembershipSet.{u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B))) x (Set.range.{u1, succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))))) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) (HMul.hMul.{u1, u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (instHMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (MulOneClass.toMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))))) x b) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))))) (Exists.intro.{succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (fun (y : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) => Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) y) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B)) (HMul.hMul.{u1, u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (instHMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (MulOneClass.toMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))))) x b) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))))) (HMul.hMul.{u1, u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (instHMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (MulOneClass.toMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))))) x b) (rfl.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Function.swap.{succ u1, succ u1, succ u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (fun (x : CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (y : Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) => Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (leftCoset.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EquivalenceGroupAddGroup.0.GroupCat.instMulOneClassαGroup.{u1} B))) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) (HMul.hMul.{u1, u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (instHMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (MulOneClass.toMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))))) x b))))))))
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.h_apply_from_coset_nin_range GroupCat.SurjectiveOfEpiAuxs.h_apply_fromCoset_nin_rangeₓ'. -/
theorem h_apply_fromCoset_nin_range (x : B) (hx : x ∈ f.range) (b : B) (hb : b ∉ f.range) :
    (h x) (fromCoset ⟨b *l f.range.carrier, ⟨b, rfl⟩⟩) =
      fromCoset ⟨x * b *l f.range.carrier, ⟨x * b, rfl⟩⟩ :=
  by
  simp only [H, tau, MonoidHom.coe_mk, Equiv.toFun_as_coe, Equiv.coe_trans, Function.comp_apply]
  rw [Equiv.symm_swap,
    @Equiv.swap_apply_of_ne_of_ne X' _ (from_coset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩) ∞
      (from_coset ⟨b *l f.range.carrier, ⟨b, rfl⟩⟩) (from_coset_ne_of_nin_range _ hb) (by simp)]
  simp only [g_apply_from_coset, ← Subtype.val_eq_coe, leftCoset_assoc]
  refine' Equiv.swap_apply_of_ne_of_ne (from_coset_ne_of_nin_range _ fun r => hb _) (by simp)
  convert Subgroup.mul_mem _ (Subgroup.inv_mem _ hx) r
  rw [← mul_assoc, mul_left_inv, one_mul]
#align Group.surjective_of_epi_auxs.h_apply_from_coset_nin_range GroupCat.SurjectiveOfEpiAuxs.h_apply_fromCoset_nin_range

/- warning: Group.surjective_of_epi_auxs.agree -> GroupCat.SurjectiveOfEpiAuxs.agree is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B), Eq.{succ u1} (Set.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (Subgroup.carrier.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f)) (setOf.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (fun (x : coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) => Eq.{succ u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) => (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) -> (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f))) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (GroupCat.SurjectiveOfEpiAuxs.h.{u1} A B f) x) (coeFn.{succ u1, succ u1} (MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) => (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) -> (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f))) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (GroupCat.SurjectiveOfEpiAuxs.g.{u1} A B f) x)))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B), Eq.{succ u1} (Set.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B)) (Subsemigroup.carrier.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (MulOneClass.toMul.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))) (Submonoid.toSubsemigroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Group.toDivInvMonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)))) (Subgroup.toSubmonoid.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f)))) (setOf.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (fun (x : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (fun (_x : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (MulOneClass.toMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B))))) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f))))) (MonoidHom.monoidHomClass.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))))) (GroupCat.SurjectiveOfEpiAuxs.h.{u1} A B f) x) (FunLike.coe.{succ u1, succ u1, succ u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (fun (_x : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) => Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) _x) (MulHomClass.toFunLike.{u1, u1, u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (MulOneClass.toMul.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B))))) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (MonoidHomClass.toMulHomClass.{u1, u1, u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f))))) (MonoidHom.monoidHomClass.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))))) (GroupCat.SurjectiveOfEpiAuxs.g.{u1} A B f) x)))
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.agree GroupCat.SurjectiveOfEpiAuxs.agreeₓ'. -/
theorem agree : f.range.carrier = { x | h x = g x } :=
  by
  refine' Set.ext fun b => ⟨_, fun hb : h b = g b => by_contradiction fun r => _⟩
  · rintro ⟨a, rfl⟩
    change h (f a) = g (f a)
    ext ⟨⟨_, ⟨y, rfl⟩⟩⟩
    · rw [g_apply_from_coset]
      by_cases m : y ∈ f.range
      · rw [h_apply_from_coset' _ _ _ m, from_coset_eq_of_mem_range _ m]
        change from_coset _ = from_coset ⟨f a *l (y *l _), _⟩
        simpa only [← from_coset_eq_of_mem_range _ (Subgroup.mul_mem _ ⟨a, rfl⟩ m), leftCoset_assoc]
      · rw [h_apply_from_coset_nin_range _ _ ⟨_, rfl⟩ _ m]
        simpa only [← Subtype.val_eq_coe, leftCoset_assoc]
    · rw [g_apply_infinity, h_apply_infinity _ _ ⟨_, rfl⟩]
  · have eq1 :
      (h b) (from_coset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩) =
        from_coset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩ :=
      by simp [H, tau, g_apply_infinity]
    have eq2 :
      (g b) (from_coset ⟨f.range.carrier, ⟨1, one_leftCoset _⟩⟩) =
        from_coset ⟨b *l f.range.carrier, ⟨b, rfl⟩⟩ :=
      rfl
    exact (from_coset_ne_of_nin_range _ r).symm (by rw [← eq1, ← eq2, FunLike.congr_fun hb])
#align Group.surjective_of_epi_auxs.agree GroupCat.SurjectiveOfEpiAuxs.agree

#print GroupCat.SurjectiveOfEpiAuxs.comp_eq /-
theorem comp_eq : (f ≫ show B ⟶ GroupCat.of SX' from g) = f ≫ h :=
  FunLike.ext _ _ fun a => by
    simp only [comp_apply, show h (f a) = _ from (by simp [← agree] : f a ∈ { b | h b = g b })]
#align Group.surjective_of_epi_auxs.comp_eq GroupCat.SurjectiveOfEpiAuxs.comp_eq
-/

/- warning: Group.surjective_of_epi_auxs.g_ne_h -> GroupCat.SurjectiveOfEpiAuxs.g_ne_h is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B), (Not (Membership.Mem.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (SetLike.hasMem.{u1, u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Subgroup.setLike.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))) x (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f))) -> (Ne.{succ u1} (MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (DivInvMonoid.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (Group.toDivInvMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.hasCoeToSort.{u1} B) (GroupCat.group.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (GroupCat.SurjectiveOfEpiAuxs.g.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.h.{u1} A B f))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (x : CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B), (Not (Membership.mem.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (SetLike.instMembership.{u1, u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (Subgroup.instSetLikeSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))) x (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f))) -> (Ne.{succ u1} (MonoidHom.{u1, u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Monoid.toMulOneClass.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (DivInvMonoid.toMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (Group.toDivInvMonoid.{u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (GroupCat.instGroupCoeGroupCatTypeInstCoeSortGroupCatType.{u1} B)))) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)) (Equiv.Perm.permGroup.{u1} (GroupCat.SurjectiveOfEpiAuxs.XWithInfinity.{u1} A B f)))))) (GroupCat.SurjectiveOfEpiAuxs.g.{u1} A B f) (GroupCat.SurjectiveOfEpiAuxs.h.{u1} A B f))
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi_auxs.g_ne_h GroupCat.SurjectiveOfEpiAuxs.g_ne_hₓ'. -/
theorem g_ne_h (x : B) (hx : x ∉ f.range) : g ≠ h :=
  by
  intro r
  replace r :=
    FunLike.congr_fun (FunLike.congr_fun r x) (from_coset ⟨f.range, ⟨1, one_leftCoset _⟩⟩)
  rw [H, g_apply_from_coset, MonoidHom.coe_mk, tau] at r
  simp only [MonoidHom.coe_range, Subtype.coe_mk, Equiv.symm_swap, Equiv.toFun_as_coe,
    Equiv.coe_trans, Function.comp_apply] at r
  erw [Equiv.swap_apply_left, g_apply_infinity, Equiv.swap_apply_right] at r
  exact from_coset_ne_of_nin_range _ hx r
#align Group.surjective_of_epi_auxs.g_ne_h GroupCat.SurjectiveOfEpiAuxs.g_ne_h

end SurjectiveOfEpiAuxs

/- warning: Group.surjective_of_epi -> GroupCat.surjective_of_epi is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) [_inst_1 : CategoryTheory.Epi.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f], Function.Surjective.{succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} A))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} B)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} A))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} B)))) f)
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) [_inst_1 : CategoryTheory.Epi.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f], Function.Surjective.{succ u1, succ u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} A) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeFun.coe.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (fun (_x : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) => (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} A) -> (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B)) (GroupCat.instCoeFunHomGroupCatToQuiverToCategoryStructLargeCategoryForAllCoeTypeInstCoeSortGroupCatType.{u1} A B) f)
Case conversion may be inaccurate. Consider using '#align Group.surjective_of_epi GroupCat.surjective_of_epiₓ'. -/
theorem surjective_of_epi [Epi f] : Function.Surjective f :=
  by
  by_contra r
  push_neg  at r
  rcases r with ⟨b, hb⟩
  exact
    surjective_of_epi_auxs.g_ne_h f b (fun ⟨c, hc⟩ => hb _ hc)
      ((cancel_epi f).1 (surjective_of_epi_auxs.comp_eq f))
#align Group.surjective_of_epi GroupCat.surjective_of_epi

/- warning: Group.epi_iff_surjective -> GroupCat.epi_iff_surjective is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f) (Function.Surjective.{succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} A))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} B)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} A))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} Group.{u1} B)))) f))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f) (Function.Surjective.{succ u1, succ u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} A) (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B) (CoeFun.coe.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) (fun (_x : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B) => (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} A) -> (CoeSort.coe.{succ (succ u1), succ (succ u1)} GroupCat.{u1} Type.{u1} GroupCat.instCoeSortGroupCatType.{u1} B)) (GroupCat.instCoeFunHomGroupCatToQuiverToCategoryStructLargeCategoryForAllCoeTypeInstCoeSortGroupCatType.{u1} A B) f))
Case conversion may be inaccurate. Consider using '#align Group.epi_iff_surjective GroupCat.epi_iff_surjectiveₓ'. -/
theorem epi_iff_surjective : Epi f ↔ Function.Surjective f :=
  ⟨fun h => @surjective_of_epi f h, ConcreteCategory.epi_of_surjective _⟩
#align Group.epi_iff_surjective GroupCat.epi_iff_surjective

/- warning: Group.epi_iff_range_eq_top -> GroupCat.epi_iff_range_eq_top is a dubious translation:
lean 3 declaration is
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f) (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) A) (GroupCat.group.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B) f) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B)) (Subgroup.hasTop.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} Group.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} Group.{u1}) B) (GroupCat.group.{u1} B))))
but is expected to have type
  forall {A : GroupCat.{u1}} {B : GroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} GroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} GroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} GroupCat.{u1} GroupCat.largeCategory.{u1} A B f) (Eq.{succ u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} A) (GroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B) f) (Top.top.{u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B)) (Subgroup.instTopSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} Group.{u1} B) (GroupCat.instGroupα.{u1} B))))
Case conversion may be inaccurate. Consider using '#align Group.epi_iff_range_eq_top GroupCat.epi_iff_range_eq_topₓ'. -/
theorem epi_iff_range_eq_top : Epi f ↔ f.range = ⊤ :=
  Iff.trans (epi_iff_surjective _) (Subgroup.eq_top_iff' f.range).symm
#align Group.epi_iff_range_eq_top GroupCat.epi_iff_range_eq_top

end GroupCat

namespace AddGroupCat

variable {A B : AddGroupCat.{u}} (f : A ⟶ B)

/- warning: AddGroup.epi_iff_surjective -> AddGroupCat.epi_iff_surjective is a dubious translation:
lean 3 declaration is
  forall {A : AddGroupCat.{u1}} {B : AddGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1} A B f) (Function.Surjective.{succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} AddGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1})) A B) (fun (_x : AddMonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) A) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} AddGroup.{u1} A))) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} AddGroup.{u1} B)))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) A) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B)) (AddMonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) A) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} AddGroup.{u1} A))) (AddMonoid.toAddZeroClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (AddGroup.toAddMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} AddGroup.{u1} B)))) f))
but is expected to have type
  forall {A : AddGroupCat.{u1}} {B : AddGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1} A B f) (Function.Surjective.{succ u1, succ u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} AddGroupCat.{u1} Type.{u1} AddGroupCat.instCoeSortAddGroupCatType.{u1} A) (CoeSort.coe.{succ (succ u1), succ (succ u1)} AddGroupCat.{u1} Type.{u1} AddGroupCat.instCoeSortAddGroupCatType.{u1} B) (CoeFun.coe.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} AddGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1})) A B) (fun (_x : Quiver.Hom.{succ u1, succ u1} AddGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1})) A B) => (CoeSort.coe.{succ (succ u1), succ (succ u1)} AddGroupCat.{u1} Type.{u1} AddGroupCat.instCoeSortAddGroupCatType.{u1} A) -> (CoeSort.coe.{succ (succ u1), succ (succ u1)} AddGroupCat.{u1} Type.{u1} AddGroupCat.instCoeSortAddGroupCatType.{u1} B)) (AddGroupCat.instCoeFunHomAddGroupCatToQuiverToCategoryStructLargeCategoryForAllCoeTypeInstCoeSortAddGroupCatType.{u1} A B) f))
Case conversion may be inaccurate. Consider using '#align AddGroup.epi_iff_surjective AddGroupCat.epi_iff_surjectiveₓ'. -/
theorem epi_iff_surjective : Epi f ↔ Function.Surjective f :=
  by
  have i1 : epi f ↔ epi (Group_AddGroup_equivalence.inverse.map f) :=
    by
    refine' ⟨_, Group_AddGroup_equivalence.inverse.epi_of_epi_map⟩
    intro e'
    apply Group_AddGroup_equivalence.inverse.map_epi
  rwa [GroupCat.epi_iff_surjective] at i1
#align AddGroup.epi_iff_surjective AddGroupCat.epi_iff_surjective

/- warning: AddGroup.epi_iff_range_eq_top -> AddGroupCat.epi_iff_range_eq_top is a dubious translation:
lean 3 declaration is
  forall {A : AddGroupCat.{u1}} {B : AddGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1} A B f) (Eq.{succ u1} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (AddGroupCat.addGroup.{u1} B)) (AddMonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) A) (AddGroupCat.addGroup.{u1} A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (AddGroupCat.addGroup.{u1} B) f) (Top.top.{u1} (AddSubgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (AddGroupCat.addGroup.{u1} B)) (AddSubgroup.hasTop.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} AddGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} AddGroup.{u1}) B) (AddGroupCat.addGroup.{u1} B))))
but is expected to have type
  forall {A : AddGroupCat.{u1}} {B : AddGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} AddGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} AddGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} AddGroupCat.{u1} AddGroupCat.largeCategory.{u1} A B f) (Eq.{succ u1} (AddSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} AddGroup.{u1} B) (AddGroupCat.instGroupα.{u1} B)) (AddMonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} AddGroup.{u1} A) (AddGroupCat.instGroupα.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} AddGroup.{u1} B) (AddGroupCat.instGroupα.{u1} B) f) (Top.top.{u1} (AddSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} AddGroup.{u1} B) (AddGroupCat.instGroupα.{u1} B)) (AddSubgroup.instTopAddSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} AddGroup.{u1} B) (AddGroupCat.instGroupα.{u1} B))))
Case conversion may be inaccurate. Consider using '#align AddGroup.epi_iff_range_eq_top AddGroupCat.epi_iff_range_eq_topₓ'. -/
theorem epi_iff_range_eq_top : Epi f ↔ f.range = ⊤ :=
  Iff.trans (epi_iff_surjective _) (AddSubgroup.eq_top_iff' f.range).symm
#align AddGroup.epi_iff_range_eq_top AddGroupCat.epi_iff_range_eq_top

end AddGroupCat

namespace GroupCat

variable {A B : GroupCat.{u}} (f : A ⟶ B)

#print GroupCat.forget_groupCat_preserves_mono /-
@[to_additive]
instance forget_groupCat_preserves_mono : (forget GroupCat).PreservesMonomorphisms
    where preserves X Y f e := by rwa [mono_iff_injective, ← CategoryTheory.mono_iff_injective] at e
#align Group.forget_Group_preserves_mono GroupCat.forget_groupCat_preserves_mono
#align AddGroup.forget_Group_preserves_mono AddGroupCat.forget_groupCat_preserves_mono
-/

#print GroupCat.forget_groupCat_preserves_epi /-
@[to_additive]
instance forget_groupCat_preserves_epi : (forget GroupCat).PreservesEpimorphisms
    where preserves X Y f e := by rwa [epi_iff_surjective, ← CategoryTheory.epi_iff_surjective] at e
#align Group.forget_Group_preserves_epi GroupCat.forget_groupCat_preserves_epi
#align AddGroup.forget_Group_preserves_epi AddGroupCat.forget_groupCat_preserves_epi
-/

end GroupCat

namespace CommGroupCat

variable {A B : CommGroupCat.{u}} (f : A ⟶ B)

/- warning: CommGroup.ker_eq_bot_of_mono -> CommGroupCat.ker_eq_bot_of_mono is a dubious translation:
lean 3 declaration is
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B) [_inst_1 : CategoryTheory.Mono.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f], Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroupCat.commGroupInstance.{u1} A))) (MonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroupCat.commGroupInstance.{u1} A)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} B)))) f) (Bot.bot.{u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroupCat.commGroupInstance.{u1} A))) (Subgroup.hasBot.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroupCat.commGroupInstance.{u1} A))))
but is expected to have type
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B) [_inst_1 : CategoryTheory.Mono.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f], Eq.{succ u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} A) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} A)) (MonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} A) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) ((fun {α : Type.{u1}} (h : Group.{u1} α) => DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α h)) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} B)))) f) (Bot.bot.{u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} A) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} A)) (Subgroup.instBotSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} A) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} A)))
Case conversion may be inaccurate. Consider using '#align CommGroup.ker_eq_bot_of_mono CommGroupCat.ker_eq_bot_of_monoₓ'. -/
@[to_additive AddCommGroupCat.ker_eq_bot_of_mono]
theorem ker_eq_bot_of_mono [Mono f] : f.ker = ⊥ :=
  MonoidHom.ker_eq_bot_of_cancel fun u v =>
    (@cancel_mono _ _ _ _ _ f _ (show CommGroupCat.of f.ker ⟶ A from u) _).1
#align CommGroup.ker_eq_bot_of_mono CommGroupCat.ker_eq_bot_of_mono
#align AddCommGroup.ker_eq_bot_of_mono AddCommGroupCat.ker_eq_bot_of_mono

/- warning: CommGroup.mono_iff_ker_eq_bot -> CommGroupCat.mono_iff_ker_eq_bot is a dubious translation:
lean 3 declaration is
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Mono.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f) (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroupCat.commGroupInstance.{u1} A))) (MonoidHom.ker.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroupCat.commGroupInstance.{u1} A)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} B)))) f) (Bot.bot.{u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroupCat.commGroupInstance.{u1} A))) (Subgroup.hasBot.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroupCat.commGroupInstance.{u1} A)))))
but is expected to have type
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Mono.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f) (Eq.{succ u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} A) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} A)) (MonoidHom.ker.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} A) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (Monoid.toMulOneClass.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) ((fun {α : Type.{u1}} (h : Group.{u1} α) => DivInvMonoid.toMonoid.{u1} α (Group.toDivInvMonoid.{u1} α h)) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (CommGroup.toGroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} B)))) f) (Bot.bot.{u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} A) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} A)) (Subgroup.instBotSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} A) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} A))))
Case conversion may be inaccurate. Consider using '#align CommGroup.mono_iff_ker_eq_bot CommGroupCat.mono_iff_ker_eq_botₓ'. -/
@[to_additive AddCommGroupCat.mono_iff_ker_eq_bot]
theorem mono_iff_ker_eq_bot : Mono f ↔ f.ker = ⊥ :=
  ⟨fun h => @ker_eq_bot_of_mono f h, fun h =>
    ConcreteCategory.mono_of_injective _ <| (MonoidHom.ker_eq_bot_iff f).1 h⟩
#align CommGroup.mono_iff_ker_eq_bot CommGroupCat.mono_iff_ker_eq_bot
#align AddCommGroup.mono_iff_ker_eq_bot AddCommGroupCat.mono_iff_ker_eq_bot

/- warning: CommGroup.mono_iff_injective -> CommGroupCat.mono_iff_injective is a dubious translation:
lean 3 declaration is
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Mono.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f) (Function.Injective.{succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} A)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} B))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} A)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} B))))) f))
but is expected to have type
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Mono.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f) (Function.Injective.{succ u1, succ u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.instCoeSortCommGroupCatType.{u1} A) (CoeSort.coe.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.instCoeSortCommGroupCatType.{u1} B) (CoeFun.coe.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B) (fun (_x : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B) => (CoeSort.coe.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.instCoeSortCommGroupCatType.{u1} A) -> (CoeSort.coe.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.instCoeSortCommGroupCatType.{u1} B)) (CommGroupCat.instCoeFunHomCommGroupCatToQuiverToCategoryStructLargeCategoryForAllCoeTypeInstCoeSortCommGroupCatType.{u1} A B) f))
Case conversion may be inaccurate. Consider using '#align CommGroup.mono_iff_injective CommGroupCat.mono_iff_injectiveₓ'. -/
@[to_additive AddCommGroupCat.mono_iff_injective]
theorem mono_iff_injective : Mono f ↔ Function.Injective f :=
  Iff.trans (mono_iff_ker_eq_bot f) <| MonoidHom.ker_eq_bot_iff f
#align CommGroup.mono_iff_injective CommGroupCat.mono_iff_injective
#align AddCommGroup.mono_iff_injective AddCommGroupCat.mono_iff_injective

/- warning: CommGroup.range_eq_top_of_epi -> CommGroupCat.range_eq_top_of_epi is a dubious translation:
lean 3 declaration is
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B) [_inst_1 : CategoryTheory.Epi.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f], Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroupCat.commGroupInstance.{u1} B))) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroupCat.commGroupInstance.{u1} A)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroupCat.commGroupInstance.{u1} B)) f) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroupCat.commGroupInstance.{u1} B))) (Subgroup.hasTop.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroupCat.commGroupInstance.{u1} B))))
but is expected to have type
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B) [_inst_1 : CategoryTheory.Epi.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f], Eq.{succ u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} B)) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} A) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} B) f) (Top.top.{u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} B)) (Subgroup.instTopSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} B)))
Case conversion may be inaccurate. Consider using '#align CommGroup.range_eq_top_of_epi CommGroupCat.range_eq_top_of_epiₓ'. -/
@[to_additive]
theorem range_eq_top_of_epi [Epi f] : f.range = ⊤ :=
  MonoidHom.range_eq_top_of_cancel fun u v h =>
    (@cancel_epi _ _ _ _ _ f _ (show B ⟶ ⟨B ⧸ MonoidHom.range f⟩ from u) v).1 h
#align CommGroup.range_eq_top_of_epi CommGroupCat.range_eq_top_of_epi
#align AddCommGroup.range_eq_top_of_epi AddCommGroupCat.range_eq_top_of_epi

/- warning: CommGroup.epi_iff_range_eq_top -> CommGroupCat.epi_iff_range_eq_top is a dubious translation:
lean 3 declaration is
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f) (Eq.{succ u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroupCat.commGroupInstance.{u1} B))) (MonoidHom.range.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroupCat.commGroupInstance.{u1} A)) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroupCat.commGroupInstance.{u1} B)) f) (Top.top.{u1} (Subgroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroupCat.commGroupInstance.{u1} B))) (Subgroup.hasTop.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroupCat.commGroupInstance.{u1} B)))))
but is expected to have type
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f) (Eq.{succ u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} B)) (MonoidHom.range.{u1, u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} A) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} A) (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} B) f) (Top.top.{u1} (Subgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} B)) (Subgroup.instTopSubgroup.{u1} (CategoryTheory.Bundled.α.{u1, u1} CommGroup.{u1} B) (_private.Mathlib.Algebra.Category.GroupCat.EpiMono.0.CommGroupCat.instGroupαCommGroup.{u1} B))))
Case conversion may be inaccurate. Consider using '#align CommGroup.epi_iff_range_eq_top CommGroupCat.epi_iff_range_eq_topₓ'. -/
@[to_additive]
theorem epi_iff_range_eq_top : Epi f ↔ f.range = ⊤ :=
  ⟨fun hf => range_eq_top_of_epi _, fun hf =>
    ConcreteCategory.epi_of_surjective _ <| MonoidHom.range_top_iff_surjective.mp hf⟩
#align CommGroup.epi_iff_range_eq_top CommGroupCat.epi_iff_range_eq_top
#align AddCommGroup.epi_iff_range_eq_top AddCommGroupCat.epi_iff_range_eq_top

/- warning: CommGroup.epi_iff_surjective -> CommGroupCat.epi_iff_surjective is a dubious translation:
lean 3 declaration is
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f) (Function.Surjective.{succ u1, succ u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B) (fun (_x : MonoidHom.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} A)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} B))))) => (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) -> (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B)) (MonoidHom.hasCoeToFun.{u1, u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) A) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} A)))) (Monoid.toMulOneClass.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (Group.toMonoid.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CommGroup.toGroup.{u1} (coeSort.{succ (succ u1), succ (succ u1)} (CategoryTheory.Bundled.{u1, u1} CommGroup.{u1}) Type.{u1} (CategoryTheory.Bundled.hasCoeToSort.{u1, u1} CommGroup.{u1}) B) (CategoryTheory.Bundled.str.{u1, u1} CommGroup.{u1} B))))) f))
but is expected to have type
  forall {A : CommGroupCat.{u1}} {B : CommGroupCat.{u1}} (f : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B), Iff (CategoryTheory.Epi.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1} A B f) (Function.Surjective.{succ u1, succ u1} (CoeSort.coe.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.instCoeSortCommGroupCatType.{u1} A) (CoeSort.coe.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.instCoeSortCommGroupCatType.{u1} B) (CoeFun.coe.{succ u1, succ u1} (Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B) (fun (_x : Quiver.Hom.{succ u1, succ u1} CommGroupCat.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} CommGroupCat.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} CommGroupCat.{u1} CommGroupCat.largeCategory.{u1})) A B) => (CoeSort.coe.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.instCoeSortCommGroupCatType.{u1} A) -> (CoeSort.coe.{succ (succ u1), succ (succ u1)} CommGroupCat.{u1} Type.{u1} CommGroupCat.instCoeSortCommGroupCatType.{u1} B)) (CommGroupCat.instCoeFunHomCommGroupCatToQuiverToCategoryStructLargeCategoryForAllCoeTypeInstCoeSortCommGroupCatType.{u1} A B) f))
Case conversion may be inaccurate. Consider using '#align CommGroup.epi_iff_surjective CommGroupCat.epi_iff_surjectiveₓ'. -/
@[to_additive]
theorem epi_iff_surjective : Epi f ↔ Function.Surjective f := by
  rw [epi_iff_range_eq_top, MonoidHom.range_top_iff_surjective]
#align CommGroup.epi_iff_surjective CommGroupCat.epi_iff_surjective
#align AddCommGroup.epi_iff_surjective AddCommGroupCat.epi_iff_surjective

#print CommGroupCat.forget_commGroupCat_preserves_mono /-
@[to_additive]
instance forget_commGroupCat_preserves_mono : (forget CommGroupCat).PreservesMonomorphisms
    where preserves X Y f e := by rwa [mono_iff_injective, ← CategoryTheory.mono_iff_injective] at e
#align CommGroup.forget_CommGroup_preserves_mono CommGroupCat.forget_commGroupCat_preserves_mono
#align AddCommGroup.forget_CommGroup_preserves_mono AddCommGroupCat.forget_commGroupCat_preserves_mono
-/

#print CommGroupCat.forget_commGroupCat_preserves_epi /-
@[to_additive]
instance forget_commGroupCat_preserves_epi : (forget CommGroupCat).PreservesEpimorphisms
    where preserves X Y f e := by rwa [epi_iff_surjective, ← CategoryTheory.epi_iff_surjective] at e
#align CommGroup.forget_CommGroup_preserves_epi CommGroupCat.forget_commGroupCat_preserves_epi
#align AddCommGroup.forget_CommGroup_preserves_epi AddCommGroupCat.forget_commGroupCat_preserves_epi
-/

end CommGroupCat

end

