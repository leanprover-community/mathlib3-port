/-
Copyright (c) 2022 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module algebra.category.Module.products
! leanprover-community/mathlib commit 86d1873c01a723aba6788f0b9051ae3d23b4c1c3
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Pi
import Mathbin.Algebra.Category.Module.Basic

/-!
# The concrete products in the category of modules are products in the categorical sense.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
-/


open CategoryTheory

open CategoryTheory.Limits

universe u v w

namespace ModuleCat

variable {R : Type u} [Ring R]

variable {ι : Type v} (Z : ι → ModuleCat.{max v w} R)

/- warning: Module.product_cone -> ModuleCat.productCone is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u}} [_inst_1 : Ring.{u} R] {ι : Type.{v}} (Z : ι -> (ModuleCat.{max v w, u} R _inst_1)), CategoryTheory.Limits.Fan.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z
but is expected to have type
  forall {R : Type.{u}} [_inst_1 : Ring.{u} R] {ι : Type.{v}} (Z : ι -> (ModuleCat.{v, u} R _inst_1)), CategoryTheory.Limits.Fan.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z
Case conversion may be inaccurate. Consider using '#align Module.product_cone ModuleCat.productConeₓ'. -/
/-- The product cone induced by the concrete product. -/
def productCone : Fan Z :=
  Fan.mk (ModuleCat.of R (∀ i : ι, Z i)) fun i => (LinearMap.proj i : (∀ i : ι, Z i) →ₗ[R] Z i)
#align Module.product_cone ModuleCat.productCone

/- warning: Module.product_cone_is_limit -> ModuleCat.productConeIsLimit is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u}} [_inst_1 : Ring.{u} R] {ι : Type.{v}} (Z : ι -> (ModuleCat.{max v w, u} R _inst_1)), CategoryTheory.Limits.IsLimit.{v, max v w, v, max u (succ (max v w))} (CategoryTheory.Discrete.{v} ι) (CategoryTheory.discreteCategory.{v} ι) (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) (CategoryTheory.Discrete.functor.{max v w, v, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) ι Z) (ModuleCat.productCone.{u, v, w} R _inst_1 ι Z)
but is expected to have type
  forall {R : Type.{u}} [_inst_1 : Ring.{u} R] {ι : Type.{v}} (Z : ι -> (ModuleCat.{v, u} R _inst_1)), CategoryTheory.Limits.IsLimit.{v, v, v, max u (succ v)} (CategoryTheory.Discrete.{v} ι) (CategoryTheory.discreteCategory.{v} ι) (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) (CategoryTheory.Discrete.functor.{v, v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) ι Z) (ModuleCat.productCone.{u, v} R _inst_1 ι Z)
Case conversion may be inaccurate. Consider using '#align Module.product_cone_is_limit ModuleCat.productConeIsLimitₓ'. -/
/-- The concrete product cone is limiting. -/
def productConeIsLimit : IsLimit (productCone Z)
    where
  lift s := (LinearMap.pi fun j => s.π.app ⟨j⟩ : s.pt →ₗ[R] ∀ i : ι, Z i)
  fac s j := by cases j; tidy
  uniq s m w := by ext (x i); exact LinearMap.congr_fun (w ⟨i⟩) x
#align Module.product_cone_is_limit ModuleCat.productConeIsLimit

-- While we could use this to construct a `has_products (Module R)` instance,
-- we already have `has_limits (Module R)` in `algebra.category.Module.limits`.
variable [HasProduct Z]

/- warning: Module.pi_iso_pi -> ModuleCat.piIsoPi is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u}} [_inst_1 : Ring.{u} R] {ι : Type.{v}} (Z : ι -> (ModuleCat.{max v w, u} R _inst_1)) [_inst_2 : CategoryTheory.Limits.HasProduct.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z], CategoryTheory.Iso.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) (CategoryTheory.Limits.piObj.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z _inst_2) (ModuleCat.of.{max v w, u} R _inst_1 (forall (i : ι), coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (Pi.addCommGroup.{v, max v w} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (Pi.module.{v, max v w, u} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{max v w} (coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{max v w, u} R _inst_1 (Z i))))
but is expected to have type
  forall {R : Type.{u}} [_inst_1 : Ring.{u} R] {ι : Type.{v}} (Z : ι -> (ModuleCat.{v, u} R _inst_1)) [_inst_2 : CategoryTheory.Limits.HasProduct.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z], CategoryTheory.Iso.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) (CategoryTheory.Limits.piObj.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z _inst_2) (ModuleCat.of.{v, u} R _inst_1 (forall (i : ι), ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (Pi.addCommGroup.{v, v} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (Pi.module.{v, v, u} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{v} (ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{v, u} R _inst_1 (Z i))))
Case conversion may be inaccurate. Consider using '#align Module.pi_iso_pi ModuleCat.piIsoPiₓ'. -/
/-- The categorical product of a family of objects in `Module`
agrees with the usual module-theoretical product.
-/
noncomputable def piIsoPi : ∏ Z ≅ ModuleCat.of R (∀ i, Z i) :=
  limit.isoLimitCone ⟨_, productConeIsLimit Z⟩
#align Module.pi_iso_pi ModuleCat.piIsoPi

/- warning: Module.pi_iso_pi_inv_kernel_ι -> ModuleCat.piIsoPi_inv_kernel_ι is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u}} [_inst_1 : Ring.{u} R] {ι : Type.{v}} (Z : ι -> (ModuleCat.{max v w, u} R _inst_1)) [_inst_2 : CategoryTheory.Limits.HasProduct.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z] (i : ι), Eq.{succ (max v w)} (Quiver.Hom.{succ (max v w), max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1))) (ModuleCat.of.{max v w, u} R _inst_1 (forall (i : ι), coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (Pi.addCommGroup.{v, max v w} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (Pi.module.{v, max v w, u} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{max v w} (coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{max v w, u} R _inst_1 (Z i)))) (Z i)) (CategoryTheory.CategoryStruct.comp.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1)) (ModuleCat.of.{max v w, u} R _inst_1 (forall (i : ι), coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (Pi.addCommGroup.{v, max v w} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (Pi.module.{v, max v w, u} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{max v w} (coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{max v w, u} R _inst_1 (Z i)))) (CategoryTheory.Limits.piObj.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z _inst_2) (Z i) (CategoryTheory.Iso.inv.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) (CategoryTheory.Limits.piObj.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z _inst_2) (ModuleCat.of.{max v w, u} R _inst_1 (forall (i : ι), coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (Pi.addCommGroup.{v, max v w} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (Pi.module.{v, max v w, u} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{max v w} (coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{max v w, u} R _inst_1 (Z i)))) (ModuleCat.piIsoPi.{u, v, w} R _inst_1 ι Z _inst_2)) (CategoryTheory.Limits.Pi.π.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z _inst_2 i)) (LinearMap.proj.{u, v, max v w} R ι (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{max v w} (coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{max v w, u} R _inst_1 (Z i)) i)
but is expected to have type
  forall {R : Type.{u}} [_inst_1 : Ring.{u} R] {ι : Type.{v}} (Z : ι -> (ModuleCat.{v, u} R _inst_1)) [_inst_2 : CategoryTheory.Limits.HasProduct.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z] (i : ι), Eq.{succ v} (Quiver.Hom.{succ v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1))) (ModuleCat.of.{v, u} R _inst_1 (forall (i : ι), ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (Pi.addCommGroup.{v, v} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (Pi.module.{v, v, u} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{v} (ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{v, u} R _inst_1 (Z i)))) (Z i)) (CategoryTheory.CategoryStruct.comp.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1)) (ModuleCat.of.{v, u} R _inst_1 (forall (i : ι), ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (Pi.addCommGroup.{v, v} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (Pi.module.{v, v, u} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{v} (ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{v, u} R _inst_1 (Z i)))) (CategoryTheory.Limits.piObj.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z _inst_2) (Z i) (CategoryTheory.Iso.inv.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) (CategoryTheory.Limits.piObj.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z _inst_2) (ModuleCat.of.{v, u} R _inst_1 (forall (i : ι), ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (Pi.addCommGroup.{v, v} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (Pi.module.{v, v, u} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{v} (ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{v, u} R _inst_1 (Z i)))) (ModuleCat.piIsoPi.{u, v} R _inst_1 ι Z _inst_2)) (CategoryTheory.Limits.Pi.π.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z _inst_2 i)) (LinearMap.proj.{u, v, v} R ι (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{v} (ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{v, u} R _inst_1 (Z i)) i)
Case conversion may be inaccurate. Consider using '#align Module.pi_iso_pi_inv_kernel_ι ModuleCat.piIsoPi_inv_kernel_ιₓ'. -/
-- We now show this isomorphism commutes with the inclusion of the kernel into the source.
@[simp, elementwise]
theorem piIsoPi_inv_kernel_ι (i : ι) :
    (piIsoPi Z).inv ≫ Pi.π Z i = (LinearMap.proj i : (∀ i : ι, Z i) →ₗ[R] Z i) :=
  limit.isoLimitCone_inv_π _ _
#align Module.pi_iso_pi_inv_kernel_ι ModuleCat.piIsoPi_inv_kernel_ι

/- warning: Module.pi_iso_pi_hom_ker_subtype -> ModuleCat.piIsoPi_hom_ker_subtype is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u}} [_inst_1 : Ring.{u} R] {ι : Type.{v}} (Z : ι -> (ModuleCat.{max v w, u} R _inst_1)) [_inst_2 : CategoryTheory.Limits.HasProduct.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z] (i : ι), Eq.{succ (max v w)} (Quiver.Hom.{succ (max v w), max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1))) (CategoryTheory.Limits.piObj.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z _inst_2) (Z i)) (CategoryTheory.CategoryStruct.comp.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1)) (CategoryTheory.Limits.piObj.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z _inst_2) (ModuleCat.of.{max v w, u} R _inst_1 (forall (i : ι), coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (Pi.addCommGroup.{v, max v w} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (Pi.module.{v, max v w, u} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{max v w} (coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{max v w, u} R _inst_1 (Z i)))) (Z i) (CategoryTheory.Iso.hom.{max v w, max u (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) (CategoryTheory.Limits.piObj.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z _inst_2) (ModuleCat.of.{max v w, u} R _inst_1 (forall (i : ι), coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (Pi.addCommGroup.{v, max v w} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (Pi.module.{v, max v w, u} ι (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{max v w} (coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{max v w, u} R _inst_1 (Z i)))) (ModuleCat.piIsoPi.{u, v, w} R _inst_1 ι Z _inst_2)) (LinearMap.proj.{u, v, max v w} R ι (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{max v w} (coeSort.{max (succ u) (succ (succ (max v w))), succ (succ (max v w))} (ModuleCat.{max v w, u} R _inst_1) Type.{max v w} (ModuleCat.hasCoeToSort.{max v w, u} R _inst_1) (Z i)) (ModuleCat.isAddCommGroup.{max v w, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{max v w, u} R _inst_1 (Z i)) i)) (CategoryTheory.Limits.Pi.π.{v, max v w, max u (succ (max v w))} ι (ModuleCat.{max v w, u} R _inst_1) (ModuleCat.moduleCategory.{max v w, u} R _inst_1) Z _inst_2 i)
but is expected to have type
  forall {R : Type.{u}} [_inst_1 : Ring.{u} R] {ι : Type.{v}} (Z : ι -> (ModuleCat.{v, u} R _inst_1)) [_inst_2 : CategoryTheory.Limits.HasProduct.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z] (i : ι), Eq.{succ v} (Quiver.Hom.{succ v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1))) (CategoryTheory.Limits.piObj.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z _inst_2) (Z i)) (CategoryTheory.CategoryStruct.comp.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1)) (CategoryTheory.Limits.piObj.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z _inst_2) (ModuleCat.of.{v, u} R _inst_1 (forall (i : ι), ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (Pi.addCommGroup.{v, v} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (Pi.module.{v, v, u} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{v} (ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{v, u} R _inst_1 (Z i)))) (Z i) (CategoryTheory.Iso.hom.{v, max u (succ v)} (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) (CategoryTheory.Limits.piObj.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z _inst_2) (ModuleCat.of.{v, u} R _inst_1 (forall (i : ι), ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (Pi.addCommGroup.{v, v} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (fun (i : ι) => ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (Pi.module.{v, v, u} ι (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) R (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{v} (ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{v, u} R _inst_1 (Z i)))) (ModuleCat.piIsoPi.{u, v} R _inst_1 ι Z _inst_2)) (LinearMap.proj.{u, v, v} R ι (Ring.toSemiring.{u} R _inst_1) (fun (i : ι) => ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{v} (ModuleCat.carrier.{v, u} R _inst_1 (Z i)) (ModuleCat.isAddCommGroup.{v, u} R _inst_1 (Z i))) (fun (i : ι) => ModuleCat.isModule.{v, u} R _inst_1 (Z i)) i)) (CategoryTheory.Limits.Pi.π.{v, v, max u (succ v)} ι (ModuleCat.{v, u} R _inst_1) (ModuleCat.moduleCategory.{v, u} R _inst_1) Z _inst_2 i)
Case conversion may be inaccurate. Consider using '#align Module.pi_iso_pi_hom_ker_subtype ModuleCat.piIsoPi_hom_ker_subtypeₓ'. -/
@[simp, elementwise]
theorem piIsoPi_hom_ker_subtype (i : ι) :
    (piIsoPi Z).hom ≫ (LinearMap.proj i : (∀ i : ι, Z i) →ₗ[R] Z i) = Pi.π Z i :=
  IsLimit.conePointUniqueUpToIso_inv_comp _ (limit.isLimit _) (Discrete.mk i)
#align Module.pi_iso_pi_hom_ker_subtype ModuleCat.piIsoPi_hom_ker_subtype

end ModuleCat

