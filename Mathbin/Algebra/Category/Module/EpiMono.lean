/-
Copyright (c) 2021 Scott Morrison All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module algebra.category.Module.epi_mono
! leanprover-community/mathlib commit 70fd9563a21e7b963887c9360bd29b2393e6225a
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Quotient
import Mathbin.Algebra.Category.Module.Basic

/-!
# Monomorphisms in `Module R`

This file shows that an `R`-linear map is a monomorphism in the category of `R`-modules
if and only if it is injective, and similarly an epimorphism if and only if it is surjective.
-/


universe v u

open CategoryTheory

open ModuleCat

open ModuleCat

namespace ModuleCat

variable {R : Type u} [Ring R] {X Y : ModuleCat.{v} R} (f : X ⟶ Y)

variable {M : Type v} [AddCommGroup M] [Module R M]

/- warning: Module.ker_eq_bot_of_mono -> ModuleCat.ker_eq_bot_of_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) [_inst_4 : CategoryTheory.Mono.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f], Eq.{succ u1} (Submodule.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X)) (LinearMap.ker.{u2, u2, u1, u1, u1} R R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (ModuleCat.linearMapClass.{u2, u1} R _inst_1 X Y) f) (Bot.bot.{u1} (Submodule.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X)) (Submodule.hasBot.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) [_inst_4 : CategoryTheory.Mono.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f], Eq.{succ u1} (Submodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X)) (LinearMap.ker.{u2, u2, u1, u1, u1} R R (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (ModuleCat.instLinearMapClassHomModuleCatToQuiverToCategoryStructModuleCategoryCarrierToSemiringToAddCommMonoidIsAddCommGroupIsModule.{u2, u1} R _inst_1 X Y) f) (Bot.bot.{u1} (Submodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X)) (Submodule.instBotSubmodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X)))
Case conversion may be inaccurate. Consider using '#align Module.ker_eq_bot_of_mono ModuleCat.ker_eq_bot_of_monoₓ'. -/
theorem ker_eq_bot_of_mono [Mono f] : f.ker = ⊥ :=
  LinearMap.ker_eq_bot_of_cancel fun u v => (@cancel_mono _ _ _ _ _ f _ (↟u) (↟v)).1
#align Module.ker_eq_bot_of_mono ModuleCat.ker_eq_bot_of_mono

/- warning: Module.range_eq_top_of_epi -> ModuleCat.range_eq_top_of_epi is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) [_inst_4 : CategoryTheory.Epi.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f], Eq.{succ u1} (Submodule.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)) (LinearMap.range.{u2, u2, u1, u1, u1} R R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (ModuleCat.linearMapClass.{u2, u1} R _inst_1 X Y) (RingHomSurjective.ids.{u2} R (Ring.toSemiring.{u2} R _inst_1)) f) (Top.top.{u1} (Submodule.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)) (Submodule.hasTop.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) [_inst_4 : CategoryTheory.Epi.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f], Eq.{succ u1} (Submodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)) (LinearMap.range.{u2, u2, u1, u1, u1} R R (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (ModuleCat.instLinearMapClassHomModuleCatToQuiverToCategoryStructModuleCategoryCarrierToSemiringToAddCommMonoidIsAddCommGroupIsModule.{u2, u1} R _inst_1 X Y) (RingHomSurjective.ids.{u2} R (Ring.toSemiring.{u2} R _inst_1)) f) (Top.top.{u1} (Submodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)) (Submodule.instTopSubmodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)))
Case conversion may be inaccurate. Consider using '#align Module.range_eq_top_of_epi ModuleCat.range_eq_top_of_epiₓ'. -/
theorem range_eq_top_of_epi [Epi f] : f.range = ⊤ :=
  LinearMap.range_eq_top_of_cancel fun u v => (@cancel_epi _ _ _ _ _ f _ (↟u) (↟v)).1
#align Module.range_eq_top_of_epi ModuleCat.range_eq_top_of_epi

/- warning: Module.mono_iff_ker_eq_bot -> ModuleCat.mono_iff_ker_eq_bot is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y), Iff (CategoryTheory.Mono.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f) (Eq.{succ u1} (Submodule.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X)) (LinearMap.ker.{u2, u2, u1, u1, u1} R R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (ModuleCat.linearMapClass.{u2, u1} R _inst_1 X Y) f) (Bot.bot.{u1} (Submodule.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X)) (Submodule.hasBot.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y), Iff (CategoryTheory.Mono.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f) (Eq.{succ u1} (Submodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X)) (LinearMap.ker.{u2, u2, u1, u1, u1} R R (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (ModuleCat.instLinearMapClassHomModuleCatToQuiverToCategoryStructModuleCategoryCarrierToSemiringToAddCommMonoidIsAddCommGroupIsModule.{u2, u1} R _inst_1 X Y) f) (Bot.bot.{u1} (Submodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X)) (Submodule.instBotSubmodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 X) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (ModuleCat.isModule.{u1, u2} R _inst_1 X))))
Case conversion may be inaccurate. Consider using '#align Module.mono_iff_ker_eq_bot ModuleCat.mono_iff_ker_eq_botₓ'. -/
theorem mono_iff_ker_eq_bot : Mono f ↔ f.ker = ⊥ :=
  ⟨fun hf => ker_eq_bot_of_mono _, fun hf =>
    ConcreteCategory.mono_of_injective _ <| LinearMap.ker_eq_bot.1 hf⟩
#align Module.mono_iff_ker_eq_bot ModuleCat.mono_iff_ker_eq_bot

/- warning: Module.mono_iff_injective -> ModuleCat.mono_iff_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y), Iff (CategoryTheory.Mono.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f) (Function.Injective.{succ u1, succ u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (fun (_x : LinearMap.{u2, u2, u1, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)) => (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) -> (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y)) (LinearMap.hasCoeToFun.{u2, u2, u1, u1} R R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) f))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y), Iff (CategoryTheory.Mono.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f) (Function.Injective.{succ u1, succ u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (FunLike.coe.{succ u1, succ u1, succ u1} (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (ModuleCat.carrier.{u1, u2} R _inst_1 X) (fun (_x : ModuleCat.carrier.{u1, u2} R _inst_1 X) => (fun (x._@.Mathlib.Algebra.Category.ModuleCat.Basic._hyg.275 : ModuleCat.carrier.{u1, u2} R _inst_1 X) => ModuleCat.carrier.{u1, u2} R _inst_1 Y) _x) (ModuleCat.instFunLikeHomModuleCatToQuiverToCategoryStructModuleCategoryCarrier.{u1, u2} R _inst_1 X Y) f))
Case conversion may be inaccurate. Consider using '#align Module.mono_iff_injective ModuleCat.mono_iff_injectiveₓ'. -/
theorem mono_iff_injective : Mono f ↔ Function.Injective f := by
  rw [mono_iff_ker_eq_bot, LinearMap.ker_eq_bot]
#align Module.mono_iff_injective ModuleCat.mono_iff_injective

/- warning: Module.epi_iff_range_eq_top -> ModuleCat.epi_iff_range_eq_top is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y), Iff (CategoryTheory.Epi.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f) (Eq.{succ u1} (Submodule.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)) (LinearMap.range.{u2, u2, u1, u1, u1} R R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (ModuleCat.linearMapClass.{u2, u1} R _inst_1 X Y) (RingHomSurjective.ids.{u2} R (Ring.toSemiring.{u2} R _inst_1)) f) (Top.top.{u1} (Submodule.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)) (Submodule.hasTop.{u2, u1} R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y))))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y), Iff (CategoryTheory.Epi.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f) (Eq.{succ u1} (Submodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)) (LinearMap.range.{u2, u2, u1, u1, u1} R R (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (ModuleCat.instLinearMapClassHomModuleCatToQuiverToCategoryStructModuleCategoryCarrierToSemiringToAddCommMonoidIsAddCommGroupIsModule.{u2, u1} R _inst_1 X Y) (RingHomSurjective.ids.{u2} R (Ring.toSemiring.{u2} R _inst_1)) f) (Top.top.{u1} (Submodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)) (Submodule.instTopSubmodule.{u2, u1} R (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 Y))))
Case conversion may be inaccurate. Consider using '#align Module.epi_iff_range_eq_top ModuleCat.epi_iff_range_eq_topₓ'. -/
theorem epi_iff_range_eq_top : Epi f ↔ f.range = ⊤ :=
  ⟨fun hf => range_eq_top_of_epi _, fun hf =>
    ConcreteCategory.epi_of_surjective _ <| LinearMap.range_eq_top.1 hf⟩
#align Module.epi_iff_range_eq_top ModuleCat.epi_iff_range_eq_top

/- warning: Module.epi_iff_surjective -> ModuleCat.epi_iff_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y), Iff (CategoryTheory.Epi.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f) (Function.Surjective.{succ u1, succ u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (coeFn.{succ u1, succ u1} (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (fun (_x : LinearMap.{u2, u2, u1, u1} R R (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y)) => (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) -> (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y)) (LinearMap.hasCoeToFun.{u2, u2, u1, u1} R R (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (Ring.toSemiring.{u2} R _inst_1) (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) X) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 X)) (AddCommGroup.toAddCommMonoid.{u1} (coeSort.{max (succ u2) (succ (succ u1)), succ (succ u1)} (ModuleCat.{u1, u2} R _inst_1) Type.{u1} (ModuleCat.hasCoeToSort.{u1, u2} R _inst_1) Y) (ModuleCat.isAddCommGroup.{u1, u2} R _inst_1 Y)) (ModuleCat.isModule.{u1, u2} R _inst_1 X) (ModuleCat.isModule.{u1, u2} R _inst_1 Y) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R _inst_1)))) f))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {X : ModuleCat.{u1, u2} R _inst_1} {Y : ModuleCat.{u1, u2} R _inst_1} (f : Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y), Iff (CategoryTheory.Epi.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X Y f) (Function.Surjective.{succ u1, succ u1} (ModuleCat.carrier.{u1, u2} R _inst_1 X) (ModuleCat.carrier.{u1, u2} R _inst_1 Y) (FunLike.coe.{succ u1, succ u1, succ u1} (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X Y) (ModuleCat.carrier.{u1, u2} R _inst_1 X) (fun (_x : ModuleCat.carrier.{u1, u2} R _inst_1 X) => (fun (x._@.Mathlib.Algebra.Category.ModuleCat.Basic._hyg.275 : ModuleCat.carrier.{u1, u2} R _inst_1 X) => ModuleCat.carrier.{u1, u2} R _inst_1 Y) _x) (ModuleCat.instFunLikeHomModuleCatToQuiverToCategoryStructModuleCategoryCarrier.{u1, u2} R _inst_1 X Y) f))
Case conversion may be inaccurate. Consider using '#align Module.epi_iff_surjective ModuleCat.epi_iff_surjectiveₓ'. -/
theorem epi_iff_surjective : Epi f ↔ Function.Surjective f := by
  rw [epi_iff_range_eq_top, LinearMap.range_eq_top]
#align Module.epi_iff_surjective ModuleCat.epi_iff_surjective

/- warning: Module.unique_of_epi_zero -> ModuleCat.uniqueOfEpiZero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {M : Type.{u1}} [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (X : ModuleCat.{u1, u2} R _inst_1) [h : CategoryTheory.Epi.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X (ModuleCat.of.{u1, u2} R _inst_1 M _inst_2 _inst_3) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X (ModuleCat.of.{u1, u2} R _inst_1 M _inst_2 _inst_3)) 0 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X (ModuleCat.of.{u1, u2} R _inst_1 M _inst_2 _inst_3)) 0 (Zero.zero.{u1} (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X (ModuleCat.of.{u1, u2} R _inst_1 M _inst_2 _inst_3)) (CategoryTheory.Limits.HasZeroMorphisms.hasZero.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) (ModuleCat.CategoryTheory.preadditive.{u1, u2} R _inst_1)) X (ModuleCat.of.{u1, u2} R _inst_1 M _inst_2 _inst_3)))))], Unique.{succ u1} M
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {M : Type.{u1}} [_inst_2 : AddCommGroup.{u1} M] [_inst_3 : Module.{u2, u1} R M (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} M _inst_2)] (X : ModuleCat.{u1, u2} R _inst_1) [h : CategoryTheory.Epi.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) X (ModuleCat.of.{u1, u2} R _inst_1 M _inst_2 _inst_3) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X (ModuleCat.of.{u1, u2} R _inst_1 M _inst_2 _inst_3)) 0 (Zero.toOfNat0.{u1} (Quiver.Hom.{succ u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1))) X (ModuleCat.of.{u1, u2} R _inst_1 M _inst_2 _inst_3)) (CategoryTheory.Limits.HasZeroMorphisms.Zero.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, max u2 (succ u1)} (ModuleCat.{u1, u2} R _inst_1) (ModuleCat.moduleCategory.{u1, u2} R _inst_1) (ModuleCat.instPreadditiveModuleCatModuleCategory.{u1, u2} R _inst_1)) X (ModuleCat.of.{u1, u2} R _inst_1 M _inst_2 _inst_3))))], Unique.{succ u1} M
Case conversion may be inaccurate. Consider using '#align Module.unique_of_epi_zero ModuleCat.uniqueOfEpiZeroₓ'. -/
/-- If the zero morphism is an epi then the codomain is trivial. -/
def uniqueOfEpiZero (X) [h : Epi (0 : X ⟶ of R M)] : Unique M :=
  uniqueOfSurjectiveZero X ((ModuleCat.epi_iff_surjective _).mp h)
#align Module.unique_of_epi_zero ModuleCat.uniqueOfEpiZero

#print ModuleCat.mono_as_hom'_subtype /-
instance mono_as_hom'_subtype (U : Submodule R X) : Mono (↾U.Subtype) :=
  (mono_iff_ker_eq_bot _).mpr (Submodule.ker_subtype U)
#align Module.mono_as_hom'_subtype ModuleCat.mono_as_hom'_subtype
-/

#print ModuleCat.epi_as_hom''_mkQ /-
instance epi_as_hom''_mkQ (U : Submodule R X) : Epi (↿U.mkQ) :=
  (epi_iff_range_eq_top _).mpr <| Submodule.range_mkQ _
#align Module.epi_as_hom''_mkq ModuleCat.epi_as_hom''_mkQ
-/

#print ModuleCat.forget_preservesEpimorphisms /-
instance forget_preservesEpimorphisms : (forget (ModuleCat.{v} R)).PreservesEpimorphisms
    where preserves X Y f hf := by
    rwa [forget_map_eq_coe, CategoryTheory.epi_iff_surjective, ← epi_iff_surjective]
#align Module.forget_preserves_epimorphisms ModuleCat.forget_preservesEpimorphisms
-/

#print ModuleCat.forget_preservesMonomorphisms /-
instance forget_preservesMonomorphisms : (forget (ModuleCat.{v} R)).PreservesMonomorphisms
    where preserves X Y f hf := by
    rwa [forget_map_eq_coe, CategoryTheory.mono_iff_injective, ← mono_iff_injective]
#align Module.forget_preserves_monomorphisms ModuleCat.forget_preservesMonomorphisms
-/

end ModuleCat

