/-
Copyright (c) 2022 Violeta Hernández Palacios. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Violeta Hernández Palacios

! This file was ported from Lean 3 source module algebra.algebraic_card
! leanprover-community/mathlib commit 38df578a6450a8c5142b3727e3ae894c2300cae0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Polynomial.Cardinal
import Mathbin.RingTheory.Algebraic

/-!
### Cardinality of algebraic numbers

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file, we prove variants of the following result: the cardinality of algebraic numbers under
an R-algebra is at most `# R[X] * ℵ₀`.

Although this can be used to prove that real or complex transcendental numbers exist, a more direct
proof is given by `liouville.is_transcendental`.
-/


universe u v

open Cardinal Polynomial Set

open Cardinal Polynomial

namespace Algebraic

/- warning: algebraic.infinite_of_char_zero -> Algebraic.infinite_of_charZero is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_3 : Ring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_3)] [_inst_5 : CharZero.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A _inst_3)))], Set.Infinite.{u2} A (setOf.{u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 _inst_3 _inst_4 x))
but is expected to have type
  forall (R : Type.{u2}) (A : Type.{u1}) [_inst_1 : CommRing.{u2} R] [_inst_2 : IsDomain.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))] [_inst_3 : Ring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3)] [_inst_5 : CharZero.{u1} A (AddGroupWithOne.toAddMonoidWithOne.{u1} A (Ring.toAddGroupWithOne.{u1} A _inst_3))], Set.Infinite.{u1} A (setOf.{u1} A (fun (x : A) => IsAlgebraic.{u2, u1} R A _inst_1 _inst_3 _inst_4 x))
Case conversion may be inaccurate. Consider using '#align algebraic.infinite_of_char_zero Algebraic.infinite_of_charZeroₓ'. -/
theorem infinite_of_charZero (R A : Type _) [CommRing R] [IsDomain R] [Ring A] [Algebra R A]
    [CharZero A] : { x : A | IsAlgebraic R x }.Infinite :=
  infinite_of_injective_forall_mem Nat.cast_injective isAlgebraic_nat
#align algebraic.infinite_of_char_zero Algebraic.infinite_of_charZero

/- warning: algebraic.aleph_0_le_cardinal_mk_of_char_zero -> Algebraic.aleph0_le_cardinal_mk_of_charZero is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))] [_inst_3 : Ring.{u2} A] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A _inst_3)] [_inst_5 : CharZero.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A _inst_3)))], LE.le.{succ u2} Cardinal.{u2} Cardinal.hasLe.{u2} Cardinal.aleph0.{u2} (Cardinal.mk.{u2} (Subtype.{succ u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 _inst_3 _inst_4 x)))
but is expected to have type
  forall (R : Type.{u2}) (A : Type.{u1}) [_inst_1 : CommRing.{u2} R] [_inst_2 : IsDomain.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))] [_inst_3 : Ring.{u1} A] [_inst_4 : Algebra.{u2, u1} R A (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u1} A _inst_3)] [_inst_5 : CharZero.{u1} A (AddGroupWithOne.toAddMonoidWithOne.{u1} A (Ring.toAddGroupWithOne.{u1} A _inst_3))], LE.le.{succ u1} Cardinal.{u1} Cardinal.instLECardinal.{u1} Cardinal.aleph0.{u1} (Cardinal.mk.{u1} (Subtype.{succ u1} A (fun (x : A) => IsAlgebraic.{u2, u1} R A _inst_1 _inst_3 _inst_4 x)))
Case conversion may be inaccurate. Consider using '#align algebraic.aleph_0_le_cardinal_mk_of_char_zero Algebraic.aleph0_le_cardinal_mk_of_charZeroₓ'. -/
theorem aleph0_le_cardinal_mk_of_charZero (R A : Type _) [CommRing R] [IsDomain R] [Ring A]
    [Algebra R A] [CharZero A] : ℵ₀ ≤ (#{ x : A // IsAlgebraic R x }) :=
  infinite_iff.1 (Set.infinite_coe_iff.2 <| infinite_of_charZero R A)
#align algebraic.aleph_0_le_cardinal_mk_of_char_zero Algebraic.aleph0_le_cardinal_mk_of_charZero

section lift

variable (R : Type u) (A : Type v) [CommRing R] [CommRing A] [IsDomain A] [Algebra R A]
  [NoZeroSMulDivisors R A]

/- warning: algebraic.cardinal_mk_lift_le_mul -> Algebraic.cardinal_mk_lift_le_mul is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_4)))))], LE.le.{succ (max u2 u1)} Cardinal.{max u2 u1} Cardinal.hasLe.{max u2 u1} (Cardinal.lift.{u1, u2} (Cardinal.mk.{u2} (Subtype.{succ u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 (CommRing.toRing.{u2} A _inst_2) _inst_4 x)))) (HMul.hMul.{succ (max u2 u1), succ (max u2 u1), succ (max u2 u1)} Cardinal.{max u2 u1} Cardinal.{max u2 u1} Cardinal.{max u2 u1} (instHMul.{succ (max u2 u1)} Cardinal.{max u2 u1} Cardinal.hasMul.{max u2 u1}) (Cardinal.lift.{u2, u1} (Cardinal.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))))) Cardinal.aleph0.{max u2 u1})
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : IsDomain.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommMonoidWithZero.toZero.{u2} A (CancelCommMonoidWithZero.toCommMonoidWithZero.{u2} A (IsDomain.toCancelCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2) _inst_3))) (Algebra.toSMul.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_4)], LE.le.{max (succ u1) (succ u2)} Cardinal.{max u2 u1} Cardinal.instLECardinal.{max u1 u2} (Cardinal.lift.{u1, u2} (Cardinal.mk.{u2} (Subtype.{succ u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 (CommRing.toRing.{u2} A _inst_2) _inst_4 x)))) (HMul.hMul.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} Cardinal.{max u1 u2} Cardinal.{max u1 u2} Cardinal.{max u1 u2} (instHMul.{max (succ u1) (succ u2)} Cardinal.{max u1 u2} Cardinal.instMulCardinal.{max u1 u2}) (Cardinal.lift.{u2, u1} (Cardinal.mk.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))))) Cardinal.aleph0.{max u1 u2})
Case conversion may be inaccurate. Consider using '#align algebraic.cardinal_mk_lift_le_mul Algebraic.cardinal_mk_lift_le_mulₓ'. -/
theorem cardinal_mk_lift_le_mul :
    Cardinal.lift.{u} (#{ x : A // IsAlgebraic R x }) ≤ Cardinal.lift.{v} (#R[X]) * ℵ₀ :=
  by
  rw [← mk_ulift, ← mk_ulift]
  choose g hg₁ hg₂ using fun x : { x : A | IsAlgebraic R x } => x.coe_prop
  refine' lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le g fun f => _
  rw [lift_le_aleph_0, le_aleph_0_iff_set_countable]
  suffices : maps_to coe (g ⁻¹' {f}) (f.root_set A)
  exact this.countable_of_inj_on (subtype.coe_injective.inj_on _) (f.root_set_finite A).Countable
  rintro x (rfl : g x = f)
  exact mem_root_set.2 ⟨hg₁ x, hg₂ x⟩
#align algebraic.cardinal_mk_lift_le_mul Algebraic.cardinal_mk_lift_le_mul

/- warning: algebraic.cardinal_mk_lift_le_max -> Algebraic.cardinal_mk_lift_le_max is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_4)))))], LE.le.{succ (max u2 u1)} Cardinal.{max u2 u1} Cardinal.hasLe.{max u2 u1} (Cardinal.lift.{u1, u2} (Cardinal.mk.{u2} (Subtype.{succ u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 (CommRing.toRing.{u2} A _inst_2) _inst_4 x)))) (LinearOrder.max.{succ (max u2 u1)} Cardinal.{max u2 u1} Cardinal.linearOrder.{max u2 u1} (Cardinal.lift.{u2, u1} (Cardinal.mk.{u1} R)) Cardinal.aleph0.{max u2 u1})
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : IsDomain.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommMonoidWithZero.toZero.{u2} A (CancelCommMonoidWithZero.toCommMonoidWithZero.{u2} A (IsDomain.toCancelCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2) _inst_3))) (Algebra.toSMul.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_4)], LE.le.{max (succ u1) (succ u2)} Cardinal.{max u2 u1} Cardinal.instLECardinal.{max u1 u2} (Cardinal.lift.{u1, u2} (Cardinal.mk.{u2} (Subtype.{succ u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 (CommRing.toRing.{u2} A _inst_2) _inst_4 x)))) (Max.max.{max (succ u2) (succ u1)} Cardinal.{max u1 u2} (CanonicallyLinearOrderedAddMonoid.toMax.{max (succ u1) (succ u2)} Cardinal.{max u1 u2} Cardinal.instCanonicallyLinearOrderedAddMonoidCardinal.{max u1 u2}) (Cardinal.lift.{u2, u1} (Cardinal.mk.{u1} R)) Cardinal.aleph0.{max u1 u2})
Case conversion may be inaccurate. Consider using '#align algebraic.cardinal_mk_lift_le_max Algebraic.cardinal_mk_lift_le_maxₓ'. -/
theorem cardinal_mk_lift_le_max :
    Cardinal.lift.{u} (#{ x : A // IsAlgebraic R x }) ≤ max (Cardinal.lift.{v} (#R)) ℵ₀ :=
  (cardinal_mk_lift_le_mul R A).trans <|
    (mul_le_mul_right' (lift_le.2 cardinal_mk_le_max) _).trans <| by simp
#align algebraic.cardinal_mk_lift_le_max Algebraic.cardinal_mk_lift_le_max

/- warning: algebraic.cardinal_mk_lift_of_infinite -> Algebraic.cardinal_mk_lift_of_infinite is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_4)))))] [_inst_6 : Infinite.{succ u1} R], Eq.{succ (succ (max u2 u1))} Cardinal.{max u2 u1} (Cardinal.lift.{u1, u2} (Cardinal.mk.{u2} (Subtype.{succ u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 (CommRing.toRing.{u2} A _inst_2) _inst_4 x)))) (Cardinal.lift.{u2, u1} (Cardinal.mk.{u1} R))
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : IsDomain.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommMonoidWithZero.toZero.{u2} A (CancelCommMonoidWithZero.toCommMonoidWithZero.{u2} A (IsDomain.toCancelCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2) _inst_3))) (Algebra.toSMul.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_4)] [_inst_6 : Infinite.{succ u1} R], Eq.{max (succ (succ u1)) (succ (succ u2))} Cardinal.{max u2 u1} (Cardinal.lift.{u1, u2} (Cardinal.mk.{u2} (Subtype.{succ u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 (CommRing.toRing.{u2} A _inst_2) _inst_4 x)))) (Cardinal.lift.{u2, u1} (Cardinal.mk.{u1} R))
Case conversion may be inaccurate. Consider using '#align algebraic.cardinal_mk_lift_of_infinite Algebraic.cardinal_mk_lift_of_infiniteₓ'. -/
@[simp]
theorem cardinal_mk_lift_of_infinite [Infinite R] :
    Cardinal.lift.{u} (#{ x : A // IsAlgebraic R x }) = Cardinal.lift.{v} (#R) :=
  ((cardinal_mk_lift_le_max R A).trans_eq (max_eq_left <| aleph0_le_mk _)).antisymm <|
    lift_mk_le'.2
      ⟨⟨fun x => ⟨algebraMap R A x, isAlgebraic_algebraMap _⟩, fun x y h =>
          NoZeroSMulDivisors.algebraMap_injective R A (Subtype.ext_iff.1 h)⟩⟩
#align algebraic.cardinal_mk_lift_of_infinite Algebraic.cardinal_mk_lift_of_infinite

variable [Countable R]

/- warning: algebraic.countable -> Algebraic.countable is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_4)))))] [_inst_6 : Countable.{succ u1} R], Set.Countable.{u2} A (setOf.{u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 (CommRing.toRing.{u2} A _inst_2) _inst_4 x))
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : IsDomain.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommMonoidWithZero.toZero.{u2} A (CancelCommMonoidWithZero.toCommMonoidWithZero.{u2} A (IsDomain.toCancelCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2) _inst_3))) (Algebra.toSMul.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_4)] [_inst_6 : Countable.{succ u1} R], Set.Countable.{u2} A (setOf.{u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 (CommRing.toRing.{u2} A _inst_2) _inst_4 x))
Case conversion may be inaccurate. Consider using '#align algebraic.countable Algebraic.countableₓ'. -/
@[simp]
protected theorem countable : Set.Countable { x : A | IsAlgebraic R x } :=
  by
  rw [← le_aleph_0_iff_set_countable, ← lift_le]
  apply (cardinal_mk_lift_le_max R A).trans
  simp
#align algebraic.countable Algebraic.countable

/- warning: algebraic.cardinal_mk_of_countble_of_char_zero -> Algebraic.cardinal_mk_of_countble_of_charZero is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : IsDomain.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} A (NonAssocRing.toNonUnitalNonAssocRing.{u2} A (Ring.toNonAssocRing.{u2} A (CommRing.toRing.{u2} A _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u2} R A (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u2} A (AddMonoid.toAddZeroClass.{u2} A (AddCommMonoid.toAddMonoid.{u2} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)))))))) (Module.toMulActionWithZero.{u1, u2} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2))))) (Algebra.toModule.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u2} A (CommRing.toRing.{u2} A _inst_2)) _inst_4)))))] [_inst_6 : Countable.{succ u1} R] [_inst_7 : CharZero.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (AddCommGroupWithOne.toAddGroupWithOne.{u2} A (Ring.toAddCommGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2))))] [_inst_8 : IsDomain.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1))], Eq.{succ (succ u2)} Cardinal.{u2} (Cardinal.mk.{u2} (Subtype.{succ u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 (CommRing.toRing.{u2} A _inst_2) _inst_4 x))) Cardinal.aleph0.{u2}
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u2}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u2} A] [_inst_3 : IsDomain.{u2} A (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_4 : Algebra.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommMonoidWithZero.toZero.{u2} A (CancelCommMonoidWithZero.toCommMonoidWithZero.{u2} A (IsDomain.toCancelCommMonoidWithZero.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2) _inst_3))) (Algebra.toSMul.{u1, u2} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u2} A (CommRing.toCommSemiring.{u2} A _inst_2)) _inst_4)] [_inst_6 : Countable.{succ u1} R] [_inst_7 : CharZero.{u2} A (AddGroupWithOne.toAddMonoidWithOne.{u2} A (Ring.toAddGroupWithOne.{u2} A (CommRing.toRing.{u2} A _inst_2)))] [_inst_8 : IsDomain.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))], Eq.{succ (succ u2)} Cardinal.{u2} (Cardinal.mk.{u2} (Subtype.{succ u2} A (fun (x : A) => IsAlgebraic.{u1, u2} R A _inst_1 (CommRing.toRing.{u2} A _inst_2) _inst_4 x))) Cardinal.aleph0.{u2}
Case conversion may be inaccurate. Consider using '#align algebraic.cardinal_mk_of_countble_of_char_zero Algebraic.cardinal_mk_of_countble_of_charZeroₓ'. -/
@[simp]
theorem cardinal_mk_of_countble_of_charZero [CharZero A] [IsDomain R] :
    (#{ x : A // IsAlgebraic R x }) = ℵ₀ :=
  (Algebraic.countable R A).le_aleph0.antisymm (aleph0_le_cardinal_mk_of_charZero R A)
#align algebraic.cardinal_mk_of_countble_of_char_zero Algebraic.cardinal_mk_of_countble_of_charZero

end lift

section NonLift

variable (R A : Type u) [CommRing R] [CommRing A] [IsDomain A] [Algebra R A]
  [NoZeroSMulDivisors R A]

/- warning: algebraic.cardinal_mk_le_mul -> Algebraic.cardinal_mk_le_mul is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u1}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))] [_inst_4 : Algebra.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u1} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u1} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u1, u1} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u1, u1} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))))) (Module.toMulActionWithZero.{u1, u1} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_4)))))], LE.le.{succ u1} Cardinal.{u1} Cardinal.hasLe.{u1} (Cardinal.mk.{u1} (Subtype.{succ u1} A (fun (x : A) => IsAlgebraic.{u1, u1} R A _inst_1 (CommRing.toRing.{u1} A _inst_2) _inst_4 x))) (HMul.hMul.{succ u1, succ u1, succ u1} Cardinal.{u1} Cardinal.{u1} Cardinal.{u1} (instHMul.{succ u1} Cardinal.{u1} Cardinal.hasMul.{u1}) (Cardinal.mk.{u1} (Polynomial.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)))) Cardinal.aleph0.{u1})
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u1}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : IsDomain.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] [_inst_4 : Algebra.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u1} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommMonoidWithZero.toZero.{u1} A (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} A (IsDomain.toCancelCommMonoidWithZero.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2) _inst_3))) (Algebra.toSMul.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_4)], LE.le.{succ u1} Cardinal.{u1} Cardinal.instLECardinal.{u1} (Cardinal.mk.{u1} (Subtype.{succ u1} A (fun (x : A) => IsAlgebraic.{u1, u1} R A _inst_1 (CommRing.toRing.{u1} A _inst_2) _inst_4 x))) (HMul.hMul.{succ u1, succ u1, succ u1} Cardinal.{u1} Cardinal.{u1} Cardinal.{u1} (instHMul.{succ u1} Cardinal.{u1} Cardinal.instMulCardinal.{u1}) (Cardinal.mk.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) Cardinal.aleph0.{u1})
Case conversion may be inaccurate. Consider using '#align algebraic.cardinal_mk_le_mul Algebraic.cardinal_mk_le_mulₓ'. -/
theorem cardinal_mk_le_mul : (#{ x : A // IsAlgebraic R x }) ≤ (#R[X]) * ℵ₀ := by
  rw [← lift_id (#_), ← lift_id (#R[X])]; exact cardinal_mk_lift_le_mul R A
#align algebraic.cardinal_mk_le_mul Algebraic.cardinal_mk_le_mul

/- warning: algebraic.cardinal_mk_le_max -> Algebraic.cardinal_mk_le_max is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u1}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))] [_inst_4 : Algebra.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u1} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u1} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u1, u1} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u1, u1} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))))) (Module.toMulActionWithZero.{u1, u1} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_4)))))], LE.le.{succ u1} Cardinal.{u1} Cardinal.hasLe.{u1} (Cardinal.mk.{u1} (Subtype.{succ u1} A (fun (x : A) => IsAlgebraic.{u1, u1} R A _inst_1 (CommRing.toRing.{u1} A _inst_2) _inst_4 x))) (LinearOrder.max.{succ u1} Cardinal.{u1} Cardinal.linearOrder.{u1} (Cardinal.mk.{u1} R) Cardinal.aleph0.{u1})
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u1}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : IsDomain.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] [_inst_4 : Algebra.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u1} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommMonoidWithZero.toZero.{u1} A (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} A (IsDomain.toCancelCommMonoidWithZero.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2) _inst_3))) (Algebra.toSMul.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_4)], LE.le.{succ u1} Cardinal.{u1} Cardinal.instLECardinal.{u1} (Cardinal.mk.{u1} (Subtype.{succ u1} A (fun (x : A) => IsAlgebraic.{u1, u1} R A _inst_1 (CommRing.toRing.{u1} A _inst_2) _inst_4 x))) (Max.max.{succ u1} Cardinal.{u1} (CanonicallyLinearOrderedAddMonoid.toMax.{succ u1} Cardinal.{u1} Cardinal.instCanonicallyLinearOrderedAddMonoidCardinal.{u1}) (Cardinal.mk.{u1} R) Cardinal.aleph0.{u1})
Case conversion may be inaccurate. Consider using '#align algebraic.cardinal_mk_le_max Algebraic.cardinal_mk_le_maxₓ'. -/
theorem cardinal_mk_le_max : (#{ x : A // IsAlgebraic R x }) ≤ max (#R) ℵ₀ := by
  rw [← lift_id (#_), ← lift_id (#R)]; exact cardinal_mk_lift_le_max R A
#align algebraic.cardinal_mk_le_max Algebraic.cardinal_mk_le_max

/- warning: algebraic.cardinal_mk_of_infinite -> Algebraic.cardinal_mk_of_infinite is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (A : Type.{u1}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : IsDomain.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))] [_inst_4 : Algebra.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u1} R A (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (MulZeroClass.toHasZero.{u1} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} A (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} A (NonAssocRing.toNonUnitalNonAssocRing.{u1} A (Ring.toNonAssocRing.{u1} A (CommRing.toRing.{u1} A _inst_2)))))) (SMulZeroClass.toHasSmul.{u1, u1} R A (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u1, u1} R A (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u1, u1} R A (Semiring.toMonoidWithZero.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (AddZeroClass.toHasZero.{u1} A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)))))))) (Module.toMulActionWithZero.{u1, u1} R A (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2))))) (Algebra.toModule.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} A (CommRing.toRing.{u1} A _inst_2)) _inst_4)))))] [_inst_6 : Infinite.{succ u1} R], Eq.{succ (succ u1)} Cardinal.{u1} (Cardinal.mk.{u1} (Subtype.{succ u1} A (fun (x : A) => IsAlgebraic.{u1, u1} R A _inst_1 (CommRing.toRing.{u1} A _inst_2) _inst_4 x))) (Cardinal.mk.{u1} R)
but is expected to have type
  forall (R : Type.{u1}) (A : Type.{u1}) [_inst_1 : CommRing.{u1} R] [_inst_2 : CommRing.{u1} A] [_inst_3 : IsDomain.{u1} A (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] [_inst_4 : Algebra.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2))] [_inst_5 : NoZeroSMulDivisors.{u1, u1} R A (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (CommMonoidWithZero.toZero.{u1} A (CancelCommMonoidWithZero.toCommMonoidWithZero.{u1} A (IsDomain.toCancelCommMonoidWithZero.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2) _inst_3))) (Algebra.toSMul.{u1, u1} R A (CommRing.toCommSemiring.{u1} R _inst_1) (CommSemiring.toSemiring.{u1} A (CommRing.toCommSemiring.{u1} A _inst_2)) _inst_4)] [_inst_6 : Infinite.{succ u1} R], Eq.{succ (succ u1)} Cardinal.{u1} (Cardinal.mk.{u1} (Subtype.{succ u1} A (fun (x : A) => IsAlgebraic.{u1, u1} R A _inst_1 (CommRing.toRing.{u1} A _inst_2) _inst_4 x))) (Cardinal.mk.{u1} R)
Case conversion may be inaccurate. Consider using '#align algebraic.cardinal_mk_of_infinite Algebraic.cardinal_mk_of_infiniteₓ'. -/
@[simp]
theorem cardinal_mk_of_infinite [Infinite R] : (#{ x : A // IsAlgebraic R x }) = (#R) :=
  lift_inj.1 <| cardinal_mk_lift_of_infinite R A
#align algebraic.cardinal_mk_of_infinite Algebraic.cardinal_mk_of_infinite

end NonLift

end Algebraic

