/-
Copyright (c) 2014 Robert Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robert Lewis, Leonardo de Moura, Johannes Hölzl, Mario Carneiro

! This file was ported from Lean 3 source module algebra.field.basic
! leanprover-community/mathlib commit c5c7e2760814660967bc27f0de95d190a22297f3
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Field.Defs
import Mathbin.Algebra.GroupWithZero.Units.Lemmas
import Mathbin.Algebra.Hom.Ring
import Mathbin.Algebra.Ring.InjSurj

/-!
# Lemmas about division (semi)rings and (semi)fields

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> https://github.com/leanprover-community/mathlib4/pull/975
> Any changes to this file require a corresponding PR to mathlib4.

-/


open Function OrderDual Set

universe u

variable {α β K : Type _}

section DivisionSemiring

variable [DivisionSemiring α] {a b c : α}

/- warning: add_div -> add_div is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] (a : α) (b : α) (c : α), Eq.{succ u1} α (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a b) c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) a c) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) b c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] (a : α) (b : α) (c : α), Eq.{succ u1} α (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a b) c) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) a c) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) b c))
Case conversion may be inaccurate. Consider using '#align add_div add_divₓ'. -/
theorem add_div (a b c : α) : (a + b) / c = a / c + b / c := by simp_rw [div_eq_mul_inv, add_mul]
#align add_div add_div

/- warning: div_add_div_same -> div_add_div_same is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] (a : α) (b : α) (c : α), Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) a c) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) b c)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a b) c)
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] (a : α) (b : α) (c : α), Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) a c) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) b c)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a b) c)
Case conversion may be inaccurate. Consider using '#align div_add_div_same div_add_div_sameₓ'. -/
@[field_simps]
theorem div_add_div_same (a b c : α) : a / c + b / c = (a + b) / c :=
  (add_div _ _ _).symm
#align div_add_div_same div_add_div_same

/- warning: same_add_div -> same_add_div is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) b a) b) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) a b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) b a) b) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) a b)))
Case conversion may be inaccurate. Consider using '#align same_add_div same_add_divₓ'. -/
theorem same_add_div (h : b ≠ 0) : (b + a) / b = 1 + a / b := by rw [← div_self h, add_div]
#align same_add_div same_add_div

/- warning: div_add_same -> div_add_same is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a b) b) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) a b) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a b) b) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) a b) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))
Case conversion may be inaccurate. Consider using '#align div_add_same div_add_sameₓ'. -/
theorem div_add_same (h : b ≠ 0) : (a + b) / b = a / b + 1 := by rw [← div_self h, add_div]
#align div_add_same div_add_same

/- warning: one_add_div -> one_add_div is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) a b)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) b a) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) a b)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) b a) b))
Case conversion may be inaccurate. Consider using '#align one_add_div one_add_divₓ'. -/
theorem one_add_div (h : b ≠ 0) : 1 + a / b = (b + a) / b :=
  (same_add_div h).symm
#align one_add_div one_add_div

/- warning: div_add_one -> div_add_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) a b) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a b) b))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) a b) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a b) b))
Case conversion may be inaccurate. Consider using '#align div_add_one div_add_oneₓ'. -/
theorem div_add_one (h : b ≠ 0) : a / b + 1 = (a + b) / b :=
  (div_add_same h).symm
#align div_add_one div_add_one

/- warning: one_div_mul_add_mul_one_div_eq_one_div_add_one_div -> one_div_mul_add_mul_one_div_eq_one_div_add_one_div is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))))) a) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a b)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))))) b)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))))) a) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))))) b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))) a) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a b)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))) b)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))) a) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))) b)))
Case conversion may be inaccurate. Consider using '#align one_div_mul_add_mul_one_div_eq_one_div_add_one_div one_div_mul_add_mul_one_div_eq_one_div_add_one_divₓ'. -/
theorem one_div_mul_add_mul_one_div_eq_one_div_add_one_div (ha : a ≠ 0) (hb : b ≠ 0) :
    1 / a * (a + b) * (1 / b) = 1 / a + 1 / b := by
  rw [mul_add, one_div_mul_cancel ha, add_mul, one_mul, mul_assoc, mul_one_div_cancel hb, mul_one,
    add_comm]
#align
  one_div_mul_add_mul_one_div_eq_one_div_add_one_div one_div_mul_add_mul_one_div_eq_one_div_add_one_div

/- warning: add_div_eq_mul_add_div -> add_div_eq_mul_add_div is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {c : α} (a : α) (b : α), (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) b c)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a c) b) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] {c : α} (a : α) (b : α), (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) b c)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))) a c) b) c))
Case conversion may be inaccurate. Consider using '#align add_div_eq_mul_add_div add_div_eq_mul_add_divₓ'. -/
theorem add_div_eq_mul_add_div (a b : α) (hc : c ≠ 0) : a + b / c = (a * c + b) / c :=
  (eq_div_iff_mul_eq hc).2 <| by rw [right_distrib, div_mul_cancel _ hc]
#align add_div_eq_mul_add_div add_div_eq_mul_add_div

/- warning: add_div' -> add_div' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] (a : α) (b : α) (c : α), (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) b (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) a c)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) b c) a) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] (a : α) (b : α) (c : α), (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) b (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) a c)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))) b c) a) c))
Case conversion may be inaccurate. Consider using '#align add_div' add_div'ₓ'. -/
@[field_simps]
theorem add_div' (a b c : α) (hc : c ≠ 0) : b + a / c = (b * c + a) / c := by
  rw [add_div, mul_div_cancel _ hc]
#align add_div' add_div'

/- warning: div_add' -> div_add' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] (a : α) (b : α) (c : α), (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) a c) b) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α _inst_1)))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) b c)) c))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : DivisionSemiring.{u1} α] (a : α) (b : α) (c : α), (Ne.{succ u1} α c (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) a c) b) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivisionSemiring.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1)))))) a (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α _inst_1))))) b c)) c))
Case conversion may be inaccurate. Consider using '#align div_add' div_add'ₓ'. -/
@[field_simps]
theorem div_add' (a b c : α) (hc : c ≠ 0) : a / c + b = (a + b * c) / c := by
  rwa [add_comm, add_div', add_comm]
#align div_add' div_add'

end DivisionSemiring

section DivisionMonoid

variable [DivisionMonoid K] [HasDistribNeg K] {a b : K}

/- warning: one_div_neg_one_eq_neg_one -> one_div_neg_one_eq_neg_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))], Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (MulOneClass.toHasOne.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))))) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (MulOneClass.toHasOne.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))))))) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (MulOneClass.toHasOne.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))], Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (InvOneClass.toOne.{u1} K (DivInvOneMonoid.toInvOneClass.{u1} K (DivisionMonoid.toDivInvOneMonoid.{u1} K _inst_1))))) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (InvOneClass.toOne.{u1} K (DivInvOneMonoid.toInvOneClass.{u1} K (DivisionMonoid.toDivInvOneMonoid.{u1} K _inst_1))))))) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (InvOneClass.toOne.{u1} K (DivInvOneMonoid.toInvOneClass.{u1} K (DivisionMonoid.toDivInvOneMonoid.{u1} K _inst_1))))))
Case conversion may be inaccurate. Consider using '#align one_div_neg_one_eq_neg_one one_div_neg_one_eq_neg_oneₓ'. -/
theorem one_div_neg_one_eq_neg_one : (1 : K) / -1 = -1 :=
  have : -1 * -1 = (1 : K) := by rw [neg_mul_neg, one_mul]
  Eq.symm (eq_one_div_of_mul_eq_one_right this)
#align one_div_neg_one_eq_neg_one one_div_neg_one_eq_neg_one

/- warning: one_div_neg_eq_neg_one_div -> one_div_neg_eq_neg_one_div is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] (a : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (MulOneClass.toHasOne.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))))) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) a)) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (MulOneClass.toHasOne.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))))) a))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] (a : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (InvOneClass.toOne.{u1} K (DivInvOneMonoid.toInvOneClass.{u1} K (DivisionMonoid.toDivInvOneMonoid.{u1} K _inst_1))))) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) a)) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (InvOneClass.toOne.{u1} K (DivInvOneMonoid.toInvOneClass.{u1} K (DivisionMonoid.toDivInvOneMonoid.{u1} K _inst_1))))) a))
Case conversion may be inaccurate. Consider using '#align one_div_neg_eq_neg_one_div one_div_neg_eq_neg_one_divₓ'. -/
theorem one_div_neg_eq_neg_one_div (a : K) : 1 / -a = -(1 / a) :=
  calc
    1 / -a = 1 / (-1 * a) := by rw [neg_eq_neg_one_mul]
    _ = 1 / a * (1 / -1) := by rw [one_div_mul_one_div_rev]
    _ = 1 / a * -1 := by rw [one_div_neg_one_eq_neg_one]
    _ = -(1 / a) := by rw [mul_neg, mul_one]
    
#align one_div_neg_eq_neg_one_div one_div_neg_eq_neg_one_div

/- warning: div_neg_eq_neg_div -> div_neg_eq_neg_div is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] (a : K) (b : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) b (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) a)) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) b a))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] (a : K) (b : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) b (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) a)) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) b a))
Case conversion may be inaccurate. Consider using '#align div_neg_eq_neg_div div_neg_eq_neg_divₓ'. -/
theorem div_neg_eq_neg_div (a b : K) : b / -a = -(b / a) :=
  calc
    b / -a = b * (1 / -a) := by rw [← inv_eq_one_div, division_def]
    _ = b * -(1 / a) := by rw [one_div_neg_eq_neg_one_div]
    _ = -(b * (1 / a)) := by rw [neg_mul_eq_mul_neg]
    _ = -(b / a) := by rw [mul_one_div]
    
#align div_neg_eq_neg_div div_neg_eq_neg_div

/- warning: neg_div -> neg_div is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] (a : K) (b : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) b) a) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) b a))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] (a : K) (b : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) b) a) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) b a))
Case conversion may be inaccurate. Consider using '#align neg_div neg_divₓ'. -/
theorem neg_div (a b : K) : -b / a = -(b / a) := by
  rw [neg_eq_neg_one_mul, mul_div_assoc, ← neg_eq_neg_one_mul]
#align neg_div neg_div

/- warning: neg_div' -> neg_div' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] (a : K) (b : K), Eq.{succ u1} K (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) b a)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) b) a)
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] (a : K) (b : K), Eq.{succ u1} K (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) b a)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) b) a)
Case conversion may be inaccurate. Consider using '#align neg_div' neg_div'ₓ'. -/
@[field_simps]
theorem neg_div' (a b : K) : -(b / a) = -b / a := by simp [neg_div]
#align neg_div' neg_div'

/- warning: neg_div_neg_eq -> neg_div_neg_eq is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] (a : K) (b : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) a) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) b)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) a b)
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] (a : K) (b : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) a) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) b)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) a b)
Case conversion may be inaccurate. Consider using '#align neg_div_neg_eq neg_div_neg_eqₓ'. -/
theorem neg_div_neg_eq (a b : K) : -a / -b = a / b := by rw [div_neg_eq_neg_div, neg_div, neg_neg]
#align neg_div_neg_eq neg_div_neg_eq

/- warning: neg_inv -> neg_inv is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] {a : K}, Eq.{succ u1} K (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)) a)) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) a))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] {a : K}, Eq.{succ u1} K (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (Inv.inv.{u1} K (InvOneClass.toInv.{u1} K (DivInvOneMonoid.toInvOneClass.{u1} K (DivisionMonoid.toDivInvOneMonoid.{u1} K _inst_1))) a)) (Inv.inv.{u1} K (InvOneClass.toInv.{u1} K (DivInvOneMonoid.toInvOneClass.{u1} K (DivisionMonoid.toDivInvOneMonoid.{u1} K _inst_1))) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) a))
Case conversion may be inaccurate. Consider using '#align neg_inv neg_invₓ'. -/
theorem neg_inv : -a⁻¹ = (-a)⁻¹ := by rw [inv_eq_one_div, inv_eq_one_div, div_neg_eq_neg_div]
#align neg_inv neg_inv

/- warning: div_neg -> div_neg is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] {b : K} (a : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) a (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) b)) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) a b))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] {b : K} (a : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) a (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) b)) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toDiv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))) a b))
Case conversion may be inaccurate. Consider using '#align div_neg div_negₓ'. -/
theorem div_neg (a : K) : a / -b = -(a / b) := by rw [← div_neg_eq_neg_div]
#align div_neg div_neg

/- warning: inv_neg -> inv_neg is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] {a : K}, Eq.{succ u1} K (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) a)) (Neg.neg.{u1} K (InvolutiveNeg.toHasNeg.{u1} K (HasDistribNeg.toHasInvolutiveNeg.{u1} K (MulOneClass.toHasMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)) a))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionMonoid.{u1} K] [_inst_2 : HasDistribNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1))))] {a : K}, Eq.{succ u1} K (Inv.inv.{u1} K (InvOneClass.toInv.{u1} K (DivInvOneMonoid.toInvOneClass.{u1} K (DivisionMonoid.toDivInvOneMonoid.{u1} K _inst_1))) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) a)) (Neg.neg.{u1} K (InvolutiveNeg.toNeg.{u1} K (HasDistribNeg.toInvolutiveNeg.{u1} K (MulOneClass.toMul.{u1} K (Monoid.toMulOneClass.{u1} K (DivInvMonoid.toMonoid.{u1} K (DivisionMonoid.toDivInvMonoid.{u1} K _inst_1)))) _inst_2)) (Inv.inv.{u1} K (InvOneClass.toInv.{u1} K (DivInvOneMonoid.toInvOneClass.{u1} K (DivisionMonoid.toDivInvOneMonoid.{u1} K _inst_1))) a))
Case conversion may be inaccurate. Consider using '#align inv_neg inv_negₓ'. -/
theorem inv_neg : (-a)⁻¹ = -a⁻¹ := by rw [neg_inv]
#align inv_neg inv_neg

end DivisionMonoid

section DivisionRing

variable [DivisionRing K] {a b : K}

/- warning: div_neg_self -> div_neg_self is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K}, (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) a (Neg.neg.{u1} K (SubNegMonoid.toHasNeg.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) a)) (Neg.neg.{u1} K (SubNegMonoid.toHasNeg.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K}, (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) a (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) a)) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align div_neg_self div_neg_selfₓ'. -/
@[simp]
theorem div_neg_self {a : K} (h : a ≠ 0) : a / -a = -1 := by rw [div_neg_eq_neg_div, div_self h]
#align div_neg_self div_neg_self

/- warning: neg_div_self -> neg_div_self is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K}, (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (Neg.neg.{u1} K (SubNegMonoid.toHasNeg.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) a) a) (Neg.neg.{u1} K (SubNegMonoid.toHasNeg.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K}, (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) a) a) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align neg_div_self neg_div_selfₓ'. -/
@[simp]
theorem neg_div_self {a : K} (h : a ≠ 0) : -a / a = -1 := by rw [neg_div, div_self h]
#align neg_div_self neg_div_self

/- warning: div_sub_div_same -> div_sub_div_same is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] (a : K) (b : K) (c : K), Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) a c) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) b c)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) a b) c)
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] (a : K) (b : K) (c : K), Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) a c) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) b c)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) a b) c)
Case conversion may be inaccurate. Consider using '#align div_sub_div_same div_sub_div_sameₓ'. -/
theorem div_sub_div_same (a b c : K) : a / c - b / c = (a - b) / c := by
  rw [sub_eq_add_neg, ← neg_div, div_add_div_same, sub_eq_add_neg]
#align div_sub_div_same div_sub_div_same

/- warning: same_sub_div -> same_sub_div is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) b a) b) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) a b)))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) b a) b) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) a b)))
Case conversion may be inaccurate. Consider using '#align same_sub_div same_sub_divₓ'. -/
theorem same_sub_div {a b : K} (h : b ≠ 0) : (b - a) / b = 1 - a / b := by
  simpa only [← @div_self _ _ b h] using (div_sub_div_same b a b).symm
#align same_sub_div same_sub_div

/- warning: one_sub_div -> one_sub_div is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) a b)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) b a) b))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) a b)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) b a) b))
Case conversion may be inaccurate. Consider using '#align one_sub_div one_sub_divₓ'. -/
theorem one_sub_div {a b : K} (h : b ≠ 0) : 1 - a / b = (b - a) / b :=
  (same_sub_div h).symm
#align one_sub_div one_sub_div

/- warning: div_sub_same -> div_sub_same is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) a b) b) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) a b) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))))))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) a b) b) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) a b) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align div_sub_same div_sub_sameₓ'. -/
theorem div_sub_same {a b : K} (h : b ≠ 0) : (a - b) / b = a / b - 1 := by
  simpa only [← @div_self _ _ b h] using (div_sub_div_same a b b).symm
#align div_sub_same div_sub_same

/- warning: div_sub_one -> div_sub_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) a b) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) a b) b))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) a b) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) a b) b))
Case conversion may be inaccurate. Consider using '#align div_sub_one div_sub_oneₓ'. -/
theorem div_sub_one {a b : K} (h : b ≠ 0) : a / b - 1 = (a - b) / b :=
  (div_sub_same h).symm
#align div_sub_one div_sub_one

/- warning: sub_div -> sub_div is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] (a : K) (b : K) (c : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) a b) c) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) a c) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) b c))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] (a : K) (b : K) (c : K), Eq.{succ u1} K (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) a b) c) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) a c) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) b c))
Case conversion may be inaccurate. Consider using '#align sub_div sub_divₓ'. -/
theorem sub_div (a b c : K) : (a - b) / c = a / c - b / c :=
  (div_sub_div_same _ _ _).symm
#align sub_div sub_div

/- warning: inv_sub_inv' -> inv_sub_inv' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1)) a) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1)) b)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1)) a) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) b a)) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1)) b)))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (Inv.inv.{u1} K (DivisionRing.toInv.{u1} K _inst_1) a) (Inv.inv.{u1} K (DivisionRing.toInv.{u1} K _inst_1) b)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (Inv.inv.{u1} K (DivisionRing.toInv.{u1} K _inst_1) a) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) b a)) (Inv.inv.{u1} K (DivisionRing.toInv.{u1} K _inst_1) b)))
Case conversion may be inaccurate. Consider using '#align inv_sub_inv' inv_sub_inv'ₓ'. -/
/-- See `inv_sub_inv` for the more convenient version when `K` is commutative. -/
theorem inv_sub_inv' {a b : K} (ha : a ≠ 0) (hb : b ≠ 0) : a⁻¹ - b⁻¹ = a⁻¹ * (b - a) * b⁻¹ := by
  rw [mul_sub, sub_mul, mul_inv_cancel_right₀ hb, inv_mul_cancel ha, one_mul]
#align inv_sub_inv' inv_sub_inv'

/- warning: one_div_mul_sub_mul_one_div_eq_one_div_add_one_div -> one_div_mul_sub_mul_one_div_eq_one_div_add_one_div is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Eq.{succ u1} K (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))) a) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) b a)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))) b)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))) a) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))) b)))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) a) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) b a)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) b)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) a) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) b)))
Case conversion may be inaccurate. Consider using '#align one_div_mul_sub_mul_one_div_eq_one_div_add_one_div one_div_mul_sub_mul_one_div_eq_one_div_add_one_divₓ'. -/
theorem one_div_mul_sub_mul_one_div_eq_one_div_add_one_div (ha : a ≠ 0) (hb : b ≠ 0) :
    1 / a * (b - a) * (1 / b) = 1 / a - 1 / b := by
  rw [mul_sub_left_distrib (1 / a), one_div_mul_cancel ha, mul_sub_right_distrib, one_mul,
    mul_assoc, mul_one_div_cancel hb, mul_one]
#align
  one_div_mul_sub_mul_one_div_eq_one_div_add_one_div one_div_mul_sub_mul_one_div_eq_one_div_add_one_div

#print DivisionRing.IsDomain /-
-- see Note [lower instance priority]
instance (priority := 100) DivisionRing.IsDomain : IsDomain K :=
  NoZeroDivisors.toIsDomain _
#align division_ring.is_domain DivisionRing.IsDomain
-/

end DivisionRing

section Semifield

variable [Semifield α] {a b c d : α}

/- warning: div_add_div -> div_add_div is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Semifield.{u1} α] {b : α} {d : α} (a : α) (c : α), (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))))))) -> (Ne.{succ u1} α d (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))) a b) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))) c d)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) a d) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) b c)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) b d)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Semifield.{u1} α] {b : α} {d : α} (a : α) (c : α), (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommGroupWithZero.toCommMonoidWithZero.{u1} α (Semifield.toCommGroupWithZero.{u1} α _inst_1)))))) -> (Ne.{succ u1} α d (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommGroupWithZero.toCommMonoidWithZero.{u1} α (Semifield.toCommGroupWithZero.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (Semifield.toDiv.{u1} α _inst_1)) a b) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (Semifield.toDiv.{u1} α _inst_1)) c d)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (Semifield.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))) a d) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))) b c)) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))) b d)))
Case conversion may be inaccurate. Consider using '#align div_add_div div_add_divₓ'. -/
theorem div_add_div (a : α) (c : α) (hb : b ≠ 0) (hd : d ≠ 0) :
    a / b + c / d = (a * d + b * c) / (b * d) := by
  rw [← mul_div_mul_right _ b hd, ← mul_div_mul_left c d hb, div_add_div_same]
#align div_add_div div_add_div

/- warning: one_div_add_one_div -> one_div_add_one_div is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Semifield.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))))) a) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))) (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))))) b)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) a b) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) a b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Semifield.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommGroupWithZero.toCommMonoidWithZero.{u1} α (Semifield.toCommGroupWithZero.{u1} α _inst_1)))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommGroupWithZero.toCommMonoidWithZero.{u1} α (Semifield.toCommGroupWithZero.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (Semifield.toDiv.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))) a) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (Semifield.toDiv.{u1} α _inst_1)) (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α (Semiring.toOne.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))) b)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (Semifield.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) a b) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))) a b)))
Case conversion may be inaccurate. Consider using '#align one_div_add_one_div one_div_add_one_divₓ'. -/
theorem one_div_add_one_div (ha : a ≠ 0) (hb : b ≠ 0) : 1 / a + 1 / b = (a + b) / (a * b) := by
  rw [div_add_div _ _ ha hb, one_mul, mul_one, add_comm]
#align one_div_add_one_div one_div_add_one_div

/- warning: inv_add_inv -> inv_add_inv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} [_inst_1 : Semifield.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))) a) (Inv.inv.{u1} α (DivInvMonoid.toHasInv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))) b)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (DivInvMonoid.toHasDiv.{u1} α (GroupWithZero.toDivInvMonoid.{u1} α (DivisionSemiring.toGroupWithZero.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toHasAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) a b) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) a b)))
but is expected to have type
  forall {α : Type.{u1}} [_inst_1 : Semifield.{u1} α] {a : α} {b : α}, (Ne.{succ u1} α a (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommGroupWithZero.toCommMonoidWithZero.{u1} α (Semifield.toCommGroupWithZero.{u1} α _inst_1)))))) -> (Ne.{succ u1} α b (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α (CommMonoidWithZero.toZero.{u1} α (CommGroupWithZero.toCommMonoidWithZero.{u1} α (Semifield.toCommGroupWithZero.{u1} α _inst_1)))))) -> (Eq.{succ u1} α (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) (Inv.inv.{u1} α (Semifield.toInv.{u1} α _inst_1) a) (Inv.inv.{u1} α (Semifield.toInv.{u1} α _inst_1) b)) (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α (Semifield.toDiv.{u1} α _inst_1)) (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α (Distrib.toAdd.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1))))))) a b) (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α (DivisionSemiring.toSemiring.{u1} α (Semifield.toDivisionSemiring.{u1} α _inst_1)))))) a b)))
Case conversion may be inaccurate. Consider using '#align inv_add_inv inv_add_invₓ'. -/
theorem inv_add_inv (ha : a ≠ 0) (hb : b ≠ 0) : a⁻¹ + b⁻¹ = (a + b) / (a * b) := by
  rw [inv_eq_one_div, inv_eq_one_div, one_div_add_one_div ha hb]
#align inv_add_inv inv_add_inv

end Semifield

section Field

variable [Field K]

attribute [local simp] mul_assoc mul_comm mul_left_comm

/- warning: div_sub_div -> div_sub_div is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] (a : K) {b : K} (c : K) {d : K}, (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))))))) -> (Ne.{succ u1} K d (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) a b) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) c d)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) a d) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) b c)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) b d)))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] (a : K) {b : K} (c : K) {d : K}, (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommGroupWithZero.toCommMonoidWithZero.{u1} K (Semifield.toCommGroupWithZero.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) -> (Ne.{succ u1} K d (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommGroupWithZero.toCommMonoidWithZero.{u1} K (Semifield.toCommGroupWithZero.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (Field.toDiv.{u1} K _inst_1)) a b) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (Field.toDiv.{u1} K _inst_1)) c d)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (Field.toDiv.{u1} K _inst_1)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) a d) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) b c)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) b d)))
Case conversion may be inaccurate. Consider using '#align div_sub_div div_sub_divₓ'. -/
@[field_simps]
theorem div_sub_div (a : K) {b : K} (c : K) {d : K} (hb : b ≠ 0) (hd : d ≠ 0) :
    a / b - c / d = (a * d - b * c) / (b * d) := by
  simp [sub_eq_add_neg]
  rw [neg_eq_neg_one_mul, ← mul_div_assoc, div_add_div _ _ hb hd, ← mul_assoc, mul_comm b,
    mul_assoc, ← neg_eq_neg_one_mul]
#align div_sub_div div_sub_div

/- warning: inv_sub_inv -> inv_sub_inv is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))))))) -> (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) a) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) b)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) b a) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) a b)))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {a : K} {b : K}, (Ne.{succ u1} K a (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommGroupWithZero.toCommMonoidWithZero.{u1} K (Semifield.toCommGroupWithZero.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) -> (Ne.{succ u1} K b (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommGroupWithZero.toCommMonoidWithZero.{u1} K (Semifield.toCommGroupWithZero.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (Inv.inv.{u1} K (Field.toInv.{u1} K _inst_1) a) (Inv.inv.{u1} K (Field.toInv.{u1} K _inst_1) b)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (Field.toDiv.{u1} K _inst_1)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) b a) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) a b)))
Case conversion may be inaccurate. Consider using '#align inv_sub_inv inv_sub_invₓ'. -/
theorem inv_sub_inv {a b : K} (ha : a ≠ 0) (hb : b ≠ 0) : a⁻¹ - b⁻¹ = (b - a) / (a * b) := by
  rw [inv_eq_one_div, inv_eq_one_div, div_sub_div _ _ ha hb, one_mul, mul_one]
#align inv_sub_inv inv_sub_inv

/- warning: sub_div' -> sub_div' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] (a : K) (b : K) (c : K), (Ne.{succ u1} K c (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) b (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) a c)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) b c) a) c))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] (a : K) (b : K) (c : K), (Ne.{succ u1} K c (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommGroupWithZero.toCommMonoidWithZero.{u1} K (Semifield.toCommGroupWithZero.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) b (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (Field.toDiv.{u1} K _inst_1)) a c)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (Field.toDiv.{u1} K _inst_1)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) b c) a) c))
Case conversion may be inaccurate. Consider using '#align sub_div' sub_div'ₓ'. -/
@[field_simps]
theorem sub_div' (a b c : K) (hc : c ≠ 0) : b - a / c = (b * c - a) / c := by
  simpa using div_sub_div b a one_ne_zero hc
#align sub_div' sub_div'

/- warning: div_sub' -> div_sub' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] (a : K) (b : K) (c : K), (Ne.{succ u1} K c (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) a c) b) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) a (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) c b)) c))
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] (a : K) (b : K) (c : K), (Ne.{succ u1} K c (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommGroupWithZero.toCommMonoidWithZero.{u1} K (Semifield.toCommGroupWithZero.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (Field.toDiv.{u1} K _inst_1)) a c) b) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (Field.toDiv.{u1} K _inst_1)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) a (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) c b)) c))
Case conversion may be inaccurate. Consider using '#align div_sub' div_sub'ₓ'. -/
@[field_simps]
theorem div_sub' (a b c : K) (hc : c ≠ 0) : a / c - b = (a - c * b) / c := by
  simpa using div_sub_div a b hc one_ne_zero
#align div_sub' div_sub'

#print Field.IsDomain /-
-- see Note [lower instance priority]
instance (priority := 100) Field.IsDomain : IsDomain K :=
  { DivisionRing.IsDomain with }
#align field.is_domain Field.IsDomain
-/

end Field

namespace RingHom

/- warning: ring_hom.injective -> RingHom.injective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : DivisionRing.{u1} α] [_inst_2 : Semiring.{u2} β] [_inst_3 : Nontrivial.{u2} β] (f : RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) (Semiring.toNonAssocSemiring.{u2} β _inst_2)), Function.Injective.{succ u1, succ u2} α β (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) (fun (_x : RingHom.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) => α -> β) (RingHom.hasCoeToFun.{u1, u2} α β (NonAssocRing.toNonAssocSemiring.{u1} α (Ring.toNonAssocRing.{u1} α (DivisionRing.toRing.{u1} α _inst_1))) (Semiring.toNonAssocSemiring.{u2} β _inst_2)) f)
but is expected to have type
  forall {α : Type.{u2}} {β : Type.{u1}} [_inst_1 : DivisionRing.{u2} α] [_inst_2 : Semiring.{u1} β] [_inst_3 : Nontrivial.{u1} β] (f : RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (DivisionRing.toRing.{u2} α _inst_1))) (Semiring.toNonAssocSemiring.{u1} β _inst_2)), Function.Injective.{succ u2, succ u1} α β (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (DivisionRing.toRing.{u2} α _inst_1))) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α (fun (_x : α) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2475 : α) => β) _x) (MulHomClass.toFunLike.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (DivisionRing.toRing.{u2} α _inst_1))) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (DivisionRing.toRing.{u2} α _inst_1))))) (NonUnitalNonAssocSemiring.toMul.{u1} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (Semiring.toNonAssocSemiring.{u1} β _inst_2))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (DivisionRing.toRing.{u2} α _inst_1))) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (DivisionRing.toRing.{u2} α _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} β (Semiring.toNonAssocSemiring.{u1} β _inst_2)) (RingHomClass.toNonUnitalRingHomClass.{max u2 u1, u2, u1} (RingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (DivisionRing.toRing.{u2} α _inst_1))) (Semiring.toNonAssocSemiring.{u1} β _inst_2)) α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (DivisionRing.toRing.{u2} α _inst_1))) (Semiring.toNonAssocSemiring.{u1} β _inst_2) (RingHom.instRingHomClassRingHom.{u2, u1} α β (NonAssocRing.toNonAssocSemiring.{u2} α (Ring.toNonAssocRing.{u2} α (DivisionRing.toRing.{u2} α _inst_1))) (Semiring.toNonAssocSemiring.{u1} β _inst_2))))) f)
Case conversion may be inaccurate. Consider using '#align ring_hom.injective RingHom.injectiveₓ'. -/
protected theorem injective [DivisionRing α] [Semiring β] [Nontrivial β] (f : α →+* β) :
    Injective f :=
  (injective_iff_map_eq_zero f).2 fun x => (map_eq_zero f).1
#align ring_hom.injective RingHom.injective

end RingHom

section NoncomputableDefs

variable {R : Type _} [Nontrivial R]

/- warning: division_ring_of_is_unit_or_eq_zero -> divisionRingOfIsUnitOrEqZero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Nontrivial.{u1} R] [hR : Ring.{u1} R], (forall (a : R), Or (IsUnit.{u1} R (Ring.toMonoid.{u1} R hR) a) (Eq.{succ u1} R a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R hR)))))))))) -> (DivisionRing.{u1} R)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Nontrivial.{u1} R] [hR : Ring.{u1} R], (forall (a : R), Or (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R hR))) a) (Eq.{succ u1} R a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R hR))))))) -> (DivisionRing.{u1} R)
Case conversion may be inaccurate. Consider using '#align division_ring_of_is_unit_or_eq_zero divisionRingOfIsUnitOrEqZeroₓ'. -/
/-- Constructs a `division_ring` structure on a `ring` consisting only of units and 0. -/
noncomputable def divisionRingOfIsUnitOrEqZero [hR : Ring R] (h : ∀ a : R, IsUnit a ∨ a = 0) :
    DivisionRing R :=
  { groupWithZeroOfIsUnitOrEqZero h, hR with }
#align division_ring_of_is_unit_or_eq_zero divisionRingOfIsUnitOrEqZero

/- warning: field_of_is_unit_or_eq_zero -> fieldOfIsUnitOrEqZero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Nontrivial.{u1} R] [hR : CommRing.{u1} R], (forall (a : R), Or (IsUnit.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R hR)) a) (Eq.{succ u1} R a (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R hR))))))))))) -> (Field.{u1} R)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Nontrivial.{u1} R] [hR : CommRing.{u1} R], (forall (a : R), Or (IsUnit.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R hR)))) a) (Eq.{succ u1} R a (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R hR))))))) -> (Field.{u1} R)
Case conversion may be inaccurate. Consider using '#align field_of_is_unit_or_eq_zero fieldOfIsUnitOrEqZeroₓ'. -/
/-- Constructs a `field` structure on a `comm_ring` consisting only of units and 0.
See note [reducible non-instances]. -/
@[reducible]
noncomputable def fieldOfIsUnitOrEqZero [hR : CommRing R] (h : ∀ a : R, IsUnit a ∨ a = 0) :
    Field R :=
  { groupWithZeroOfIsUnitOrEqZero h, hR with }
#align field_of_is_unit_or_eq_zero fieldOfIsUnitOrEqZero

end NoncomputableDefs

/- warning: function.injective.division_semiring -> Function.Injective.divisionSemiring is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : DivisionSemiring.{u2} β] [_inst_2 : Zero.{u1} α] [_inst_3 : Mul.{u1} α] [_inst_4 : Add.{u1} α] [_inst_5 : One.{u1} α] [_inst_6 : Inv.{u1} α] [_inst_7 : Div.{u1} α] [_inst_8 : HasSmul.{0, u1} Nat α] [_inst_9 : Pow.{u1, 0} α Nat] [_inst_10 : Pow.{u1, 0} α Int] [_inst_11 : NatCast.{u1} α] (f : α -> β), (Function.Injective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α _inst_2)))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1))))))))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α _inst_5)))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1))))))))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α _inst_4) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1)))))) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_3) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1)))))) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Inv.inv.{u1} α _inst_6 x)) (Inv.inv.{u2} β (DivInvMonoid.toHasInv.{u2} β (GroupWithZero.toDivInvMonoid.{u2} β (DivisionSemiring.toGroupWithZero.{u2} β _inst_1))) (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α _inst_7) x y)) (HDiv.hDiv.{u2, u2, u2} β β β (instHDiv.{u2} β (DivInvMonoid.toHasDiv.{u2} β (GroupWithZero.toDivInvMonoid.{u2} β (DivisionSemiring.toGroupWithZero.{u2} β _inst_1)))) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HasSmul.smul.{0, u1} Nat α _inst_8 n x)) (HasSmul.smul.{0, u2} Nat β (AddMonoid.SMul.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1)))))) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat _inst_9) x n)) (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat (Monoid.Pow.{u2} β (MonoidWithZero.toMonoid.{u2} β (Semiring.toMonoidWithZero.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1))))) (f x) n)) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int _inst_10) x n)) (HPow.hPow.{u2, 0, u2} β Int β (instHPow.{u2, 0} β Int (DivInvMonoid.Pow.{u2} β (GroupWithZero.toDivInvMonoid.{u2} β (DivisionSemiring.toGroupWithZero.{u2} β _inst_1)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} β (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α _inst_11))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β (AddMonoidWithOne.toNatCast.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1)))))))) n)) -> (DivisionSemiring.{u1} α)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : DivisionSemiring.{u2} β] [_inst_2 : Zero.{u1} α] [_inst_3 : Mul.{u1} α] [_inst_4 : Add.{u1} α] [_inst_5 : One.{u1} α] [_inst_6 : Inv.{u1} α] [_inst_7 : Div.{u1} α] [_inst_8 : SMul.{0, u1} Nat α] [_inst_9 : Pow.{u1, 0} α Nat] [_inst_10 : Pow.{u1, 0} α Int] [_inst_11 : NatCast.{u1} α] (f : α -> β), (Function.Injective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α _inst_2))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (MonoidWithZero.toZero.{u2} β (Semiring.toMonoidWithZero.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1)))))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α _inst_5))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (Semiring.toOne.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1))))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α _inst_4) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (Distrib.toAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1)))))) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_3) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1))))) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Inv.inv.{u1} α _inst_6 x)) (Inv.inv.{u2} β (DivisionSemiring.toInv.{u2} β _inst_1) (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α _inst_7) x y)) (HDiv.hDiv.{u2, u2, u2} β β β (instHDiv.{u2} β (DivisionSemiring.toDiv.{u2} β _inst_1)) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α _inst_8) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β (AddMonoid.SMul.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1))))))) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat _inst_9) x n)) (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat (Monoid.Pow.{u2} β (MonoidWithZero.toMonoid.{u2} β (Semiring.toMonoidWithZero.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1))))) (f x) n)) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int _inst_10) x n)) (HPow.hPow.{u2, 0, u2} β Int β (instHPow.{u2, 0} β Int (DivInvMonoid.Pow.{u2} β (GroupWithZero.toDivInvMonoid.{u2} β (DivisionSemiring.toGroupWithZero.{u2} β _inst_1)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} β (f (Nat.cast.{u1} α _inst_11 n)) (Nat.cast.{u2} β (Semiring.toNatCast.{u2} β (DivisionSemiring.toSemiring.{u2} β _inst_1)) n)) -> (DivisionSemiring.{u1} α)
Case conversion may be inaccurate. Consider using '#align function.injective.division_semiring Function.Injective.divisionSemiringₓ'. -/
-- See note [reducible non-instances]
/-- Pullback a `division_semiring` along an injective function. -/
@[reducible]
protected def Function.Injective.divisionSemiring [DivisionSemiring β] [Zero α] [Mul α] [Add α]
    [One α] [Inv α] [Div α] [HasSmul ℕ α] [Pow α ℕ] [Pow α ℤ] [NatCast α] (f : α → β)
    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (inv : ∀ x, f x⁻¹ = (f x)⁻¹)
    (div : ∀ x y, f (x / y) = f x / f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (zpow : ∀ (x) (n : ℤ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : DivisionSemiring α :=
  { hf.GroupWithZero f zero one mul inv div npow zpow,
    hf.Semiring f zero one add mul nsmul npow nat_cast with }
#align function.injective.division_semiring Function.Injective.divisionSemiring

/- warning: function.injective.division_ring -> Function.Injective.divisionRing is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {K' : Type.{u2}} [_inst_2 : Zero.{u2} K'] [_inst_3 : One.{u2} K'] [_inst_4 : Add.{u2} K'] [_inst_5 : Mul.{u2} K'] [_inst_6 : Neg.{u2} K'] [_inst_7 : Sub.{u2} K'] [_inst_8 : Inv.{u2} K'] [_inst_9 : Div.{u2} K'] [_inst_10 : HasSmul.{0, u2} Nat K'] [_inst_11 : HasSmul.{0, u2} Int K'] [_inst_12 : HasSmul.{0, u2} Rat K'] [_inst_13 : Pow.{u2, 0} K' Nat] [_inst_14 : Pow.{u2, 0} K' Int] [_inst_15 : NatCast.{u2} K'] [_inst_16 : IntCast.{u2} K'] [_inst_17 : HasRatCast.{u2} K'] (f : K' -> K), (Function.Injective.{succ u2, succ u1} K' K f) -> (Eq.{succ u1} K (f (OfNat.ofNat.{u2} K' 0 (OfNat.mk.{u2} K' 0 (Zero.zero.{u2} K' _inst_2)))) (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) -> (Eq.{succ u1} K (f (OfNat.ofNat.{u2} K' 1 (OfNat.mk.{u2} K' 1 (One.one.{u2} K' _inst_3)))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HAdd.hAdd.{u2, u2, u2} K' K' K' (instHAdd.{u2} K' _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (f x) (f y))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HMul.hMul.{u2, u2, u2} K' K' K' (instHMul.{u2} K' _inst_5) x y)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (f x) (f y))) -> (forall (x : K'), Eq.{succ u1} K (f (Neg.neg.{u2} K' _inst_6 x)) (Neg.neg.{u1} K (SubNegMonoid.toHasNeg.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (f x))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HSub.hSub.{u2, u2, u2} K' K' K' (instHSub.{u2} K' _inst_7) x y)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (f x) (f y))) -> (forall (x : K'), Eq.{succ u1} K (f (Inv.inv.{u2} K' _inst_8 x)) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1)) (f x))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HDiv.hDiv.{u2, u2, u2} K' K' K' (instHDiv.{u2} K' _inst_9) x y)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (f x) (f y))) -> (forall (x : K') (n : Nat), Eq.{succ u1} K (f (HasSmul.smul.{0, u2} Nat K' _inst_10 n x)) (HasSmul.smul.{0, u1} Nat K (AddMonoid.SMul.{u1} K (AddMonoidWithOne.toAddMonoid.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) n (f x))) -> (forall (x : K') (n : Int), Eq.{succ u1} K (f (HasSmul.smul.{0, u2} Int K' _inst_11 n x)) (HasSmul.smul.{0, u1} Int K (SubNegMonoid.hasSmulInt.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) n (f x))) -> (forall (x : K') (n : Rat), Eq.{succ u1} K (f (HasSmul.smul.{0, u2} Rat K' _inst_12 n x)) (HasSmul.smul.{0, u1} Rat K (Rat.smulDivisionRing.{u1} K _inst_1) n (f x))) -> (forall (x : K') (n : Nat), Eq.{succ u1} K (f (HPow.hPow.{u2, 0, u2} K' Nat K' (instHPow.{u2, 0} K' Nat _inst_13) x n)) (HPow.hPow.{u1, 0, u1} K Nat K (instHPow.{u1, 0} K Nat (Monoid.Pow.{u1} K (Ring.toMonoid.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (f x) n)) -> (forall (x : K') (n : Int), Eq.{succ u1} K (f (HPow.hPow.{u2, 0, u2} K' Int K' (instHPow.{u2, 0} K' Int _inst_14) x n)) (HPow.hPow.{u1, 0, u1} K Int K (instHPow.{u1, 0} K Int (DivInvMonoid.Pow.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} K (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat K' (HasLiftT.mk.{1, succ u2} Nat K' (CoeTCₓ.coe.{1, succ u2} Nat K' (Nat.castCoe.{u2} K' _inst_15))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat K (HasLiftT.mk.{1, succ u1} Nat K (CoeTCₓ.coe.{1, succ u1} Nat K (Nat.castCoe.{u1} K (AddMonoidWithOne.toNatCast.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))) n)) -> (forall (n : Int), Eq.{succ u1} K (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int K' (HasLiftT.mk.{1, succ u2} Int K' (CoeTCₓ.coe.{1, succ u2} Int K' (Int.castCoe.{u2} K' _inst_16))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int K (HasLiftT.mk.{1, succ u1} Int K (CoeTCₓ.coe.{1, succ u1} Int K (Int.castCoe.{u1} K (AddGroupWithOne.toHasIntCast.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) n)) -> (forall (n : Rat), Eq.{succ u1} K (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Rat K' (HasLiftT.mk.{1, succ u2} Rat K' (CoeTCₓ.coe.{1, succ u2} Rat K' (Rat.castCoe.{u2} K' _inst_17))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Rat K (HasLiftT.mk.{1, succ u1} Rat K (CoeTCₓ.coe.{1, succ u1} Rat K (Rat.castCoe.{u1} K (DivisionRing.toHasRatCast.{u1} K _inst_1)))) n)) -> (DivisionRing.{u2} K')
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : DivisionRing.{u1} K] {K' : Type.{u2}} [_inst_2 : Zero.{u2} K'] [_inst_3 : One.{u2} K'] [_inst_4 : Add.{u2} K'] [_inst_5 : Mul.{u2} K'] [_inst_6 : Neg.{u2} K'] [_inst_7 : Sub.{u2} K'] [_inst_8 : Inv.{u2} K'] [_inst_9 : Div.{u2} K'] [_inst_10 : SMul.{0, u2} Nat K'] [_inst_11 : SMul.{0, u2} Int K'] [_inst_12 : SMul.{0, u2} Rat K'] [_inst_13 : Pow.{u2, 0} K' Nat] [_inst_14 : Pow.{u2, 0} K' Int] [_inst_15 : NatCast.{u2} K'] [_inst_16 : IntCast.{u2} K'] [_inst_17 : HasRatCast.{u2} K'] (f : K' -> K), (Function.Injective.{succ u2, succ u1} K' K f) -> (Eq.{succ u1} K (f (OfNat.ofNat.{u2} K' 0 (Zero.toOfNat0.{u2} K' _inst_2))) (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (f (OfNat.ofNat.{u2} K' 1 (One.toOfNat1.{u2} K' _inst_3))) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HAdd.hAdd.{u2, u2, u2} K' K' K' (instHAdd.{u2} K' _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (f x) (f y))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HMul.hMul.{u2, u2, u2} K' K' K' (instHMul.{u2} K' _inst_5) x y)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (f x) (f y))) -> (forall (x : K'), Eq.{succ u1} K (f (Neg.neg.{u2} K' _inst_6 x)) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (f x))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HSub.hSub.{u2, u2, u2} K' K' K' (instHSub.{u2} K' _inst_7) x y)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (f x) (f y))) -> (forall (x : K'), Eq.{succ u1} K (f (Inv.inv.{u2} K' _inst_8 x)) (Inv.inv.{u1} K (DivisionRing.toInv.{u1} K _inst_1) (f x))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HDiv.hDiv.{u2, u2, u2} K' K' K' (instHDiv.{u2} K' _inst_9) x y)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivisionRing.toDiv.{u1} K _inst_1)) (f x) (f y))) -> (forall (x : K') (n : Nat), Eq.{succ u1} K (f (HSMul.hSMul.{0, u2, u2} Nat K' K' (instHSMul.{0, u2} Nat K' _inst_10) n x)) (HSMul.hSMul.{0, u1, u1} Nat K K (instHSMul.{0, u1} Nat K (AddMonoid.SMul.{u1} K (AddMonoidWithOne.toAddMonoid.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) n (f x))) -> (forall (x : K') (n : Int), Eq.{succ u1} K (f (HSMul.hSMul.{0, u2, u2} Int K' K' (instHSMul.{0, u2} Int K' _inst_11) n x)) (HSMul.hSMul.{0, u1, u1} Int K K (instHSMul.{0, u1} Int K (SubNegMonoid.SMulInt.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (Ring.toAddGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) n (f x))) -> (forall (x : K') (n : Rat), Eq.{succ u1} K (f (HSMul.hSMul.{0, u2, u2} Rat K' K' (instHSMul.{0, u2} Rat K' _inst_12) n x)) (HSMul.hSMul.{0, u1, u1} Rat K K (instHSMul.{0, u1} Rat K (Rat.smulDivisionRing.{u1} K _inst_1)) n (f x))) -> (forall (x : K') (n : Nat), Eq.{succ u1} K (f (HPow.hPow.{u2, 0, u2} K' Nat K' (instHPow.{u2, 0} K' Nat _inst_13) x n)) (HPow.hPow.{u1, 0, u1} K Nat K (instHPow.{u1, 0} K Nat (Monoid.Pow.{u1} K (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))))) (f x) n)) -> (forall (x : K') (n : Int), Eq.{succ u1} K (f (HPow.hPow.{u2, 0, u2} K' Int K' (instHPow.{u2, 0} K' Int _inst_14) x n)) (HPow.hPow.{u1, 0, u1} K Int K (instHPow.{u1, 0} K Int (DivInvMonoid.Pow.{u1} K (DivisionRing.toDivInvMonoid.{u1} K _inst_1))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} K (f (Nat.cast.{u2} K' _inst_15 n)) (Nat.cast.{u1} K (NonAssocRing.toNatCast.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) n)) -> (forall (n : Int), Eq.{succ u1} K (f (Int.cast.{u2} K' _inst_16 n)) (Int.cast.{u1} K (Ring.toIntCast.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) n)) -> (forall (n : Rat), Eq.{succ u1} K (f (HasRatCast.ratCast.{u2} K' _inst_17 n)) (HasRatCast.ratCast.{u1} K (DivisionRing.toHasRatCast.{u1} K _inst_1) n)) -> (DivisionRing.{u2} K')
Case conversion may be inaccurate. Consider using '#align function.injective.division_ring Function.Injective.divisionRingₓ'. -/
/-- Pullback a `division_ring` along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.divisionRing [DivisionRing K] {K'} [Zero K'] [One K'] [Add K']
    [Mul K'] [Neg K'] [Sub K'] [Inv K'] [Div K'] [HasSmul ℕ K'] [HasSmul ℤ K'] [HasSmul ℚ K']
    [Pow K' ℕ] [Pow K' ℤ] [NatCast K'] [IntCast K'] [HasRatCast K'] (f : K' → K) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (neg : ∀ x, f (-x) = -f x)
    (sub : ∀ x y, f (x - y) = f x - f y) (inv : ∀ x, f x⁻¹ = (f x)⁻¹)
    (div : ∀ x y, f (x / y) = f x / f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (qsmul : ∀ (x) (n : ℚ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (zpow : ∀ (x) (n : ℤ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) (rat_cast : ∀ n : ℚ, f n = n) :
    DivisionRing K' :=
  { hf.GroupWithZero f zero one mul inv div npow zpow,
    hf.Ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with
    ratCast := coe
    rat_cast_mk := fun a b h1 h2 =>
      hf
        (by
          erw [rat_cast, mul, inv, int_cast, nat_cast] <;> exact DivisionRing.ratCast_mk a b h1 h2)
    qsmul := (· • ·)
    qsmul_eq_mul' := fun a x => hf (by erw [qsmul, mul, Rat.smul_def, rat_cast]) }
#align function.injective.division_ring Function.Injective.divisionRing

/- warning: function.injective.semifield -> Function.Injective.semifield is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Semifield.{u2} β] [_inst_2 : Zero.{u1} α] [_inst_3 : Mul.{u1} α] [_inst_4 : Add.{u1} α] [_inst_5 : One.{u1} α] [_inst_6 : Inv.{u1} α] [_inst_7 : Div.{u1} α] [_inst_8 : HasSmul.{0, u1} Nat α] [_inst_9 : Pow.{u1, 0} α Nat] [_inst_10 : Pow.{u1, 0} α Int] [_inst_11 : NatCast.{u1} α] (f : α -> β), (Function.Injective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α _inst_2)))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1)))))))))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (OfNat.mk.{u1} α 1 (One.one.{u1} α _inst_5)))) (OfNat.ofNat.{u2} β 1 (OfNat.mk.{u2} β 1 (One.one.{u2} β (AddMonoidWithOne.toOne.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1)))))))))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α _inst_4) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (Distrib.toHasAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1))))))) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_3) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (Distrib.toHasMul.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1))))))) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Inv.inv.{u1} α _inst_6 x)) (Inv.inv.{u2} β (DivInvMonoid.toHasInv.{u2} β (GroupWithZero.toDivInvMonoid.{u2} β (DivisionSemiring.toGroupWithZero.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1)))) (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α _inst_7) x y)) (HDiv.hDiv.{u2, u2, u2} β β β (instHDiv.{u2} β (DivInvMonoid.toHasDiv.{u2} β (GroupWithZero.toDivInvMonoid.{u2} β (DivisionSemiring.toGroupWithZero.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1))))) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HasSmul.smul.{0, u1} Nat α _inst_8 n x)) (HasSmul.smul.{0, u2} Nat β (AddMonoid.SMul.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1))))))) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat _inst_9) x n)) (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat (Monoid.Pow.{u2} β (MonoidWithZero.toMonoid.{u2} β (Semiring.toMonoidWithZero.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1)))))) (f x) n)) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int _inst_10) x n)) (HPow.hPow.{u2, 0, u2} β Int β (instHPow.{u2, 0} β Int (DivInvMonoid.Pow.{u2} β (GroupWithZero.toDivInvMonoid.{u2} β (DivisionSemiring.toGroupWithZero.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} β (f ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat α (HasLiftT.mk.{1, succ u1} Nat α (CoeTCₓ.coe.{1, succ u1} Nat α (Nat.castCoe.{u1} α _inst_11))) n)) ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat β (HasLiftT.mk.{1, succ u2} Nat β (CoeTCₓ.coe.{1, succ u2} Nat β (Nat.castCoe.{u2} β (AddMonoidWithOne.toNatCast.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1))))))))) n)) -> (Semifield.{u1} α)
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} [_inst_1 : Semifield.{u2} β] [_inst_2 : Zero.{u1} α] [_inst_3 : Mul.{u1} α] [_inst_4 : Add.{u1} α] [_inst_5 : One.{u1} α] [_inst_6 : Inv.{u1} α] [_inst_7 : Div.{u1} α] [_inst_8 : SMul.{0, u1} Nat α] [_inst_9 : Pow.{u1, 0} α Nat] [_inst_10 : Pow.{u1, 0} α Int] [_inst_11 : NatCast.{u1} α] (f : α -> β), (Function.Injective.{succ u1, succ u2} α β f) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (Zero.toOfNat0.{u1} α _inst_2))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β (CommMonoidWithZero.toZero.{u2} β (CommGroupWithZero.toCommMonoidWithZero.{u2} β (Semifield.toCommGroupWithZero.{u2} β _inst_1)))))) -> (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 1 (One.toOfNat1.{u1} α _inst_5))) (OfNat.ofNat.{u2} β 1 (One.toOfNat1.{u2} β (Semiring.toOne.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1)))))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HAdd.hAdd.{u1, u1, u1} α α α (instHAdd.{u1} α _inst_4) x y)) (HAdd.hAdd.{u2, u2, u2} β β β (instHAdd.{u2} β (Distrib.toAdd.{u2} β (NonUnitalNonAssocSemiring.toDistrib.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1))))))) (f x) (f y))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α _inst_3) x y)) (HMul.hMul.{u2, u2, u2} β β β (instHMul.{u2} β (NonUnitalNonAssocSemiring.toMul.{u2} β (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1)))))) (f x) (f y))) -> (forall (x : α), Eq.{succ u2} β (f (Inv.inv.{u1} α _inst_6 x)) (Inv.inv.{u2} β (Semifield.toInv.{u2} β _inst_1) (f x))) -> (forall (x : α) (y : α), Eq.{succ u2} β (f (HDiv.hDiv.{u1, u1, u1} α α α (instHDiv.{u1} α _inst_7) x y)) (HDiv.hDiv.{u2, u2, u2} β β β (instHDiv.{u2} β (Semifield.toDiv.{u2} β _inst_1)) (f x) (f y))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HSMul.hSMul.{0, u1, u1} Nat α α (instHSMul.{0, u1} Nat α _inst_8) n x)) (HSMul.hSMul.{0, u2, u2} Nat β β (instHSMul.{0, u2} Nat β (AddMonoid.SMul.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} β (NonAssocSemiring.toAddCommMonoidWithOne.{u2} β (Semiring.toNonAssocSemiring.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1)))))))) n (f x))) -> (forall (x : α) (n : Nat), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Nat α (instHPow.{u1, 0} α Nat _inst_9) x n)) (HPow.hPow.{u2, 0, u2} β Nat β (instHPow.{u2, 0} β Nat (Monoid.Pow.{u2} β (MonoidWithZero.toMonoid.{u2} β (Semiring.toMonoidWithZero.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1)))))) (f x) n)) -> (forall (x : α) (n : Int), Eq.{succ u2} β (f (HPow.hPow.{u1, 0, u1} α Int α (instHPow.{u1, 0} α Int _inst_10) x n)) (HPow.hPow.{u2, 0, u2} β Int β (instHPow.{u2, 0} β Int (DivInvMonoid.Pow.{u2} β (GroupWithZero.toDivInvMonoid.{u2} β (DivisionSemiring.toGroupWithZero.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1))))) (f x) n)) -> (forall (n : Nat), Eq.{succ u2} β (f (Nat.cast.{u1} α _inst_11 n)) (Nat.cast.{u2} β (Semiring.toNatCast.{u2} β (DivisionSemiring.toSemiring.{u2} β (Semifield.toDivisionSemiring.{u2} β _inst_1))) n)) -> (Semifield.{u1} α)
Case conversion may be inaccurate. Consider using '#align function.injective.semifield Function.Injective.semifieldₓ'. -/
-- See note [reducible non-instances]
/-- Pullback a `field` along an injective function. -/
@[reducible]
protected def Function.Injective.semifield [Semifield β] [Zero α] [Mul α] [Add α] [One α] [Inv α]
    [Div α] [HasSmul ℕ α] [Pow α ℕ] [Pow α ℤ] [NatCast α] (f : α → β) (hf : Injective f)
    (zero : f 0 = 0) (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y)
    (mul : ∀ x y, f (x * y) = f x * f y) (inv : ∀ x, f x⁻¹ = (f x)⁻¹)
    (div : ∀ x y, f (x / y) = f x / f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (zpow : ∀ (x) (n : ℤ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) : Semifield α :=
  { hf.CommGroupWithZero f zero one mul inv div npow zpow,
    hf.CommSemiring f zero one add mul nsmul npow nat_cast with }
#align function.injective.semifield Function.Injective.semifield

/- warning: function.injective.field -> Function.Injective.field is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {K' : Type.{u2}} [_inst_2 : Zero.{u2} K'] [_inst_3 : Mul.{u2} K'] [_inst_4 : Add.{u2} K'] [_inst_5 : Neg.{u2} K'] [_inst_6 : Sub.{u2} K'] [_inst_7 : One.{u2} K'] [_inst_8 : Inv.{u2} K'] [_inst_9 : Div.{u2} K'] [_inst_10 : HasSmul.{0, u2} Nat K'] [_inst_11 : HasSmul.{0, u2} Int K'] [_inst_12 : HasSmul.{0, u2} Rat K'] [_inst_13 : Pow.{u2, 0} K' Nat] [_inst_14 : Pow.{u2, 0} K' Int] [_inst_15 : NatCast.{u2} K'] [_inst_16 : IntCast.{u2} K'] [_inst_17 : HasRatCast.{u2} K'] (f : K' -> K), (Function.Injective.{succ u2, succ u1} K' K f) -> (Eq.{succ u1} K (f (OfNat.ofNat.{u2} K' 0 (OfNat.mk.{u2} K' 0 (Zero.zero.{u2} K' _inst_2)))) (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))))))) -> (Eq.{succ u1} K (f (OfNat.ofNat.{u2} K' 1 (OfNat.mk.{u2} K' 1 (One.one.{u2} K' _inst_7)))) (OfNat.ofNat.{u1} K 1 (OfNat.mk.{u1} K 1 (One.one.{u1} K (AddMonoidWithOne.toOne.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HAdd.hAdd.{u2, u2, u2} K' K' K' (instHAdd.{u2} K' _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toHasAdd.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (f x) (f y))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HMul.hMul.{u2, u2, u2} K' K' K' (instHMul.{u2} K' _inst_3) x y)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (Distrib.toHasMul.{u1} K (Ring.toDistrib.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (f x) (f y))) -> (forall (x : K'), Eq.{succ u1} K (f (Neg.neg.{u2} K' _inst_5 x)) (Neg.neg.{u1} K (SubNegMonoid.toHasNeg.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))) (f x))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HSub.hSub.{u2, u2, u2} K' K' K' (instHSub.{u2} K' _inst_6) x y)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (SubNegMonoid.toHasSub.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) (f x) (f y))) -> (forall (x : K'), Eq.{succ u1} K (f (Inv.inv.{u2} K' _inst_8 x)) (Inv.inv.{u1} K (DivInvMonoid.toHasInv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (f x))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HDiv.hDiv.{u2, u2, u2} K' K' K' (instHDiv.{u2} K' _inst_9) x y)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (DivInvMonoid.toHasDiv.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (f x) (f y))) -> (forall (x : K') (n : Nat), Eq.{succ u1} K (f (HasSmul.smul.{0, u2} Nat K' _inst_10 n x)) (HasSmul.smul.{0, u1} Nat K (AddMonoid.SMul.{u1} K (AddMonoidWithOne.toAddMonoid.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))) n (f x))) -> (forall (x : K') (n : Int), Eq.{succ u1} K (f (HasSmul.smul.{0, u2} Int K' _inst_11 n x)) (HasSmul.smul.{0, u1} Int K (SubNegMonoid.hasSmulInt.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))) n (f x))) -> (forall (x : K') (n : Rat), Eq.{succ u1} K (f (HasSmul.smul.{0, u2} Rat K' _inst_12 n x)) (HasSmul.smul.{0, u1} Rat K (Rat.smulDivisionRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)) n (f x))) -> (forall (x : K') (n : Nat), Eq.{succ u1} K (f (HPow.hPow.{u2, 0, u2} K' Nat K' (instHPow.{u2, 0} K' Nat _inst_13) x n)) (HPow.hPow.{u1, 0, u1} K Nat K (instHPow.{u1, 0} K Nat (Monoid.Pow.{u1} K (Ring.toMonoid.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) (f x) n)) -> (forall (x : K') (n : Int), Eq.{succ u1} K (f (HPow.hPow.{u2, 0, u2} K' Int K' (instHPow.{u2, 0} K' Int _inst_14) x n)) (HPow.hPow.{u1, 0, u1} K Int K (instHPow.{u1, 0} K Int (DivInvMonoid.Pow.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} K (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Nat K' (HasLiftT.mk.{1, succ u2} Nat K' (CoeTCₓ.coe.{1, succ u2} Nat K' (Nat.castCoe.{u2} K' _inst_15))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat K (HasLiftT.mk.{1, succ u1} Nat K (CoeTCₓ.coe.{1, succ u1} Nat K (Nat.castCoe.{u1} K (AddMonoidWithOne.toNatCast.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))))) n)) -> (forall (n : Int), Eq.{succ u1} K (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Int K' (HasLiftT.mk.{1, succ u2} Int K' (CoeTCₓ.coe.{1, succ u2} Int K' (Int.castCoe.{u2} K' _inst_16))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int K (HasLiftT.mk.{1, succ u1} Int K (CoeTCₓ.coe.{1, succ u1} Int K (Int.castCoe.{u1} K (AddGroupWithOne.toHasIntCast.{u1} K (NonAssocRing.toAddGroupWithOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) n)) -> (forall (n : Rat), Eq.{succ u1} K (f ((fun (a : Type) (b : Type.{u2}) [self : HasLiftT.{1, succ u2} a b] => self.0) Rat K' (HasLiftT.mk.{1, succ u2} Rat K' (CoeTCₓ.coe.{1, succ u2} Rat K' (Rat.castCoe.{u2} K' _inst_17))) n)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Rat K (HasLiftT.mk.{1, succ u1} Rat K (CoeTCₓ.coe.{1, succ u1} Rat K (Rat.castCoe.{u1} K (DivisionRing.toHasRatCast.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))) n)) -> (Field.{u2} K')
but is expected to have type
  forall {K : Type.{u1}} [_inst_1 : Field.{u1} K] {K' : Type.{u2}} [_inst_2 : Zero.{u2} K'] [_inst_3 : Mul.{u2} K'] [_inst_4 : Add.{u2} K'] [_inst_5 : Neg.{u2} K'] [_inst_6 : Sub.{u2} K'] [_inst_7 : One.{u2} K'] [_inst_8 : Inv.{u2} K'] [_inst_9 : Div.{u2} K'] [_inst_10 : SMul.{0, u2} Nat K'] [_inst_11 : SMul.{0, u2} Int K'] [_inst_12 : SMul.{0, u2} Rat K'] [_inst_13 : Pow.{u2, 0} K' Nat] [_inst_14 : Pow.{u2, 0} K' Int] [_inst_15 : NatCast.{u2} K'] [_inst_16 : IntCast.{u2} K'] [_inst_17 : HasRatCast.{u2} K'] (f : K' -> K), (Function.Injective.{succ u2, succ u1} K' K f) -> (Eq.{succ u1} K (f (OfNat.ofNat.{u2} K' 0 (Zero.toOfNat0.{u2} K' _inst_2))) (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (CommMonoidWithZero.toZero.{u1} K (CommGroupWithZero.toCommMonoidWithZero.{u1} K (Semifield.toCommGroupWithZero.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) -> (Eq.{succ u1} K (f (OfNat.ofNat.{u2} K' 1 (One.toOfNat1.{u2} K' _inst_7))) (OfNat.ofNat.{u1} K 1 (One.toOfNat1.{u1} K (NonAssocRing.toOne.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HAdd.hAdd.{u2, u2, u2} K' K' K' (instHAdd.{u2} K' _inst_4) x y)) (HAdd.hAdd.{u1, u1, u1} K K K (instHAdd.{u1} K (Distrib.toAdd.{u1} K (NonUnitalNonAssocSemiring.toDistrib.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))))) (f x) (f y))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HMul.hMul.{u2, u2, u2} K' K' K' (instHMul.{u2} K' _inst_3) x y)) (HMul.hMul.{u1, u1, u1} K K K (instHMul.{u1} K (NonUnitalNonAssocRing.toMul.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))))) (f x) (f y))) -> (forall (x : K'), Eq.{succ u1} K (f (Neg.neg.{u2} K' _inst_5 x)) (Neg.neg.{u1} K (Ring.toNeg.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) (f x))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HSub.hSub.{u2, u2, u2} K' K' K' (instHSub.{u2} K' _inst_6) x y)) (HSub.hSub.{u1, u1, u1} K K K (instHSub.{u1} K (Ring.toSub.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (f x) (f y))) -> (forall (x : K'), Eq.{succ u1} K (f (Inv.inv.{u2} K' _inst_8 x)) (Inv.inv.{u1} K (Field.toInv.{u1} K _inst_1) (f x))) -> (forall (x : K') (y : K'), Eq.{succ u1} K (f (HDiv.hDiv.{u2, u2, u2} K' K' K' (instHDiv.{u2} K' _inst_9) x y)) (HDiv.hDiv.{u1, u1, u1} K K K (instHDiv.{u1} K (Field.toDiv.{u1} K _inst_1)) (f x) (f y))) -> (forall (x : K') (n : Nat), Eq.{succ u1} K (f (HSMul.hSMul.{0, u2, u2} Nat K' K' (instHSMul.{0, u2} Nat K' _inst_10) n x)) (HSMul.hSMul.{0, u1, u1} Nat K K (instHSMul.{0, u1} Nat K (AddMonoid.SMul.{u1} K (AddMonoidWithOne.toAddMonoid.{u1} K (AddGroupWithOne.toAddMonoidWithOne.{u1} K (Ring.toAddGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))) n (f x))) -> (forall (x : K') (n : Int), Eq.{succ u1} K (f (HSMul.hSMul.{0, u2, u2} Int K' K' (instHSMul.{0, u2} Int K' _inst_11) n x)) (HSMul.hSMul.{0, u1, u1} Int K K (instHSMul.{0, u1} Int K (SubNegMonoid.SMulInt.{u1} K (AddGroup.toSubNegMonoid.{u1} K (AddGroupWithOne.toAddGroup.{u1} K (Ring.toAddGroupWithOne.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))))))) n (f x))) -> (forall (x : K') (n : Rat), Eq.{succ u1} K (f (HSMul.hSMul.{0, u2, u2} Rat K' K' (instHSMul.{0, u2} Rat K' _inst_12) n x)) (HSMul.hSMul.{0, u1, u1} Rat K K (instHSMul.{0, u1} Rat K (Rat.smulDivisionRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) n (f x))) -> (forall (x : K') (n : Nat), Eq.{succ u1} K (f (HPow.hPow.{u2, 0, u2} K' Nat K' (instHPow.{u2, 0} K' Nat _inst_13) x n)) (HPow.hPow.{u1, 0, u1} K Nat K (instHPow.{u1, 0} K Nat (Monoid.Pow.{u1} K (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (Semifield.toDivisionSemiring.{u1} K (Field.toSemifield.{u1} K _inst_1))))))) (f x) n)) -> (forall (x : K') (n : Int), Eq.{succ u1} K (f (HPow.hPow.{u2, 0, u2} K' Int K' (instHPow.{u2, 0} K' Int _inst_14) x n)) (HPow.hPow.{u1, 0, u1} K Int K (instHPow.{u1, 0} K Int (DivInvMonoid.Pow.{u1} K (DivisionRing.toDivInvMonoid.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) (f x) n)) -> (forall (n : Nat), Eq.{succ u1} K (f (Nat.cast.{u2} K' _inst_15 n)) (Nat.cast.{u1} K (NonAssocRing.toNatCast.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1)))) n)) -> (forall (n : Int), Eq.{succ u1} K (f (Int.cast.{u2} K' _inst_16 n)) (Int.cast.{u1} K (Ring.toIntCast.{u1} K (DivisionRing.toRing.{u1} K (Field.toDivisionRing.{u1} K _inst_1))) n)) -> (forall (n : Rat), Eq.{succ u1} K (f (HasRatCast.ratCast.{u2} K' _inst_17 n)) (HasRatCast.ratCast.{u1} K (Field.toHasRatCast.{u1} K _inst_1) n)) -> (Field.{u2} K')
Case conversion may be inaccurate. Consider using '#align function.injective.field Function.Injective.fieldₓ'. -/
/-- Pullback a `field` along an injective function.
See note [reducible non-instances]. -/
@[reducible]
protected def Function.Injective.field [Field K] {K'} [Zero K'] [Mul K'] [Add K'] [Neg K'] [Sub K']
    [One K'] [Inv K'] [Div K'] [HasSmul ℕ K'] [HasSmul ℤ K'] [HasSmul ℚ K'] [Pow K' ℕ] [Pow K' ℤ]
    [NatCast K'] [IntCast K'] [HasRatCast K'] (f : K' → K) (hf : Injective f) (zero : f 0 = 0)
    (one : f 1 = 1) (add : ∀ x y, f (x + y) = f x + f y) (mul : ∀ x y, f (x * y) = f x * f y)
    (neg : ∀ x, f (-x) = -f x) (sub : ∀ x y, f (x - y) = f x - f y) (inv : ∀ x, f x⁻¹ = (f x)⁻¹)
    (div : ∀ x y, f (x / y) = f x / f y) (nsmul : ∀ (x) (n : ℕ), f (n • x) = n • f x)
    (zsmul : ∀ (x) (n : ℤ), f (n • x) = n • f x) (qsmul : ∀ (x) (n : ℚ), f (n • x) = n • f x)
    (npow : ∀ (x) (n : ℕ), f (x ^ n) = f x ^ n) (zpow : ∀ (x) (n : ℤ), f (x ^ n) = f x ^ n)
    (nat_cast : ∀ n : ℕ, f n = n) (int_cast : ∀ n : ℤ, f n = n) (rat_cast : ∀ n : ℚ, f n = n) :
    Field K' :=
  { hf.CommGroupWithZero f zero one mul inv div npow zpow,
    hf.CommRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with
    ratCast := coe
    rat_cast_mk := fun a b h1 h2 =>
      hf
        (by
          erw [rat_cast, mul, inv, int_cast, nat_cast] <;> exact DivisionRing.ratCast_mk a b h1 h2)
    qsmul := (· • ·)
    qsmul_eq_mul' := fun a x => hf (by erw [qsmul, mul, Rat.smul_def, rat_cast]) }
#align function.injective.field Function.Injective.field

/-! ### Order dual -/


instance [h : HasRatCast α] : HasRatCast αᵒᵈ :=
  h

instance [h : DivisionSemiring α] : DivisionSemiring αᵒᵈ :=
  h

instance [h : DivisionRing α] : DivisionRing αᵒᵈ :=
  h

instance [h : Semifield α] : Semifield αᵒᵈ :=
  h

instance [h : Field α] : Field αᵒᵈ :=
  h

#print to_dual_rat_cast /-
@[simp]
theorem to_dual_rat_cast [HasRatCast α] (n : ℚ) : toDual (n : α) = n :=
  rfl
#align to_dual_rat_cast to_dual_rat_cast
-/

#print of_dual_rat_cast /-
@[simp]
theorem of_dual_rat_cast [HasRatCast α] (n : ℚ) : (ofDual n : α) = n :=
  rfl
#align of_dual_rat_cast of_dual_rat_cast
-/

/-! ### Lexicographic order -/


instance [h : HasRatCast α] : HasRatCast (Lex α) :=
  h

instance [h : DivisionSemiring α] : DivisionSemiring (Lex α) :=
  h

instance [h : DivisionRing α] : DivisionRing (Lex α) :=
  h

instance [h : Semifield α] : Semifield (Lex α) :=
  h

instance [h : Field α] : Field (Lex α) :=
  h

#print to_lex_rat_cast /-
@[simp]
theorem to_lex_rat_cast [HasRatCast α] (n : ℚ) : toLex (n : α) = n :=
  rfl
#align to_lex_rat_cast to_lex_rat_cast
-/

#print of_lex_rat_cast /-
@[simp]
theorem of_lex_rat_cast [HasRatCast α] (n : ℚ) : (ofLex n : α) = n :=
  rfl
#align of_lex_rat_cast of_lex_rat_cast
-/

